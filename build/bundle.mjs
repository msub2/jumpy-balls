/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "130", MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, CullFaceNone = 0, CullFaceBack = 1, CullFaceFront = 2, CullFaceFrontBack = 3, BasicShadowMap = 0, PCFShadowMap = 1, PCFSoftShadowMap = 2, VSMShadowMap = 3, FrontSide = 0, BackSide = 1, DoubleSide = 2, FlatShading = 1, SmoothShading = 2, NoBlending = 0, NormalBlending = 1, AdditiveBlending = 2, SubtractiveBlending = 3, MultiplyBlending = 4, CustomBlending = 5, AddEquation = 100, SubtractEquation = 101, ReverseSubtractEquation = 102, MinEquation = 103, MaxEquation = 104, ZeroFactor = 200, OneFactor = 201, SrcColorFactor = 202, OneMinusSrcColorFactor = 203, SrcAlphaFactor = 204, OneMinusSrcAlphaFactor = 205, DstAlphaFactor = 206, OneMinusDstAlphaFactor = 207, DstColorFactor = 208, OneMinusDstColorFactor = 209, SrcAlphaSaturateFactor = 210, NeverDepth = 0, AlwaysDepth = 1, LessDepth = 2, LessEqualDepth = 3, EqualDepth = 4, GreaterEqualDepth = 5, GreaterDepth = 6, NotEqualDepth = 7, MultiplyOperation = 0, MixOperation = 1, AddOperation = 2, NoToneMapping = 0, LinearToneMapping = 1, ReinhardToneMapping = 2, CineonToneMapping = 3, ACESFilmicToneMapping = 4, CustomToneMapping = 5, UVMapping = 300, CubeReflectionMapping = 301, CubeRefractionMapping = 302, EquirectangularReflectionMapping = 303, EquirectangularRefractionMapping = 304, CubeUVReflectionMapping = 306, CubeUVRefractionMapping = 307, RepeatWrapping = 1e3, ClampToEdgeWrapping = 1001, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipmapNearestFilter = 1004, NearestMipMapNearestFilter = 1004, NearestMipmapLinearFilter = 1005, NearestMipMapLinearFilter = 1005, LinearFilter = 1006, LinearMipmapNearestFilter = 1007, LinearMipMapNearestFilter = 1007, LinearMipmapLinearFilter = 1008, LinearMipMapLinearFilter = 1008, UnsignedByteType = 1009, ByteType = 1010, ShortType = 1011, UnsignedShortType = 1012, IntType = 1013, UnsignedIntType = 1014, FloatType = 1015, HalfFloatType = 1016, UnsignedShort4444Type = 1017, UnsignedShort5551Type = 1018, UnsignedShort565Type = 1019, UnsignedInt248Type = 1020, AlphaFormat = 1021, RGBFormat = 1022, RGBAFormat = 1023, LuminanceFormat = 1024, LuminanceAlphaFormat = 1025, RGBEFormat = RGBAFormat, DepthFormat = 1026, DepthStencilFormat = 1027, RedFormat = 1028, RedIntegerFormat = 1029, RGFormat = 1030, RGIntegerFormat = 1031, RGBIntegerFormat = 1032, RGBAIntegerFormat = 1033, RGB_S3TC_DXT1_Format = 33776, RGBA_S3TC_DXT1_Format = 33777, RGBA_S3TC_DXT3_Format = 33778, RGBA_S3TC_DXT5_Format = 33779, RGB_PVRTC_4BPPV1_Format = 35840, RGB_PVRTC_2BPPV1_Format = 35841, RGBA_PVRTC_4BPPV1_Format = 35842, RGBA_PVRTC_2BPPV1_Format = 35843, RGB_ETC1_Format = 36196, RGB_ETC2_Format = 37492, RGBA_ETC2_EAC_Format = 37496, RGBA_ASTC_4x4_Format = 37808, RGBA_ASTC_5x4_Format = 37809, RGBA_ASTC_5x5_Format = 37810, RGBA_ASTC_6x5_Format = 37811, RGBA_ASTC_6x6_Format = 37812, RGBA_ASTC_8x5_Format = 37813, RGBA_ASTC_8x6_Format = 37814, RGBA_ASTC_8x8_Format = 37815, RGBA_ASTC_10x5_Format = 37816, RGBA_ASTC_10x6_Format = 37817, RGBA_ASTC_10x8_Format = 37818, RGBA_ASTC_10x10_Format = 37819, RGBA_ASTC_12x10_Format = 37820, RGBA_ASTC_12x12_Format = 37821, RGBA_BPTC_Format = 36492, SRGB8_ALPHA8_ASTC_4x4_Format = 37840, SRGB8_ALPHA8_ASTC_5x4_Format = 37841, SRGB8_ALPHA8_ASTC_5x5_Format = 37842, SRGB8_ALPHA8_ASTC_6x5_Format = 37843, SRGB8_ALPHA8_ASTC_6x6_Format = 37844, SRGB8_ALPHA8_ASTC_8x5_Format = 37845, SRGB8_ALPHA8_ASTC_8x6_Format = 37846, SRGB8_ALPHA8_ASTC_8x8_Format = 37847, SRGB8_ALPHA8_ASTC_10x5_Format = 37848, SRGB8_ALPHA8_ASTC_10x6_Format = 37849, SRGB8_ALPHA8_ASTC_10x8_Format = 37850, SRGB8_ALPHA8_ASTC_10x10_Format = 37851, SRGB8_ALPHA8_ASTC_12x10_Format = 37852, SRGB8_ALPHA8_ASTC_12x12_Format = 37853, LoopOnce = 2200, LoopRepeat = 2201, LoopPingPong = 2202, InterpolateDiscrete = 2300, InterpolateLinear = 2301, InterpolateSmooth = 2302, ZeroCurvatureEnding = 2400, ZeroSlopeEnding = 2401, WrapAroundEnding = 2402, NormalAnimationBlendMode = 2500, AdditiveAnimationBlendMode = 2501, TrianglesDrawMode = 0, TriangleStripDrawMode = 1, TriangleFanDrawMode = 2, LinearEncoding = 3e3, sRGBEncoding = 3001, GammaEncoding = 3007, RGBEEncoding = 3002, LogLuvEncoding = 3003, RGBM7Encoding = 3004, RGBM16Encoding = 3005, RGBDEncoding = 3006, BasicDepthPacking = 3200, RGBADepthPacking = 3201, TangentSpaceNormalMap = 0, ObjectSpaceNormalMap = 1, ZeroStencilOp = 0, KeepStencilOp = 7680, ReplaceStencilOp = 7681, IncrementStencilOp = 7682, DecrementStencilOp = 7683, IncrementWrapStencilOp = 34055, DecrementWrapStencilOp = 34056, InvertStencilOp = 5386, NeverStencilFunc = 512, LessStencilFunc = 513, EqualStencilFunc = 514, LessEqualStencilFunc = 515, GreaterStencilFunc = 516, NotEqualStencilFunc = 517, GreaterEqualStencilFunc = 518, AlwaysStencilFunc = 519, StaticDrawUsage = 35044, DynamicDrawUsage = 35048, StreamDrawUsage = 35040, StaticReadUsage = 35045, DynamicReadUsage = 35049, StreamReadUsage = 35041, StaticCopyUsage = 35046, DynamicCopyUsage = 35050, StreamCopyUsage = 35042, GLSL1 = "100", GLSL3 = "300 es";
let EventDispatcher$1 = class {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e];
    if (n !== void 0) {
      const r = n.indexOf(t);
      r !== -1 && n.splice(r, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const n = i.slice(0);
      for (let r = 0, s = n.length; r < s; r++)
        n[r].call(this, e);
      e.target = null;
    }
  }
};
const _lut$1 = [];
for (let o = 0; o < 256; o++)
  _lut$1[o] = (o < 16 ? "0" : "") + o.toString(16);
let _seed = 1234567;
const DEG2RAD = Math.PI / 180, RAD2DEG = 180 / Math.PI;
function generateUUID$1() {
  const o = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (_lut$1[o & 255] + _lut$1[o >> 8 & 255] + _lut$1[o >> 16 & 255] + _lut$1[o >> 24 & 255] + "-" + _lut$1[e & 255] + _lut$1[e >> 8 & 255] + "-" + _lut$1[e >> 16 & 15 | 64] + _lut$1[e >> 24 & 255] + "-" + _lut$1[t & 63 | 128] + _lut$1[t >> 8 & 255] + "-" + _lut$1[t >> 16 & 255] + _lut$1[t >> 24 & 255] + _lut$1[i & 255] + _lut$1[i >> 8 & 255] + _lut$1[i >> 16 & 255] + _lut$1[i >> 24 & 255]).toUpperCase();
}
function clamp(o, e, t) {
  return Math.max(e, Math.min(t, o));
}
function euclideanModulo(o, e) {
  return (o % e + e) % e;
}
function mapLinear(o, e, t, i, n) {
  return i + (o - e) * (n - i) / (t - e);
}
function inverseLerp(o, e, t) {
  return o !== e ? (t - o) / (e - o) : 0;
}
function lerp(o, e, t) {
  return (1 - t) * o + t * e;
}
function damp(o, e, t, i) {
  return lerp(o, e, 1 - Math.exp(-t * i));
}
function pingpong(o, e = 1) {
  return e - Math.abs(euclideanModulo(o, e * 2) - e);
}
function smoothstep(o, e, t) {
  return o <= e ? 0 : o >= t ? 1 : (o = (o - e) / (t - e), o * o * (3 - 2 * o));
}
function smootherstep(o, e, t) {
  return o <= e ? 0 : o >= t ? 1 : (o = (o - e) / (t - e), o * o * o * (o * (o * 6 - 15) + 10));
}
function randInt(o, e) {
  return o + Math.floor(Math.random() * (e - o + 1));
}
function randFloat(o, e) {
  return o + Math.random() * (e - o);
}
function randFloatSpread(o) {
  return o * (0.5 - Math.random());
}
function seededRandom(o) {
  return o !== void 0 && (_seed = o % 2147483647), _seed = _seed * 16807 % 2147483647, (_seed - 1) / 2147483646;
}
function degToRad(o) {
  return o * DEG2RAD;
}
function radToDeg(o) {
  return o * RAD2DEG;
}
function isPowerOfTwo(o) {
  return (o & o - 1) === 0 && o !== 0;
}
function ceilPowerOfTwo(o) {
  return Math.pow(2, Math.ceil(Math.log(o) / Math.LN2));
}
function floorPowerOfTwo(o) {
  return Math.pow(2, Math.floor(Math.log(o) / Math.LN2));
}
function setQuaternionFromProperEuler(o, e, t, i, n) {
  const r = Math.cos, s = Math.sin, a = r(t / 2), l = s(t / 2), c = r((e + i) / 2), u = s((e + i) / 2), h = r((e - i) / 2), d = s((e - i) / 2), f = r((i - e) / 2), p = s((i - e) / 2);
  switch (n) {
    case "XYX":
      o.set(a * u, l * h, l * d, a * c);
      break;
    case "YZY":
      o.set(l * d, a * u, l * h, a * c);
      break;
    case "ZXZ":
      o.set(l * h, l * d, a * u, a * c);
      break;
    case "XZX":
      o.set(a * u, l * p, l * f, a * c);
      break;
    case "YXY":
      o.set(l * f, a * u, l * p, a * c);
      break;
    case "ZYZ":
      o.set(l * p, l * f, a * u, a * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n);
  }
}
var MathUtils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DEG2RAD,
  RAD2DEG,
  generateUUID: generateUUID$1,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler
});
class Vector2 {
  constructor(e = 0, t = 0) {
    this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this);
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this);
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, n = e.elements;
    return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t, i) {
    return i !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t), n = Math.sin(t), r = this.x - e.x, s = this.y - e.y;
    return this.x = r * i - s * n + e.x, this.y = r * n + s * i + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
}
Vector2.prototype.isVector2 = !0;
class Matrix3 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
  }
  set(e, t, i, n, r, s, a, l, c) {
    const u = this.elements;
    return u[0] = e, u[1] = n, u[2] = a, u[3] = t, u[4] = r, u[5] = l, u[6] = i, u[7] = s, u[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, n = t.elements, r = this.elements, s = i[0], a = i[3], l = i[6], c = i[1], u = i[4], h = i[7], d = i[2], f = i[5], p = i[8], m = n[0], v = n[3], y = n[6], g = n[1], _ = n[4], b = n[7], S = n[2], x = n[5], M = n[8];
    return r[0] = s * m + a * g + l * S, r[3] = s * v + a * _ + l * x, r[6] = s * y + a * b + l * M, r[1] = c * m + u * g + h * S, r[4] = c * v + u * _ + h * x, r[7] = c * y + u * b + h * M, r[2] = d * m + f * g + p * S, r[5] = d * v + f * _ + p * x, r[8] = d * y + f * b + p * M, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], s = e[4], a = e[5], l = e[6], c = e[7], u = e[8];
    return t * s * u - t * a * c - i * r * u + i * a * l + n * r * c - n * s * l;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], s = e[4], a = e[5], l = e[6], c = e[7], u = e[8], h = u * s - a * c, d = a * l - u * r, f = c * r - s * l, p = t * h + i * d + n * f;
    if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const m = 1 / p;
    return e[0] = h * m, e[1] = (n * c - u * i) * m, e[2] = (a * i - n * s) * m, e[3] = d * m, e[4] = (u * t - n * l) * m, e[5] = (n * r - a * t) * m, e[6] = f * m, e[7] = (i * l - c * t) * m, e[8] = (s * t - i * r) * m, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, i, n, r, s, a) {
    const l = Math.cos(r), c = Math.sin(r);
    return this.set(
      i * l,
      i * c,
      -i * (l * s + c * a) + s + e,
      -n * c,
      n * l,
      -n * (-c * s + l * a) + a + t,
      0,
      0,
      1
    ), this;
  }
  scale(e, t) {
    const i = this.elements;
    return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= t, i[4] *= t, i[7] *= t, this;
  }
  rotate(e) {
    const t = Math.cos(e), i = Math.sin(e), n = this.elements, r = n[0], s = n[3], a = n[6], l = n[1], c = n[4], u = n[7];
    return n[0] = t * r + i * l, n[3] = t * s + i * c, n[6] = t * a + i * u, n[1] = -i * r + t * l, n[4] = -i * s + t * c, n[7] = -i * a + t * u, this;
  }
  translate(e, t) {
    const i = this.elements;
    return i[0] += e * i[2], i[3] += e * i[5], i[6] += e * i[8], i[1] += t * i[2], i[4] += t * i[5], i[7] += t * i[8], this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let n = 0; n < 9; n++)
      if (t[n] !== i[n]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
Matrix3.prototype.isMatrix3 = !0;
let _canvas;
class ImageUtils {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      _canvas === void 0 && (_canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), _canvas.width = e.width, _canvas.height = e.height;
      const i = _canvas.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = _canvas;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
}
let textureId = 0;
class Texture extends EventDispatcher$1 {
  constructor(e = Texture.DEFAULT_IMAGE, t = Texture.DEFAULT_MAPPING, i = ClampToEdgeWrapping, n = ClampToEdgeWrapping, r = LinearFilter, s = LinearMipmapLinearFilter, a = RGBAFormat, l = UnsignedByteType, c = 1, u = LinearEncoding) {
    super(), Object.defineProperty(this, "id", { value: textureId++ }), this.uuid = generateUUID$1(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = s, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Matrix3(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = u, this.version = 0, this.onUpdate = null;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const n = this.image;
      if (n.uuid === void 0 && (n.uuid = generateUUID$1()), !t && e.images[n.uuid] === void 0) {
        let r;
        if (Array.isArray(n)) {
          r = [];
          for (let s = 0, a = n.length; s < a; s++)
            n[s].isDataTexture ? r.push(serializeImage(n[s].image)) : r.push(serializeImage(n[s]));
        } else
          r = serializeImage(n);
        e.images[n.uuid] = {
          uuid: n.uuid,
          url: r
        };
      }
      i.image = n.uuid;
    }
    return t || (e.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== UVMapping) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case RepeatWrapping:
          e.x = e.x - Math.floor(e.x);
          break;
        case ClampToEdgeWrapping:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case RepeatWrapping:
          e.y = e.y - Math.floor(e.y);
          break;
        case ClampToEdgeWrapping:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = !0;
function serializeImage(o) {
  return typeof HTMLImageElement < "u" && o instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && o instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && o instanceof ImageBitmap ? ImageUtils.getDataURL(o) : o.data ? {
    data: Array.prototype.slice.call(o.data),
    width: o.width,
    height: o.height,
    type: o.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
class Vector4 {
  constructor(e = 0, t = 0, i = 0, n = 1) {
    this.x = e, this.y = t, this.z = i, this.w = n;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, n) {
    return this.x = e, this.y = t, this.z = i, this.w = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this);
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this);
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, n = this.z, r = this.w, s = e.elements;
    return this.x = s[0] * t + s[4] * i + s[8] * n + s[12] * r, this.y = s[1] * t + s[5] * i + s[9] * n + s[13] * r, this.z = s[2] * t + s[6] * i + s[10] * n + s[14] * r, this.w = s[3] * t + s[7] * i + s[11] * n + s[15] * r, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, n, r;
    const l = e.elements, c = l[0], u = l[4], h = l[8], d = l[1], f = l[5], p = l[9], m = l[2], v = l[6], y = l[10];
    if (Math.abs(u - d) < 0.01 && Math.abs(h - m) < 0.01 && Math.abs(p - v) < 0.01) {
      if (Math.abs(u + d) < 0.1 && Math.abs(h + m) < 0.1 && Math.abs(p + v) < 0.1 && Math.abs(c + f + y - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const _ = (c + 1) / 2, b = (f + 1) / 2, S = (y + 1) / 2, x = (u + d) / 4, M = (h + m) / 4, w = (p + v) / 4;
      return _ > b && _ > S ? _ < 0.01 ? (i = 0, n = 0.707106781, r = 0.707106781) : (i = Math.sqrt(_), n = x / i, r = M / i) : b > S ? b < 0.01 ? (i = 0.707106781, n = 0, r = 0.707106781) : (n = Math.sqrt(b), i = x / n, r = w / n) : S < 0.01 ? (i = 0.707106781, n = 0.707106781, r = 0) : (r = Math.sqrt(S), i = M / r, n = w / r), this.set(i, n, r, t), this;
    }
    let g = Math.sqrt((v - p) * (v - p) + (h - m) * (h - m) + (d - u) * (d - u));
    return Math.abs(g) < 1e-3 && (g = 1), this.x = (v - p) / g, this.y = (h - m) / g, this.z = (d - u) / g, this.w = Math.acos((c + f + y - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t, i) {
    return i !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
}
Vector4.prototype.isVector4 = !0;
class WebGLRenderTarget extends EventDispatcher$1 {
  constructor(e, t, i = {}) {
    super(), this.width = e, this.height = t, this.depth = 1, this.scissor = new Vector4(0, 0, e, t), this.scissorTest = !1, this.viewport = new Vector4(0, 0, e, t), this.texture = new Texture(void 0, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.image = { width: e, height: t, depth: 1 }, this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !1, this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : LinearFilter, this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0, this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1, this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null;
  }
  setTexture(e) {
    e.image = {
      width: this.width,
      height: this.height,
      depth: this.depth
    }, this.texture = e;
  }
  setSize(e, t, i = 1) {
    (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e, this.height = t, this.depth = i, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.image = { ...this.texture.image }, this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
WebGLRenderTarget.prototype.isWebGLRenderTarget = !0;
class WebGLMultipleRenderTargets extends WebGLRenderTarget {
  constructor(e, t, i) {
    super(e, t);
    const n = this.texture;
    this.texture = [];
    for (let r = 0; r < i; r++)
      this.texture[r] = n.clone();
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      this.width = e, this.height = t, this.depth = i;
      for (let n = 0, r = this.texture.length; n < r; n++)
        this.texture[n].image.width = e, this.texture[n].image.height = t, this.texture[n].image.depth = i;
      this.dispose();
    }
    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this.texture.length = 0;
    for (let t = 0, i = e.texture.length; t < i; t++)
      this.texture[t] = e.texture[t].clone();
    return this;
  }
}
WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = !0;
class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
  constructor(e, t, i) {
    super(e, t, i), this.samples = 4;
  }
  copy(e) {
    return super.copy.call(this, e), this.samples = e.samples, this;
  }
}
WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = !0;
class Quaternion {
  constructor(e = 0, t = 0, i = 0, n = 1) {
    this._x = e, this._y = t, this._z = i, this._w = n;
  }
  static slerp(e, t, i, n) {
    return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), i.slerpQuaternions(e, t, n);
  }
  static slerpFlat(e, t, i, n, r, s, a) {
    let l = i[n + 0], c = i[n + 1], u = i[n + 2], h = i[n + 3];
    const d = r[s + 0], f = r[s + 1], p = r[s + 2], m = r[s + 3];
    if (a === 0) {
      e[t + 0] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h;
      return;
    }
    if (a === 1) {
      e[t + 0] = d, e[t + 1] = f, e[t + 2] = p, e[t + 3] = m;
      return;
    }
    if (h !== m || l !== d || c !== f || u !== p) {
      let v = 1 - a;
      const y = l * d + c * f + u * p + h * m, g = y >= 0 ? 1 : -1, _ = 1 - y * y;
      if (_ > Number.EPSILON) {
        const S = Math.sqrt(_), x = Math.atan2(S, y * g);
        v = Math.sin(v * x) / S, a = Math.sin(a * x) / S;
      }
      const b = a * g;
      if (l = l * v + d * b, c = c * v + f * b, u = u * v + p * b, h = h * v + m * b, v === 1 - a) {
        const S = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
        l *= S, c *= S, u *= S, h *= S;
      }
    }
    e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h;
  }
  static multiplyQuaternionsFlat(e, t, i, n, r, s) {
    const a = i[n], l = i[n + 1], c = i[n + 2], u = i[n + 3], h = r[s], d = r[s + 1], f = r[s + 2], p = r[s + 3];
    return e[t] = a * p + u * h + l * f - c * d, e[t + 1] = l * p + u * d + c * h - a * f, e[t + 2] = c * p + u * f + a * d - l * h, e[t + 3] = u * p - a * h - l * d - c * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, i, n) {
    return this._x = e, this._y = t, this._z = i, this._w = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    if (!(e && e.isEuler))
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    const i = e._x, n = e._y, r = e._z, s = e._order, a = Math.cos, l = Math.sin, c = a(i / 2), u = a(n / 2), h = a(r / 2), d = l(i / 2), f = l(n / 2), p = l(r / 2);
    switch (s) {
      case "XYZ":
        this._x = d * u * h + c * f * p, this._y = c * f * h - d * u * p, this._z = c * u * p + d * f * h, this._w = c * u * h - d * f * p;
        break;
      case "YXZ":
        this._x = d * u * h + c * f * p, this._y = c * f * h - d * u * p, this._z = c * u * p - d * f * h, this._w = c * u * h + d * f * p;
        break;
      case "ZXY":
        this._x = d * u * h - c * f * p, this._y = c * f * h + d * u * p, this._z = c * u * p + d * f * h, this._w = c * u * h - d * f * p;
        break;
      case "ZYX":
        this._x = d * u * h - c * f * p, this._y = c * f * h + d * u * p, this._z = c * u * p - d * f * h, this._w = c * u * h + d * f * p;
        break;
      case "YZX":
        this._x = d * u * h + c * f * p, this._y = c * f * h + d * u * p, this._z = c * u * p - d * f * h, this._w = c * u * h - d * f * p;
        break;
      case "XZY":
        this._x = d * u * h - c * f * p, this._y = c * f * h - d * u * p, this._z = c * u * p + d * f * h, this._w = c * u * h + d * f * p;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2, n = Math.sin(i);
    return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, i = t[0], n = t[4], r = t[8], s = t[1], a = t[5], l = t[9], c = t[2], u = t[6], h = t[10], d = i + a + h;
    if (d > 0) {
      const f = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / f, this._x = (u - l) * f, this._y = (r - c) * f, this._z = (s - n) * f;
    } else if (i > a && i > h) {
      const f = 2 * Math.sqrt(1 + i - a - h);
      this._w = (u - l) / f, this._x = 0.25 * f, this._y = (n + s) / f, this._z = (r + c) / f;
    } else if (a > h) {
      const f = 2 * Math.sqrt(1 + a - i - h);
      this._w = (r - c) / f, this._x = (n + s) / f, this._y = 0.25 * f, this._z = (l + u) / f;
    } else {
      const f = 2 * Math.sqrt(1 + h - i - a);
      this._w = (s - n) / f, this._x = (r + c) / f, this._y = (l + u) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const n = Math.min(1, t / i);
    return this.slerp(e, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e, t) {
    return t !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x, n = e._y, r = e._z, s = e._w, a = t._x, l = t._y, c = t._z, u = t._w;
    return this._x = i * u + s * a + n * c - r * l, this._y = n * u + s * l + r * a - i * c, this._z = r * u + s * c + i * l - n * a, this._w = s * u - i * a - n * l - r * c, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x, n = this._y, r = this._z, s = this._w;
    let a = s * e._w + i * e._x + n * e._y + r * e._z;
    if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1)
      return this._w = s, this._x = i, this._y = n, this._z = r, this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const f = 1 - t;
      return this._w = f * s + t * this._w, this._x = f * i + t * this._x, this._y = f * n + t * this._y, this._z = f * r + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const c = Math.sqrt(l), u = Math.atan2(c, a), h = Math.sin((1 - t) * u) / c, d = Math.sin(t * u) / c;
    return this._w = s * h + this._w * d, this._x = i * h + this._x * d, this._y = n * h + this._y * d, this._z = r * h + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, i) {
    this.copy(e).slerp(t, i);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
}
Quaternion.prototype.isQuaternion = !0;
class Vector3 {
  constructor(e = 0, t = 0, i = 0) {
    this.x = e, this.y = t, this.z = i;
  }
  set(e, t, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this);
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this);
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this);
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(_quaternion$4.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, n = this.z, r = e.elements;
    return this.x = r[0] * t + r[3] * i + r[6] * n, this.y = r[1] * t + r[4] * i + r[7] * n, this.z = r[2] * t + r[5] * i + r[8] * n, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, n = this.z, r = e.elements, s = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
    return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * s, this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * s, this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * s, this;
  }
  applyQuaternion(e) {
    const t = this.x, i = this.y, n = this.z, r = e.x, s = e.y, a = e.z, l = e.w, c = l * t + s * n - a * i, u = l * i + a * t - r * n, h = l * n + r * i - s * t, d = -r * t - s * i - a * n;
    return this.x = c * l + d * -r + u * -a - h * -s, this.y = u * l + d * -s + h * -r - c * -a, this.z = h * l + d * -a + c * -s - u * -r, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, i = this.y, n = this.z, r = e.elements;
    return this.x = r[0] * t + r[4] * i + r[8] * n, this.y = r[1] * t + r[5] * i + r[9] * n, this.z = r[2] * t + r[6] * i + r[10] * n, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this;
  }
  cross(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x, n = e.y, r = e.z, s = t.x, a = t.y, l = t.z;
    return this.x = n * l - r * a, this.y = r * s - i * l, this.z = i * a - n * s, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return _vector$c.copy(this).projectOnVector(e), this.sub(_vector$c);
  }
  reflect(e) {
    return this.sub(_vector$c.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(clamp(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y, n = this.z - e.z;
    return t * t + i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const n = Math.sin(t) * e;
    return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = i, this.z = n, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t, i) {
    return i !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
}
Vector3.prototype.isVector3 = !0;
const _vector$c = /* @__PURE__ */ new Vector3(), _quaternion$4 = /* @__PURE__ */ new Quaternion();
class Box3 {
  constructor(e = new Vector3(1 / 0, 1 / 0, 1 / 0), t = new Vector3(-1 / 0, -1 / 0, -1 / 0)) {
    this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    let t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, s = -1 / 0, a = -1 / 0;
    for (let l = 0, c = e.length; l < c; l += 3) {
      const u = e[l], h = e[l + 1], d = e[l + 2];
      u < t && (t = u), h < i && (i = h), d < n && (n = d), u > r && (r = u), h > s && (s = h), d > a && (a = d);
    }
    return this.min.set(t, i, n), this.max.set(r, s, a), this;
  }
  setFromBufferAttribute(e) {
    let t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, s = -1 / 0, a = -1 / 0;
    for (let l = 0, c = e.count; l < c; l++) {
      const u = e.getX(l), h = e.getY(l), d = e.getZ(l);
      u < t && (t = u), h < i && (i = h), d < n && (n = d), u > r && (r = u), h > s && (s = h), d > a && (a = d);
    }
    return this.min.set(t, i, n), this.max.set(r, s, a), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = _vector$b.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e) {
    return this.makeEmpty(), this.expandByObject(e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e) {
    e.updateWorldMatrix(!1, !1);
    const t = e.geometry;
    t !== void 0 && (t.boundingBox === null && t.computeBoundingBox(), _box$3.copy(t.boundingBox), _box$3.applyMatrix4(e.matrixWorld), this.union(_box$3));
    const i = e.children;
    for (let n = 0, r = i.length; n < r; n++)
      this.expandByObject(i[n]);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, _vector$b), _vector$b.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, i;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(_center), _extents.subVectors(this.max, _center), _v0$2.subVectors(e.a, _center), _v1$7.subVectors(e.b, _center), _v2$3.subVectors(e.c, _center), _f0.subVectors(_v1$7, _v0$2), _f1.subVectors(_v2$3, _v1$7), _f2.subVectors(_v0$2, _v2$3);
    let t = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    return !satForAxes(t, _v0$2, _v1$7, _v2$3, _extents) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !satForAxes(t, _v0$2, _v1$7, _v2$3, _extents)) ? !1 : (_triangleNormal.crossVectors(_f0, _f1), t = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z], satForAxes(t, _v0$2, _v1$7, _v2$3, _extents));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return _vector$b.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return this.getCenter(e.center), e.radius = this.getSize(_vector$b).length() * 0.5, e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(_points), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
Box3.prototype.isBox3 = !0;
const _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
], _vector$b = /* @__PURE__ */ new Vector3(), _box$3 = /* @__PURE__ */ new Box3(), _v0$2 = /* @__PURE__ */ new Vector3(), _v1$7 = /* @__PURE__ */ new Vector3(), _v2$3 = /* @__PURE__ */ new Vector3(), _f0 = /* @__PURE__ */ new Vector3(), _f1 = /* @__PURE__ */ new Vector3(), _f2 = /* @__PURE__ */ new Vector3(), _center = /* @__PURE__ */ new Vector3(), _extents = /* @__PURE__ */ new Vector3(), _triangleNormal = /* @__PURE__ */ new Vector3(), _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(o, e, t, i, n) {
  for (let r = 0, s = o.length - 3; r <= s; r += 3) {
    _testAxis.fromArray(o, r);
    const a = n.x * Math.abs(_testAxis.x) + n.y * Math.abs(_testAxis.y) + n.z * Math.abs(_testAxis.z), l = e.dot(_testAxis), c = t.dot(_testAxis), u = i.dot(_testAxis);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a)
      return !1;
  }
  return !0;
}
const _box$2 = /* @__PURE__ */ new Box3(), _v1$6 = /* @__PURE__ */ new Vector3(), _toFarthestPoint = /* @__PURE__ */ new Vector3(), _toPoint = /* @__PURE__ */ new Vector3();
class Sphere {
  constructor(e = new Vector3(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : _box$2.setFromPoints(e).getCenter(i);
    let n = 0;
    for (let r = 0, s = e.length; r < s; r++)
      n = Math.max(n, i.distanceToSquared(e[r]));
    return this.radius = Math.sqrt(n), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    _toPoint.subVectors(e, this.center);
    const t = _toPoint.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t), n = (i - this.radius) * 0.5;
      this.center.add(_toPoint.multiplyScalar(n / i)), this.radius += n;
    }
    return this;
  }
  union(e) {
    return _toFarthestPoint.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(_v1$6.copy(e.center).add(_toFarthestPoint)), this.expandByPoint(_v1$6.copy(e.center).sub(_toFarthestPoint)), this;
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$a = /* @__PURE__ */ new Vector3(), _segCenter = /* @__PURE__ */ new Vector3(), _segDir = /* @__PURE__ */ new Vector3(), _diff = /* @__PURE__ */ new Vector3(), _edge1 = /* @__PURE__ */ new Vector3(), _edge2 = /* @__PURE__ */ new Vector3(), _normal$1 = /* @__PURE__ */ new Vector3();
class Ray {
  constructor(e = new Vector3(), t = new Vector3(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, _vector$a)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = _vector$a.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (_vector$a.copy(this.direction).multiplyScalar(t).add(this.origin), _vector$a.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, n) {
    _segCenter.copy(e).add(t).multiplyScalar(0.5), _segDir.copy(t).sub(e).normalize(), _diff.copy(this.origin).sub(_segCenter);
    const r = e.distanceTo(t) * 0.5, s = -this.direction.dot(_segDir), a = _diff.dot(this.direction), l = -_diff.dot(_segDir), c = _diff.lengthSq(), u = Math.abs(1 - s * s);
    let h, d, f, p;
    if (u > 0)
      if (h = s * l - a, d = s * a - l, p = r * u, h >= 0)
        if (d >= -p)
          if (d <= p) {
            const m = 1 / u;
            h *= m, d *= m, f = h * (h + s * d + 2 * a) + d * (s * h + d + 2 * l) + c;
          } else
            d = r, h = Math.max(0, -(s * d + a)), f = -h * h + d * (d + 2 * l) + c;
        else
          d = -r, h = Math.max(0, -(s * d + a)), f = -h * h + d * (d + 2 * l) + c;
      else
        d <= -p ? (h = Math.max(0, -(-s * r + a)), d = h > 0 ? -r : Math.min(Math.max(-r, -l), r), f = -h * h + d * (d + 2 * l) + c) : d <= p ? (h = 0, d = Math.min(Math.max(-r, -l), r), f = d * (d + 2 * l) + c) : (h = Math.max(0, -(s * r + a)), d = h > 0 ? r : Math.min(Math.max(-r, -l), r), f = -h * h + d * (d + 2 * l) + c);
    else
      d = s > 0 ? -r : r, h = Math.max(0, -(s * d + a)), f = -h * h + d * (d + 2 * l) + c;
    return i && i.copy(this.direction).multiplyScalar(h).add(this.origin), n && n.copy(_segDir).multiplyScalar(d).add(_segCenter), f;
  }
  intersectSphere(e, t) {
    _vector$a.subVectors(e.center, this.origin);
    const i = _vector$a.dot(this.direction), n = _vector$a.dot(_vector$a) - i * i, r = e.radius * e.radius;
    if (n > r) return null;
    const s = Math.sqrt(r - n), a = i - s, l = i + s;
    return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, n, r, s, a, l;
    const c = 1 / this.direction.x, u = 1 / this.direction.y, h = 1 / this.direction.z, d = this.origin;
    return c >= 0 ? (i = (e.min.x - d.x) * c, n = (e.max.x - d.x) * c) : (i = (e.max.x - d.x) * c, n = (e.min.x - d.x) * c), u >= 0 ? (r = (e.min.y - d.y) * u, s = (e.max.y - d.y) * u) : (r = (e.max.y - d.y) * u, s = (e.min.y - d.y) * u), i > s || r > n || ((r > i || i !== i) && (i = r), (s < n || n !== n) && (n = s), h >= 0 ? (a = (e.min.z - d.z) * h, l = (e.max.z - d.z) * h) : (a = (e.max.z - d.z) * h, l = (e.min.z - d.z) * h), i > l || a > n) || ((a > i || i !== i) && (i = a), (l < n || n !== n) && (n = l), n < 0) ? null : this.at(i >= 0 ? i : n, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, _vector$a) !== null;
  }
  intersectTriangle(e, t, i, n, r) {
    _edge1.subVectors(t, e), _edge2.subVectors(i, e), _normal$1.crossVectors(_edge1, _edge2);
    let s = this.direction.dot(_normal$1), a;
    if (s > 0) {
      if (n) return null;
      a = 1;
    } else if (s < 0)
      a = -1, s = -s;
    else
      return null;
    _diff.subVectors(this.origin, e);
    const l = a * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (l < 0)
      return null;
    const c = a * this.direction.dot(_edge1.cross(_diff));
    if (c < 0 || l + c > s)
      return null;
    const u = -a * _diff.dot(_normal$1);
    return u < 0 ? null : this.at(u / s, r);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
  }
  set(e, t, i, n, r, s, a, l, c, u, h, d, f, p, m, v) {
    const y = this.elements;
    return y[0] = e, y[4] = t, y[8] = i, y[12] = n, y[1] = r, y[5] = s, y[9] = a, y[13] = l, y[2] = c, y[6] = u, y[10] = h, y[14] = d, y[3] = f, y[7] = p, y[11] = m, y[15] = v, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
  }
  copyPosition(e) {
    const t = this.elements, i = e.elements;
    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, i) {
    return this.set(
      e.x,
      t.x,
      i.x,
      0,
      e.y,
      t.y,
      i.y,
      0,
      e.z,
      t.z,
      i.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, i = e.elements, n = 1 / _v1$5.setFromMatrixColumn(e, 0).length(), r = 1 / _v1$5.setFromMatrixColumn(e, 1).length(), s = 1 / _v1$5.setFromMatrixColumn(e, 2).length();
    return t[0] = i[0] * n, t[1] = i[1] * n, t[2] = i[2] * n, t[3] = 0, t[4] = i[4] * r, t[5] = i[5] * r, t[6] = i[6] * r, t[7] = 0, t[8] = i[8] * s, t[9] = i[9] * s, t[10] = i[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    const t = this.elements, i = e.x, n = e.y, r = e.z, s = Math.cos(i), a = Math.sin(i), l = Math.cos(n), c = Math.sin(n), u = Math.cos(r), h = Math.sin(r);
    if (e.order === "XYZ") {
      const d = s * u, f = s * h, p = a * u, m = a * h;
      t[0] = l * u, t[4] = -l * h, t[8] = c, t[1] = f + p * c, t[5] = d - m * c, t[9] = -a * l, t[2] = m - d * c, t[6] = p + f * c, t[10] = s * l;
    } else if (e.order === "YXZ") {
      const d = l * u, f = l * h, p = c * u, m = c * h;
      t[0] = d + m * a, t[4] = p * a - f, t[8] = s * c, t[1] = s * h, t[5] = s * u, t[9] = -a, t[2] = f * a - p, t[6] = m + d * a, t[10] = s * l;
    } else if (e.order === "ZXY") {
      const d = l * u, f = l * h, p = c * u, m = c * h;
      t[0] = d - m * a, t[4] = -s * h, t[8] = p + f * a, t[1] = f + p * a, t[5] = s * u, t[9] = m - d * a, t[2] = -s * c, t[6] = a, t[10] = s * l;
    } else if (e.order === "ZYX") {
      const d = s * u, f = s * h, p = a * u, m = a * h;
      t[0] = l * u, t[4] = p * c - f, t[8] = d * c + m, t[1] = l * h, t[5] = m * c + d, t[9] = f * c - p, t[2] = -c, t[6] = a * l, t[10] = s * l;
    } else if (e.order === "YZX") {
      const d = s * l, f = s * c, p = a * l, m = a * c;
      t[0] = l * u, t[4] = m - d * h, t[8] = p * h + f, t[1] = h, t[5] = s * u, t[9] = -a * u, t[2] = -c * u, t[6] = f * h + p, t[10] = d - m * h;
    } else if (e.order === "XZY") {
      const d = s * l, f = s * c, p = a * l, m = a * c;
      t[0] = l * u, t[4] = -h, t[8] = c * u, t[1] = d * h + m, t[5] = s * u, t[9] = f * h - p, t[2] = p * h - f, t[6] = a * u, t[10] = m * h + d;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(_zero, e, _one);
  }
  lookAt(e, t, i) {
    const n = this.elements;
    return _z.subVectors(e, t), _z.lengthSq() === 0 && (_z.z = 1), _z.normalize(), _x.crossVectors(i, _z), _x.lengthSq() === 0 && (Math.abs(i.z) === 1 ? _z.x += 1e-4 : _z.z += 1e-4, _z.normalize(), _x.crossVectors(i, _z)), _x.normalize(), _y.crossVectors(_z, _x), n[0] = _x.x, n[4] = _y.x, n[8] = _z.x, n[1] = _x.y, n[5] = _y.y, n[9] = _z.y, n[2] = _x.z, n[6] = _y.z, n[10] = _z.z, this;
  }
  multiply(e, t) {
    return t !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, n = t.elements, r = this.elements, s = i[0], a = i[4], l = i[8], c = i[12], u = i[1], h = i[5], d = i[9], f = i[13], p = i[2], m = i[6], v = i[10], y = i[14], g = i[3], _ = i[7], b = i[11], S = i[15], x = n[0], M = n[4], w = n[8], D = n[12], B = n[1], z = n[5], F = n[9], P = n[13], R = n[2], L = n[6], A = n[10], k = n[14], Q = n[3], U = n[7], H = n[11], I = n[15];
    return r[0] = s * x + a * B + l * R + c * Q, r[4] = s * M + a * z + l * L + c * U, r[8] = s * w + a * F + l * A + c * H, r[12] = s * D + a * P + l * k + c * I, r[1] = u * x + h * B + d * R + f * Q, r[5] = u * M + h * z + d * L + f * U, r[9] = u * w + h * F + d * A + f * H, r[13] = u * D + h * P + d * k + f * I, r[2] = p * x + m * B + v * R + y * Q, r[6] = p * M + m * z + v * L + y * U, r[10] = p * w + m * F + v * A + y * H, r[14] = p * D + m * P + v * k + y * I, r[3] = g * x + _ * B + b * R + S * Q, r[7] = g * M + _ * z + b * L + S * U, r[11] = g * w + _ * F + b * A + S * H, r[15] = g * D + _ * P + b * k + S * I, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[4], n = e[8], r = e[12], s = e[1], a = e[5], l = e[9], c = e[13], u = e[2], h = e[6], d = e[10], f = e[14], p = e[3], m = e[7], v = e[11], y = e[15];
    return p * (+r * l * h - n * c * h - r * a * d + i * c * d + n * a * f - i * l * f) + m * (+t * l * f - t * c * d + r * s * d - n * s * f + n * c * u - r * l * u) + v * (+t * c * h - t * a * f - r * s * h + i * s * f + r * a * u - i * c * u) + y * (-n * a * u - t * l * h + t * a * d + n * s * h - i * s * d + i * l * u);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, i) {
    const n = this.elements;
    return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], s = e[4], a = e[5], l = e[6], c = e[7], u = e[8], h = e[9], d = e[10], f = e[11], p = e[12], m = e[13], v = e[14], y = e[15], g = h * v * c - m * d * c + m * l * f - a * v * f - h * l * y + a * d * y, _ = p * d * c - u * v * c - p * l * f + s * v * f + u * l * y - s * d * y, b = u * m * c - p * h * c + p * a * f - s * m * f - u * a * y + s * h * y, S = p * h * l - u * m * l - p * a * d + s * m * d + u * a * v - s * h * v, x = t * g + i * _ + n * b + r * S;
    if (x === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const M = 1 / x;
    return e[0] = g * M, e[1] = (m * d * r - h * v * r - m * n * f + i * v * f + h * n * y - i * d * y) * M, e[2] = (a * v * r - m * l * r + m * n * c - i * v * c - a * n * y + i * l * y) * M, e[3] = (h * l * r - a * d * r - h * n * c + i * d * c + a * n * f - i * l * f) * M, e[4] = _ * M, e[5] = (u * v * r - p * d * r + p * n * f - t * v * f - u * n * y + t * d * y) * M, e[6] = (p * l * r - s * v * r - p * n * c + t * v * c + s * n * y - t * l * y) * M, e[7] = (s * d * r - u * l * r + u * n * c - t * d * c - s * n * f + t * l * f) * M, e[8] = b * M, e[9] = (p * h * r - u * m * r - p * i * f + t * m * f + u * i * y - t * h * y) * M, e[10] = (s * m * r - p * a * r + p * i * c - t * m * c - s * i * y + t * a * y) * M, e[11] = (u * a * r - s * h * r - u * i * c + t * h * c + s * i * f - t * a * f) * M, e[12] = S * M, e[13] = (u * m * n - p * h * n + p * i * d - t * m * d - u * i * v + t * h * v) * M, e[14] = (p * a * n - s * m * n - p * i * l + t * m * l + s * i * v - t * a * v) * M, e[15] = (s * h * n - u * a * n + u * i * l - t * h * l - s * i * d + t * a * d) * M, this;
  }
  scale(e) {
    const t = this.elements, i = e.x, n = e.y, r = e.z;
    return t[0] *= i, t[4] *= n, t[8] *= r, t[1] *= i, t[5] *= n, t[9] *= r, t[2] *= i, t[6] *= n, t[10] *= r, t[3] *= i, t[7] *= n, t[11] *= r, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, n));
  }
  makeTranslation(e, t, i) {
    return this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      0,
      i,
      0,
      0,
      1,
      0,
      0,
      -i,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t), n = Math.sin(t), r = 1 - i, s = e.x, a = e.y, l = e.z, c = r * s, u = r * a;
    return this.set(
      c * s + i,
      c * a - n * l,
      c * l + n * a,
      0,
      c * a + n * l,
      u * a + i,
      u * l - n * s,
      0,
      c * l - n * a,
      u * l + n * s,
      r * l * l + i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, i) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, i, n, r, s) {
    return this.set(
      1,
      i,
      r,
      0,
      e,
      1,
      s,
      0,
      t,
      n,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, i) {
    const n = this.elements, r = t._x, s = t._y, a = t._z, l = t._w, c = r + r, u = s + s, h = a + a, d = r * c, f = r * u, p = r * h, m = s * u, v = s * h, y = a * h, g = l * c, _ = l * u, b = l * h, S = i.x, x = i.y, M = i.z;
    return n[0] = (1 - (m + y)) * S, n[1] = (f + b) * S, n[2] = (p - _) * S, n[3] = 0, n[4] = (f - b) * x, n[5] = (1 - (d + y)) * x, n[6] = (v + g) * x, n[7] = 0, n[8] = (p + _) * M, n[9] = (v - g) * M, n[10] = (1 - (d + m)) * M, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
  }
  decompose(e, t, i) {
    const n = this.elements;
    let r = _v1$5.set(n[0], n[1], n[2]).length();
    const s = _v1$5.set(n[4], n[5], n[6]).length(), a = _v1$5.set(n[8], n[9], n[10]).length();
    this.determinant() < 0 && (r = -r), e.x = n[12], e.y = n[13], e.z = n[14], _m1$2.copy(this);
    const c = 1 / r, u = 1 / s, h = 1 / a;
    return _m1$2.elements[0] *= c, _m1$2.elements[1] *= c, _m1$2.elements[2] *= c, _m1$2.elements[4] *= u, _m1$2.elements[5] *= u, _m1$2.elements[6] *= u, _m1$2.elements[8] *= h, _m1$2.elements[9] *= h, _m1$2.elements[10] *= h, t.setFromRotationMatrix(_m1$2), i.x = r, i.y = s, i.z = a, this;
  }
  makePerspective(e, t, i, n, r, s) {
    s === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    const a = this.elements, l = 2 * r / (t - e), c = 2 * r / (i - n), u = (t + e) / (t - e), h = (i + n) / (i - n), d = -(s + r) / (s - r), f = -2 * s * r / (s - r);
    return a[0] = l, a[4] = 0, a[8] = u, a[12] = 0, a[1] = 0, a[5] = c, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = d, a[14] = f, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this;
  }
  makeOrthographic(e, t, i, n, r, s) {
    const a = this.elements, l = 1 / (t - e), c = 1 / (i - n), u = 1 / (s - r), h = (t + e) * l, d = (i + n) * c, f = (s + r) * u;
    return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -d, a[2] = 0, a[6] = 0, a[10] = -2 * u, a[14] = -f, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let n = 0; n < 16; n++)
      if (t[n] !== i[n]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
  }
}
Matrix4.prototype.isMatrix4 = !0;
const _v1$5 = /* @__PURE__ */ new Vector3(), _m1$2 = /* @__PURE__ */ new Matrix4(), _zero = /* @__PURE__ */ new Vector3(0, 0, 0), _one = /* @__PURE__ */ new Vector3(1, 1, 1), _x = /* @__PURE__ */ new Vector3(), _y = /* @__PURE__ */ new Vector3(), _z = /* @__PURE__ */ new Vector3(), _matrix$1 = /* @__PURE__ */ new Matrix4(), _quaternion$3 = /* @__PURE__ */ new Quaternion();
class Euler {
  constructor(e = 0, t = 0, i = 0, n = Euler.DefaultOrder) {
    this._x = e, this._y = t, this._z = i, this._order = n;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, i, n = this._order) {
    return this._x = e, this._y = t, this._z = i, this._order = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const n = e.elements, r = n[0], s = n[4], a = n[8], l = n[1], c = n[5], u = n[9], h = n[2], d = n[6], f = n[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(clamp(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(d, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, r), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(clamp(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-s, c)) : (this._y = 0, this._z = Math.atan2(l, r));
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-s, c));
        break;
      case "YZX":
        this._z = Math.asin(clamp(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, f));
        break;
      case "XZY":
        this._z = Math.asin(-clamp(s, -1, 1)), Math.abs(s) < 0.9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-u, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return _matrix$1.makeRotationFromQuaternion(e), this.setFromRotationMatrix(_matrix$1, t, i);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return _quaternion$3.setFromEuler(this), this.setFromQuaternion(_quaternion$3, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  toVector3(e) {
    return e ? e.set(this._x, this._y, this._z) : new Vector3(this._x, this._y, this._z);
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
}
Euler.prototype.isEuler = !0;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class Layers {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = 1 << e | 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = /* @__PURE__ */ new Vector3(), _q1 = /* @__PURE__ */ new Quaternion(), _m1$1 = /* @__PURE__ */ new Matrix4(), _target = /* @__PURE__ */ new Vector3(), _position$3 = /* @__PURE__ */ new Vector3(), _scale$2 = /* @__PURE__ */ new Vector3(), _quaternion$2 = /* @__PURE__ */ new Quaternion(), _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0), _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0), _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1), _addedEvent = { type: "added" }, _removedEvent = { type: "removed" };
class Object3D extends EventDispatcher$1 {
  constructor() {
    super(), Object.defineProperty(this, "id", { value: _object3DId++ }), this.uuid = generateUUID$1(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Object3D.DefaultUp.clone();
    const e = new Vector3(), t = new Euler(), i = new Quaternion(), n = new Vector3(1, 1, 1);
    function r() {
      i.setFromEuler(t, !1);
    }
    function s() {
      t.setFromQuaternion(i, void 0, !1);
    }
    t._onChange(r), i._onChange(s), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    }), this.matrix = new Matrix4(), this.matrixWorld = new Matrix4(), this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Layers(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return _q1.setFromAxisAngle(e, t), this.quaternion.multiply(_q1), this;
  }
  rotateOnWorldAxis(e, t) {
    return _q1.setFromAxisAngle(e, t), this.quaternion.premultiply(_q1), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(_xAxis, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(_yAxis, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(_zAxis, e);
  }
  translateOnAxis(e, t) {
    return _v1$4.copy(e).applyQuaternion(this.quaternion), this.position.add(_v1$4.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(_xAxis, e);
  }
  translateY(e) {
    return this.translateOnAxis(_yAxis, e);
  }
  translateZ(e) {
    return this.translateOnAxis(_zAxis, e);
  }
  localToWorld(e) {
    return e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return e.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, i) {
    e.isVector3 ? _target.copy(e) : _target.set(e, t, i);
    const n = this.parent;
    this.updateWorldMatrix(!0, !1), _position$3.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? _m1$1.lookAt(_position$3, _target, this.up) : _m1$1.lookAt(_target, _position$3, this.up), this.quaternion.setFromRotationMatrix(_m1$1), n && (_m1$1.extractRotation(n.matrixWorld), _q1.setFromRotationMatrix(_m1$1), this.quaternion.premultiply(_q1.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(_addedEvent)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(_removedEvent)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      t.parent = null, t.dispatchEvent(_removedEvent);
    }
    return this.children.length = 0, this;
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), _m1$1.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), _m1$1.multiply(e.parent.matrixWorld)), e.applyMatrix4(_m1$1), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, n = this.children.length; i < n; i++) {
      const s = this.children[i].getObjectByProperty(e, t);
      if (s !== void 0)
        return s;
    }
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, e, _scale$2), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, _quaternion$2, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++)
      t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++)
      t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++)
      t[i].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (e === !0 && i !== null && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const n = this.children;
      for (let r = 0, s = n.length; r < s; r++)
        n[r].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", i = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {}
    }, i.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const n = {};
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === !0 && (n.castShadow = !0), this.receiveShadow === !0 && (n.receiveShadow = !0), this.visible === !1 && (n.visible = !1), this.frustumCulled === !1 && (n.frustumCulled = !1), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON()));
    function r(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (n.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      n.geometry = r(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const h = l[c];
            r(e.shapes, h);
          }
        else
          r(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(r(e.materials, this.material[l]));
        n.material = a;
      } else
        n.material = r(e.materials, this.material);
    if (this.children.length > 0) {
      n.children = [];
      for (let a = 0; a < this.children.length; a++)
        n.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      n.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        n.animations.push(r(e.animations, l));
      }
    }
    if (t) {
      const a = s(e.geometries), l = s(e.materials), c = s(e.textures), u = s(e.images), h = s(e.shapes), d = s(e.skeletons), f = s(e.animations);
      a.length > 0 && (i.geometries = a), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), u.length > 0 && (i.images = u), h.length > 0 && (i.shapes = h), d.length > 0 && (i.skeletons = d), f.length > 0 && (i.animations = f);
    }
    return i.object = n, i;
    function s(a) {
      const l = [];
      for (const c in a) {
        const u = a[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let i = 0; i < e.children.length; i++) {
        const n = e.children[i];
        this.add(n.clone());
      }
    return this;
  }
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = !0;
Object3D.prototype.isObject3D = !0;
const _v0$1 = /* @__PURE__ */ new Vector3(), _v1$3 = /* @__PURE__ */ new Vector3(), _v2$2 = /* @__PURE__ */ new Vector3(), _v3$1 = /* @__PURE__ */ new Vector3(), _vab = /* @__PURE__ */ new Vector3(), _vac = /* @__PURE__ */ new Vector3(), _vbc = /* @__PURE__ */ new Vector3(), _vap = /* @__PURE__ */ new Vector3(), _vbp = /* @__PURE__ */ new Vector3(), _vcp = /* @__PURE__ */ new Vector3();
class Triangle {
  constructor(e = new Vector3(), t = new Vector3(), i = new Vector3()) {
    this.a = e, this.b = t, this.c = i;
  }
  static getNormal(e, t, i, n) {
    n.subVectors(i, t), _v0$1.subVectors(e, t), n.cross(_v0$1);
    const r = n.lengthSq();
    return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, i, n, r) {
    _v0$1.subVectors(n, t), _v1$3.subVectors(i, t), _v2$2.subVectors(e, t);
    const s = _v0$1.dot(_v0$1), a = _v0$1.dot(_v1$3), l = _v0$1.dot(_v2$2), c = _v1$3.dot(_v1$3), u = _v1$3.dot(_v2$2), h = s * c - a * a;
    if (h === 0)
      return r.set(-2, -1, -1);
    const d = 1 / h, f = (c * l - a * u) * d, p = (s * u - a * l) * d;
    return r.set(1 - f - p, p, f);
  }
  static containsPoint(e, t, i, n) {
    return this.getBarycoord(e, t, i, n, _v3$1), _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(e, t, i, n, r, s, a, l) {
    return this.getBarycoord(e, t, i, n, _v3$1), l.set(0, 0), l.addScaledVector(r, _v3$1.x), l.addScaledVector(s, _v3$1.y), l.addScaledVector(a, _v3$1.z), l;
  }
  static isFrontFacing(e, t, i, n) {
    return _v0$1.subVectors(i, t), _v1$3.subVectors(e, t), _v0$1.cross(_v1$3).dot(n) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, n) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return _v0$1.subVectors(this.c, this.b), _v1$3.subVectors(this.a, this.b), _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Triangle.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Triangle.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, i, n, r) {
    return Triangle.getUV(e, this.a, this.b, this.c, t, i, n, r);
  }
  containsPoint(e) {
    return Triangle.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a, n = this.b, r = this.c;
    let s, a;
    _vab.subVectors(n, i), _vac.subVectors(r, i), _vap.subVectors(e, i);
    const l = _vab.dot(_vap), c = _vac.dot(_vap);
    if (l <= 0 && c <= 0)
      return t.copy(i);
    _vbp.subVectors(e, n);
    const u = _vab.dot(_vbp), h = _vac.dot(_vbp);
    if (u >= 0 && h <= u)
      return t.copy(n);
    const d = l * h - u * c;
    if (d <= 0 && l >= 0 && u <= 0)
      return s = l / (l - u), t.copy(i).addScaledVector(_vab, s);
    _vcp.subVectors(e, r);
    const f = _vab.dot(_vcp), p = _vac.dot(_vcp);
    if (p >= 0 && f <= p)
      return t.copy(r);
    const m = f * c - l * p;
    if (m <= 0 && c >= 0 && p <= 0)
      return a = c / (c - p), t.copy(i).addScaledVector(_vac, a);
    const v = u * p - f * h;
    if (v <= 0 && h - u >= 0 && f - p >= 0)
      return _vbc.subVectors(r, n), a = (h - u) / (h - u + (f - p)), t.copy(n).addScaledVector(_vbc, a);
    const y = 1 / (v + m + d);
    return s = m * y, a = d * y, t.copy(i).addScaledVector(_vab, s).addScaledVector(_vac, a);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let materialId = 0;
class Material extends EventDispatcher$1 {
  constructor() {
    super(), Object.defineProperty(this, "id", { value: materialId++ }), this.uuid = generateUUID$1(), this.name = "", this.type = "Material", this.fog = !0, this.blending = NormalBlending, this.side = FrontSide, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = SrcAlphaFactor, this.blendDst = OneMinusSrcAlphaFactor, this.blendEquation = AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = LessEqualDepth, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = AlwaysStencilFunc, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = KeepStencilOp, this.stencilZFail = KeepStencilOp, this.stencilZPass = KeepStencilOp, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0;
  }
  onBuild() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn("THREE.Material: '" + t + "' parameter is undefined.");
          continue;
        }
        if (t === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = i === FlatShading;
          continue;
        }
        const n = this[t];
        if (n === void 0) {
          console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
          continue;
        }
        n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen && this.sheen.isColor && (i.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== NormalBlending && (i.blending = this.blending), this.side !== FrontSide && (i.side = this.side), this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, this.rotation && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === !0 && (i.morphTargets = !0), this.morphNormals === !0 && (i.morphNormals = !0), this.flatShading === !0 && (i.flatShading = this.flatShading), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData);
    function n(r) {
      const s = [];
      for (const a in r) {
        const l = r[a];
        delete l.metadata, s.push(l);
      }
      return s;
    }
    if (t) {
      const r = n(e.textures), s = n(e.images);
      r.length > 0 && (i.textures = r), s.length > 0 && (i.images = s);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const n = t.length;
      i = new Array(n);
      for (let r = 0; r !== n; ++r)
        i[r] = t[r].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
Material.prototype.isMaterial = !0;
const _colorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, _hslA = { h: 0, s: 0, l: 0 }, _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(o, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? o + (e - o) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? o + (e - o) * 6 * (2 / 3 - t) : o;
}
function SRGBToLinear(o) {
  return o < 0.04045 ? o * 0.0773993808 : Math.pow(o * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(o) {
  return o < 31308e-7 ? o * 12.92 : 1.055 * Math.pow(o, 0.41666) - 0.055;
}
class Color {
  constructor(e, t, i) {
    return t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i);
  }
  set(e) {
    return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, this;
  }
  setRGB(e, t, i) {
    return this.r = e, this.g = t, this.b = i, this;
  }
  setHSL(e, t, i) {
    if (e = euclideanModulo(e, 1), t = clamp(t, 0, 1), i = clamp(i, 0, 1), t === 0)
      this.r = this.g = this.b = i;
    else {
      const n = i <= 0.5 ? i * (1 + t) : i + t - i * t, r = 2 * i - n;
      this.r = hue2rgb(r, n, e + 1 / 3), this.g = hue2rgb(r, n, e), this.b = hue2rgb(r, n, e - 1 / 3);
    }
    return this;
  }
  setStyle(e) {
    function t(n) {
      n !== void 0 && parseFloat(n) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let i;
    if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
      let n;
      const r = i[1], s = i[2];
      switch (r) {
        case "rgb":
        case "rgba":
          if (n = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
            return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, t(n[4]), this;
          if (n = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
            return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, t(n[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (n = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
            const a = parseFloat(n[1]) / 360, l = parseInt(n[2], 10) / 100, c = parseInt(n[3], 10) / 100;
            return t(n[4]), this.setHSL(a, l, c);
          }
          break;
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const n = i[1], r = n.length;
      if (r === 3)
        return this.r = parseInt(n.charAt(0) + n.charAt(0), 16) / 255, this.g = parseInt(n.charAt(1) + n.charAt(1), 16) / 255, this.b = parseInt(n.charAt(2) + n.charAt(2), 16) / 255, this;
      if (r === 6)
        return this.r = parseInt(n.charAt(0) + n.charAt(1), 16) / 255, this.g = parseInt(n.charAt(2) + n.charAt(3), 16) / 255, this.b = parseInt(n.charAt(4) + n.charAt(5), 16) / 255, this;
    }
    return e && e.length > 0 ? this.setColorName(e) : this;
  }
  setColorName(e) {
    const t = _colorKeywords[e.toLowerCase()];
    return t !== void 0 ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copyGammaToLinear(e, t = 2) {
    return this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this;
  }
  copyLinearToGamma(e, t = 2) {
    const i = t > 0 ? 1 / t : 1;
    return this.r = Math.pow(e.r, i), this.g = Math.pow(e.g, i), this.b = Math.pow(e.b, i), this;
  }
  convertGammaToLinear(e) {
    return this.copyGammaToLinear(this, e), this;
  }
  convertLinearToGamma(e) {
    return this.copyLinearToGamma(this, e), this;
  }
  copySRGBToLinear(e) {
    return this.r = SRGBToLinear(e.r), this.g = SRGBToLinear(e.g), this.b = SRGBToLinear(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = LinearToSRGB(e.r), this.g = LinearToSRGB(e.g), this.b = LinearToSRGB(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(e) {
    const t = this.r, i = this.g, n = this.b, r = Math.max(t, i, n), s = Math.min(t, i, n);
    let a, l;
    const c = (s + r) / 2;
    if (s === r)
      a = 0, l = 0;
    else {
      const u = r - s;
      switch (l = c <= 0.5 ? u / (r + s) : u / (2 - r - s), r) {
        case t:
          a = (i - n) / u + (i < n ? 6 : 0);
          break;
        case i:
          a = (n - t) / u + 2;
          break;
        case n:
          a = (t - i) / u + 4;
          break;
      }
      a /= 6;
    }
    return e.h = a, e.s = l, e.l = c, e;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(e, t, i) {
    return this.getHSL(_hslA), _hslA.h += e, _hslA.s += t, _hslA.l += i, this.setHSL(_hslA.h, _hslA.s, _hslA.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, i) {
    return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this;
  }
  lerpHSL(e, t) {
    this.getHSL(_hslA), e.getHSL(_hslB);
    const i = lerp(_hslA.h, _hslB.h, t), n = lerp(_hslA.s, _hslB.s, t), r = lerp(_hslA.l, _hslB.l, t);
    return this.setHSL(i, n, r), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), e.normalized === !0 && (this.r /= 255, this.g /= 255, this.b /= 255), this;
  }
  toJSON() {
    return this.getHex();
  }
}
Color.NAMES = _colorKeywords;
Color.prototype.isColor = !0;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
class MeshBasicMaterial extends Material {
  constructor(e) {
    super(), this.type = "MeshBasicMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.morphTargets = e.morphTargets, this;
  }
}
MeshBasicMaterial.prototype.isMeshBasicMaterial = !0;
const _vector$9 = /* @__PURE__ */ new Vector3(), _vector2$1 = /* @__PURE__ */ new Vector2();
class BufferAttribute {
  constructor(e, t, i) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i === !0, this.usage = StaticDrawUsage, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
  }
  copyAt(e, t, i) {
    e *= this.itemSize, i *= t.itemSize;
    for (let n = 0, r = this.itemSize; n < r; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  copyColorsArray(e) {
    const t = this.array;
    let i = 0;
    for (let n = 0, r = e.length; n < r; n++) {
      let s = e[n];
      s === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), s = new Color()), t[i++] = s.r, t[i++] = s.g, t[i++] = s.b;
    }
    return this;
  }
  copyVector2sArray(e) {
    const t = this.array;
    let i = 0;
    for (let n = 0, r = e.length; n < r; n++) {
      let s = e[n];
      s === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), s = new Vector2()), t[i++] = s.x, t[i++] = s.y;
    }
    return this;
  }
  copyVector3sArray(e) {
    const t = this.array;
    let i = 0;
    for (let n = 0, r = e.length; n < r; n++) {
      let s = e[n];
      s === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), s = new Vector3()), t[i++] = s.x, t[i++] = s.y, t[i++] = s.z;
    }
    return this;
  }
  copyVector4sArray(e) {
    const t = this.array;
    let i = 0;
    for (let n = 0, r = e.length; n < r; n++) {
      let s = e[n];
      s === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), s = new Vector4()), t[i++] = s.x, t[i++] = s.y, t[i++] = s.z, t[i++] = s.w;
    }
    return this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        _vector2$1.fromBufferAttribute(this, t), _vector2$1.applyMatrix3(e), this.setXY(t, _vector2$1.x, _vector2$1.y);
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        _vector$9.fromBufferAttribute(this, t), _vector$9.applyMatrix3(e), this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      _vector$9.x = this.getX(t), _vector$9.y = this.getY(t), _vector$9.z = this.getZ(t), _vector$9.applyMatrix4(e), this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      _vector$9.x = this.getX(t), _vector$9.y = this.getY(t), _vector$9.z = this.getZ(t), _vector$9.applyNormalMatrix(e), this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      _vector$9.x = this.getX(t), _vector$9.y = this.getY(t), _vector$9.z = this.getZ(t), _vector$9.transformDirection(e), this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    return this.array[e * this.itemSize];
  }
  setX(e, t) {
    return this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    return this.array[e * this.itemSize + 1];
  }
  setY(e, t) {
    return this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    return this.array[e * this.itemSize + 2];
  }
  setZ(e, t) {
    return this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    return this.array[e * this.itemSize + 3];
  }
  setW(e, t) {
    return this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, i) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, n) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this;
  }
  setXYZW(e, t, i, n, r) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== StaticDrawUsage && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
}
BufferAttribute.prototype.isBufferAttribute = !0;
class Int8BufferAttribute extends BufferAttribute {
  constructor(e, t, i) {
    super(new Int8Array(e), t, i);
  }
}
class Uint8BufferAttribute extends BufferAttribute {
  constructor(e, t, i) {
    super(new Uint8Array(e), t, i);
  }
}
class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(e, t, i) {
    super(new Uint8ClampedArray(e), t, i);
  }
}
class Int16BufferAttribute extends BufferAttribute {
  constructor(e, t, i) {
    super(new Int16Array(e), t, i);
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class Int32BufferAttribute extends BufferAttribute {
  constructor(e, t, i) {
    super(new Int32Array(e), t, i);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class Float16BufferAttribute extends BufferAttribute {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
Float16BufferAttribute.prototype.isFloat16BufferAttribute = !0;
class Float32BufferAttribute extends BufferAttribute {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
class Float64BufferAttribute extends BufferAttribute {
  constructor(e, t, i) {
    super(new Float64Array(e), t, i);
  }
}
function arrayMax(o) {
  if (o.length === 0) return -1 / 0;
  let e = o[0];
  for (let t = 1, i = o.length; t < i; ++t)
    o[t] > e && (e = o[t]);
  return e;
}
const TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function getTypedArray(o, e) {
  return new TYPED_ARRAYS[o](e);
}
let _id = 0;
const _m1 = /* @__PURE__ */ new Matrix4(), _obj = /* @__PURE__ */ new Object3D(), _offset = /* @__PURE__ */ new Vector3(), _box$1 = /* @__PURE__ */ new Box3(), _boxMorphTargets = /* @__PURE__ */ new Box3(), _vector$8 = /* @__PURE__ */ new Vector3();
class BufferGeometry extends EventDispatcher$1 {
  constructor() {
    super(), Object.defineProperty(this, "id", { value: _id++ }), this.uuid = generateUUID$1(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (arrayMax(e) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: i
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const r = new Matrix3().getNormalMatrix(e);
      i.applyNormalMatrix(r), i.needsUpdate = !0;
    }
    const n = this.attributes.tangent;
    return n !== void 0 && (n.transformDirection(e), n.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return _m1.makeRotationFromQuaternion(e), this.applyMatrix4(_m1), this;
  }
  rotateX(e) {
    return _m1.makeRotationX(e), this.applyMatrix4(_m1), this;
  }
  rotateY(e) {
    return _m1.makeRotationY(e), this.applyMatrix4(_m1), this;
  }
  rotateZ(e) {
    return _m1.makeRotationZ(e), this.applyMatrix4(_m1), this;
  }
  translate(e, t, i) {
    return _m1.makeTranslation(e, t, i), this.applyMatrix4(_m1), this;
  }
  scale(e, t, i) {
    return _m1.makeScale(e, t, i), this.applyMatrix4(_m1), this;
  }
  lookAt(e) {
    return _obj.lookAt(e), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(_offset).negate(), this.translate(_offset.x, _offset.y, _offset.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const r = e[i];
      t.push(r.x, r.y, r.z || 0);
    }
    return this.setAttribute("position", new Float32BufferAttribute(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new Vector3(-1 / 0, -1 / 0, -1 / 0),
        new Vector3(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let i = 0, n = t.length; i < n; i++) {
          const r = t[i];
          _box$1.setFromBufferAttribute(r), this.morphTargetsRelative ? (_vector$8.addVectors(this.boundingBox.min, _box$1.min), this.boundingBox.expandByPoint(_vector$8), _vector$8.addVectors(this.boundingBox.max, _box$1.max), this.boundingBox.expandByPoint(_vector$8)) : (this.boundingBox.expandByPoint(_box$1.min), this.boundingBox.expandByPoint(_box$1.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new Vector3(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (_box$1.setFromBufferAttribute(e), t)
        for (let r = 0, s = t.length; r < s; r++) {
          const a = t[r];
          _boxMorphTargets.setFromBufferAttribute(a), this.morphTargetsRelative ? (_vector$8.addVectors(_box$1.min, _boxMorphTargets.min), _box$1.expandByPoint(_vector$8), _vector$8.addVectors(_box$1.max, _boxMorphTargets.max), _box$1.expandByPoint(_vector$8)) : (_box$1.expandByPoint(_boxMorphTargets.min), _box$1.expandByPoint(_boxMorphTargets.max));
        }
      _box$1.getCenter(i);
      let n = 0;
      for (let r = 0, s = e.count; r < s; r++)
        _vector$8.fromBufferAttribute(e, r), n = Math.max(n, i.distanceToSquared(_vector$8));
      if (t)
        for (let r = 0, s = t.length; r < s; r++) {
          const a = t[r], l = this.morphTargetsRelative;
          for (let c = 0, u = a.count; c < u; c++)
            _vector$8.fromBufferAttribute(a, c), l && (_offset.fromBufferAttribute(e, c), _vector$8.add(_offset)), n = Math.max(n, i.distanceToSquared(_vector$8));
        }
      this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeFaceNormals() {
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = e.array, n = t.position.array, r = t.normal.array, s = t.uv.array, a = n.length / 3;
    t.tangent === void 0 && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * a), 4));
    const l = t.tangent.array, c = [], u = [];
    for (let B = 0; B < a; B++)
      c[B] = new Vector3(), u[B] = new Vector3();
    const h = new Vector3(), d = new Vector3(), f = new Vector3(), p = new Vector2(), m = new Vector2(), v = new Vector2(), y = new Vector3(), g = new Vector3();
    function _(B, z, F) {
      h.fromArray(n, B * 3), d.fromArray(n, z * 3), f.fromArray(n, F * 3), p.fromArray(s, B * 2), m.fromArray(s, z * 2), v.fromArray(s, F * 2), d.sub(h), f.sub(h), m.sub(p), v.sub(p);
      const P = 1 / (m.x * v.y - v.x * m.y);
      isFinite(P) && (y.copy(d).multiplyScalar(v.y).addScaledVector(f, -m.y).multiplyScalar(P), g.copy(f).multiplyScalar(m.x).addScaledVector(d, -v.x).multiplyScalar(P), c[B].add(y), c[z].add(y), c[F].add(y), u[B].add(g), u[z].add(g), u[F].add(g));
    }
    let b = this.groups;
    b.length === 0 && (b = [{
      start: 0,
      count: i.length
    }]);
    for (let B = 0, z = b.length; B < z; ++B) {
      const F = b[B], P = F.start, R = F.count;
      for (let L = P, A = P + R; L < A; L += 3)
        _(
          i[L + 0],
          i[L + 1],
          i[L + 2]
        );
    }
    const S = new Vector3(), x = new Vector3(), M = new Vector3(), w = new Vector3();
    function D(B) {
      M.fromArray(r, B * 3), w.copy(M);
      const z = c[B];
      S.copy(z), S.sub(M.multiplyScalar(M.dot(z))).normalize(), x.crossVectors(w, z);
      const P = x.dot(u[B]) < 0 ? -1 : 1;
      l[B * 4] = S.x, l[B * 4 + 1] = S.y, l[B * 4 + 2] = S.z, l[B * 4 + 3] = P;
    }
    for (let B = 0, z = b.length; B < z; ++B) {
      const F = b[B], P = F.start, R = F.count;
      for (let L = P, A = P + R; L < A; L += 3)
        D(i[L + 0]), D(i[L + 1]), D(i[L + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        i = new BufferAttribute(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
      else
        for (let d = 0, f = i.count; d < f; d++)
          i.setXYZ(d, 0, 0, 0);
      const n = new Vector3(), r = new Vector3(), s = new Vector3(), a = new Vector3(), l = new Vector3(), c = new Vector3(), u = new Vector3(), h = new Vector3();
      if (e)
        for (let d = 0, f = e.count; d < f; d += 3) {
          const p = e.getX(d + 0), m = e.getX(d + 1), v = e.getX(d + 2);
          n.fromBufferAttribute(t, p), r.fromBufferAttribute(t, m), s.fromBufferAttribute(t, v), u.subVectors(s, r), h.subVectors(n, r), u.cross(h), a.fromBufferAttribute(i, p), l.fromBufferAttribute(i, m), c.fromBufferAttribute(i, v), a.add(u), l.add(u), c.add(u), i.setXYZ(p, a.x, a.y, a.z), i.setXYZ(m, l.x, l.y, l.z), i.setXYZ(v, c.x, c.y, c.z);
        }
      else
        for (let d = 0, f = t.count; d < f; d += 3)
          n.fromBufferAttribute(t, d + 0), r.fromBufferAttribute(t, d + 1), s.fromBufferAttribute(t, d + 2), u.subVectors(s, r), h.subVectors(n, r), u.cross(h), i.setXYZ(d + 0, u.x, u.y, u.z), i.setXYZ(d + 1, u.x, u.y, u.z), i.setXYZ(d + 2, u.x, u.y, u.z);
      this.normalizeNormals(), i.needsUpdate = !0;
    }
  }
  merge(e, t) {
    if (!(e && e.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
      return;
    }
    t === void 0 && (t = 0, console.warn(
      "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
    ));
    const i = this.attributes;
    for (const n in i) {
      if (e.attributes[n] === void 0) continue;
      const s = i[n].array, a = e.attributes[n], l = a.array, c = a.itemSize * t, u = Math.min(l.length, s.length - c);
      for (let h = 0, d = c; h < u; h++, d++)
        s[d] = l[h];
    }
    return this;
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      _vector$8.fromBufferAttribute(e, t), _vector$8.normalize(), e.setXYZ(t, _vector$8.x, _vector$8.y, _vector$8.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const c = a.array, u = a.itemSize, h = a.normalized, d = new c.constructor(l.length * u);
      let f = 0, p = 0;
      for (let m = 0, v = l.length; m < v; m++) {
        a.isInterleavedBufferAttribute ? f = l[m] * a.data.stride + a.offset : f = l[m] * u;
        for (let y = 0; y < u; y++)
          d[p++] = c[f++];
      }
      return new BufferAttribute(d, u, h);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new BufferGeometry(), i = this.index.array, n = this.attributes;
    for (const a in n) {
      const l = n[a], c = e(l, i);
      t.setAttribute(a, c);
    }
    const r = this.morphAttributes;
    for (const a in r) {
      const l = [], c = r[a];
      for (let u = 0, h = c.length; u < h; u++) {
        const d = c[u], f = e(d, i);
        l.push(f);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const s = this.groups;
    for (let a = 0, l = s.length; a < l; a++) {
      const c = s[a];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const c in l)
        l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const i = this.attributes;
    for (const l in i) {
      const c = i[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const n = {};
    let r = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l], u = [];
      for (let h = 0, d = c.length; h < d; h++) {
        const f = c[h];
        u.push(f.toJSON(e.data));
      }
      u.length > 0 && (n[l] = u, r = !0);
    }
    r && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const s = this.groups;
    s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
    const a = this.boundingSphere;
    return a !== null && (e.data.boundingSphere = {
      center: a.center.toArray(),
      radius: a.radius
    }), e;
  }
  clone() {
    return new BufferGeometry().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const n = e.attributes;
    for (const c in n) {
      const u = n[c];
      this.setAttribute(c, u.clone(t));
    }
    const r = e.morphAttributes;
    for (const c in r) {
      const u = [], h = r[c];
      for (let d = 0, f = h.length; d < f; d++)
        u.push(h[d].clone(t));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const s = e.groups;
    for (let c = 0, u = s.length; c < u; c++) {
      const h = s[c];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
BufferGeometry.prototype.isBufferGeometry = !0;
const _inverseMatrix$2 = /* @__PURE__ */ new Matrix4(), _ray$2 = /* @__PURE__ */ new Ray(), _sphere$3 = /* @__PURE__ */ new Sphere(), _vA$1 = /* @__PURE__ */ new Vector3(), _vB$1 = /* @__PURE__ */ new Vector3(), _vC$1 = /* @__PURE__ */ new Vector3(), _tempA = /* @__PURE__ */ new Vector3(), _tempB = /* @__PURE__ */ new Vector3(), _tempC = /* @__PURE__ */ new Vector3(), _morphA = /* @__PURE__ */ new Vector3(), _morphB = /* @__PURE__ */ new Vector3(), _morphC = /* @__PURE__ */ new Vector3(), _uvA$1 = /* @__PURE__ */ new Vector2(), _uvB$1 = /* @__PURE__ */ new Vector2(), _uvC$1 = /* @__PURE__ */ new Vector2(), _intersectionPoint = /* @__PURE__ */ new Vector3(), _intersectionPointWorld = /* @__PURE__ */ new Vector3();
class Mesh extends Object3D {
  constructor(e = new BufferGeometry(), t = new MeshBasicMaterial()) {
    super(), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e) {
    return super.copy(e), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const e = this.geometry;
    if (e.isBufferGeometry) {
      const t = e.morphAttributes, i = Object.keys(t);
      if (i.length > 0) {
        const n = t[i[0]];
        if (n !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let r = 0, s = n.length; r < s; r++) {
            const a = n[r].name || String(r);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
          }
        }
      }
    } else {
      const t = e.morphTargets;
      t !== void 0 && t.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  raycast(e, t) {
    const i = this.geometry, n = this.material, r = this.matrixWorld;
    if (n === void 0 || (i.boundingSphere === null && i.computeBoundingSphere(), _sphere$3.copy(i.boundingSphere), _sphere$3.applyMatrix4(r), e.ray.intersectsSphere(_sphere$3) === !1) || (_inverseMatrix$2.copy(r).invert(), _ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$2), i.boundingBox !== null && _ray$2.intersectsBox(i.boundingBox) === !1))
      return;
    let s;
    if (i.isBufferGeometry) {
      const a = i.index, l = i.attributes.position, c = i.morphAttributes.position, u = i.morphTargetsRelative, h = i.attributes.uv, d = i.attributes.uv2, f = i.groups, p = i.drawRange;
      if (a !== null)
        if (Array.isArray(n))
          for (let m = 0, v = f.length; m < v; m++) {
            const y = f[m], g = n[y.materialIndex], _ = Math.max(y.start, p.start), b = Math.min(y.start + y.count, p.start + p.count);
            for (let S = _, x = b; S < x; S += 3) {
              const M = a.getX(S), w = a.getX(S + 1), D = a.getX(S + 2);
              s = checkBufferGeometryIntersection(this, g, e, _ray$2, l, c, u, h, d, M, w, D), s && (s.faceIndex = Math.floor(S / 3), s.face.materialIndex = y.materialIndex, t.push(s));
            }
          }
        else {
          const m = Math.max(0, p.start), v = Math.min(a.count, p.start + p.count);
          for (let y = m, g = v; y < g; y += 3) {
            const _ = a.getX(y), b = a.getX(y + 1), S = a.getX(y + 2);
            s = checkBufferGeometryIntersection(this, n, e, _ray$2, l, c, u, h, d, _, b, S), s && (s.faceIndex = Math.floor(y / 3), t.push(s));
          }
        }
      else if (l !== void 0)
        if (Array.isArray(n))
          for (let m = 0, v = f.length; m < v; m++) {
            const y = f[m], g = n[y.materialIndex], _ = Math.max(y.start, p.start), b = Math.min(y.start + y.count, p.start + p.count);
            for (let S = _, x = b; S < x; S += 3) {
              const M = S, w = S + 1, D = S + 2;
              s = checkBufferGeometryIntersection(this, g, e, _ray$2, l, c, u, h, d, M, w, D), s && (s.faceIndex = Math.floor(S / 3), s.face.materialIndex = y.materialIndex, t.push(s));
            }
          }
        else {
          const m = Math.max(0, p.start), v = Math.min(l.count, p.start + p.count);
          for (let y = m, g = v; y < g; y += 3) {
            const _ = y, b = y + 1, S = y + 2;
            s = checkBufferGeometryIntersection(this, n, e, _ray$2, l, c, u, h, d, _, b, S), s && (s.faceIndex = Math.floor(y / 3), t.push(s));
          }
        }
    } else i.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  }
}
Mesh.prototype.isMesh = !0;
function checkIntersection(o, e, t, i, n, r, s, a) {
  let l;
  if (e.side === BackSide ? l = i.intersectTriangle(s, r, n, !0, a) : l = i.intersectTriangle(n, r, s, e.side !== DoubleSide, a), l === null) return null;
  _intersectionPointWorld.copy(a), _intersectionPointWorld.applyMatrix4(o.matrixWorld);
  const c = t.ray.origin.distanceTo(_intersectionPointWorld);
  return c < t.near || c > t.far ? null : {
    distance: c,
    point: _intersectionPointWorld.clone(),
    object: o
  };
}
function checkBufferGeometryIntersection(o, e, t, i, n, r, s, a, l, c, u, h) {
  _vA$1.fromBufferAttribute(n, c), _vB$1.fromBufferAttribute(n, u), _vC$1.fromBufferAttribute(n, h);
  const d = o.morphTargetInfluences;
  if (e.morphTargets && r && d) {
    _morphA.set(0, 0, 0), _morphB.set(0, 0, 0), _morphC.set(0, 0, 0);
    for (let p = 0, m = r.length; p < m; p++) {
      const v = d[p], y = r[p];
      v !== 0 && (_tempA.fromBufferAttribute(y, c), _tempB.fromBufferAttribute(y, u), _tempC.fromBufferAttribute(y, h), s ? (_morphA.addScaledVector(_tempA, v), _morphB.addScaledVector(_tempB, v), _morphC.addScaledVector(_tempC, v)) : (_morphA.addScaledVector(_tempA.sub(_vA$1), v), _morphB.addScaledVector(_tempB.sub(_vB$1), v), _morphC.addScaledVector(_tempC.sub(_vC$1), v)));
    }
    _vA$1.add(_morphA), _vB$1.add(_morphB), _vC$1.add(_morphC);
  }
  o.isSkinnedMesh && (o.boneTransform(c, _vA$1), o.boneTransform(u, _vB$1), o.boneTransform(h, _vC$1));
  const f = checkIntersection(o, e, t, i, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (f) {
    a && (_uvA$1.fromBufferAttribute(a, c), _uvB$1.fromBufferAttribute(a, u), _uvC$1.fromBufferAttribute(a, h), f.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2())), l && (_uvA$1.fromBufferAttribute(l, c), _uvB$1.fromBufferAttribute(l, u), _uvC$1.fromBufferAttribute(l, h), f.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()));
    const p = {
      a: c,
      b: u,
      c: h,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, p.normal), f.face = p;
  }
  return f;
}
class BoxGeometry extends BufferGeometry {
  constructor(e = 1, t = 1, i = 1, n = 1, r = 1, s = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: i,
      widthSegments: n,
      heightSegments: r,
      depthSegments: s
    };
    const a = this;
    n = Math.floor(n), r = Math.floor(r), s = Math.floor(s);
    const l = [], c = [], u = [], h = [];
    let d = 0, f = 0;
    p("z", "y", "x", -1, -1, i, t, e, s, r, 0), p("z", "y", "x", 1, -1, i, t, -e, s, r, 1), p("x", "z", "y", 1, 1, e, i, t, n, s, 2), p("x", "z", "y", 1, -1, e, i, -t, n, s, 3), p("x", "y", "z", 1, -1, e, t, i, n, r, 4), p("x", "y", "z", -1, -1, e, t, -i, n, r, 5), this.setIndex(l), this.setAttribute("position", new Float32BufferAttribute(c, 3)), this.setAttribute("normal", new Float32BufferAttribute(u, 3)), this.setAttribute("uv", new Float32BufferAttribute(h, 2));
    function p(m, v, y, g, _, b, S, x, M, w, D) {
      const B = b / M, z = S / w, F = b / 2, P = S / 2, R = x / 2, L = M + 1, A = w + 1;
      let k = 0, Q = 0;
      const U = new Vector3();
      for (let H = 0; H < A; H++) {
        const I = H * z - P;
        for (let V = 0; V < L; V++) {
          const W = V * B - F;
          U[m] = W * g, U[v] = I * _, U[y] = R, c.push(U.x, U.y, U.z), U[m] = 0, U[v] = 0, U[y] = x > 0 ? 1 : -1, u.push(U.x, U.y, U.z), h.push(V / M), h.push(1 - H / w), k += 1;
        }
      }
      for (let H = 0; H < w; H++)
        for (let I = 0; I < M; I++) {
          const V = d + I + L * H, W = d + I + L * (H + 1), X = d + (I + 1) + L * (H + 1), q = d + (I + 1) + L * H;
          l.push(V, W, q), l.push(W, X, q), Q += 6;
        }
      a.addGroup(f, Q, D), f += Q, d += k;
    }
  }
  static fromJSON(e) {
    return new BoxGeometry(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function cloneUniforms(o) {
  const e = {};
  for (const t in o) {
    e[t] = {};
    for (const i in o[t]) {
      const n = o[t][i];
      n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? e[t][i] = n.clone() : Array.isArray(n) ? e[t][i] = n.slice() : e[t][i] = n;
    }
  }
  return e;
}
function mergeUniforms(o) {
  const e = {};
  for (let t = 0; t < o.length; t++) {
    const i = cloneUniforms(o[t]);
    for (const n in i)
      e[n] = i[n];
  }
  return e;
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ShaderMaterial extends Material {
  constructor(e) {
    super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = default_vertex, this.fragmentShader = default_fragment, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1
      // set to use shader texture LOD
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv2: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && (e.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e));
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = cloneUniforms(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const n in this.uniforms) {
      const s = this.uniforms[n].value;
      s && s.isTexture ? t.uniforms[n] = {
        type: "t",
        value: s.toJSON(e).uuid
      } : s && s.isColor ? t.uniforms[n] = {
        type: "c",
        value: s.getHex()
      } : s && s.isVector2 ? t.uniforms[n] = {
        type: "v2",
        value: s.toArray()
      } : s && s.isVector3 ? t.uniforms[n] = {
        type: "v3",
        value: s.toArray()
      } : s && s.isVector4 ? t.uniforms[n] = {
        type: "v4",
        value: s.toArray()
      } : s && s.isMatrix3 ? t.uniforms[n] = {
        type: "m3",
        value: s.toArray()
      } : s && s.isMatrix4 ? t.uniforms[n] = {
        type: "m4",
        value: s.toArray()
      } : t.uniforms[n] = {
        value: s
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
    const i = {};
    for (const n in this.extensions)
      this.extensions[n] === !0 && (i[n] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
ShaderMaterial.prototype.isShaderMaterial = !0;
let Camera$1 = class extends Object3D {
  constructor() {
    super(), this.type = "Camera", this.matrixWorldInverse = new Matrix4(), this.projectionMatrix = new Matrix4(), this.projectionMatrixInverse = new Matrix4();
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
Camera$1.prototype.isCamera = !0;
class PerspectiveCamera extends Camera$1 {
  constructor(e = 50, t = 1, i = 0.1, n = 2e3) {
    super(), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = RAD2DEG * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(
      Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, i, n, r, s) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = s, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom, i = 2 * t, n = this.aspect * i, r = -0.5 * n;
    const s = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = s.fullWidth, c = s.fullHeight;
      r += s.offsetX * n / l, t -= s.offsetY * i / c, n *= s.width / l, i *= s.height / c;
    }
    const a = this.filmOffset;
    a !== 0 && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
PerspectiveCamera.prototype.isPerspectiveCamera = !0;
const fov = 90, aspect = 1;
class CubeCamera extends Object3D {
  constructor(e, t, i) {
    if (super(), this.type = "CubeCamera", i.isWebGLCubeRenderTarget !== !0) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = i;
    const n = new PerspectiveCamera(fov, aspect, e, t);
    n.layers = this.layers, n.up.set(0, -1, 0), n.lookAt(new Vector3(1, 0, 0)), this.add(n);
    const r = new PerspectiveCamera(fov, aspect, e, t);
    r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Vector3(-1, 0, 0)), this.add(r);
    const s = new PerspectiveCamera(fov, aspect, e, t);
    s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new Vector3(0, 1, 0)), this.add(s);
    const a = new PerspectiveCamera(fov, aspect, e, t);
    a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new Vector3(0, -1, 0)), this.add(a);
    const l = new PerspectiveCamera(fov, aspect, e, t);
    l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Vector3(0, 0, 1)), this.add(l);
    const c = new PerspectiveCamera(fov, aspect, e, t);
    c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new Vector3(0, 0, -1)), this.add(c);
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const i = this.renderTarget, [n, r, s, a, l, c] = this.children, u = e.xr.enabled, h = e.getRenderTarget();
    e.xr.enabled = !1;
    const d = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0), e.render(t, n), e.setRenderTarget(i, 1), e.render(t, r), e.setRenderTarget(i, 2), e.render(t, s), e.setRenderTarget(i, 3), e.render(t, a), e.setRenderTarget(i, 4), e.render(t, l), i.texture.generateMipmaps = d, e.setRenderTarget(i, 5), e.render(t, c), e.setRenderTarget(h), e.xr.enabled = u;
  }
}
class CubeTexture extends Texture {
  constructor(e, t, i, n, r, s, a, l, c, u) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : CubeReflectionMapping, a = a !== void 0 ? a : RGBFormat, super(e, t, i, n, r, s, a, l, c, u), this._needsFlipEnvMap = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
CubeTexture.prototype.isCubeTexture = !0;
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(e, t, i) {
    Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = i), super(e, e, t), t = t || {}, this.texture = new CubeTexture(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : LinearFilter, this.texture._needsFlipEnvMap = !1;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.format = RGBAFormat, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, n = new BoxGeometry(5, 5, 5), r = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    r.uniforms.tEquirect.value = t;
    const s = new Mesh(n, r), a = t.minFilter;
    return t.minFilter === LinearMipmapLinearFilter && (t.minFilter = LinearFilter), new CubeCamera(1, 10, this).update(e, s), t.minFilter = a, s.geometry.dispose(), s.material.dispose(), this;
  }
  clear(e, t, i, n) {
    const r = e.getRenderTarget();
    for (let s = 0; s < 6; s++)
      e.setRenderTarget(this, s), e.clear(t, i, n);
    e.setRenderTarget(r);
  }
}
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = !0;
const _vector1 = /* @__PURE__ */ new Vector3(), _vector2 = /* @__PURE__ */ new Vector3(), _normalMatrix = /* @__PURE__ */ new Matrix3();
class Plane {
  constructor(e = new Vector3(1, 0, 0), t = 0) {
    this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, i, n) {
    return this.normal.set(e, t, i), this.constant = n, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const n = _vector1.subVectors(i, t).cross(_vector2.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(n, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, t) {
    const i = e.delta(_vector1), n = this.normal.dot(i);
    if (n === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const r = -(e.start.dot(this.normal) + this.constant) / n;
    return r < 0 || r > 1 ? null : t.copy(i).multiplyScalar(r).add(e.start);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return t < 0 && i > 0 || i < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || _normalMatrix.getNormalMatrix(e), n = this.coplanarPoint(_vector1).applyMatrix4(e), r = this.normal.applyMatrix3(i).normalize();
    return this.constant = -n.dot(r), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Plane.prototype.isPlane = !0;
const _sphere$2 = /* @__PURE__ */ new Sphere(), _vector$7 = /* @__PURE__ */ new Vector3();
class Frustum {
  constructor(e = new Plane(), t = new Plane(), i = new Plane(), n = new Plane(), r = new Plane(), s = new Plane()) {
    this.planes = [e, t, i, n, r, s];
  }
  set(e, t, i, n, r, s) {
    const a = this.planes;
    return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(s), this;
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++)
      t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes, i = e.elements, n = i[0], r = i[1], s = i[2], a = i[3], l = i[4], c = i[5], u = i[6], h = i[7], d = i[8], f = i[9], p = i[10], m = i[11], v = i[12], y = i[13], g = i[14], _ = i[15];
    return t[0].setComponents(a - n, h - l, m - d, _ - v).normalize(), t[1].setComponents(a + n, h + l, m + d, _ + v).normalize(), t[2].setComponents(a + r, h + c, m + f, _ + y).normalize(), t[3].setComponents(a - r, h - c, m - f, _ - y).normalize(), t[4].setComponents(a - s, h - u, m - p, _ - g).normalize(), t[5].setComponents(a + s, h + u, m + p, _ + g).normalize(), this;
  }
  intersectsObject(e) {
    const t = e.geometry;
    return t.boundingSphere === null && t.computeBoundingSphere(), _sphere$2.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(_sphere$2);
  }
  intersectsSprite(e) {
    return _sphere$2.center.set(0, 0, 0), _sphere$2.radius = 0.7071067811865476, _sphere$2.applyMatrix4(e.matrixWorld), this.intersectsSphere(_sphere$2);
  }
  intersectsSphere(e) {
    const t = this.planes, i = e.center, n = -e.radius;
    for (let r = 0; r < 6; r++)
      if (t[r].distanceToPoint(i) < n)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const n = t[i];
      if (_vector$7.x = n.normal.x > 0 ? e.max.x : e.min.x, _vector$7.y = n.normal.y > 0 ? e.max.y : e.min.y, _vector$7.z = n.normal.z > 0 ? e.max.z : e.min.z, n.distanceToPoint(_vector$7) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++)
      if (t[i].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let o = null, e = !1, t = null, i = null;
  function n(r, s) {
    t(r, s), i = o.requestAnimationFrame(n);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (i = o.requestAnimationFrame(n), e = !0);
    },
    stop: function() {
      o.cancelAnimationFrame(i), e = !1;
    },
    setAnimationLoop: function(r) {
      t = r;
    },
    setContext: function(r) {
      o = r;
    }
  };
}
function WebGLAttributes(o, e) {
  const t = e.isWebGL2, i = /* @__PURE__ */ new WeakMap();
  function n(c, u) {
    const h = c.array, d = c.usage, f = o.createBuffer();
    o.bindBuffer(u, f), o.bufferData(u, h, d), c.onUploadCallback();
    let p = 5126;
    return h instanceof Float32Array ? p = 5126 : h instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : h instanceof Uint16Array ? c.isFloat16BufferAttribute ? t ? p = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : p = 5123 : h instanceof Int16Array ? p = 5122 : h instanceof Uint32Array ? p = 5125 : h instanceof Int32Array ? p = 5124 : h instanceof Int8Array ? p = 5120 : (h instanceof Uint8Array || h instanceof Uint8ClampedArray) && (p = 5121), {
      buffer: f,
      type: p,
      bytesPerElement: h.BYTES_PER_ELEMENT,
      version: c.version
    };
  }
  function r(c, u, h) {
    const d = u.array, f = u.updateRange;
    o.bindBuffer(h, c), f.count === -1 ? o.bufferSubData(h, 0, d) : (t ? o.bufferSubData(
      h,
      f.offset * d.BYTES_PER_ELEMENT,
      d,
      f.offset,
      f.count
    ) : o.bufferSubData(
      h,
      f.offset * d.BYTES_PER_ELEMENT,
      d.subarray(f.offset, f.offset + f.count)
    ), f.count = -1);
  }
  function s(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), i.get(c);
  }
  function a(c) {
    c.isInterleavedBufferAttribute && (c = c.data);
    const u = i.get(c);
    u && (o.deleteBuffer(u.buffer), i.delete(c));
  }
  function l(c, u) {
    if (c.isGLBufferAttribute) {
      const d = i.get(c);
      (!d || d.version < c.version) && i.set(c, {
        buffer: c.buffer,
        type: c.type,
        bytesPerElement: c.elementSize,
        version: c.version
      });
      return;
    }
    c.isInterleavedBufferAttribute && (c = c.data);
    const h = i.get(c);
    h === void 0 ? i.set(c, n(c, u)) : h.version < c.version && (r(h.buffer, c, u), h.version = c.version);
  }
  return {
    get: s,
    remove: a,
    update: l
  };
}
class PlaneGeometry extends BufferGeometry {
  constructor(e = 1, t = 1, i = 1, n = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: i,
      heightSegments: n
    };
    const r = e / 2, s = t / 2, a = Math.floor(i), l = Math.floor(n), c = a + 1, u = l + 1, h = e / a, d = t / l, f = [], p = [], m = [], v = [];
    for (let y = 0; y < u; y++) {
      const g = y * d - s;
      for (let _ = 0; _ < c; _++) {
        const b = _ * h - r;
        p.push(b, -g, 0), m.push(0, 0, 1), v.push(_ / a), v.push(1 - y / l);
      }
    }
    for (let y = 0; y < l; y++)
      for (let g = 0; g < a; g++) {
        const _ = g + c * y, b = g + c * (y + 1), S = g + 1 + c * (y + 1), x = g + 1 + c * y;
        f.push(_, b, x), f.push(b, S, x);
      }
    this.setIndex(f), this.setAttribute("position", new Float32BufferAttribute(p, 3)), this.setAttribute("normal", new Float32BufferAttribute(m, 3)), this.setAttribute("uv", new Float32BufferAttribute(v, 2));
  }
  static fromJSON(e) {
    return new PlaneGeometry(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, alphatest_fragment = `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`, aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`, aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, begin_vertex = "vec3 transformed = vec3( position );", beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, bsdfs = `vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotVH ) {
	float fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`, bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, color_fragment = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, color_pars_fragment = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, color_pars_vertex = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, color_vertex = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, common = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment = `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`, envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, fog_vertex = `#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`, fog_pars_vertex = `#ifdef USE_FOG
	varying float fogDepth;
#endif`, fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`, lightmap_fragment = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`, lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, lights_lambert_vertex = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`, lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`, envmap_physical_pars_fragment = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`, lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, lights_toon_pars_fragment = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`, lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, lights_phong_pars_fragment = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`, lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`, lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, lights_fragment_begin = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`, lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, logdepthbuf_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, logdepthbuf_pars_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, logdepthbuf_pars_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, logdepthbuf_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, map_fragment = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`, map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, map_particle_pars_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`, morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`, morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`, normal_fragment_begin = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, normal_fragment_maps = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, clearcoat_normal_fragment_begin = `#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, shadowmap_pars_fragment = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, shadowmap_pars_vertex = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, shadowmap_vertex = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`, shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`, skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, tonemapping_pars_fragment = `#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, transmission_fragment = `#ifdef USE_TRANSMISSION
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSNMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition.xyz / vWorldPosition.w;
	vec3 v = normalize( cameraPosition - pos );
	float ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );
	vec3 transmission = transmissionFactor * getIBLVolumeRefraction(
		normal, v, roughnessFactor, material.diffuseColor, totalSpecular,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );
#endif`, transmission_pars_fragment = `#ifdef USE_TRANSMISSION
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec4 vWorldPosition;
	vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {
		vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);
		vec3 modelScale;
		modelScale.x = length(vec3(modelMatrix[0].xyz));
		modelScale.y = length(vec3(modelMatrix[1].xyz));
		modelScale.z = length(vec3(modelMatrix[2].xyz));
		return normalize(refractionVector) * thickness * modelScale;
	}
	float applyIorToRoughness(float roughness, float ior) {
		return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);
	}
	vec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {
		float framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);
		return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;
	}
	vec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {
		if (attenuationDistance == 0.0) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;
			vec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);			return transmittance * radiance;
		}
	}
	vec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance) {
		vec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);
		vec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);
		return (1.0 - specularColor) * attenuatedColor * baseColor;
	}
#endif`, uv_pars_fragment = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, uv_pars_vertex = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, uv_vertex = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, uv2_pars_fragment = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, uv2_pars_vertex = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, uv2_vertex = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`, background_frag = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, background_vert = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, cube_frag = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, cube_vert = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, depth_frag = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, depth_vert = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, distanceRGBA_frag = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, distanceRGBA_vert = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, equirect_frag = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, equirect_vert = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, linedashed_frag = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, linedashed_vert = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, meshbasic_frag = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshbasic_vert = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, meshlambert_frag = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshlambert_vert = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshmatcap_frag = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshmatcap_vert = `#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, meshtoon_frag = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshtoon_vert = `#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshphong_frag = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshphong_vert = `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshphysical_frag = `#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform vec3 attenuationColor;
	uniform float attenuationDistance;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <transmission_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshphysical_vert = `#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#ifdef USE_TRANSMISSION
	varying vec4 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition;
#endif
}`, normal_frag = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`, normal_vert = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, points_frag = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, points_vert = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, shadow_frag = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, shadow_vert = `#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, sprite_frag = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, sprite_vert = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;
const ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_frag,
  background_vert,
  cube_frag,
  cube_vert,
  depth_frag,
  depth_vert,
  distanceRGBA_frag,
  distanceRGBA_vert,
  equirect_frag,
  equirect_vert,
  linedashed_frag,
  linedashed_vert,
  meshbasic_frag,
  meshbasic_vert,
  meshlambert_frag,
  meshlambert_vert,
  meshmatcap_frag,
  meshmatcap_vert,
  meshtoon_frag,
  meshtoon_vert,
  meshphong_frag,
  meshphong_vert,
  meshphysical_frag,
  meshphysical_vert,
  normal_frag,
  normal_vert,
  points_frag,
  points_vert,
  shadow_frag,
  shadow_vert,
  sprite_frag,
  sprite_vert
}, UniformsLib = {
  common: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Matrix3() },
    uv2Transform: { value: new Matrix3() },
    alphaMap: { value: null }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    refractionRatio: { value: 0.98 },
    maxMipLevel: { value: 0 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new Matrix3() }
  },
  sprite: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    center: { value: new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new Matrix3() }
  }
}, ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        specular: { value: new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix3() },
      t2D: { value: null }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: new Color(0) },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color(0) }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(o, e, t, i, n) {
  const r = new Color(0);
  let s = 0, a, l, c = null, u = 0, h = null;
  function d(p, m) {
    let v = !1, y = m.isScene === !0 ? m.background : null;
    y && y.isTexture && (y = e.get(y));
    const g = o.xr, _ = g.getSession && g.getSession();
    _ && _.environmentBlendMode === "additive" && (y = null), y === null ? f(r, s) : y && y.isColor && (f(y, 1), v = !0), (o.autoClear || v) && o.clear(o.autoClearColor, o.autoClearDepth, o.autoClearStencil), y && (y.isCubeTexture || y.mapping === CubeUVReflectionMapping) ? (l === void 0 && (l = new Mesh(
      new BoxGeometry(1, 1, 1),
      new ShaderMaterial({
        name: "BackgroundCubeMaterial",
        uniforms: cloneUniforms(ShaderLib.cube.uniforms),
        vertexShader: ShaderLib.cube.vertexShader,
        fragmentShader: ShaderLib.cube.fragmentShader,
        side: BackSide,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(b, S, x) {
      this.matrixWorld.copyPosition(x.matrixWorld);
    }, Object.defineProperty(l.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), i.update(l)), l.material.uniforms.envMap.value = y, l.material.uniforms.flipEnvMap.value = y.isCubeTexture && y._needsFlipEnvMap ? -1 : 1, (c !== y || u !== y.version || h !== o.toneMapping) && (l.material.needsUpdate = !0, c = y, u = y.version, h = o.toneMapping), p.unshift(l, l.geometry, l.material, 0, 0, null)) : y && y.isTexture && (a === void 0 && (a = new Mesh(
      new PlaneGeometry(2, 2),
      new ShaderMaterial({
        name: "BackgroundMaterial",
        uniforms: cloneUniforms(ShaderLib.background.uniforms),
        vertexShader: ShaderLib.background.vertexShader,
        fragmentShader: ShaderLib.background.fragmentShader,
        side: FrontSide,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), a.geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), i.update(a)), a.material.uniforms.t2D.value = y, y.matrixAutoUpdate === !0 && y.updateMatrix(), a.material.uniforms.uvTransform.value.copy(y.matrix), (c !== y || u !== y.version || h !== o.toneMapping) && (a.material.needsUpdate = !0, c = y, u = y.version, h = o.toneMapping), p.unshift(a, a.geometry, a.material, 0, 0, null));
  }
  function f(p, m) {
    t.buffers.color.setClear(p.r, p.g, p.b, m, n);
  }
  return {
    getClearColor: function() {
      return r;
    },
    setClearColor: function(p, m = 1) {
      r.set(p), s = m, f(r, s);
    },
    getClearAlpha: function() {
      return s;
    },
    setClearAlpha: function(p) {
      s = p, f(r, s);
    },
    render: d
  };
}
function WebGLBindingStates(o, e, t, i) {
  const n = o.getParameter(34921), r = i.isWebGL2 ? null : e.get("OES_vertex_array_object"), s = i.isWebGL2 || r !== null, a = {}, l = m(null);
  let c = l;
  function u(P, R, L, A, k) {
    let Q = !1;
    if (s) {
      const U = p(A, L, R);
      c !== U && (c = U, d(c.object)), Q = v(A, k), Q && y(A, k);
    } else {
      const U = R.wireframe === !0;
      (c.geometry !== A.id || c.program !== L.id || c.wireframe !== U) && (c.geometry = A.id, c.program = L.id, c.wireframe = U, Q = !0);
    }
    P.isInstancedMesh === !0 && (Q = !0), k !== null && t.update(k, 34963), Q && (M(P, R, L, A), k !== null && o.bindBuffer(34963, t.get(k).buffer));
  }
  function h() {
    return i.isWebGL2 ? o.createVertexArray() : r.createVertexArrayOES();
  }
  function d(P) {
    return i.isWebGL2 ? o.bindVertexArray(P) : r.bindVertexArrayOES(P);
  }
  function f(P) {
    return i.isWebGL2 ? o.deleteVertexArray(P) : r.deleteVertexArrayOES(P);
  }
  function p(P, R, L) {
    const A = L.wireframe === !0;
    let k = a[P.id];
    k === void 0 && (k = {}, a[P.id] = k);
    let Q = k[R.id];
    Q === void 0 && (Q = {}, k[R.id] = Q);
    let U = Q[A];
    return U === void 0 && (U = m(h()), Q[A] = U), U;
  }
  function m(P) {
    const R = [], L = [], A = [];
    for (let k = 0; k < n; k++)
      R[k] = 0, L[k] = 0, A[k] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: R,
      enabledAttributes: L,
      attributeDivisors: A,
      object: P,
      attributes: {},
      index: null
    };
  }
  function v(P, R) {
    const L = c.attributes, A = P.attributes;
    let k = 0;
    for (const Q in A) {
      const U = L[Q], H = A[Q];
      if (U === void 0 || U.attribute !== H || U.data !== H.data) return !0;
      k++;
    }
    return c.attributesNum !== k || c.index !== R;
  }
  function y(P, R) {
    const L = {}, A = P.attributes;
    let k = 0;
    for (const Q in A) {
      const U = A[Q], H = {};
      H.attribute = U, U.data && (H.data = U.data), L[Q] = H, k++;
    }
    c.attributes = L, c.attributesNum = k, c.index = R;
  }
  function g() {
    const P = c.newAttributes;
    for (let R = 0, L = P.length; R < L; R++)
      P[R] = 0;
  }
  function _(P) {
    b(P, 0);
  }
  function b(P, R) {
    const L = c.newAttributes, A = c.enabledAttributes, k = c.attributeDivisors;
    L[P] = 1, A[P] === 0 && (o.enableVertexAttribArray(P), A[P] = 1), k[P] !== R && ((i.isWebGL2 ? o : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](P, R), k[P] = R);
  }
  function S() {
    const P = c.newAttributes, R = c.enabledAttributes;
    for (let L = 0, A = R.length; L < A; L++)
      R[L] !== P[L] && (o.disableVertexAttribArray(L), R[L] = 0);
  }
  function x(P, R, L, A, k, Q) {
    i.isWebGL2 === !0 && (L === 5124 || L === 5125) ? o.vertexAttribIPointer(P, R, L, k, Q) : o.vertexAttribPointer(P, R, L, A, k, Q);
  }
  function M(P, R, L, A) {
    if (i.isWebGL2 === !1 && (P.isInstancedMesh || A.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    g();
    const k = A.attributes, Q = L.getAttributes(), U = R.defaultAttributeValues;
    for (const H in Q) {
      const I = Q[H];
      if (I >= 0) {
        const V = k[H];
        if (V !== void 0) {
          const W = V.normalized, X = V.itemSize, q = t.get(V);
          if (q === void 0) continue;
          const O = q.buffer, te = q.type, ne = q.bytesPerElement;
          if (V.isInterleavedBufferAttribute) {
            const ce = V.data, he = ce.stride, le = V.offset;
            ce && ce.isInstancedInterleavedBuffer ? (b(I, ce.meshPerAttribute), A._maxInstanceCount === void 0 && (A._maxInstanceCount = ce.meshPerAttribute * ce.count)) : _(I), o.bindBuffer(34962, O), x(I, X, te, W, he * ne, le * ne);
          } else
            V.isInstancedBufferAttribute ? (b(I, V.meshPerAttribute), A._maxInstanceCount === void 0 && (A._maxInstanceCount = V.meshPerAttribute * V.count)) : _(I), o.bindBuffer(34962, O), x(I, X, te, W, 0, 0);
        } else if (H === "instanceMatrix") {
          const W = t.get(P.instanceMatrix);
          if (W === void 0) continue;
          const X = W.buffer, q = W.type;
          b(I + 0, 1), b(I + 1, 1), b(I + 2, 1), b(I + 3, 1), o.bindBuffer(34962, X), o.vertexAttribPointer(I + 0, 4, q, !1, 64, 0), o.vertexAttribPointer(I + 1, 4, q, !1, 64, 16), o.vertexAttribPointer(I + 2, 4, q, !1, 64, 32), o.vertexAttribPointer(I + 3, 4, q, !1, 64, 48);
        } else if (H === "instanceColor") {
          const W = t.get(P.instanceColor);
          if (W === void 0) continue;
          const X = W.buffer, q = W.type;
          b(I, 1), o.bindBuffer(34962, X), o.vertexAttribPointer(I, 3, q, !1, 12, 0);
        } else if (U !== void 0) {
          const W = U[H];
          if (W !== void 0)
            switch (W.length) {
              case 2:
                o.vertexAttrib2fv(I, W);
                break;
              case 3:
                o.vertexAttrib3fv(I, W);
                break;
              case 4:
                o.vertexAttrib4fv(I, W);
                break;
              default:
                o.vertexAttrib1fv(I, W);
            }
        }
      }
    }
    S();
  }
  function w() {
    z();
    for (const P in a) {
      const R = a[P];
      for (const L in R) {
        const A = R[L];
        for (const k in A)
          f(A[k].object), delete A[k];
        delete R[L];
      }
      delete a[P];
    }
  }
  function D(P) {
    if (a[P.id] === void 0) return;
    const R = a[P.id];
    for (const L in R) {
      const A = R[L];
      for (const k in A)
        f(A[k].object), delete A[k];
      delete R[L];
    }
    delete a[P.id];
  }
  function B(P) {
    for (const R in a) {
      const L = a[R];
      if (L[P.id] === void 0) continue;
      const A = L[P.id];
      for (const k in A)
        f(A[k].object), delete A[k];
      delete L[P.id];
    }
  }
  function z() {
    F(), c !== l && (c = l, d(c.object));
  }
  function F() {
    l.geometry = null, l.program = null, l.wireframe = !1;
  }
  return {
    setup: u,
    reset: z,
    resetDefaultState: F,
    dispose: w,
    releaseStatesOfGeometry: D,
    releaseStatesOfProgram: B,
    initAttributes: g,
    enableAttribute: _,
    disableUnusedAttributes: S
  };
}
function WebGLBufferRenderer(o, e, t, i) {
  const n = i.isWebGL2;
  let r;
  function s(c) {
    r = c;
  }
  function a(c, u) {
    o.drawArrays(r, c, u), t.update(u, r, 1);
  }
  function l(c, u, h) {
    if (h === 0) return;
    let d, f;
    if (n)
      d = o, f = "drawArraysInstanced";
    else if (d = e.get("ANGLE_instanced_arrays"), f = "drawArraysInstancedANGLE", d === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    d[f](r, c, u, h), t.update(u, r, h);
  }
  this.setMode = s, this.render = a, this.renderInstances = l;
}
function WebGLCapabilities(o, e, t) {
  let i;
  function n() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const M = e.get("EXT_texture_filter_anisotropic");
      i = o.getParameter(M.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      i = 0;
    return i;
  }
  function r(M) {
    if (M === "highp") {
      if (o.getShaderPrecisionFormat(35633, 36338).precision > 0 && o.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      M = "mediump";
    }
    return M === "mediump" && o.getShaderPrecisionFormat(35633, 36337).precision > 0 && o.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const s = typeof WebGL2RenderingContext < "u" && o instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && o instanceof WebGL2ComputeRenderingContext;
  let a = t.precision !== void 0 ? t.precision : "highp";
  const l = r(a);
  l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
  const c = s || e.has("WEBGL_draw_buffers"), u = t.logarithmicDepthBuffer === !0, h = o.getParameter(34930), d = o.getParameter(35660), f = o.getParameter(3379), p = o.getParameter(34076), m = o.getParameter(34921), v = o.getParameter(36347), y = o.getParameter(36348), g = o.getParameter(36349), _ = d > 0, b = s || e.has("OES_texture_float"), S = _ && b, x = s ? o.getParameter(36183) : 0;
  return {
    isWebGL2: s,
    drawBuffers: c,
    getMaxAnisotropy: n,
    getMaxPrecision: r,
    precision: a,
    logarithmicDepthBuffer: u,
    maxTextures: h,
    maxVertexTextures: d,
    maxTextureSize: f,
    maxCubemapSize: p,
    maxAttributes: m,
    maxVertexUniforms: v,
    maxVaryings: y,
    maxFragmentUniforms: g,
    vertexTextures: _,
    floatFragmentTextures: b,
    floatVertexTextures: S,
    maxSamples: x
  };
}
function WebGLClipping(o) {
  const e = this;
  let t = null, i = 0, n = !1, r = !1;
  const s = new Plane(), a = new Matrix3(), l = { value: null, needsUpdate: !1 };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, d, f) {
    const p = h.length !== 0 || d || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    i !== 0 || n;
    return n = d, t = u(h, f, 0), i = h.length, p;
  }, this.beginShadows = function() {
    r = !0, u(null);
  }, this.endShadows = function() {
    r = !1, c();
  }, this.setState = function(h, d, f) {
    const p = h.clippingPlanes, m = h.clipIntersection, v = h.clipShadows, y = o.get(h);
    if (!n || p === null || p.length === 0 || r && !v)
      r ? u(null) : c();
    else {
      const g = r ? 0 : i, _ = g * 4;
      let b = y.clippingState || null;
      l.value = b, b = u(p, d, _, f);
      for (let S = 0; S !== _; ++S)
        b[S] = t[S];
      y.clippingState = b, this.numIntersection = m ? this.numPlanes : 0, this.numPlanes += g;
    }
  };
  function c() {
    l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function u(h, d, f, p) {
    const m = h !== null ? h.length : 0;
    let v = null;
    if (m !== 0) {
      if (v = l.value, p !== !0 || v === null) {
        const y = f + m * 4, g = d.matrixWorldInverse;
        a.getNormalMatrix(g), (v === null || v.length < y) && (v = new Float32Array(y));
        for (let _ = 0, b = f; _ !== m; ++_, b += 4)
          s.copy(h[_]).applyMatrix4(g, a), s.normal.toArray(v, b), v[b + 3] = s.constant;
      }
      l.value = v, l.needsUpdate = !0;
    }
    return e.numPlanes = m, e.numIntersection = 0, v;
  }
}
function WebGLCubeMaps(o) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(s, a) {
    return a === EquirectangularReflectionMapping ? s.mapping = CubeReflectionMapping : a === EquirectangularRefractionMapping && (s.mapping = CubeRefractionMapping), s;
  }
  function i(s) {
    if (s && s.isTexture) {
      const a = s.mapping;
      if (a === EquirectangularReflectionMapping || a === EquirectangularRefractionMapping)
        if (e.has(s)) {
          const l = e.get(s).texture;
          return t(l, s.mapping);
        } else {
          const l = s.image;
          if (l && l.height > 0) {
            const c = o.getRenderTarget(), u = new WebGLCubeRenderTarget(l.height / 2);
            return u.fromEquirectangularTexture(o, s), e.set(s, u), o.setRenderTarget(c), s.addEventListener("dispose", n), t(u.texture, s.mapping);
          } else
            return null;
        }
    }
    return s;
  }
  function n(s) {
    const a = s.target;
    a.removeEventListener("dispose", n);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: r
  };
}
function WebGLExtensions(o) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0)
      return e[i];
    let n;
    switch (i) {
      case "WEBGL_depth_texture":
        n = o.getExtension("WEBGL_depth_texture") || o.getExtension("MOZ_WEBGL_depth_texture") || o.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        n = o.getExtension("EXT_texture_filter_anisotropic") || o.getExtension("MOZ_EXT_texture_filter_anisotropic") || o.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        n = o.getExtension("WEBGL_compressed_texture_s3tc") || o.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || o.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        n = o.getExtension("WEBGL_compressed_texture_pvrtc") || o.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        n = o.getExtension(i);
    }
    return e[i] = n, n;
  }
  return {
    has: function(i) {
      return t(i) !== null;
    },
    init: function(i) {
      i.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float");
    },
    get: function(i) {
      const n = t(i);
      return n === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), n;
    }
  };
}
function WebGLGeometries(o, e, t, i) {
  const n = {}, r = /* @__PURE__ */ new WeakMap();
  function s(h) {
    const d = h.target;
    d.index !== null && e.remove(d.index);
    for (const p in d.attributes)
      e.remove(d.attributes[p]);
    d.removeEventListener("dispose", s), delete n[d.id];
    const f = r.get(d);
    f && (e.remove(f), r.delete(d)), i.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, t.memory.geometries--;
  }
  function a(h, d) {
    return n[d.id] === !0 || (d.addEventListener("dispose", s), n[d.id] = !0, t.memory.geometries++), d;
  }
  function l(h) {
    const d = h.attributes;
    for (const p in d)
      e.update(d[p], 34962);
    const f = h.morphAttributes;
    for (const p in f) {
      const m = f[p];
      for (let v = 0, y = m.length; v < y; v++)
        e.update(m[v], 34962);
    }
  }
  function c(h) {
    const d = [], f = h.index, p = h.attributes.position;
    let m = 0;
    if (f !== null) {
      const g = f.array;
      m = f.version;
      for (let _ = 0, b = g.length; _ < b; _ += 3) {
        const S = g[_ + 0], x = g[_ + 1], M = g[_ + 2];
        d.push(S, x, x, M, M, S);
      }
    } else {
      const g = p.array;
      m = p.version;
      for (let _ = 0, b = g.length / 3 - 1; _ < b; _ += 3) {
        const S = _ + 0, x = _ + 1, M = _ + 2;
        d.push(S, x, x, M, M, S);
      }
    }
    const v = new (arrayMax(d) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(d, 1);
    v.version = m;
    const y = r.get(h);
    y && e.remove(y), r.set(h, v);
  }
  function u(h) {
    const d = r.get(h);
    if (d) {
      const f = h.index;
      f !== null && d.version < f.version && c(h);
    } else
      c(h);
    return r.get(h);
  }
  return {
    get: a,
    update: l,
    getWireframeAttribute: u
  };
}
function WebGLIndexedBufferRenderer(o, e, t, i) {
  const n = i.isWebGL2;
  let r;
  function s(d) {
    r = d;
  }
  let a, l;
  function c(d) {
    a = d.type, l = d.bytesPerElement;
  }
  function u(d, f) {
    o.drawElements(r, f, a, d * l), t.update(f, r, 1);
  }
  function h(d, f, p) {
    if (p === 0) return;
    let m, v;
    if (n)
      m = o, v = "drawElementsInstanced";
    else if (m = e.get("ANGLE_instanced_arrays"), v = "drawElementsInstancedANGLE", m === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    m[v](r, f, a, d * l, p), t.update(f, r, p);
  }
  this.setMode = s, this.setIndex = c, this.render = u, this.renderInstances = h;
}
function WebGLInfo(o) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function i(r, s, a) {
    switch (t.calls++, s) {
      case 4:
        t.triangles += a * (r / 3);
        break;
      case 1:
        t.lines += a * (r / 2);
        break;
      case 3:
        t.lines += a * (r - 1);
        break;
      case 2:
        t.lines += a * r;
        break;
      case 0:
        t.points += a * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", s);
        break;
    }
  }
  function n() {
    t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: n,
    update: i
  };
}
function numericalSort(o, e) {
  return o[0] - e[0];
}
function absNumericalSort(o, e) {
  return Math.abs(e[1]) - Math.abs(o[1]);
}
function WebGLMorphtargets(o) {
  const e = {}, t = new Float32Array(8), i = [];
  for (let r = 0; r < 8; r++)
    i[r] = [r, 0];
  function n(r, s, a, l) {
    const c = r.morphTargetInfluences, u = c === void 0 ? 0 : c.length;
    let h = e[s.id];
    if (h === void 0 || h.length !== u) {
      h = [];
      for (let v = 0; v < u; v++)
        h[v] = [v, 0];
      e[s.id] = h;
    }
    for (let v = 0; v < u; v++) {
      const y = h[v];
      y[0] = v, y[1] = c[v];
    }
    h.sort(absNumericalSort);
    for (let v = 0; v < 8; v++)
      v < u && h[v][1] ? (i[v][0] = h[v][0], i[v][1] = h[v][1]) : (i[v][0] = Number.MAX_SAFE_INTEGER, i[v][1] = 0);
    i.sort(numericalSort);
    const d = a.morphTargets && s.morphAttributes.position, f = a.morphNormals && s.morphAttributes.normal;
    let p = 0;
    for (let v = 0; v < 8; v++) {
      const y = i[v], g = y[0], _ = y[1];
      g !== Number.MAX_SAFE_INTEGER && _ ? (d && s.getAttribute("morphTarget" + v) !== d[g] && s.setAttribute("morphTarget" + v, d[g]), f && s.getAttribute("morphNormal" + v) !== f[g] && s.setAttribute("morphNormal" + v, f[g]), t[v] = _, p += _) : (d && s.hasAttribute("morphTarget" + v) === !0 && s.deleteAttribute("morphTarget" + v), f && s.hasAttribute("morphNormal" + v) === !0 && s.deleteAttribute("morphNormal" + v), t[v] = 0);
    }
    const m = s.morphTargetsRelative ? 1 : 1 - p;
    l.getUniforms().setValue(o, "morphTargetBaseInfluence", m), l.getUniforms().setValue(o, "morphTargetInfluences", t);
  }
  return {
    update: n
  };
}
function WebGLObjects(o, e, t, i) {
  let n = /* @__PURE__ */ new WeakMap();
  function r(l) {
    const c = i.render.frame, u = l.geometry, h = e.get(l, u);
    return n.get(h) !== c && (e.update(h), n.set(h, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), t.update(l.instanceMatrix, 34962), l.instanceColor !== null && t.update(l.instanceColor, 34962)), h;
  }
  function s() {
    n = /* @__PURE__ */ new WeakMap();
  }
  function a(l) {
    const c = l.target;
    c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return {
    update: r,
    dispose: s
  };
}
class DataTexture2DArray extends Texture {
  constructor(e = null, t = 1, i = 1, n = 1) {
    super(null), this.image = { data: e, width: t, height: i, depth: n }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0;
  }
}
DataTexture2DArray.prototype.isDataTexture2DArray = !0;
class DataTexture3D extends Texture {
  constructor(e = null, t = 1, i = 1, n = 1) {
    super(null), this.image = { data: e, width: t, height: i, depth: n }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0;
  }
}
DataTexture3D.prototype.isDataTexture3D = !0;
const emptyTexture = new Texture(), emptyTexture2dArray = new DataTexture2DArray(), emptyTexture3d = new DataTexture3D(), emptyCubeTexture = new CubeTexture(), arrayCacheF32 = [], arrayCacheI32 = [], mat4array = new Float32Array(16), mat3array = new Float32Array(9), mat2array = new Float32Array(4);
function flatten(o, e, t) {
  const i = o[0];
  if (i <= 0 || i > 0) return o;
  const n = e * t;
  let r = arrayCacheF32[n];
  if (r === void 0 && (r = new Float32Array(n), arrayCacheF32[n] = r), e !== 0) {
    i.toArray(r, 0);
    for (let s = 1, a = 0; s !== e; ++s)
      a += t, o[s].toArray(r, a);
  }
  return r;
}
function arraysEqual(o, e) {
  if (o.length !== e.length) return !1;
  for (let t = 0, i = o.length; t < i; t++)
    if (o[t] !== e[t]) return !1;
  return !0;
}
function copyArray$1(o, e) {
  for (let t = 0, i = e.length; t < i; t++)
    o[t] = e[t];
}
function allocTexUnits(o, e) {
  let t = arrayCacheI32[e];
  t === void 0 && (t = new Int32Array(e), arrayCacheI32[e] = t);
  for (let i = 0; i !== e; ++i)
    t[i] = o.allocateTextureUnit();
  return t;
}
function setValueV1f(o, e) {
  const t = this.cache;
  t[0] !== e && (o.uniform1f(this.addr, e), t[0] = e);
}
function setValueV2f(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (o.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (arraysEqual(t, e)) return;
    o.uniform2fv(this.addr, e), copyArray$1(t, e);
  }
}
function setValueV3f(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (o.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (o.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (arraysEqual(t, e)) return;
    o.uniform3fv(this.addr, e), copyArray$1(t, e);
  }
}
function setValueV4f(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (o.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (arraysEqual(t, e)) return;
    o.uniform4fv(this.addr, e), copyArray$1(t, e);
  }
}
function setValueM2(o, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (arraysEqual(t, e)) return;
    o.uniformMatrix2fv(this.addr, !1, e), copyArray$1(t, e);
  } else {
    if (arraysEqual(t, i)) return;
    mat2array.set(i), o.uniformMatrix2fv(this.addr, !1, mat2array), copyArray$1(t, i);
  }
}
function setValueM3(o, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (arraysEqual(t, e)) return;
    o.uniformMatrix3fv(this.addr, !1, e), copyArray$1(t, e);
  } else {
    if (arraysEqual(t, i)) return;
    mat3array.set(i), o.uniformMatrix3fv(this.addr, !1, mat3array), copyArray$1(t, i);
  }
}
function setValueM4(o, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (arraysEqual(t, e)) return;
    o.uniformMatrix4fv(this.addr, !1, e), copyArray$1(t, e);
  } else {
    if (arraysEqual(t, i)) return;
    mat4array.set(i), o.uniformMatrix4fv(this.addr, !1, mat4array), copyArray$1(t, i);
  }
}
function setValueV1i(o, e) {
  const t = this.cache;
  t[0] !== e && (o.uniform1i(this.addr, e), t[0] = e);
}
function setValueV2i(o, e) {
  const t = this.cache;
  arraysEqual(t, e) || (o.uniform2iv(this.addr, e), copyArray$1(t, e));
}
function setValueV3i(o, e) {
  const t = this.cache;
  arraysEqual(t, e) || (o.uniform3iv(this.addr, e), copyArray$1(t, e));
}
function setValueV4i(o, e) {
  const t = this.cache;
  arraysEqual(t, e) || (o.uniform4iv(this.addr, e), copyArray$1(t, e));
}
function setValueV1ui(o, e) {
  const t = this.cache;
  t[0] !== e && (o.uniform1ui(this.addr, e), t[0] = e);
}
function setValueV2ui(o, e) {
  const t = this.cache;
  arraysEqual(t, e) || (o.uniform2uiv(this.addr, e), copyArray$1(t, e));
}
function setValueV3ui(o, e) {
  const t = this.cache;
  arraysEqual(t, e) || (o.uniform3uiv(this.addr, e), copyArray$1(t, e));
}
function setValueV4ui(o, e) {
  const t = this.cache;
  arraysEqual(t, e) || (o.uniform4uiv(this.addr, e), copyArray$1(t, e));
}
function setValueT1(o, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (o.uniform1i(this.addr, n), i[0] = n), t.safeSetTexture2D(e || emptyTexture, n);
}
function setValueT3D1(o, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (o.uniform1i(this.addr, n), i[0] = n), t.setTexture3D(e || emptyTexture3d, n);
}
function setValueT6(o, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (o.uniform1i(this.addr, n), i[0] = n), t.safeSetTextureCube(e || emptyCubeTexture, n);
}
function setValueT2DArray1(o, e, t) {
  const i = this.cache, n = t.allocateTextureUnit();
  i[0] !== n && (o.uniform1i(this.addr, n), i[0] = n), t.setTexture2DArray(e || emptyTexture2dArray, n);
}
function getSingularSetter(o) {
  switch (o) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(o, e) {
  o.uniform1fv(this.addr, e);
}
function setValueV2fArray(o, e) {
  const t = flatten(e, this.size, 2);
  o.uniform2fv(this.addr, t);
}
function setValueV3fArray(o, e) {
  const t = flatten(e, this.size, 3);
  o.uniform3fv(this.addr, t);
}
function setValueV4fArray(o, e) {
  const t = flatten(e, this.size, 4);
  o.uniform4fv(this.addr, t);
}
function setValueM2Array(o, e) {
  const t = flatten(e, this.size, 4);
  o.uniformMatrix2fv(this.addr, !1, t);
}
function setValueM3Array(o, e) {
  const t = flatten(e, this.size, 9);
  o.uniformMatrix3fv(this.addr, !1, t);
}
function setValueM4Array(o, e) {
  const t = flatten(e, this.size, 16);
  o.uniformMatrix4fv(this.addr, !1, t);
}
function setValueV1iArray(o, e) {
  o.uniform1iv(this.addr, e);
}
function setValueV2iArray(o, e) {
  o.uniform2iv(this.addr, e);
}
function setValueV3iArray(o, e) {
  o.uniform3iv(this.addr, e);
}
function setValueV4iArray(o, e) {
  o.uniform4iv(this.addr, e);
}
function setValueV1uiArray(o, e) {
  o.uniform1uiv(this.addr, e);
}
function setValueV2uiArray(o, e) {
  o.uniform2uiv(this.addr, e);
}
function setValueV3uiArray(o, e) {
  o.uniform3uiv(this.addr, e);
}
function setValueV4uiArray(o, e) {
  o.uniform4uiv(this.addr, e);
}
function setValueT1Array(o, e, t) {
  const i = e.length, n = allocTexUnits(t, i);
  o.uniform1iv(this.addr, n);
  for (let r = 0; r !== i; ++r)
    t.safeSetTexture2D(e[r] || emptyTexture, n[r]);
}
function setValueT6Array(o, e, t) {
  const i = e.length, n = allocTexUnits(t, i);
  o.uniform1iv(this.addr, n);
  for (let r = 0; r !== i; ++r)
    t.safeSetTextureCube(e[r] || emptyCubeTexture, n[r]);
}
function getPureArraySetter(o) {
  switch (o) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
  }
}
function SingleUniform(o, e, t) {
  this.id = o, this.addr = t, this.cache = [], this.setValue = getSingularSetter(e.type);
}
function PureArrayUniform(o, e, t) {
  this.id = o, this.addr = t, this.cache = [], this.size = e.size, this.setValue = getPureArraySetter(e.type);
}
PureArrayUniform.prototype.updateCache = function(o) {
  const e = this.cache;
  o instanceof Float32Array && e.length !== o.length && (this.cache = new Float32Array(o.length)), copyArray$1(e, o);
};
function StructuredUniform(o) {
  this.id = o, this.seq = [], this.map = {};
}
StructuredUniform.prototype.setValue = function(o, e, t) {
  const i = this.seq;
  for (let n = 0, r = i.length; n !== r; ++n) {
    const s = i[n];
    s.setValue(o, e[s.id], t);
  }
};
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(o, e) {
  o.seq.push(e), o.map[e.id] = e;
}
function parseUniform(o, e, t) {
  const i = o.name, n = i.length;
  for (RePathPart.lastIndex = 0; ; ) {
    const r = RePathPart.exec(i), s = RePathPart.lastIndex;
    let a = r[1];
    const l = r[2] === "]", c = r[3];
    if (l && (a = a | 0), c === void 0 || c === "[" && s + 2 === n) {
      addUniform(t, c === void 0 ? new SingleUniform(a, o, e) : new PureArrayUniform(a, o, e));
      break;
    } else {
      let h = t.map[a];
      h === void 0 && (h = new StructuredUniform(a), addUniform(t, h)), t = h;
    }
  }
}
function WebGLUniforms(o, e) {
  this.seq = [], this.map = {};
  const t = o.getProgramParameter(e, 35718);
  for (let i = 0; i < t; ++i) {
    const n = o.getActiveUniform(e, i), r = o.getUniformLocation(e, n.name);
    parseUniform(n, r, this);
  }
}
WebGLUniforms.prototype.setValue = function(o, e, t, i) {
  const n = this.map[e];
  n !== void 0 && n.setValue(o, t, i);
};
WebGLUniforms.prototype.setOptional = function(o, e, t) {
  const i = e[t];
  i !== void 0 && this.setValue(o, t, i);
};
WebGLUniforms.upload = function(o, e, t, i) {
  for (let n = 0, r = e.length; n !== r; ++n) {
    const s = e[n], a = t[s.id];
    a.needsUpdate !== !1 && s.setValue(o, a.value, i);
  }
};
WebGLUniforms.seqWithValue = function(o, e) {
  const t = [];
  for (let i = 0, n = o.length; i !== n; ++i) {
    const r = o[i];
    r.id in e && t.push(r);
  }
  return t;
};
function WebGLShader(o, e, t) {
  const i = o.createShader(e);
  return o.shaderSource(i, t), o.compileShader(i), i;
}
let programIdCount = 0;
function addLineNumbers(o) {
  const e = o.split(`
`);
  for (let t = 0; t < e.length; t++)
    e[t] = t + 1 + ": " + e[t];
  return e.join(`
`);
}
function getEncodingComponents(o) {
  switch (o) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case LogLuvEncoding:
      return ["LogLuv", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", o), ["Linear", "( value )"];
  }
}
function getShaderErrors(o, e, t) {
  const i = o.getShaderParameter(e, 35713), n = o.getShaderInfoLog(e).trim();
  if (i && n === "") return "";
  const r = o.getShaderSource(e);
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + t + `
` + n + addLineNumbers(r);
}
function getTexelDecodingFunction(o, e) {
  const t = getEncodingComponents(e);
  return "vec4 " + o + "( vec4 value ) { return " + t[0] + "ToLinear" + t[1] + "; }";
}
function getTexelEncodingFunction(o, e) {
  const t = getEncodingComponents(e);
  return "vec4 " + o + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function getToneMappingFunction(o, e) {
  let t;
  switch (e) {
    case LinearToneMapping:
      t = "Linear";
      break;
    case ReinhardToneMapping:
      t = "Reinhard";
      break;
    case CineonToneMapping:
      t = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      t = "ACESFilmic";
      break;
    case CustomToneMapping:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + o + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function generateExtensions(o) {
  return [
    o.extensionDerivatives || o.envMapCubeUV || o.bumpMap || o.tangentSpaceNormalMap || o.clearcoatNormalMap || o.flatShading || o.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (o.extensionFragDepth || o.logarithmicDepthBuffer) && o.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    o.extensionDrawBuffers && o.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (o.extensionShaderTextureLOD || o.envMap || o.transmission > 0) && o.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(filterEmptyLine).join(`
`);
}
function generateDefines(o) {
  const e = [];
  for (const t in o) {
    const i = o[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function fetchAttributeLocations(o, e) {
  const t = {}, i = o.getProgramParameter(e, 35721);
  for (let n = 0; n < i; n++) {
    const s = o.getActiveAttrib(e, n).name;
    t[s] = o.getAttribLocation(e, s);
  }
  return t;
}
function filterEmptyLine(o) {
  return o !== "";
}
function replaceLightNums(o, e) {
  return o.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function replaceClippingPlaneNums(o, e) {
  return o.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(o) {
  return o.replace(includePattern, includeReplacer);
}
function includeReplacer(o, e) {
  const t = ShaderChunk[e];
  if (t === void 0)
    throw new Error("Can not resolve #include <" + e + ">");
  return resolveIncludes(t);
}
const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(o) {
  return o.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(o, e, t, i) {
  return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), loopReplacer(o, e, t, i);
}
function loopReplacer(o, e, t, i) {
  let n = "";
  for (let r = parseInt(e); r < parseInt(t); r++)
    n += i.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
  return n;
}
function generatePrecision(o) {
  let e = "precision " + o.precision + ` float;
precision ` + o.precision + " int;";
  return o.precision === "highp" ? e += `
#define HIGH_PRECISION` : o.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : o.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function generateShadowMapTypeDefine(o) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return o.shadowMapType === PCFShadowMap ? e = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === PCFSoftShadowMap ? e = "SHADOWMAP_TYPE_PCF_SOFT" : o.shadowMapType === VSMShadowMap && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function generateEnvMapTypeDefine(o) {
  let e = "ENVMAP_TYPE_CUBE";
  if (o.envMap)
    switch (o.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function generateEnvMapModeDefine(o) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (o.envMap)
    switch (o.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function generateEnvMapBlendingDefine(o) {
  let e = "ENVMAP_BLENDING_NONE";
  if (o.envMap)
    switch (o.combine) {
      case MultiplyOperation:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function WebGLProgram(o, e, t, i) {
  const n = o.getContext(), r = t.defines;
  let s = t.vertexShader, a = t.fragmentShader;
  const l = generateShadowMapTypeDefine(t), c = generateEnvMapTypeDefine(t), u = generateEnvMapModeDefine(t), h = generateEnvMapBlendingDefine(t), d = o.gammaFactor > 0 ? o.gammaFactor : 1, f = t.isWebGL2 ? "" : generateExtensions(t), p = generateDefines(r), m = n.createProgram();
  let v, y, g = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (v = [
    p
  ].filter(filterEmptyLine).join(`
`), v.length > 0 && (v += `
`), y = [
    f,
    p
  ].filter(filterEmptyLine).join(`
`), y.length > 0 && (y += `
`)) : (v = [
    generatePrecision(t),
    "#define SHADER_NAME " + t.shaderName,
    p,
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
    "#define GAMMA_FACTOR " + d,
    "#define MAX_BONES " + t.maxBones,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + u : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUvs ? "#define USE_UV" : "",
    t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.useVertexTexture ? "#define BONE_TEXTURE" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_MORPHTARGETS",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(filterEmptyLine).join(`
`), y = [
    f,
    generatePrecision(t),
    "#define SHADER_NAME " + t.shaderName,
    p,
    t.alphaTest ? "#define ALPHATEST " + t.alphaTest + (t.alphaTest % 1 ? "" : ".0") : "",
    // add '.0' if integer
    "#define GAMMA_FACTOR " + d,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + c : "",
    t.envMap ? "#define " + u : "",
    t.envMap ? "#define " + h : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUvs ? "#define USE_UV" : "",
    t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
    t.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    ShaderChunk.encodings_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    t.map ? getTexelDecodingFunction("mapTexelToLinear", t.mapEncoding) : "",
    t.matcap ? getTexelDecodingFunction("matcapTexelToLinear", t.matcapEncoding) : "",
    t.envMap ? getTexelDecodingFunction("envMapTexelToLinear", t.envMapEncoding) : "",
    t.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", t.emissiveMapEncoding) : "",
    t.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", t.lightMapEncoding) : "",
    getTexelEncodingFunction("linearToOutputTexel", t.outputEncoding),
    t.depthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(filterEmptyLine).join(`
`)), s = resolveIncludes(s), s = replaceLightNums(s, t), s = replaceClippingPlaneNums(s, t), a = resolveIncludes(a), a = replaceLightNums(a, t), a = replaceClippingPlaneNums(a, t), s = unrollLoops(s), a = unrollLoops(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (g = `#version 300 es
`, v = [
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + v, y = [
    "#define varying in",
    t.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
    t.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + y);
  const _ = g + v + s, b = g + y + a, S = WebGLShader(n, 35633, _), x = WebGLShader(n, 35632, b);
  if (n.attachShader(m, S), n.attachShader(m, x), t.index0AttributeName !== void 0 ? n.bindAttribLocation(m, 0, t.index0AttributeName) : t.morphTargets === !0 && n.bindAttribLocation(m, 0, "position"), n.linkProgram(m), o.debug.checkShaderErrors) {
    const D = n.getProgramInfoLog(m).trim(), B = n.getShaderInfoLog(S).trim(), z = n.getShaderInfoLog(x).trim();
    let F = !0, P = !0;
    if (n.getProgramParameter(m, 35714) === !1) {
      F = !1;
      const R = getShaderErrors(n, S, "vertex"), L = getShaderErrors(n, x, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", n.getError(), "35715", n.getProgramParameter(m, 35715), "gl.getProgramInfoLog", D, R, L);
    } else D !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", D) : (B === "" || z === "") && (P = !1);
    P && (this.diagnostics = {
      runnable: F,
      programLog: D,
      vertexShader: {
        log: B,
        prefix: v
      },
      fragmentShader: {
        log: z,
        prefix: y
      }
    });
  }
  n.deleteShader(S), n.deleteShader(x);
  let M;
  this.getUniforms = function() {
    return M === void 0 && (M = new WebGLUniforms(n, m)), M;
  };
  let w;
  return this.getAttributes = function() {
    return w === void 0 && (w = fetchAttributeLocations(n, m)), w;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), n.deleteProgram(m), this.program = void 0;
  }, this.name = t.shaderName, this.id = programIdCount++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = S, this.fragmentShader = x, this;
}
function WebGLPrograms(o, e, t, i, n, r) {
  const s = [], a = i.isWebGL2, l = i.logarithmicDepthBuffer, c = i.floatVertexTextures, u = i.maxVertexUniforms, h = i.vertexTextures;
  let d = i.precision;
  const f = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  }, p = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "instancingColor",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "vertexAlphas",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "sheen",
    "transmission",
    "transmissionMap",
    "thicknessMap"
  ];
  function m(x) {
    const w = x.skeleton.bones;
    if (c)
      return 1024;
    {
      const B = Math.floor((u - 20) / 4), z = Math.min(B, w.length);
      return z < w.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + w.length + " bones. This GPU supports " + z + "."), 0) : z;
    }
  }
  function v(x) {
    let M;
    return x && x.isTexture ? M = x.encoding : x && x.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), M = x.texture.encoding) : M = LinearEncoding, M;
  }
  function y(x, M, w, D, B) {
    const z = D.fog, F = x.isMeshStandardMaterial ? D.environment : null, P = e.get(x.envMap || F), R = f[x.type], L = B.isSkinnedMesh ? m(B) : 0;
    x.precision !== null && (d = i.getMaxPrecision(x.precision), d !== x.precision && console.warn("THREE.WebGLProgram.getParameters:", x.precision, "not supported, using", d, "instead."));
    let A, k;
    if (R) {
      const H = ShaderLib[R];
      A = H.vertexShader, k = H.fragmentShader;
    } else
      A = x.vertexShader, k = x.fragmentShader;
    const Q = o.getRenderTarget();
    return {
      isWebGL2: a,
      shaderID: R,
      shaderName: x.type,
      vertexShader: A,
      fragmentShader: k,
      defines: x.defines,
      isRawShaderMaterial: x.isRawShaderMaterial === !0,
      glslVersion: x.glslVersion,
      precision: d,
      instancing: B.isInstancedMesh === !0,
      instancingColor: B.isInstancedMesh === !0 && B.instanceColor !== null,
      supportsVertexTextures: h,
      outputEncoding: Q !== null ? v(Q.texture) : o.outputEncoding,
      map: !!x.map,
      mapEncoding: v(x.map),
      matcap: !!x.matcap,
      matcapEncoding: v(x.matcap),
      envMap: !!P,
      envMapMode: P && P.mapping,
      envMapEncoding: v(P),
      envMapCubeUV: !!P && (P.mapping === CubeUVReflectionMapping || P.mapping === CubeUVRefractionMapping),
      lightMap: !!x.lightMap,
      lightMapEncoding: v(x.lightMap),
      aoMap: !!x.aoMap,
      emissiveMap: !!x.emissiveMap,
      emissiveMapEncoding: v(x.emissiveMap),
      bumpMap: !!x.bumpMap,
      normalMap: !!x.normalMap,
      objectSpaceNormalMap: x.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: x.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!x.clearcoatMap,
      clearcoatRoughnessMap: !!x.clearcoatRoughnessMap,
      clearcoatNormalMap: !!x.clearcoatNormalMap,
      displacementMap: !!x.displacementMap,
      roughnessMap: !!x.roughnessMap,
      metalnessMap: !!x.metalnessMap,
      specularMap: !!x.specularMap,
      alphaMap: !!x.alphaMap,
      gradientMap: !!x.gradientMap,
      sheen: !!x.sheen,
      transmission: !!x.transmission,
      transmissionMap: !!x.transmissionMap,
      thicknessMap: !!x.thicknessMap,
      combine: x.combine,
      vertexTangents: x.normalMap && x.vertexTangents,
      vertexColors: x.vertexColors,
      vertexAlphas: x.vertexColors === !0 && B.geometry && B.geometry.attributes.color && B.geometry.attributes.color.itemSize === 4,
      vertexUvs: !!x.map || !!x.bumpMap || !!x.normalMap || !!x.specularMap || !!x.alphaMap || !!x.emissiveMap || !!x.roughnessMap || !!x.metalnessMap || !!x.clearcoatMap || !!x.clearcoatRoughnessMap || !!x.clearcoatNormalMap || !!x.displacementMap || !!x.transmissionMap || !!x.thicknessMap,
      uvsVertexOnly: !(x.map || x.bumpMap || x.normalMap || x.specularMap || x.alphaMap || x.emissiveMap || x.roughnessMap || x.metalnessMap || x.clearcoatNormalMap || x.transmission || x.transmissionMap || x.thicknessMap) && !!x.displacementMap,
      fog: !!z,
      useFog: x.fog,
      fogExp2: z && z.isFogExp2,
      flatShading: !!x.flatShading,
      sizeAttenuation: x.sizeAttenuation,
      logarithmicDepthBuffer: l,
      skinning: B.isSkinnedMesh === !0 && L > 0,
      maxBones: L,
      useVertexTexture: c,
      morphTargets: x.morphTargets,
      morphNormals: x.morphNormals,
      numDirLights: M.directional.length,
      numPointLights: M.point.length,
      numSpotLights: M.spot.length,
      numRectAreaLights: M.rectArea.length,
      numHemiLights: M.hemi.length,
      numDirLightShadows: M.directionalShadowMap.length,
      numPointLightShadows: M.pointShadowMap.length,
      numSpotLightShadows: M.spotShadowMap.length,
      numClippingPlanes: r.numPlanes,
      numClipIntersection: r.numIntersection,
      dithering: x.dithering,
      shadowMapEnabled: o.shadowMap.enabled && w.length > 0,
      shadowMapType: o.shadowMap.type,
      toneMapping: x.toneMapped ? o.toneMapping : NoToneMapping,
      physicallyCorrectLights: o.physicallyCorrectLights,
      premultipliedAlpha: x.premultipliedAlpha,
      alphaTest: x.alphaTest,
      doubleSided: x.side === DoubleSide,
      flipSided: x.side === BackSide,
      depthPacking: x.depthPacking !== void 0 ? x.depthPacking : !1,
      index0AttributeName: x.index0AttributeName,
      extensionDerivatives: x.extensions && x.extensions.derivatives,
      extensionFragDepth: x.extensions && x.extensions.fragDepth,
      extensionDrawBuffers: x.extensions && x.extensions.drawBuffers,
      extensionShaderTextureLOD: x.extensions && x.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: a || t.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: a || t.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: a || t.has("EXT_shader_texture_lod"),
      customProgramCacheKey: x.customProgramCacheKey()
    };
  }
  function g(x) {
    const M = [];
    if (x.shaderID ? M.push(x.shaderID) : (M.push(x.fragmentShader), M.push(x.vertexShader)), x.defines !== void 0)
      for (const w in x.defines)
        M.push(w), M.push(x.defines[w]);
    if (x.isRawShaderMaterial === !1) {
      for (let w = 0; w < p.length; w++)
        M.push(x[p[w]]);
      M.push(o.outputEncoding), M.push(o.gammaFactor);
    }
    return M.push(x.customProgramCacheKey), M.join();
  }
  function _(x) {
    const M = f[x.type];
    let w;
    if (M) {
      const D = ShaderLib[M];
      w = UniformsUtils.clone(D.uniforms);
    } else
      w = x.uniforms;
    return w;
  }
  function b(x, M) {
    let w;
    for (let D = 0, B = s.length; D < B; D++) {
      const z = s[D];
      if (z.cacheKey === M) {
        w = z, ++w.usedTimes;
        break;
      }
    }
    return w === void 0 && (w = new WebGLProgram(o, M, x, n), s.push(w)), w;
  }
  function S(x) {
    if (--x.usedTimes === 0) {
      const M = s.indexOf(x);
      s[M] = s[s.length - 1], s.pop(), x.destroy();
    }
  }
  return {
    getParameters: y,
    getProgramCacheKey: g,
    getUniforms: _,
    acquireProgram: b,
    releaseProgram: S,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: s
  };
}
function WebGLProperties() {
  let o = /* @__PURE__ */ new WeakMap();
  function e(r) {
    let s = o.get(r);
    return s === void 0 && (s = {}, o.set(r, s)), s;
  }
  function t(r) {
    o.delete(r);
  }
  function i(r, s, a) {
    o.get(r)[s] = a;
  }
  function n() {
    o = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: i,
    dispose: n
  };
}
function painterSortStable(o, e) {
  return o.groupOrder !== e.groupOrder ? o.groupOrder - e.groupOrder : o.renderOrder !== e.renderOrder ? o.renderOrder - e.renderOrder : o.program !== e.program ? o.program.id - e.program.id : o.material.id !== e.material.id ? o.material.id - e.material.id : o.z !== e.z ? o.z - e.z : o.id - e.id;
}
function reversePainterSortStable(o, e) {
  return o.groupOrder !== e.groupOrder ? o.groupOrder - e.groupOrder : o.renderOrder !== e.renderOrder ? o.renderOrder - e.renderOrder : o.z !== e.z ? e.z - o.z : o.id - e.id;
}
function WebGLRenderList(o) {
  const e = [];
  let t = 0;
  const i = [], n = [], r = [], s = { id: -1 };
  function a() {
    t = 0, i.length = 0, n.length = 0, r.length = 0;
  }
  function l(f, p, m, v, y, g) {
    let _ = e[t];
    const b = o.get(m);
    return _ === void 0 ? (_ = {
      id: f.id,
      object: f,
      geometry: p,
      material: m,
      program: b.program || s,
      groupOrder: v,
      renderOrder: f.renderOrder,
      z: y,
      group: g
    }, e[t] = _) : (_.id = f.id, _.object = f, _.geometry = p, _.material = m, _.program = b.program || s, _.groupOrder = v, _.renderOrder = f.renderOrder, _.z = y, _.group = g), t++, _;
  }
  function c(f, p, m, v, y, g) {
    const _ = l(f, p, m, v, y, g);
    m.transmission > 0 ? n.push(_) : m.transparent === !0 ? r.push(_) : i.push(_);
  }
  function u(f, p, m, v, y, g) {
    const _ = l(f, p, m, v, y, g);
    m.transmission > 0 ? n.unshift(_) : m.transparent === !0 ? r.unshift(_) : i.unshift(_);
  }
  function h(f, p) {
    i.length > 1 && i.sort(f || painterSortStable), n.length > 1 && n.sort(p || reversePainterSortStable), r.length > 1 && r.sort(p || reversePainterSortStable);
  }
  function d() {
    for (let f = t, p = e.length; f < p; f++) {
      const m = e[f];
      if (m.id === null) break;
      m.id = null, m.object = null, m.geometry = null, m.material = null, m.program = null, m.group = null;
    }
  }
  return {
    opaque: i,
    transmissive: n,
    transparent: r,
    init: a,
    push: c,
    unshift: u,
    finish: d,
    sort: h
  };
}
function WebGLRenderLists(o) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(n, r) {
    let s;
    return e.has(n) === !1 ? (s = new WebGLRenderList(o), e.set(n, [s])) : r >= e.get(n).length ? (s = new WebGLRenderList(o), e.get(n).push(s)) : s = e.get(n)[r], s;
  }
  function i() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    dispose: i
  };
}
function UniformsCache() {
  const o = {};
  return {
    get: function(e) {
      if (o[e.id] !== void 0)
        return o[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          t = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      return o[e.id] = t, t;
    }
  };
}
function ShadowUniformsCache() {
  const o = {};
  return {
    get: function(e) {
      if (o[e.id] !== void 0)
        return o[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return o[e.id] = t, t;
    }
  };
}
let nextVersion = 0;
function shadowCastingLightsFirst(o, e) {
  return (e.castShadow ? 1 : 0) - (o.castShadow ? 1 : 0);
}
function WebGLLights(o, e) {
  const t = new UniformsCache(), i = ShadowUniformsCache(), n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let u = 0; u < 9; u++) n.probe.push(new Vector3());
  const r = new Vector3(), s = new Matrix4(), a = new Matrix4();
  function l(u) {
    let h = 0, d = 0, f = 0;
    for (let M = 0; M < 9; M++) n.probe[M].set(0, 0, 0);
    let p = 0, m = 0, v = 0, y = 0, g = 0, _ = 0, b = 0, S = 0;
    u.sort(shadowCastingLightsFirst);
    for (let M = 0, w = u.length; M < w; M++) {
      const D = u[M], B = D.color, z = D.intensity, F = D.distance, P = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
      if (D.isAmbientLight)
        h += B.r * z, d += B.g * z, f += B.b * z;
      else if (D.isLightProbe)
        for (let R = 0; R < 9; R++)
          n.probe[R].addScaledVector(D.sh.coefficients[R], z);
      else if (D.isDirectionalLight) {
        const R = t.get(D);
        if (R.color.copy(D.color).multiplyScalar(D.intensity), D.castShadow) {
          const L = D.shadow, A = i.get(D);
          A.shadowBias = L.bias, A.shadowNormalBias = L.normalBias, A.shadowRadius = L.radius, A.shadowMapSize = L.mapSize, n.directionalShadow[p] = A, n.directionalShadowMap[p] = P, n.directionalShadowMatrix[p] = D.shadow.matrix, _++;
        }
        n.directional[p] = R, p++;
      } else if (D.isSpotLight) {
        const R = t.get(D);
        if (R.position.setFromMatrixPosition(D.matrixWorld), R.color.copy(B).multiplyScalar(z), R.distance = F, R.coneCos = Math.cos(D.angle), R.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)), R.decay = D.decay, D.castShadow) {
          const L = D.shadow, A = i.get(D);
          A.shadowBias = L.bias, A.shadowNormalBias = L.normalBias, A.shadowRadius = L.radius, A.shadowMapSize = L.mapSize, n.spotShadow[v] = A, n.spotShadowMap[v] = P, n.spotShadowMatrix[v] = D.shadow.matrix, S++;
        }
        n.spot[v] = R, v++;
      } else if (D.isRectAreaLight) {
        const R = t.get(D);
        R.color.copy(B).multiplyScalar(z), R.halfWidth.set(D.width * 0.5, 0, 0), R.halfHeight.set(0, D.height * 0.5, 0), n.rectArea[y] = R, y++;
      } else if (D.isPointLight) {
        const R = t.get(D);
        if (R.color.copy(D.color).multiplyScalar(D.intensity), R.distance = D.distance, R.decay = D.decay, D.castShadow) {
          const L = D.shadow, A = i.get(D);
          A.shadowBias = L.bias, A.shadowNormalBias = L.normalBias, A.shadowRadius = L.radius, A.shadowMapSize = L.mapSize, A.shadowCameraNear = L.camera.near, A.shadowCameraFar = L.camera.far, n.pointShadow[m] = A, n.pointShadowMap[m] = P, n.pointShadowMatrix[m] = D.shadow.matrix, b++;
        }
        n.point[m] = R, m++;
      } else if (D.isHemisphereLight) {
        const R = t.get(D);
        R.skyColor.copy(D.color).multiplyScalar(z), R.groundColor.copy(D.groundColor).multiplyScalar(z), n.hemi[g] = R, g++;
      }
    }
    y > 0 && (e.isWebGL2 || o.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1, n.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2) : o.has("OES_texture_half_float_linear") === !0 ? (n.rectAreaLTC1 = UniformsLib.LTC_HALF_1, n.rectAreaLTC2 = UniformsLib.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), n.ambient[0] = h, n.ambient[1] = d, n.ambient[2] = f;
    const x = n.hash;
    (x.directionalLength !== p || x.pointLength !== m || x.spotLength !== v || x.rectAreaLength !== y || x.hemiLength !== g || x.numDirectionalShadows !== _ || x.numPointShadows !== b || x.numSpotShadows !== S) && (n.directional.length = p, n.spot.length = v, n.rectArea.length = y, n.point.length = m, n.hemi.length = g, n.directionalShadow.length = _, n.directionalShadowMap.length = _, n.pointShadow.length = b, n.pointShadowMap.length = b, n.spotShadow.length = S, n.spotShadowMap.length = S, n.directionalShadowMatrix.length = _, n.pointShadowMatrix.length = b, n.spotShadowMatrix.length = S, x.directionalLength = p, x.pointLength = m, x.spotLength = v, x.rectAreaLength = y, x.hemiLength = g, x.numDirectionalShadows = _, x.numPointShadows = b, x.numSpotShadows = S, n.version = nextVersion++);
  }
  function c(u, h) {
    let d = 0, f = 0, p = 0, m = 0, v = 0;
    const y = h.matrixWorldInverse;
    for (let g = 0, _ = u.length; g < _; g++) {
      const b = u[g];
      if (b.isDirectionalLight) {
        const S = n.directional[d];
        S.direction.setFromMatrixPosition(b.matrixWorld), r.setFromMatrixPosition(b.target.matrixWorld), S.direction.sub(r), S.direction.transformDirection(y), d++;
      } else if (b.isSpotLight) {
        const S = n.spot[p];
        S.position.setFromMatrixPosition(b.matrixWorld), S.position.applyMatrix4(y), S.direction.setFromMatrixPosition(b.matrixWorld), r.setFromMatrixPosition(b.target.matrixWorld), S.direction.sub(r), S.direction.transformDirection(y), p++;
      } else if (b.isRectAreaLight) {
        const S = n.rectArea[m];
        S.position.setFromMatrixPosition(b.matrixWorld), S.position.applyMatrix4(y), a.identity(), s.copy(b.matrixWorld), s.premultiply(y), a.extractRotation(s), S.halfWidth.set(b.width * 0.5, 0, 0), S.halfHeight.set(0, b.height * 0.5, 0), S.halfWidth.applyMatrix4(a), S.halfHeight.applyMatrix4(a), m++;
      } else if (b.isPointLight) {
        const S = n.point[f];
        S.position.setFromMatrixPosition(b.matrixWorld), S.position.applyMatrix4(y), f++;
      } else if (b.isHemisphereLight) {
        const S = n.hemi[v];
        S.direction.setFromMatrixPosition(b.matrixWorld), S.direction.transformDirection(y), S.direction.normalize(), v++;
      }
    }
  }
  return {
    setup: l,
    setupView: c,
    state: n
  };
}
function WebGLRenderState(o, e) {
  const t = new WebGLLights(o, e), i = [], n = [];
  function r() {
    i.length = 0, n.length = 0;
  }
  function s(h) {
    i.push(h);
  }
  function a(h) {
    n.push(h);
  }
  function l() {
    t.setup(i);
  }
  function c(h) {
    t.setupView(i, h);
  }
  return {
    init: r,
    state: {
      lightsArray: i,
      shadowsArray: n,
      lights: t
    },
    setupLights: l,
    setupLightsView: c,
    pushLight: s,
    pushShadow: a
  };
}
function WebGLRenderStates(o, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function i(r, s = 0) {
    let a;
    return t.has(r) === !1 ? (a = new WebGLRenderState(o, e), t.set(r, [a])) : s >= t.get(r).length ? (a = new WebGLRenderState(o, e), t.get(r).push(a)) : a = t.get(r)[s], a;
  }
  function n() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: n
  };
}
class MeshDepthMaterial extends Material {
  constructor(e) {
    super(), this.type = "MeshDepthMaterial", this.depthPacking = BasicDepthPacking, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
MeshDepthMaterial.prototype.isMeshDepthMaterial = !0;
class MeshDistanceMaterial extends Material {
  constructor(e) {
    super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Vector3(), this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = !0;
var vsm_frag = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`, vsm_vert = `void main() {
	gl_Position = vec4( position, 1.0 );
}`;
function WebGLShadowMap(o, e, t) {
  let i = new Frustum();
  const n = new Vector2(), r = new Vector2(), s = new Vector4(), a = [], l = [], c = {}, u = t.maxTextureSize, h = { 0: BackSide, 1: FrontSide, 2: DoubleSide }, d = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  }), f = d.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const p = new BufferGeometry();
  p.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const m = new Mesh(p, d), v = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = PCFShadowMap, this.render = function(x, M, w) {
    if (v.enabled === !1 || v.autoUpdate === !1 && v.needsUpdate === !1 || x.length === 0) return;
    const D = o.getRenderTarget(), B = o.getActiveCubeFace(), z = o.getActiveMipmapLevel(), F = o.state;
    F.setBlending(NoBlending), F.buffers.color.setClear(1, 1, 1, 1), F.buffers.depth.setTest(!0), F.setScissorTest(!1);
    for (let P = 0, R = x.length; P < R; P++) {
      const L = x[P], A = L.shadow;
      if (A === void 0) {
        console.warn("THREE.WebGLShadowMap:", L, "has no shadow.");
        continue;
      }
      if (A.autoUpdate === !1 && A.needsUpdate === !1) continue;
      n.copy(A.mapSize);
      const k = A.getFrameExtents();
      if (n.multiply(k), r.copy(A.mapSize), (n.x > u || n.y > u) && (n.x > u && (r.x = Math.floor(u / k.x), n.x = r.x * k.x, A.mapSize.x = r.x), n.y > u && (r.y = Math.floor(u / k.y), n.y = r.y * k.y, A.mapSize.y = r.y)), A.map === null && !A.isPointLightShadow && this.type === VSMShadowMap) {
        const U = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
        A.map = new WebGLRenderTarget(n.x, n.y, U), A.map.texture.name = L.name + ".shadowMap", A.mapPass = new WebGLRenderTarget(n.x, n.y, U), A.camera.updateProjectionMatrix();
      }
      if (A.map === null) {
        const U = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
        A.map = new WebGLRenderTarget(n.x, n.y, U), A.map.texture.name = L.name + ".shadowMap", A.camera.updateProjectionMatrix();
      }
      o.setRenderTarget(A.map), o.clear();
      const Q = A.getViewportCount();
      for (let U = 0; U < Q; U++) {
        const H = A.getViewport(U);
        s.set(
          r.x * H.x,
          r.y * H.y,
          r.x * H.z,
          r.y * H.w
        ), F.viewport(s), A.updateMatrices(L, U), i = A.getFrustum(), S(M, w, A.camera, L, this.type);
      }
      !A.isPointLightShadow && this.type === VSMShadowMap && y(A, w), A.needsUpdate = !1;
    }
    v.needsUpdate = !1, o.setRenderTarget(D, B, z);
  };
  function y(x, M) {
    const w = e.update(m);
    d.uniforms.shadow_pass.value = x.map.texture, d.uniforms.resolution.value = x.mapSize, d.uniforms.radius.value = x.radius, o.setRenderTarget(x.mapPass), o.clear(), o.renderBufferDirect(M, null, w, d, m, null), f.uniforms.shadow_pass.value = x.mapPass.texture, f.uniforms.resolution.value = x.mapSize, f.uniforms.radius.value = x.radius, o.setRenderTarget(x.map), o.clear(), o.renderBufferDirect(M, null, w, f, m, null);
  }
  function g(x) {
    const M = x << 0;
    let w = a[M];
    return w === void 0 && (w = new MeshDepthMaterial({
      depthPacking: RGBADepthPacking,
      morphTargets: x
    }), a[M] = w), w;
  }
  function _(x) {
    const M = x << 0;
    let w = l[M];
    return w === void 0 && (w = new MeshDistanceMaterial({
      morphTargets: x
    }), l[M] = w), w;
  }
  function b(x, M, w, D, B, z, F) {
    let P = null, R = g, L = x.customDepthMaterial;
    if (D.isPointLight === !0 && (R = _, L = x.customDistanceMaterial), L === void 0) {
      let A = !1;
      w.morphTargets === !0 && (A = M.morphAttributes && M.morphAttributes.position && M.morphAttributes.position.length > 0), P = R(A);
    } else
      P = L;
    if (o.localClippingEnabled && w.clipShadows === !0 && w.clippingPlanes.length !== 0) {
      const A = P.uuid, k = w.uuid;
      let Q = c[A];
      Q === void 0 && (Q = {}, c[A] = Q);
      let U = Q[k];
      U === void 0 && (U = P.clone(), Q[k] = U), P = U;
    }
    return P.visible = w.visible, P.wireframe = w.wireframe, F === VSMShadowMap ? P.side = w.shadowSide !== null ? w.shadowSide : w.side : P.side = w.shadowSide !== null ? w.shadowSide : h[w.side], P.clipShadows = w.clipShadows, P.clippingPlanes = w.clippingPlanes, P.clipIntersection = w.clipIntersection, P.wireframeLinewidth = w.wireframeLinewidth, P.linewidth = w.linewidth, D.isPointLight === !0 && P.isMeshDistanceMaterial === !0 && (P.referencePosition.setFromMatrixPosition(D.matrixWorld), P.nearDistance = B, P.farDistance = z), P;
  }
  function S(x, M, w, D, B) {
    if (x.visible === !1) return;
    if (x.layers.test(M.layers) && (x.isMesh || x.isLine || x.isPoints) && (x.castShadow || x.receiveShadow && B === VSMShadowMap) && (!x.frustumCulled || i.intersectsObject(x))) {
      x.modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, x.matrixWorld);
      const P = e.update(x), R = x.material;
      if (Array.isArray(R)) {
        const L = P.groups;
        for (let A = 0, k = L.length; A < k; A++) {
          const Q = L[A], U = R[Q.materialIndex];
          if (U && U.visible) {
            const H = b(x, P, U, D, w.near, w.far, B);
            o.renderBufferDirect(w, null, P, H, x, Q);
          }
        }
      } else if (R.visible) {
        const L = b(x, P, R, D, w.near, w.far, B);
        o.renderBufferDirect(w, null, P, L, x, null);
      }
    }
    const F = x.children;
    for (let P = 0, R = F.length; P < R; P++)
      S(F[P], M, w, D, B);
  }
}
function WebGLState(o, e, t) {
  const i = t.isWebGL2;
  function n() {
    let N = !1;
    const ee = new Vector4();
    let J = null;
    const ye = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(me) {
        J !== me && !N && (o.colorMask(me, me, me, me), J = me);
      },
      setLocked: function(me) {
        N = me;
      },
      setClear: function(me, Le, Te, we, xe) {
        xe === !0 && (me *= we, Le *= we, Te *= we), ee.set(me, Le, Te, we), ye.equals(ee) === !1 && (o.clearColor(me, Le, Te, we), ye.copy(ee));
      },
      reset: function() {
        N = !1, J = null, ye.set(-1, 0, 0, 0);
      }
    };
  }
  function r() {
    let N = !1, ee = null, J = null, ye = null;
    return {
      setTest: function(me) {
        me ? X(2929) : q(2929);
      },
      setMask: function(me) {
        ee !== me && !N && (o.depthMask(me), ee = me);
      },
      setFunc: function(me) {
        if (J !== me) {
          if (me)
            switch (me) {
              case NeverDepth:
                o.depthFunc(512);
                break;
              case AlwaysDepth:
                o.depthFunc(519);
                break;
              case LessDepth:
                o.depthFunc(513);
                break;
              case LessEqualDepth:
                o.depthFunc(515);
                break;
              case EqualDepth:
                o.depthFunc(514);
                break;
              case GreaterEqualDepth:
                o.depthFunc(518);
                break;
              case GreaterDepth:
                o.depthFunc(516);
                break;
              case NotEqualDepth:
                o.depthFunc(517);
                break;
              default:
                o.depthFunc(515);
            }
          else
            o.depthFunc(515);
          J = me;
        }
      },
      setLocked: function(me) {
        N = me;
      },
      setClear: function(me) {
        ye !== me && (o.clearDepth(me), ye = me);
      },
      reset: function() {
        N = !1, ee = null, J = null, ye = null;
      }
    };
  }
  function s() {
    let N = !1, ee = null, J = null, ye = null, me = null, Le = null, Te = null, we = null, xe = null;
    return {
      setTest: function(Pe) {
        N || (Pe ? X(2960) : q(2960));
      },
      setMask: function(Pe) {
        ee !== Pe && !N && (o.stencilMask(Pe), ee = Pe);
      },
      setFunc: function(Pe, Fe, He) {
        (J !== Pe || ye !== Fe || me !== He) && (o.stencilFunc(Pe, Fe, He), J = Pe, ye = Fe, me = He);
      },
      setOp: function(Pe, Fe, He) {
        (Le !== Pe || Te !== Fe || we !== He) && (o.stencilOp(Pe, Fe, He), Le = Pe, Te = Fe, we = He);
      },
      setLocked: function(Pe) {
        N = Pe;
      },
      setClear: function(Pe) {
        xe !== Pe && (o.clearStencil(Pe), xe = Pe);
      },
      reset: function() {
        N = !1, ee = null, J = null, ye = null, me = null, Le = null, Te = null, we = null, xe = null;
      }
    };
  }
  const a = new n(), l = new r(), c = new s();
  let u = {}, h = null, d = {}, f = null, p = !1, m = null, v = null, y = null, g = null, _ = null, b = null, S = null, x = !1, M = null, w = null, D = null, B = null, z = null;
  const F = o.getParameter(35661);
  let P = !1, R = 0;
  const L = o.getParameter(7938);
  L.indexOf("WebGL") !== -1 ? (R = parseFloat(/^WebGL (\d)/.exec(L)[1]), P = R >= 1) : L.indexOf("OpenGL ES") !== -1 && (R = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]), P = R >= 2);
  let A = null, k = {};
  const Q = o.getParameter(3088), U = o.getParameter(2978), H = new Vector4().fromArray(Q), I = new Vector4().fromArray(U);
  function V(N, ee, J) {
    const ye = new Uint8Array(4), me = o.createTexture();
    o.bindTexture(N, me), o.texParameteri(N, 10241, 9728), o.texParameteri(N, 10240, 9728);
    for (let Le = 0; Le < J; Le++)
      o.texImage2D(ee + Le, 0, 6408, 1, 1, 0, 6408, 5121, ye);
    return me;
  }
  const W = {};
  W[3553] = V(3553, 3553, 1), W[34067] = V(34067, 34069, 6), a.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), X(2929), l.setFunc(LessEqualDepth), re(!1), se(CullFaceBack), X(2884), le(NoBlending);
  function X(N) {
    u[N] !== !0 && (o.enable(N), u[N] = !0);
  }
  function q(N) {
    u[N] !== !1 && (o.disable(N), u[N] = !1);
  }
  function O(N) {
    N !== h && (o.bindFramebuffer(36160, N), h = N);
  }
  function te(N, ee) {
    return ee === null && h !== null && (ee = h), d[N] !== ee ? (o.bindFramebuffer(N, ee), d[N] = ee, i && (N === 36009 && (d[36160] = ee), N === 36160 && (d[36009] = ee)), !0) : !1;
  }
  function ne(N) {
    return f !== N ? (o.useProgram(N), f = N, !0) : !1;
  }
  const ce = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (i)
    ce[MinEquation] = 32775, ce[MaxEquation] = 32776;
  else {
    const N = e.get("EXT_blend_minmax");
    N !== null && (ce[MinEquation] = N.MIN_EXT, ce[MaxEquation] = N.MAX_EXT);
  }
  const he = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function le(N, ee, J, ye, me, Le, Te, we) {
    if (N === NoBlending) {
      p === !0 && (q(3042), p = !1);
      return;
    }
    if (p === !1 && (X(3042), p = !0), N !== CustomBlending) {
      if (N !== m || we !== x) {
        if ((v !== AddEquation || _ !== AddEquation) && (o.blendEquation(32774), v = AddEquation, _ = AddEquation), we)
          switch (N) {
            case NormalBlending:
              o.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              o.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              o.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              o.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", N);
              break;
          }
        else
          switch (N) {
            case NormalBlending:
              o.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              o.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              o.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              o.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", N);
              break;
          }
        y = null, g = null, b = null, S = null, m = N, x = we;
      }
      return;
    }
    me = me || ee, Le = Le || J, Te = Te || ye, (ee !== v || me !== _) && (o.blendEquationSeparate(ce[ee], ce[me]), v = ee, _ = me), (J !== y || ye !== g || Le !== b || Te !== S) && (o.blendFuncSeparate(he[J], he[ye], he[Le], he[Te]), y = J, g = ye, b = Le, S = Te), m = N, x = null;
  }
  function G(N, ee) {
    N.side === DoubleSide ? q(2884) : X(2884);
    let J = N.side === BackSide;
    ee && (J = !J), re(J), N.blending === NormalBlending && N.transparent === !1 ? le(NoBlending) : le(N.blending, N.blendEquation, N.blendSrc, N.blendDst, N.blendEquationAlpha, N.blendSrcAlpha, N.blendDstAlpha, N.premultipliedAlpha), l.setFunc(N.depthFunc), l.setTest(N.depthTest), l.setMask(N.depthWrite), a.setMask(N.colorWrite);
    const ye = N.stencilWrite;
    c.setTest(ye), ye && (c.setMask(N.stencilWriteMask), c.setFunc(N.stencilFunc, N.stencilRef, N.stencilFuncMask), c.setOp(N.stencilFail, N.stencilZFail, N.stencilZPass)), oe(N.polygonOffset, N.polygonOffsetFactor, N.polygonOffsetUnits), N.alphaToCoverage === !0 ? X(32926) : q(32926);
  }
  function re(N) {
    M !== N && (N ? o.frontFace(2304) : o.frontFace(2305), M = N);
  }
  function se(N) {
    N !== CullFaceNone ? (X(2884), N !== w && (N === CullFaceBack ? o.cullFace(1029) : N === CullFaceFront ? o.cullFace(1028) : o.cullFace(1032))) : q(2884), w = N;
  }
  function ae(N) {
    N !== D && (P && o.lineWidth(N), D = N);
  }
  function oe(N, ee, J) {
    N ? (X(32823), (B !== ee || z !== J) && (o.polygonOffset(ee, J), B = ee, z = J)) : q(32823);
  }
  function E(N) {
    N ? X(3089) : q(3089);
  }
  function T(N) {
    N === void 0 && (N = 33984 + F - 1), A !== N && (o.activeTexture(N), A = N);
  }
  function $(N, ee) {
    A === null && T();
    let J = k[A];
    J === void 0 && (J = { type: void 0, texture: void 0 }, k[A] = J), (J.type !== N || J.texture !== ee) && (o.bindTexture(N, ee || W[N]), J.type = N, J.texture = ee);
  }
  function Z() {
    const N = k[A];
    N !== void 0 && N.type !== void 0 && (o.bindTexture(N.type, null), N.type = void 0, N.texture = void 0);
  }
  function j() {
    try {
      o.compressedTexImage2D.apply(o, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function de() {
    try {
      o.texImage2D.apply(o, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function ue() {
    try {
      o.texImage3D.apply(o, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function pe(N) {
    H.equals(N) === !1 && (o.scissor(N.x, N.y, N.z, N.w), H.copy(N));
  }
  function fe(N) {
    I.equals(N) === !1 && (o.viewport(N.x, N.y, N.z, N.w), I.copy(N));
  }
  function ve() {
    o.disable(3042), o.disable(2884), o.disable(2929), o.disable(32823), o.disable(3089), o.disable(2960), o.disable(32926), o.blendEquation(32774), o.blendFunc(1, 0), o.blendFuncSeparate(1, 0, 1, 0), o.colorMask(!0, !0, !0, !0), o.clearColor(0, 0, 0, 0), o.depthMask(!0), o.depthFunc(513), o.clearDepth(1), o.stencilMask(4294967295), o.stencilFunc(519, 0, 4294967295), o.stencilOp(7680, 7680, 7680), o.clearStencil(0), o.cullFace(1029), o.frontFace(2305), o.polygonOffset(0, 0), o.activeTexture(33984), o.bindFramebuffer(36160, null), i === !0 && (o.bindFramebuffer(36009, null), o.bindFramebuffer(36008, null)), o.useProgram(null), o.lineWidth(1), o.scissor(0, 0, o.canvas.width, o.canvas.height), o.viewport(0, 0, o.canvas.width, o.canvas.height), u = {}, A = null, k = {}, h = null, d = {}, f = null, p = !1, m = null, v = null, y = null, g = null, _ = null, b = null, S = null, x = !1, M = null, w = null, D = null, B = null, z = null, H.set(0, 0, o.canvas.width, o.canvas.height), I.set(0, 0, o.canvas.width, o.canvas.height), a.reset(), l.reset(), c.reset();
  }
  return {
    buffers: {
      color: a,
      depth: l,
      stencil: c
    },
    enable: X,
    disable: q,
    bindFramebuffer: te,
    bindXRFramebuffer: O,
    useProgram: ne,
    setBlending: le,
    setMaterial: G,
    setFlipSided: re,
    setCullFace: se,
    setLineWidth: ae,
    setPolygonOffset: oe,
    setScissorTest: E,
    activeTexture: T,
    bindTexture: $,
    unbindTexture: Z,
    compressedTexImage2D: j,
    texImage2D: de,
    texImage3D: ue,
    scissor: pe,
    viewport: fe,
    reset: ve
  };
}
function WebGLTextures(o, e, t, i, n, r, s) {
  const a = n.isWebGL2, l = n.maxTextures, c = n.maxCubemapSize, u = n.maxTextureSize, h = n.maxSamples, d = /* @__PURE__ */ new WeakMap();
  let f, p = !1;
  try {
    p = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function m(E, T) {
    return p ? new OffscreenCanvas(E, T) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function v(E, T, $, Z) {
    let j = 1;
    if ((E.width > Z || E.height > Z) && (j = Z / Math.max(E.width, E.height)), j < 1 || T === !0)
      if (typeof HTMLImageElement < "u" && E instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && E instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && E instanceof ImageBitmap) {
        const de = T ? floorPowerOfTwo : Math.floor, ue = de(j * E.width), pe = de(j * E.height);
        f === void 0 && (f = m(ue, pe));
        const fe = $ ? m(ue, pe) : f;
        return fe.width = ue, fe.height = pe, fe.getContext("2d").drawImage(E, 0, 0, ue, pe), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + E.width + "x" + E.height + ") to (" + ue + "x" + pe + ")."), fe;
      } else
        return "data" in E && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + E.width + "x" + E.height + ")."), E;
    return E;
  }
  function y(E) {
    return isPowerOfTwo(E.width) && isPowerOfTwo(E.height);
  }
  function g(E) {
    return a ? !1 : E.wrapS !== ClampToEdgeWrapping || E.wrapT !== ClampToEdgeWrapping || E.minFilter !== NearestFilter && E.minFilter !== LinearFilter;
  }
  function _(E, T) {
    return E.generateMipmaps && T && E.minFilter !== NearestFilter && E.minFilter !== LinearFilter;
  }
  function b(E, T, $, Z, j = 1) {
    o.generateMipmap(E);
    const de = i.get(T);
    de.__maxMipLevel = Math.log2(Math.max($, Z, j));
  }
  function S(E, T, $) {
    if (a === !1) return T;
    if (E !== null) {
      if (o[E] !== void 0) return o[E];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + E + "'");
    }
    let Z = T;
    return T === 6403 && ($ === 5126 && (Z = 33326), $ === 5131 && (Z = 33325), $ === 5121 && (Z = 33321)), T === 6407 && ($ === 5126 && (Z = 34837), $ === 5131 && (Z = 34843), $ === 5121 && (Z = 32849)), T === 6408 && ($ === 5126 && (Z = 34836), $ === 5131 && (Z = 34842), $ === 5121 && (Z = 32856)), (Z === 33325 || Z === 33326 || Z === 34842 || Z === 34836) && e.get("EXT_color_buffer_float"), Z;
  }
  function x(E) {
    return E === NearestFilter || E === NearestMipmapNearestFilter || E === NearestMipmapLinearFilter ? 9728 : 9729;
  }
  function M(E) {
    const T = E.target;
    T.removeEventListener("dispose", M), D(T), T.isVideoTexture && d.delete(T), s.memory.textures--;
  }
  function w(E) {
    const T = E.target;
    T.removeEventListener("dispose", w), B(T);
  }
  function D(E) {
    const T = i.get(E);
    T.__webglInit !== void 0 && (o.deleteTexture(T.__webglTexture), i.remove(E));
  }
  function B(E) {
    const T = E.texture, $ = i.get(E), Z = i.get(T);
    if (E) {
      if (Z.__webglTexture !== void 0 && (o.deleteTexture(Z.__webglTexture), s.memory.textures--), E.depthTexture && E.depthTexture.dispose(), E.isWebGLCubeRenderTarget)
        for (let j = 0; j < 6; j++)
          o.deleteFramebuffer($.__webglFramebuffer[j]), $.__webglDepthbuffer && o.deleteRenderbuffer($.__webglDepthbuffer[j]);
      else
        o.deleteFramebuffer($.__webglFramebuffer), $.__webglDepthbuffer && o.deleteRenderbuffer($.__webglDepthbuffer), $.__webglMultisampledFramebuffer && o.deleteFramebuffer($.__webglMultisampledFramebuffer), $.__webglColorRenderbuffer && o.deleteRenderbuffer($.__webglColorRenderbuffer), $.__webglDepthRenderbuffer && o.deleteRenderbuffer($.__webglDepthRenderbuffer);
      if (E.isWebGLMultipleRenderTargets)
        for (let j = 0, de = T.length; j < de; j++) {
          const ue = i.get(T[j]);
          ue.__webglTexture && (o.deleteTexture(ue.__webglTexture), s.memory.textures--), i.remove(T[j]);
        }
      i.remove(T), i.remove(E);
    }
  }
  let z = 0;
  function F() {
    z = 0;
  }
  function P() {
    const E = z;
    return E >= l && console.warn("THREE.WebGLTextures: Trying to use " + E + " texture units while this GPU supports only " + l), z += 1, E;
  }
  function R(E, T) {
    const $ = i.get(E);
    if (E.isVideoTexture && G(E), E.version > 0 && $.__version !== E.version) {
      const Z = E.image;
      if (Z === void 0)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      else if (Z.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        V($, E, T);
        return;
      }
    }
    t.activeTexture(33984 + T), t.bindTexture(3553, $.__webglTexture);
  }
  function L(E, T) {
    const $ = i.get(E);
    if (E.version > 0 && $.__version !== E.version) {
      V($, E, T);
      return;
    }
    t.activeTexture(33984 + T), t.bindTexture(35866, $.__webglTexture);
  }
  function A(E, T) {
    const $ = i.get(E);
    if (E.version > 0 && $.__version !== E.version) {
      V($, E, T);
      return;
    }
    t.activeTexture(33984 + T), t.bindTexture(32879, $.__webglTexture);
  }
  function k(E, T) {
    const $ = i.get(E);
    if (E.version > 0 && $.__version !== E.version) {
      W($, E, T);
      return;
    }
    t.activeTexture(33984 + T), t.bindTexture(34067, $.__webglTexture);
  }
  const Q = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  }, U = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function H(E, T, $) {
    if ($ ? (o.texParameteri(E, 10242, Q[T.wrapS]), o.texParameteri(E, 10243, Q[T.wrapT]), (E === 32879 || E === 35866) && o.texParameteri(E, 32882, Q[T.wrapR]), o.texParameteri(E, 10240, U[T.magFilter]), o.texParameteri(E, 10241, U[T.minFilter])) : (o.texParameteri(E, 10242, 33071), o.texParameteri(E, 10243, 33071), (E === 32879 || E === 35866) && o.texParameteri(E, 32882, 33071), (T.wrapS !== ClampToEdgeWrapping || T.wrapT !== ClampToEdgeWrapping) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), o.texParameteri(E, 10240, x(T.magFilter)), o.texParameteri(E, 10241, x(T.minFilter)), T.minFilter !== NearestFilter && T.minFilter !== LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) {
      const Z = e.get("EXT_texture_filter_anisotropic");
      if (T.type === FloatType && e.has("OES_texture_float_linear") === !1 || a === !1 && T.type === HalfFloatType && e.has("OES_texture_half_float_linear") === !1) return;
      (T.anisotropy > 1 || i.get(T).__currentAnisotropy) && (o.texParameterf(E, Z.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(T.anisotropy, n.getMaxAnisotropy())), i.get(T).__currentAnisotropy = T.anisotropy);
    }
  }
  function I(E, T) {
    E.__webglInit === void 0 && (E.__webglInit = !0, T.addEventListener("dispose", M), E.__webglTexture = o.createTexture(), s.memory.textures++);
  }
  function V(E, T, $) {
    let Z = 3553;
    T.isDataTexture2DArray && (Z = 35866), T.isDataTexture3D && (Z = 32879), I(E, T), t.activeTexture(33984 + $), t.bindTexture(Z, E.__webglTexture), o.pixelStorei(37440, T.flipY), o.pixelStorei(37441, T.premultiplyAlpha), o.pixelStorei(3317, T.unpackAlignment), o.pixelStorei(37443, 0);
    const j = g(T) && y(T.image) === !1, de = v(T.image, j, !1, u), ue = y(de) || a, pe = r.convert(T.format);
    let fe = r.convert(T.type), ve = S(T.internalFormat, pe, fe);
    H(Z, T, ue);
    let N;
    const ee = T.mipmaps;
    if (T.isDepthTexture)
      ve = 6402, a ? T.type === FloatType ? ve = 36012 : T.type === UnsignedIntType ? ve = 33190 : T.type === UnsignedInt248Type ? ve = 35056 : ve = 33189 : T.type === FloatType && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), T.format === DepthFormat && ve === 6402 && T.type !== UnsignedShortType && T.type !== UnsignedIntType && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), T.type = UnsignedShortType, fe = r.convert(T.type)), T.format === DepthStencilFormat && ve === 6402 && (ve = 34041, T.type !== UnsignedInt248Type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), T.type = UnsignedInt248Type, fe = r.convert(T.type))), t.texImage2D(3553, 0, ve, de.width, de.height, 0, pe, fe, null);
    else if (T.isDataTexture)
      if (ee.length > 0 && ue) {
        for (let J = 0, ye = ee.length; J < ye; J++)
          N = ee[J], t.texImage2D(3553, J, ve, N.width, N.height, 0, pe, fe, N.data);
        T.generateMipmaps = !1, E.__maxMipLevel = ee.length - 1;
      } else
        t.texImage2D(3553, 0, ve, de.width, de.height, 0, pe, fe, de.data), E.__maxMipLevel = 0;
    else if (T.isCompressedTexture) {
      for (let J = 0, ye = ee.length; J < ye; J++)
        N = ee[J], T.format !== RGBAFormat && T.format !== RGBFormat ? pe !== null ? t.compressedTexImage2D(3553, J, ve, N.width, N.height, 0, N.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : t.texImage2D(3553, J, ve, N.width, N.height, 0, pe, fe, N.data);
      E.__maxMipLevel = ee.length - 1;
    } else if (T.isDataTexture2DArray)
      t.texImage3D(35866, 0, ve, de.width, de.height, de.depth, 0, pe, fe, de.data), E.__maxMipLevel = 0;
    else if (T.isDataTexture3D)
      t.texImage3D(32879, 0, ve, de.width, de.height, de.depth, 0, pe, fe, de.data), E.__maxMipLevel = 0;
    else if (ee.length > 0 && ue) {
      for (let J = 0, ye = ee.length; J < ye; J++)
        N = ee[J], t.texImage2D(3553, J, ve, pe, fe, N);
      T.generateMipmaps = !1, E.__maxMipLevel = ee.length - 1;
    } else
      t.texImage2D(3553, 0, ve, pe, fe, de), E.__maxMipLevel = 0;
    _(T, ue) && b(Z, T, de.width, de.height), E.__version = T.version, T.onUpdate && T.onUpdate(T);
  }
  function W(E, T, $) {
    if (T.image.length !== 6) return;
    I(E, T), t.activeTexture(33984 + $), t.bindTexture(34067, E.__webglTexture), o.pixelStorei(37440, T.flipY), o.pixelStorei(37441, T.premultiplyAlpha), o.pixelStorei(3317, T.unpackAlignment), o.pixelStorei(37443, 0);
    const Z = T && (T.isCompressedTexture || T.image[0].isCompressedTexture), j = T.image[0] && T.image[0].isDataTexture, de = [];
    for (let J = 0; J < 6; J++)
      !Z && !j ? de[J] = v(T.image[J], !1, !0, c) : de[J] = j ? T.image[J].image : T.image[J];
    const ue = de[0], pe = y(ue) || a, fe = r.convert(T.format), ve = r.convert(T.type), N = S(T.internalFormat, fe, ve);
    H(34067, T, pe);
    let ee;
    if (Z) {
      for (let J = 0; J < 6; J++) {
        ee = de[J].mipmaps;
        for (let ye = 0; ye < ee.length; ye++) {
          const me = ee[ye];
          T.format !== RGBAFormat && T.format !== RGBFormat ? fe !== null ? t.compressedTexImage2D(34069 + J, ye, N, me.width, me.height, 0, me.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : t.texImage2D(34069 + J, ye, N, me.width, me.height, 0, fe, ve, me.data);
        }
      }
      E.__maxMipLevel = ee.length - 1;
    } else {
      ee = T.mipmaps;
      for (let J = 0; J < 6; J++)
        if (j) {
          t.texImage2D(34069 + J, 0, N, de[J].width, de[J].height, 0, fe, ve, de[J].data);
          for (let ye = 0; ye < ee.length; ye++) {
            const Le = ee[ye].image[J].image;
            t.texImage2D(34069 + J, ye + 1, N, Le.width, Le.height, 0, fe, ve, Le.data);
          }
        } else {
          t.texImage2D(34069 + J, 0, N, fe, ve, de[J]);
          for (let ye = 0; ye < ee.length; ye++) {
            const me = ee[ye];
            t.texImage2D(34069 + J, ye + 1, N, fe, ve, me.image[J]);
          }
        }
      E.__maxMipLevel = ee.length;
    }
    _(T, pe) && b(34067, T, ue.width, ue.height), E.__version = T.version, T.onUpdate && T.onUpdate(T);
  }
  function X(E, T, $, Z, j) {
    const de = r.convert($.format), ue = r.convert($.type), pe = S($.internalFormat, de, ue);
    j === 32879 || j === 35866 ? t.texImage3D(j, 0, pe, T.width, T.height, T.depth, 0, de, ue, null) : t.texImage2D(j, 0, pe, T.width, T.height, 0, de, ue, null), t.bindFramebuffer(36160, E), o.framebufferTexture2D(36160, Z, j, i.get($).__webglTexture, 0), t.bindFramebuffer(36160, null);
  }
  function q(E, T, $) {
    if (o.bindRenderbuffer(36161, E), T.depthBuffer && !T.stencilBuffer) {
      let Z = 33189;
      if ($) {
        const j = T.depthTexture;
        j && j.isDepthTexture && (j.type === FloatType ? Z = 36012 : j.type === UnsignedIntType && (Z = 33190));
        const de = le(T);
        o.renderbufferStorageMultisample(36161, de, Z, T.width, T.height);
      } else
        o.renderbufferStorage(36161, Z, T.width, T.height);
      o.framebufferRenderbuffer(36160, 36096, 36161, E);
    } else if (T.depthBuffer && T.stencilBuffer) {
      if ($) {
        const Z = le(T);
        o.renderbufferStorageMultisample(36161, Z, 35056, T.width, T.height);
      } else
        o.renderbufferStorage(36161, 34041, T.width, T.height);
      o.framebufferRenderbuffer(36160, 33306, 36161, E);
    } else {
      const Z = T.isWebGLMultipleRenderTargets === !0 ? T.texture[0] : T.texture, j = r.convert(Z.format), de = r.convert(Z.type), ue = S(Z.internalFormat, j, de);
      if ($) {
        const pe = le(T);
        o.renderbufferStorageMultisample(36161, pe, ue, T.width, T.height);
      } else
        o.renderbufferStorage(36161, ue, T.width, T.height);
    }
    o.bindRenderbuffer(36161, null);
  }
  function O(E, T) {
    if (T && T.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(36160, E), !(T.depthTexture && T.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!i.get(T.depthTexture).__webglTexture || T.depthTexture.image.width !== T.width || T.depthTexture.image.height !== T.height) && (T.depthTexture.image.width = T.width, T.depthTexture.image.height = T.height, T.depthTexture.needsUpdate = !0), R(T.depthTexture, 0);
    const Z = i.get(T.depthTexture).__webglTexture;
    if (T.depthTexture.format === DepthFormat)
      o.framebufferTexture2D(36160, 36096, 3553, Z, 0);
    else if (T.depthTexture.format === DepthStencilFormat)
      o.framebufferTexture2D(36160, 33306, 3553, Z, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function te(E) {
    const T = i.get(E), $ = E.isWebGLCubeRenderTarget === !0;
    if (E.depthTexture) {
      if ($) throw new Error("target.depthTexture not supported in Cube render targets");
      O(T.__webglFramebuffer, E);
    } else if ($) {
      T.__webglDepthbuffer = [];
      for (let Z = 0; Z < 6; Z++)
        t.bindFramebuffer(36160, T.__webglFramebuffer[Z]), T.__webglDepthbuffer[Z] = o.createRenderbuffer(), q(T.__webglDepthbuffer[Z], E, !1);
    } else
      t.bindFramebuffer(36160, T.__webglFramebuffer), T.__webglDepthbuffer = o.createRenderbuffer(), q(T.__webglDepthbuffer, E, !1);
    t.bindFramebuffer(36160, null);
  }
  function ne(E) {
    const T = E.texture, $ = i.get(E), Z = i.get(T);
    E.addEventListener("dispose", w), E.isWebGLMultipleRenderTargets !== !0 && (Z.__webglTexture = o.createTexture(), Z.__version = T.version, s.memory.textures++);
    const j = E.isWebGLCubeRenderTarget === !0, de = E.isWebGLMultipleRenderTargets === !0, ue = E.isWebGLMultisampleRenderTarget === !0, pe = T.isDataTexture3D || T.isDataTexture2DArray, fe = y(E) || a;
    if (a && T.format === RGBFormat && (T.type === FloatType || T.type === HalfFloatType) && (T.format = RGBAFormat, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), j) {
      $.__webglFramebuffer = [];
      for (let ve = 0; ve < 6; ve++)
        $.__webglFramebuffer[ve] = o.createFramebuffer();
    } else if ($.__webglFramebuffer = o.createFramebuffer(), de)
      if (n.drawBuffers) {
        const ve = E.texture;
        for (let N = 0, ee = ve.length; N < ee; N++) {
          const J = i.get(ve[N]);
          J.__webglTexture === void 0 && (J.__webglTexture = o.createTexture(), s.memory.textures++);
        }
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
    else if (ue)
      if (a) {
        $.__webglMultisampledFramebuffer = o.createFramebuffer(), $.__webglColorRenderbuffer = o.createRenderbuffer(), o.bindRenderbuffer(36161, $.__webglColorRenderbuffer);
        const ve = r.convert(T.format), N = r.convert(T.type), ee = S(T.internalFormat, ve, N), J = le(E);
        o.renderbufferStorageMultisample(36161, J, ee, E.width, E.height), t.bindFramebuffer(36160, $.__webglMultisampledFramebuffer), o.framebufferRenderbuffer(36160, 36064, 36161, $.__webglColorRenderbuffer), o.bindRenderbuffer(36161, null), E.depthBuffer && ($.__webglDepthRenderbuffer = o.createRenderbuffer(), q($.__webglDepthRenderbuffer, E, !0)), t.bindFramebuffer(36160, null);
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
    if (j) {
      t.bindTexture(34067, Z.__webglTexture), H(34067, T, fe);
      for (let ve = 0; ve < 6; ve++)
        X($.__webglFramebuffer[ve], E, T, 36064, 34069 + ve);
      _(T, fe) && b(34067, T, E.width, E.height), t.bindTexture(34067, null);
    } else if (de) {
      const ve = E.texture;
      for (let N = 0, ee = ve.length; N < ee; N++) {
        const J = ve[N], ye = i.get(J);
        t.bindTexture(3553, ye.__webglTexture), H(3553, J, fe), X($.__webglFramebuffer, E, J, 36064 + N, 3553), _(J, fe) && b(3553, J, E.width, E.height);
      }
      t.bindTexture(3553, null);
    } else {
      let ve = 3553;
      pe && (a ? ve = T.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), t.bindTexture(ve, Z.__webglTexture), H(ve, T, fe), X($.__webglFramebuffer, E, T, 36064, ve), _(T, fe) && b(ve, T, E.width, E.height, E.depth), t.bindTexture(ve, null);
    }
    E.depthBuffer && te(E);
  }
  function ce(E) {
    const T = y(E) || a, $ = E.isWebGLMultipleRenderTargets === !0 ? E.texture : [E.texture];
    for (let Z = 0, j = $.length; Z < j; Z++) {
      const de = $[Z];
      if (_(de, T)) {
        const ue = E.isWebGLCubeRenderTarget ? 34067 : 3553, pe = i.get(de).__webglTexture;
        t.bindTexture(ue, pe), b(ue, de, E.width, E.height), t.bindTexture(ue, null);
      }
    }
  }
  function he(E) {
    if (E.isWebGLMultisampleRenderTarget)
      if (a) {
        const T = E.width, $ = E.height;
        let Z = 16384;
        E.depthBuffer && (Z |= 256), E.stencilBuffer && (Z |= 1024);
        const j = i.get(E);
        t.bindFramebuffer(36008, j.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, j.__webglFramebuffer), o.blitFramebuffer(0, 0, T, $, 0, 0, T, $, Z, 9728), t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, j.__webglMultisampledFramebuffer);
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
  }
  function le(E) {
    return a && E.isWebGLMultisampleRenderTarget ? Math.min(h, E.samples) : 0;
  }
  function G(E) {
    const T = s.render.frame;
    d.get(E) !== T && (d.set(E, T), E.update());
  }
  let re = !1, se = !1;
  function ae(E, T) {
    E && E.isWebGLRenderTarget && (re === !1 && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), re = !0), E = E.texture), R(E, T);
  }
  function oe(E, T) {
    E && E.isWebGLCubeRenderTarget && (se === !1 && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), se = !0), E = E.texture), k(E, T);
  }
  this.allocateTextureUnit = P, this.resetTextureUnits = F, this.setTexture2D = R, this.setTexture2DArray = L, this.setTexture3D = A, this.setTextureCube = k, this.setupRenderTarget = ne, this.updateRenderTargetMipmap = ce, this.updateMultisampleRenderTarget = he, this.safeSetTexture2D = ae, this.safeSetTextureCube = oe;
}
function WebGLUtils(o, e, t) {
  const i = t.isWebGL2;
  function n(r) {
    let s;
    if (r === UnsignedByteType) return 5121;
    if (r === UnsignedShort4444Type) return 32819;
    if (r === UnsignedShort5551Type) return 32820;
    if (r === UnsignedShort565Type) return 33635;
    if (r === ByteType) return 5120;
    if (r === ShortType) return 5122;
    if (r === UnsignedShortType) return 5123;
    if (r === IntType) return 5124;
    if (r === UnsignedIntType) return 5125;
    if (r === FloatType) return 5126;
    if (r === HalfFloatType)
      return i ? 5131 : (s = e.get("OES_texture_half_float"), s !== null ? s.HALF_FLOAT_OES : null);
    if (r === AlphaFormat) return 6406;
    if (r === RGBFormat) return 6407;
    if (r === RGBAFormat) return 6408;
    if (r === LuminanceFormat) return 6409;
    if (r === LuminanceAlphaFormat) return 6410;
    if (r === DepthFormat) return 6402;
    if (r === DepthStencilFormat) return 34041;
    if (r === RedFormat) return 6403;
    if (r === RedIntegerFormat) return 36244;
    if (r === RGFormat) return 33319;
    if (r === RGIntegerFormat) return 33320;
    if (r === RGBIntegerFormat) return 36248;
    if (r === RGBAIntegerFormat) return 36249;
    if (r === RGB_S3TC_DXT1_Format || r === RGBA_S3TC_DXT1_Format || r === RGBA_S3TC_DXT3_Format || r === RGBA_S3TC_DXT5_Format)
      if (s = e.get("WEBGL_compressed_texture_s3tc"), s !== null) {
        if (r === RGB_S3TC_DXT1_Format) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === RGBA_S3TC_DXT1_Format) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === RGBA_S3TC_DXT3_Format) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === RGBA_S3TC_DXT5_Format) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (r === RGB_PVRTC_4BPPV1_Format || r === RGB_PVRTC_2BPPV1_Format || r === RGBA_PVRTC_4BPPV1_Format || r === RGBA_PVRTC_2BPPV1_Format)
      if (s = e.get("WEBGL_compressed_texture_pvrtc"), s !== null) {
        if (r === RGB_PVRTC_4BPPV1_Format) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === RGB_PVRTC_2BPPV1_Format) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === RGBA_PVRTC_4BPPV1_Format) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === RGBA_PVRTC_2BPPV1_Format) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (r === RGB_ETC1_Format)
      return s = e.get("WEBGL_compressed_texture_etc1"), s !== null ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
    if ((r === RGB_ETC2_Format || r === RGBA_ETC2_EAC_Format) && (s = e.get("WEBGL_compressed_texture_etc"), s !== null)) {
      if (r === RGB_ETC2_Format) return s.COMPRESSED_RGB8_ETC2;
      if (r === RGBA_ETC2_EAC_Format) return s.COMPRESSED_RGBA8_ETC2_EAC;
    }
    if (r === RGBA_ASTC_4x4_Format || r === RGBA_ASTC_5x4_Format || r === RGBA_ASTC_5x5_Format || r === RGBA_ASTC_6x5_Format || r === RGBA_ASTC_6x6_Format || r === RGBA_ASTC_8x5_Format || r === RGBA_ASTC_8x6_Format || r === RGBA_ASTC_8x8_Format || r === RGBA_ASTC_10x5_Format || r === RGBA_ASTC_10x6_Format || r === RGBA_ASTC_10x8_Format || r === RGBA_ASTC_10x10_Format || r === RGBA_ASTC_12x10_Format || r === RGBA_ASTC_12x12_Format || r === SRGB8_ALPHA8_ASTC_4x4_Format || r === SRGB8_ALPHA8_ASTC_5x4_Format || r === SRGB8_ALPHA8_ASTC_5x5_Format || r === SRGB8_ALPHA8_ASTC_6x5_Format || r === SRGB8_ALPHA8_ASTC_6x6_Format || r === SRGB8_ALPHA8_ASTC_8x5_Format || r === SRGB8_ALPHA8_ASTC_8x6_Format || r === SRGB8_ALPHA8_ASTC_8x8_Format || r === SRGB8_ALPHA8_ASTC_10x5_Format || r === SRGB8_ALPHA8_ASTC_10x6_Format || r === SRGB8_ALPHA8_ASTC_10x8_Format || r === SRGB8_ALPHA8_ASTC_10x10_Format || r === SRGB8_ALPHA8_ASTC_12x10_Format || r === SRGB8_ALPHA8_ASTC_12x12_Format)
      return s = e.get("WEBGL_compressed_texture_astc"), s !== null ? r : null;
    if (r === RGBA_BPTC_Format)
      return s = e.get("EXT_texture_compression_bptc"), s !== null ? r : null;
    if (r === UnsignedInt248Type)
      return i ? 34042 : (s = e.get("WEBGL_depth_texture"), s !== null ? s.UNSIGNED_INT_24_8_WEBGL : null);
  }
  return { convert: n };
}
class ArrayCamera extends PerspectiveCamera {
  constructor(e = []) {
    super(), this.cameras = e;
  }
}
ArrayCamera.prototype.isArrayCamera = !0;
class Group extends Object3D {
  constructor() {
    super(), this.type = "Group";
  }
}
Group.prototype.isGroup = !0;
const _moveEvent = { type: "move" };
class WebXRController {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Group(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Group(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Vector3(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Vector3()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Group(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Vector3(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Vector3()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, i) {
    let n = null, r = null, s = null;
    const a = this._targetRay, l = this._grip, c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred")
      if (a !== null && (n = t.getPose(e.targetRaySpace, i), n !== null && (a.matrix.fromArray(n.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), n.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(n.linearVelocity)) : a.hasLinearVelocity = !1, n.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(n.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(_moveEvent))), c && e.hand) {
        s = !0;
        for (const m of e.hand.values()) {
          const v = t.getJointPose(m, i);
          if (c.joints[m.jointName] === void 0) {
            const g = new Group();
            g.matrixAutoUpdate = !1, g.visible = !1, c.joints[m.jointName] = g, c.add(g);
          }
          const y = c.joints[m.jointName];
          v !== null && (y.matrix.fromArray(v.transform.matrix), y.matrix.decompose(y.position, y.rotation, y.scale), y.jointRadius = v.radius), y.visible = v !== null;
        }
        const u = c.joints["index-finger-tip"], h = c.joints["thumb-tip"], d = u.position.distanceTo(h.position), f = 0.02, p = 5e-3;
        c.inputState.pinching && d > f + p ? (c.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !c.inputState.pinching && d <= f - p && (c.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, i), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
    return a !== null && (a.visible = n !== null), l !== null && (l.visible = r !== null), c !== null && (c.visible = s !== null), this;
  }
}
class WebXRManager extends EventDispatcher$1 {
  constructor(e, t) {
    super();
    const i = this, n = e.state;
    let r = null, s = 1, a = null, l = "local-floor", c = null, u = null, h = null, d = null;
    const f = [], p = /* @__PURE__ */ new Map(), m = new PerspectiveCamera();
    m.layers.enable(1), m.viewport = new Vector4();
    const v = new PerspectiveCamera();
    v.layers.enable(2), v.viewport = new Vector4();
    const y = [m, v], g = new ArrayCamera();
    g.layers.enable(1), g.layers.enable(2);
    let _ = null, b = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(L) {
      let A = f[L];
      return A === void 0 && (A = new WebXRController(), f[L] = A), A.getTargetRaySpace();
    }, this.getControllerGrip = function(L) {
      let A = f[L];
      return A === void 0 && (A = new WebXRController(), f[L] = A), A.getGripSpace();
    }, this.getHand = function(L) {
      let A = f[L];
      return A === void 0 && (A = new WebXRController(), f[L] = A), A.getHandSpace();
    };
    function S(L) {
      const A = p.get(L.inputSource);
      A && A.dispatchEvent({ type: L.type, data: L.inputSource });
    }
    function x() {
      p.forEach(function(L, A) {
        L.disconnect(A);
      }), p.clear(), _ = null, b = null, n.bindXRFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), R.stop(), i.isPresenting = !1, i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(L) {
      s = L, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(L) {
      l = L, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return a;
    }, this.getSession = function() {
      return r;
    }, this.setSession = async function(L) {
      if (r = L, r !== null) {
        r.addEventListener("select", S), r.addEventListener("selectstart", S), r.addEventListener("selectend", S), r.addEventListener("squeeze", S), r.addEventListener("squeezestart", S), r.addEventListener("squeezeend", S), r.addEventListener("end", x), r.addEventListener("inputsourceschange", M);
        const A = t.getContextAttributes();
        if (A.xrCompatible !== !0 && await t.makeXRCompatible(), r.renderState.layers === void 0) {
          const k = {
            antialias: A.antialias,
            alpha: A.alpha,
            depth: A.depth,
            stencil: A.stencil,
            framebufferScaleFactor: s
          }, Q = new XRWebGLLayer(r, t, k);
          r.updateRenderState({ baseLayer: Q });
        } else {
          let k = 0;
          A.depth && (k = A.stencil ? 34041 : 6402);
          const Q = {
            colorFormat: A.alpha ? 6408 : 6407,
            depthFormat: k,
            scaleFactor: s
          };
          u = new XRWebGLBinding(r, t), d = u.createProjectionLayer(Q), h = t.createFramebuffer(), r.updateRenderState({ layers: [d] });
        }
        a = await r.requestReferenceSpace(l), R.setContext(r), R.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" });
      }
    };
    function M(L) {
      const A = r.inputSources;
      for (let k = 0; k < f.length; k++)
        p.set(A[k], f[k]);
      for (let k = 0; k < L.removed.length; k++) {
        const Q = L.removed[k], U = p.get(Q);
        U && (U.dispatchEvent({ type: "disconnected", data: Q }), p.delete(Q));
      }
      for (let k = 0; k < L.added.length; k++) {
        const Q = L.added[k], U = p.get(Q);
        U && U.dispatchEvent({ type: "connected", data: Q });
      }
    }
    const w = new Vector3(), D = new Vector3();
    function B(L, A, k) {
      w.setFromMatrixPosition(A.matrixWorld), D.setFromMatrixPosition(k.matrixWorld);
      const Q = w.distanceTo(D), U = A.projectionMatrix.elements, H = k.projectionMatrix.elements, I = U[14] / (U[10] - 1), V = U[14] / (U[10] + 1), W = (U[9] + 1) / U[5], X = (U[9] - 1) / U[5], q = (U[8] - 1) / U[0], O = (H[8] + 1) / H[0], te = I * q, ne = I * O, ce = Q / (-q + O), he = ce * -q;
      A.matrixWorld.decompose(L.position, L.quaternion, L.scale), L.translateX(he), L.translateZ(ce), L.matrixWorld.compose(L.position, L.quaternion, L.scale), L.matrixWorldInverse.copy(L.matrixWorld).invert();
      const le = I + ce, G = V + ce, re = te - he, se = ne + (Q - he), ae = W * V / G * le, oe = X * V / G * le;
      L.projectionMatrix.makePerspective(re, se, ae, oe, le, G);
    }
    function z(L, A) {
      A === null ? L.matrixWorld.copy(L.matrix) : L.matrixWorld.multiplyMatrices(A.matrixWorld, L.matrix), L.matrixWorldInverse.copy(L.matrixWorld).invert();
    }
    this.updateCamera = function(L) {
      if (r === null) return;
      g.near = v.near = m.near = L.near, g.far = v.far = m.far = L.far, (_ !== g.near || b !== g.far) && (r.updateRenderState({
        depthNear: g.near,
        depthFar: g.far
      }), _ = g.near, b = g.far);
      const A = L.parent, k = g.cameras;
      z(g, A);
      for (let U = 0; U < k.length; U++)
        z(k[U], A);
      g.matrixWorld.decompose(g.position, g.quaternion, g.scale), L.position.copy(g.position), L.quaternion.copy(g.quaternion), L.scale.copy(g.scale), L.matrix.copy(g.matrix), L.matrixWorld.copy(g.matrixWorld);
      const Q = L.children;
      for (let U = 0, H = Q.length; U < H; U++)
        Q[U].updateMatrixWorld(!0);
      k.length === 2 ? B(g, m, v) : g.projectionMatrix.copy(m.projectionMatrix);
    }, this.getCamera = function() {
      return g;
    };
    let F = null;
    function P(L, A) {
      if (c = A.getViewerPose(a), c !== null) {
        const Q = c.views, U = r.renderState.baseLayer;
        r.renderState.layers === void 0 && n.bindXRFramebuffer(U.framebuffer);
        let H = !1;
        Q.length !== g.cameras.length && (g.cameras.length = 0, H = !0);
        for (let I = 0; I < Q.length; I++) {
          const V = Q[I];
          let W = null;
          if (r.renderState.layers === void 0)
            W = U.getViewport(V);
          else {
            const q = u.getViewSubImage(d, V);
            n.bindXRFramebuffer(h), t.framebufferTexture2D(36160, 36064, 3553, q.colorTexture, 0), q.depthStencilTexture !== void 0 && t.framebufferTexture2D(36160, 36096, 3553, q.depthStencilTexture, 0), W = q.viewport;
          }
          const X = y[I];
          X.matrix.fromArray(V.transform.matrix), X.projectionMatrix.fromArray(V.projectionMatrix), X.viewport.set(W.x, W.y, W.width, W.height), I === 0 && g.matrix.copy(X.matrix), H === !0 && g.cameras.push(X);
        }
      }
      const k = r.inputSources;
      for (let Q = 0; Q < f.length; Q++) {
        const U = f[Q], H = k[Q];
        U.update(H, A, a);
      }
      F && F(L, A);
    }
    const R = new WebGLAnimation();
    R.setAnimationLoop(P), this.setAnimationLoop = function(L) {
      F = L;
    }, this.dispose = function() {
    };
  }
}
function WebGLMaterials(o) {
  function e(y, g) {
    y.fogColor.value.copy(g.color), g.isFog ? (y.fogNear.value = g.near, y.fogFar.value = g.far) : g.isFogExp2 && (y.fogDensity.value = g.density);
  }
  function t(y, g, _, b, S) {
    g.isMeshBasicMaterial ? i(y, g) : g.isMeshLambertMaterial ? (i(y, g), l(y, g)) : g.isMeshToonMaterial ? (i(y, g), u(y, g)) : g.isMeshPhongMaterial ? (i(y, g), c(y, g)) : g.isMeshStandardMaterial ? (i(y, g), g.isMeshPhysicalMaterial ? d(y, g, S) : h(y, g)) : g.isMeshMatcapMaterial ? (i(y, g), f(y, g)) : g.isMeshDepthMaterial ? (i(y, g), p(y, g)) : g.isMeshDistanceMaterial ? (i(y, g), m(y, g)) : g.isMeshNormalMaterial ? (i(y, g), v(y, g)) : g.isLineBasicMaterial ? (n(y, g), g.isLineDashedMaterial && r(y, g)) : g.isPointsMaterial ? s(y, g, _, b) : g.isSpriteMaterial ? a(y, g) : g.isShadowMaterial ? (y.color.value.copy(g.color), y.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function i(y, g) {
    y.opacity.value = g.opacity, g.color && y.diffuse.value.copy(g.color), g.emissive && y.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (y.map.value = g.map), g.alphaMap && (y.alphaMap.value = g.alphaMap), g.specularMap && (y.specularMap.value = g.specularMap);
    const _ = o.get(g).envMap;
    if (_) {
      y.envMap.value = _, y.flipEnvMap.value = _.isCubeTexture && _._needsFlipEnvMap ? -1 : 1, y.reflectivity.value = g.reflectivity, y.refractionRatio.value = g.refractionRatio;
      const x = o.get(_).__maxMipLevel;
      x !== void 0 && (y.maxMipLevel.value = x);
    }
    g.lightMap && (y.lightMap.value = g.lightMap, y.lightMapIntensity.value = g.lightMapIntensity), g.aoMap && (y.aoMap.value = g.aoMap, y.aoMapIntensity.value = g.aoMapIntensity);
    let b;
    g.map ? b = g.map : g.specularMap ? b = g.specularMap : g.displacementMap ? b = g.displacementMap : g.normalMap ? b = g.normalMap : g.bumpMap ? b = g.bumpMap : g.roughnessMap ? b = g.roughnessMap : g.metalnessMap ? b = g.metalnessMap : g.alphaMap ? b = g.alphaMap : g.emissiveMap ? b = g.emissiveMap : g.clearcoatMap ? b = g.clearcoatMap : g.clearcoatNormalMap ? b = g.clearcoatNormalMap : g.clearcoatRoughnessMap && (b = g.clearcoatRoughnessMap), b !== void 0 && (b.isWebGLRenderTarget && (b = b.texture), b.matrixAutoUpdate === !0 && b.updateMatrix(), y.uvTransform.value.copy(b.matrix));
    let S;
    g.aoMap ? S = g.aoMap : g.lightMap && (S = g.lightMap), S !== void 0 && (S.isWebGLRenderTarget && (S = S.texture), S.matrixAutoUpdate === !0 && S.updateMatrix(), y.uv2Transform.value.copy(S.matrix));
  }
  function n(y, g) {
    y.diffuse.value.copy(g.color), y.opacity.value = g.opacity;
  }
  function r(y, g) {
    y.dashSize.value = g.dashSize, y.totalSize.value = g.dashSize + g.gapSize, y.scale.value = g.scale;
  }
  function s(y, g, _, b) {
    y.diffuse.value.copy(g.color), y.opacity.value = g.opacity, y.size.value = g.size * _, y.scale.value = b * 0.5, g.map && (y.map.value = g.map), g.alphaMap && (y.alphaMap.value = g.alphaMap);
    let S;
    g.map ? S = g.map : g.alphaMap && (S = g.alphaMap), S !== void 0 && (S.matrixAutoUpdate === !0 && S.updateMatrix(), y.uvTransform.value.copy(S.matrix));
  }
  function a(y, g) {
    y.diffuse.value.copy(g.color), y.opacity.value = g.opacity, y.rotation.value = g.rotation, g.map && (y.map.value = g.map), g.alphaMap && (y.alphaMap.value = g.alphaMap);
    let _;
    g.map ? _ = g.map : g.alphaMap && (_ = g.alphaMap), _ !== void 0 && (_.matrixAutoUpdate === !0 && _.updateMatrix(), y.uvTransform.value.copy(_.matrix));
  }
  function l(y, g) {
    g.emissiveMap && (y.emissiveMap.value = g.emissiveMap);
  }
  function c(y, g) {
    y.specular.value.copy(g.specular), y.shininess.value = Math.max(g.shininess, 1e-4), g.emissiveMap && (y.emissiveMap.value = g.emissiveMap), g.bumpMap && (y.bumpMap.value = g.bumpMap, y.bumpScale.value = g.bumpScale, g.side === BackSide && (y.bumpScale.value *= -1)), g.normalMap && (y.normalMap.value = g.normalMap, y.normalScale.value.copy(g.normalScale), g.side === BackSide && y.normalScale.value.negate()), g.displacementMap && (y.displacementMap.value = g.displacementMap, y.displacementScale.value = g.displacementScale, y.displacementBias.value = g.displacementBias);
  }
  function u(y, g) {
    g.gradientMap && (y.gradientMap.value = g.gradientMap), g.emissiveMap && (y.emissiveMap.value = g.emissiveMap), g.bumpMap && (y.bumpMap.value = g.bumpMap, y.bumpScale.value = g.bumpScale, g.side === BackSide && (y.bumpScale.value *= -1)), g.normalMap && (y.normalMap.value = g.normalMap, y.normalScale.value.copy(g.normalScale), g.side === BackSide && y.normalScale.value.negate()), g.displacementMap && (y.displacementMap.value = g.displacementMap, y.displacementScale.value = g.displacementScale, y.displacementBias.value = g.displacementBias);
  }
  function h(y, g) {
    y.roughness.value = g.roughness, y.metalness.value = g.metalness, g.roughnessMap && (y.roughnessMap.value = g.roughnessMap), g.metalnessMap && (y.metalnessMap.value = g.metalnessMap), g.emissiveMap && (y.emissiveMap.value = g.emissiveMap), g.bumpMap && (y.bumpMap.value = g.bumpMap, y.bumpScale.value = g.bumpScale, g.side === BackSide && (y.bumpScale.value *= -1)), g.normalMap && (y.normalMap.value = g.normalMap, y.normalScale.value.copy(g.normalScale), g.side === BackSide && y.normalScale.value.negate()), g.displacementMap && (y.displacementMap.value = g.displacementMap, y.displacementScale.value = g.displacementScale, y.displacementBias.value = g.displacementBias), o.get(g).envMap && (y.envMapIntensity.value = g.envMapIntensity);
  }
  function d(y, g, _) {
    h(y, g), y.reflectivity.value = g.reflectivity, y.clearcoat.value = g.clearcoat, y.clearcoatRoughness.value = g.clearcoatRoughness, g.sheen && y.sheen.value.copy(g.sheen), g.clearcoatMap && (y.clearcoatMap.value = g.clearcoatMap), g.clearcoatRoughnessMap && (y.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap), g.clearcoatNormalMap && (y.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), y.clearcoatNormalMap.value = g.clearcoatNormalMap, g.side === BackSide && y.clearcoatNormalScale.value.negate()), y.transmission.value = g.transmission, g.transmissionMap && (y.transmissionMap.value = g.transmissionMap), g.transmission > 0 && (y.transmissionSamplerMap.value = _.texture, y.transmissionSamplerSize.value.set(_.width, _.height)), y.thickness.value = g.thickness, g.thicknessMap && (y.thicknessMap.value = g.thicknessMap), y.attenuationDistance.value = g.attenuationDistance, y.attenuationColor.value.copy(g.attenuationColor);
  }
  function f(y, g) {
    g.matcap && (y.matcap.value = g.matcap), g.bumpMap && (y.bumpMap.value = g.bumpMap, y.bumpScale.value = g.bumpScale, g.side === BackSide && (y.bumpScale.value *= -1)), g.normalMap && (y.normalMap.value = g.normalMap, y.normalScale.value.copy(g.normalScale), g.side === BackSide && y.normalScale.value.negate()), g.displacementMap && (y.displacementMap.value = g.displacementMap, y.displacementScale.value = g.displacementScale, y.displacementBias.value = g.displacementBias);
  }
  function p(y, g) {
    g.displacementMap && (y.displacementMap.value = g.displacementMap, y.displacementScale.value = g.displacementScale, y.displacementBias.value = g.displacementBias);
  }
  function m(y, g) {
    g.displacementMap && (y.displacementMap.value = g.displacementMap, y.displacementScale.value = g.displacementScale, y.displacementBias.value = g.displacementBias), y.referencePosition.value.copy(g.referencePosition), y.nearDistance.value = g.nearDistance, y.farDistance.value = g.farDistance;
  }
  function v(y, g) {
    g.bumpMap && (y.bumpMap.value = g.bumpMap, y.bumpScale.value = g.bumpScale, g.side === BackSide && (y.bumpScale.value *= -1)), g.normalMap && (y.normalMap.value = g.normalMap, y.normalScale.value.copy(g.normalScale), g.side === BackSide && y.normalScale.value.negate()), g.displacementMap && (y.displacementMap.value = g.displacementMap, y.displacementScale.value = g.displacementScale, y.displacementBias.value = g.displacementBias);
  }
  return {
    refreshFogUniforms: e,
    refreshMaterialUniforms: t
  };
}
function createCanvasElement() {
  const o = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  return o.style.display = "block", o;
}
function WebGLRenderer$1(o = {}) {
  const e = o.canvas !== void 0 ? o.canvas : createCanvasElement(), t = o.context !== void 0 ? o.context : null, i = o.alpha !== void 0 ? o.alpha : !1, n = o.depth !== void 0 ? o.depth : !0, r = o.stencil !== void 0 ? o.stencil : !0, s = o.antialias !== void 0 ? o.antialias : !1, a = o.premultipliedAlpha !== void 0 ? o.premultipliedAlpha : !0, l = o.preserveDrawingBuffer !== void 0 ? o.preserveDrawingBuffer : !1, c = o.powerPreference !== void 0 ? o.powerPreference : "default", u = o.failIfMajorPerformanceCaveat !== void 0 ? o.failIfMajorPerformanceCaveat : !1;
  let h = null, d = null;
  const f = [], p = [];
  this.domElement = e, this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: !0
  }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = LinearEncoding, this.physicallyCorrectLights = !1, this.toneMapping = NoToneMapping, this.toneMappingExposure = 1;
  const m = this;
  let v = !1, y = 0, g = 0, _ = null, b = -1, S = null;
  const x = new Vector4(), M = new Vector4();
  let w = null, D = e.width, B = e.height, z = 1, F = null, P = null;
  const R = new Vector4(0, 0, D, B), L = new Vector4(0, 0, D, B);
  let A = !1;
  const k = [], Q = new Frustum();
  let U = !1, H = !1, I = null;
  const V = new Matrix4(), W = new Vector3(), X = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
  function q() {
    return _ === null ? z : 1;
  }
  let O = t;
  function te(C, K) {
    for (let Y = 0; Y < C.length; Y++) {
      const ie = C[Y], ge = e.getContext(ie, K);
      if (ge !== null) return ge;
    }
    return null;
  }
  try {
    const C = {
      alpha: i,
      depth: n,
      stencil: r,
      antialias: s,
      premultipliedAlpha: a,
      preserveDrawingBuffer: l,
      powerPreference: c,
      failIfMajorPerformanceCaveat: u
    };
    if (e.addEventListener("webglcontextlost", Le, !1), e.addEventListener("webglcontextrestored", Te, !1), O === null) {
      const K = ["webgl2", "webgl", "experimental-webgl"];
      if (m.isWebGL1Renderer === !0 && K.shift(), O = te(K, C), O === null)
        throw te(K) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    O.getShaderPrecisionFormat === void 0 && (O.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (C) {
    throw console.error("THREE.WebGLRenderer: " + C.message), C;
  }
  let ne, ce, he, le, G, re, se, ae, oe, E, T, $, Z, j, de, ue, pe, fe, ve, N, ee, J;
  function ye() {
    ne = new WebGLExtensions(O), ce = new WebGLCapabilities(O, ne, o), ne.init(ce), ee = new WebGLUtils(O, ne, ce), he = new WebGLState(O, ne, ce), k[0] = 1029, le = new WebGLInfo(), G = new WebGLProperties(), re = new WebGLTextures(O, ne, he, G, ce, ee, le), se = new WebGLCubeMaps(m), ae = new WebGLAttributes(O, ce), J = new WebGLBindingStates(O, ne, ae, ce), oe = new WebGLGeometries(O, ae, le, J), E = new WebGLObjects(O, oe, ae, le), fe = new WebGLMorphtargets(O), de = new WebGLClipping(G), T = new WebGLPrograms(m, se, ne, ce, J, de), $ = new WebGLMaterials(G), Z = new WebGLRenderLists(G), j = new WebGLRenderStates(ne, ce), pe = new WebGLBackground(m, se, he, E, a), ue = new WebGLShadowMap(m, E, ce), ve = new WebGLBufferRenderer(O, ne, le, ce), N = new WebGLIndexedBufferRenderer(O, ne, le, ce), le.programs = T.programs, m.capabilities = ce, m.extensions = ne, m.properties = G, m.renderLists = Z, m.shadowMap = ue, m.state = he, m.info = le;
  }
  ye();
  const me = new WebXRManager(m, O);
  this.xr = me, this.getContext = function() {
    return O;
  }, this.getContextAttributes = function() {
    return O.getContextAttributes();
  }, this.forceContextLoss = function() {
    const C = ne.get("WEBGL_lose_context");
    C && C.loseContext();
  }, this.forceContextRestore = function() {
    const C = ne.get("WEBGL_lose_context");
    C && C.restoreContext();
  }, this.getPixelRatio = function() {
    return z;
  }, this.setPixelRatio = function(C) {
    C !== void 0 && (z = C, this.setSize(D, B, !1));
  }, this.getSize = function(C) {
    return C.set(D, B);
  }, this.setSize = function(C, K, Y) {
    if (me.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    D = C, B = K, e.width = Math.floor(C * z), e.height = Math.floor(K * z), Y !== !1 && (e.style.width = C + "px", e.style.height = K + "px"), this.setViewport(0, 0, C, K);
  }, this.getDrawingBufferSize = function(C) {
    return C.set(D * z, B * z).floor();
  }, this.setDrawingBufferSize = function(C, K, Y) {
    D = C, B = K, z = Y, e.width = Math.floor(C * Y), e.height = Math.floor(K * Y), this.setViewport(0, 0, C, K);
  }, this.getCurrentViewport = function(C) {
    return C.copy(x);
  }, this.getViewport = function(C) {
    return C.copy(R);
  }, this.setViewport = function(C, K, Y, ie) {
    C.isVector4 ? R.set(C.x, C.y, C.z, C.w) : R.set(C, K, Y, ie), he.viewport(x.copy(R).multiplyScalar(z).floor());
  }, this.getScissor = function(C) {
    return C.copy(L);
  }, this.setScissor = function(C, K, Y, ie) {
    C.isVector4 ? L.set(C.x, C.y, C.z, C.w) : L.set(C, K, Y, ie), he.scissor(M.copy(L).multiplyScalar(z).floor());
  }, this.getScissorTest = function() {
    return A;
  }, this.setScissorTest = function(C) {
    he.setScissorTest(A = C);
  }, this.setOpaqueSort = function(C) {
    F = C;
  }, this.setTransparentSort = function(C) {
    P = C;
  }, this.getClearColor = function(C) {
    return C.copy(pe.getClearColor());
  }, this.setClearColor = function() {
    pe.setClearColor.apply(pe, arguments);
  }, this.getClearAlpha = function() {
    return pe.getClearAlpha();
  }, this.setClearAlpha = function() {
    pe.setClearAlpha.apply(pe, arguments);
  }, this.clear = function(C, K, Y) {
    let ie = 0;
    (C === void 0 || C) && (ie |= 16384), (K === void 0 || K) && (ie |= 256), (Y === void 0 || Y) && (ie |= 1024), O.clear(ie);
  }, this.clearColor = function() {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function() {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function() {
    this.clear(!1, !1, !0);
  }, this.dispose = function() {
    e.removeEventListener("webglcontextlost", Le, !1), e.removeEventListener("webglcontextrestored", Te, !1), Z.dispose(), j.dispose(), G.dispose(), se.dispose(), E.dispose(), J.dispose(), me.dispose(), me.removeEventListener("sessionstart", Ee), me.removeEventListener("sessionend", Ue), I && (I.dispose(), I = null), Je.stop();
  };
  function Le(C) {
    C.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), v = !0;
  }
  function Te() {
    console.log("THREE.WebGLRenderer: Context Restored."), v = !1;
    const C = le.autoReset, K = ue.enabled, Y = ue.autoUpdate, ie = ue.needsUpdate, ge = ue.type;
    ye(), le.autoReset = C, ue.enabled = K, ue.autoUpdate = Y, ue.needsUpdate = ie, ue.type = ge;
  }
  function we(C) {
    const K = C.target;
    K.removeEventListener("dispose", we), xe(K);
  }
  function xe(C) {
    Pe(C), G.remove(C);
  }
  function Pe(C) {
    const K = G.get(C).programs;
    K !== void 0 && K.forEach(function(Y) {
      T.releaseProgram(Y);
    });
  }
  function Fe(C, K) {
    C.render(function(Y) {
      m.renderBufferImmediate(Y, K);
    });
  }
  this.renderBufferImmediate = function(C, K) {
    J.initAttributes();
    const Y = G.get(C);
    C.hasPositions && !Y.position && (Y.position = O.createBuffer()), C.hasNormals && !Y.normal && (Y.normal = O.createBuffer()), C.hasUvs && !Y.uv && (Y.uv = O.createBuffer()), C.hasColors && !Y.color && (Y.color = O.createBuffer());
    const ie = K.getAttributes();
    C.hasPositions && (O.bindBuffer(34962, Y.position), O.bufferData(34962, C.positionArray, 35048), J.enableAttribute(ie.position), O.vertexAttribPointer(ie.position, 3, 5126, !1, 0, 0)), C.hasNormals && (O.bindBuffer(34962, Y.normal), O.bufferData(34962, C.normalArray, 35048), J.enableAttribute(ie.normal), O.vertexAttribPointer(ie.normal, 3, 5126, !1, 0, 0)), C.hasUvs && (O.bindBuffer(34962, Y.uv), O.bufferData(34962, C.uvArray, 35048), J.enableAttribute(ie.uv), O.vertexAttribPointer(ie.uv, 2, 5126, !1, 0, 0)), C.hasColors && (O.bindBuffer(34962, Y.color), O.bufferData(34962, C.colorArray, 35048), J.enableAttribute(ie.color), O.vertexAttribPointer(ie.color, 3, 5126, !1, 0, 0)), J.disableUnusedAttributes(), O.drawArrays(4, 0, C.count), C.count = 0;
  }, this.renderBufferDirect = function(C, K, Y, ie, ge, Ae) {
    K === null && (K = X);
    const be = ge.isMesh && ge.matrixWorld.determinant() < 0, _e = $e(C, K, ie, ge);
    he.setMaterial(ie, be);
    let De = Y.index;
    const Me = Y.attributes.position;
    if (De === null) {
      if (Me === void 0 || Me.count === 0) return;
    } else if (De.count === 0)
      return;
    let Be = 1;
    ie.wireframe === !0 && (De = oe.getWireframeAttribute(Y), Be = 2), (ie.morphTargets || ie.morphNormals) && fe.update(ge, Y, ie, _e), J.setup(ge, ie, _e, Y, De);
    let Ce, Ne = ve;
    De !== null && (Ce = ae.get(De), Ne = N, Ne.setIndex(Ce));
    const Ze = De !== null ? De.count : Me.count, Ye = Y.drawRange.start * Be, rt = Y.drawRange.count * Be, Ge = Ae !== null ? Ae.start * Be : 0, tt = Ae !== null ? Ae.count * Be : 1 / 0, je = Math.max(Ye, Ge), Se = Math.min(Ze, Ye + rt, Ge + tt) - 1, st = Math.max(0, Se - je + 1);
    if (st !== 0) {
      if (ge.isMesh)
        ie.wireframe === !0 ? (he.setLineWidth(ie.wireframeLinewidth * q()), Ne.setMode(1)) : Ne.setMode(4);
      else if (ge.isLine) {
        let ct = ie.linewidth;
        ct === void 0 && (ct = 1), he.setLineWidth(ct * q()), ge.isLineSegments ? Ne.setMode(1) : ge.isLineLoop ? Ne.setMode(2) : Ne.setMode(3);
      } else ge.isPoints ? Ne.setMode(0) : ge.isSprite && Ne.setMode(4);
      if (ge.isInstancedMesh)
        Ne.renderInstances(je, st, ge.count);
      else if (Y.isInstancedBufferGeometry) {
        const ct = Math.min(Y.instanceCount, Y._maxInstanceCount);
        Ne.renderInstances(je, st, ct);
      } else
        Ne.render(je, st);
    }
  }, this.compile = function(C, K) {
    d = j.get(C), d.init(), C.traverseVisible(function(Y) {
      Y.isLight && Y.layers.test(K.layers) && (d.pushLight(Y), Y.castShadow && d.pushShadow(Y));
    }), d.setupLights(), C.traverse(function(Y) {
      const ie = Y.material;
      if (ie)
        if (Array.isArray(ie))
          for (let ge = 0; ge < ie.length; ge++) {
            const Ae = ie[ge];
            Re(Ae, C, Y);
          }
        else
          Re(ie, C, Y);
    });
  };
  let He = null;
  function Ve(C) {
    He && He(C);
  }
  function Ee() {
    Je.stop();
  }
  function Ue() {
    Je.start();
  }
  const Je = new WebGLAnimation();
  Je.setAnimationLoop(Ve), typeof window < "u" && Je.setContext(window), this.setAnimationLoop = function(C) {
    He = C, me.setAnimationLoop(C), C === null ? Je.stop() : Je.start();
  }, me.addEventListener("sessionstart", Ee), me.addEventListener("sessionend", Ue), this.render = function(C, K) {
    if (K !== void 0 && K.isCamera !== !0) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (v === !0) return;
    C.autoUpdate === !0 && C.updateMatrixWorld(), K.parent === null && K.updateMatrixWorld(), me.enabled === !0 && me.isPresenting === !0 && (me.cameraAutoUpdate === !0 && me.updateCamera(K), K = me.getCamera()), C.isScene === !0 && C.onBeforeRender(m, C, K, _), d = j.get(C, p.length), d.init(), p.push(d), V.multiplyMatrices(K.projectionMatrix, K.matrixWorldInverse), Q.setFromProjectionMatrix(V), H = this.localClippingEnabled, U = de.init(this.clippingPlanes, H, K), h = Z.get(C, f.length), h.init(), f.push(h), Oe(C, K, 0, m.sortObjects), h.finish(), m.sortObjects === !0 && h.sort(F, P), U === !0 && de.beginShadows();
    const Y = d.state.shadowsArray;
    ue.render(Y, C, K), d.setupLights(), d.setupLightsView(K), U === !0 && de.endShadows(), this.info.autoReset === !0 && this.info.reset(), pe.render(h, C);
    const ie = h.opaque, ge = h.transmissive, Ae = h.transparent;
    ie.length > 0 && We(ie, C, K), ge.length > 0 && Ie(ie, ge, C, K), Ae.length > 0 && We(Ae, C, K), _ !== null && (re.updateMultisampleRenderTarget(_), re.updateRenderTargetMipmap(_)), C.isScene === !0 && C.onAfterRender(m, C, K), he.buffers.depth.setTest(!0), he.buffers.depth.setMask(!0), he.buffers.color.setMask(!0), he.setPolygonOffset(!1), J.resetDefaultState(), b = -1, S = null, p.pop(), p.length > 0 ? d = p[p.length - 1] : d = null, f.pop(), f.length > 0 ? h = f[f.length - 1] : h = null;
  };
  function Oe(C, K, Y, ie) {
    if (C.visible === !1) return;
    if (C.layers.test(K.layers)) {
      if (C.isGroup)
        Y = C.renderOrder;
      else if (C.isLOD)
        C.autoUpdate === !0 && C.update(K);
      else if (C.isLight)
        d.pushLight(C), C.castShadow && d.pushShadow(C);
      else if (C.isSprite) {
        if (!C.frustumCulled || Q.intersectsSprite(C)) {
          ie && W.setFromMatrixPosition(C.matrixWorld).applyMatrix4(V);
          const be = E.update(C), _e = C.material;
          _e.visible && h.push(C, be, _e, Y, W.z, null);
        }
      } else if (C.isImmediateRenderObject)
        ie && W.setFromMatrixPosition(C.matrixWorld).applyMatrix4(V), h.push(C, null, C.material, Y, W.z, null);
      else if ((C.isMesh || C.isLine || C.isPoints) && (C.isSkinnedMesh && C.skeleton.frame !== le.render.frame && (C.skeleton.update(), C.skeleton.frame = le.render.frame), !C.frustumCulled || Q.intersectsObject(C))) {
        ie && W.setFromMatrixPosition(C.matrixWorld).applyMatrix4(V);
        const be = E.update(C), _e = C.material;
        if (Array.isArray(_e)) {
          const De = be.groups;
          for (let Me = 0, Be = De.length; Me < Be; Me++) {
            const Ce = De[Me], Ne = _e[Ce.materialIndex];
            Ne && Ne.visible && h.push(C, be, Ne, Y, W.z, Ce);
          }
        } else _e.visible && h.push(C, be, _e, Y, W.z, null);
      }
    }
    const Ae = C.children;
    for (let be = 0, _e = Ae.length; be < _e; be++)
      Oe(Ae[be], K, Y, ie);
  }
  function Ie(C, K, Y, ie) {
    if (I === null) {
      const _e = s === !0 && ce.isWebGL2 === !0 ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
      I = new _e(1024, 1024, {
        generateMipmaps: !0,
        type: ee.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
        minFilter: LinearMipmapLinearFilter,
        magFilter: NearestFilter,
        wrapS: ClampToEdgeWrapping,
        wrapT: ClampToEdgeWrapping
      });
    }
    const ge = m.getRenderTarget();
    m.setRenderTarget(I), m.clear();
    const Ae = m.toneMapping;
    m.toneMapping = NoToneMapping, We(C, Y, ie), m.toneMapping = Ae, re.updateMultisampleRenderTarget(I), re.updateRenderTargetMipmap(I), m.setRenderTarget(ge), We(K, Y, ie);
  }
  function We(C, K, Y) {
    const ie = K.isScene === !0 ? K.overrideMaterial : null;
    for (let ge = 0, Ae = C.length; ge < Ae; ge++) {
      const be = C[ge], _e = be.object, De = be.geometry, Me = ie === null ? be.material : ie, Be = be.group;
      if (Y.isArrayCamera) {
        const Ce = Y.cameras;
        for (let Ne = 0, Ze = Ce.length; Ne < Ze; Ne++) {
          const Ye = Ce[Ne];
          _e.layers.test(Ye.layers) && (he.viewport(x.copy(Ye.viewport)), d.setupLightsView(Ye), ze(_e, K, Ye, De, Me, Be));
        }
      } else
        ze(_e, K, Y, De, Me, Be);
    }
  }
  function ze(C, K, Y, ie, ge, Ae) {
    if (C.onBeforeRender(m, K, Y, ie, ge, Ae), C.modelViewMatrix.multiplyMatrices(Y.matrixWorldInverse, C.matrixWorld), C.normalMatrix.getNormalMatrix(C.modelViewMatrix), C.isImmediateRenderObject) {
      const be = $e(Y, K, ge, C);
      he.setMaterial(ge), J.reset(), Fe(C, be);
    } else
      ge.transparent === !0 && ge.side === DoubleSide ? (ge.side = BackSide, ge.needsUpdate = !0, m.renderBufferDirect(Y, K, ie, ge, C, Ae), ge.side = FrontSide, ge.needsUpdate = !0, m.renderBufferDirect(Y, K, ie, ge, C, Ae), ge.side = DoubleSide) : m.renderBufferDirect(Y, K, ie, ge, C, Ae);
    C.onAfterRender(m, K, Y, ie, ge, Ae);
  }
  function Re(C, K, Y) {
    K.isScene !== !0 && (K = X);
    const ie = G.get(C), ge = d.state.lights, Ae = d.state.shadowsArray, be = ge.state.version, _e = T.getParameters(C, ge.state, Ae, K, Y), De = T.getProgramCacheKey(_e);
    let Me = ie.programs;
    ie.environment = C.isMeshStandardMaterial ? K.environment : null, ie.fog = K.fog, ie.envMap = se.get(C.envMap || ie.environment), Me === void 0 && (C.addEventListener("dispose", we), Me = /* @__PURE__ */ new Map(), ie.programs = Me);
    let Be = Me.get(De);
    if (Be !== void 0) {
      if (ie.currentProgram === Be && ie.lightsStateVersion === be)
        return ke(C, _e), Be;
    } else
      _e.uniforms = T.getUniforms(C), C.onBuild(_e, m), C.onBeforeCompile(_e, m), Be = T.acquireProgram(_e, De), Me.set(De, Be), ie.uniforms = _e.uniforms;
    const Ce = ie.uniforms;
    (!C.isShaderMaterial && !C.isRawShaderMaterial || C.clipping === !0) && (Ce.clippingPlanes = de.uniform), ke(C, _e), ie.needsLights = qe(C), ie.lightsStateVersion = be, ie.needsLights && (Ce.ambientLightColor.value = ge.state.ambient, Ce.lightProbe.value = ge.state.probe, Ce.directionalLights.value = ge.state.directional, Ce.directionalLightShadows.value = ge.state.directionalShadow, Ce.spotLights.value = ge.state.spot, Ce.spotLightShadows.value = ge.state.spotShadow, Ce.rectAreaLights.value = ge.state.rectArea, Ce.ltc_1.value = ge.state.rectAreaLTC1, Ce.ltc_2.value = ge.state.rectAreaLTC2, Ce.pointLights.value = ge.state.point, Ce.pointLightShadows.value = ge.state.pointShadow, Ce.hemisphereLights.value = ge.state.hemi, Ce.directionalShadowMap.value = ge.state.directionalShadowMap, Ce.directionalShadowMatrix.value = ge.state.directionalShadowMatrix, Ce.spotShadowMap.value = ge.state.spotShadowMap, Ce.spotShadowMatrix.value = ge.state.spotShadowMatrix, Ce.pointShadowMap.value = ge.state.pointShadowMap, Ce.pointShadowMatrix.value = ge.state.pointShadowMatrix);
    const Ne = Be.getUniforms(), Ze = WebGLUniforms.seqWithValue(Ne.seq, Ce);
    return ie.currentProgram = Be, ie.uniformsList = Ze, Be;
  }
  function ke(C, K) {
    const Y = G.get(C);
    Y.outputEncoding = K.outputEncoding, Y.instancing = K.instancing, Y.skinning = K.skinning, Y.numClippingPlanes = K.numClippingPlanes, Y.numIntersection = K.numClipIntersection, Y.vertexAlphas = K.vertexAlphas;
  }
  function $e(C, K, Y, ie) {
    K.isScene !== !0 && (K = X), re.resetTextureUnits();
    const ge = K.fog, Ae = Y.isMeshStandardMaterial ? K.environment : null, be = _ === null ? m.outputEncoding : _.texture.encoding, _e = se.get(Y.envMap || Ae), De = Y.vertexColors === !0 && ie.geometry && ie.geometry.attributes.color && ie.geometry.attributes.color.itemSize === 4, Me = G.get(Y), Be = d.state.lights;
    if (U === !0 && (H === !0 || C !== S)) {
      const je = C === S && Y.id === b;
      de.setState(Y, C, je);
    }
    let Ce = !1;
    Y.version === Me.__version ? (Me.needsLights && Me.lightsStateVersion !== Be.state.version || Me.outputEncoding !== be || ie.isInstancedMesh && Me.instancing === !1 || !ie.isInstancedMesh && Me.instancing === !0 || ie.isSkinnedMesh && Me.skinning === !1 || !ie.isSkinnedMesh && Me.skinning === !0 || Me.envMap !== _e || Y.fog && Me.fog !== ge || Me.numClippingPlanes !== void 0 && (Me.numClippingPlanes !== de.numPlanes || Me.numIntersection !== de.numIntersection) || Me.vertexAlphas !== De) && (Ce = !0) : (Ce = !0, Me.__version = Y.version);
    let Ne = Me.currentProgram;
    Ce === !0 && (Ne = Re(Y, K, ie));
    let Ze = !1, Ye = !1, rt = !1;
    const Ge = Ne.getUniforms(), tt = Me.uniforms;
    if (he.useProgram(Ne.program) && (Ze = !0, Ye = !0, rt = !0), Y.id !== b && (b = Y.id, Ye = !0), Ze || S !== C) {
      if (Ge.setValue(O, "projectionMatrix", C.projectionMatrix), ce.logarithmicDepthBuffer && Ge.setValue(
        O,
        "logDepthBufFC",
        2 / (Math.log(C.far + 1) / Math.LN2)
      ), S !== C && (S = C, Ye = !0, rt = !0), Y.isShaderMaterial || Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshStandardMaterial || Y.envMap) {
        const je = Ge.map.cameraPosition;
        je !== void 0 && je.setValue(
          O,
          W.setFromMatrixPosition(C.matrixWorld)
        );
      }
      (Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshLambertMaterial || Y.isMeshBasicMaterial || Y.isMeshStandardMaterial || Y.isShaderMaterial) && Ge.setValue(O, "isOrthographic", C.isOrthographicCamera === !0), (Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshLambertMaterial || Y.isMeshBasicMaterial || Y.isMeshStandardMaterial || Y.isShaderMaterial || Y.isShadowMaterial || ie.isSkinnedMesh) && Ge.setValue(O, "viewMatrix", C.matrixWorldInverse);
    }
    if (ie.isSkinnedMesh) {
      Ge.setOptional(O, ie, "bindMatrix"), Ge.setOptional(O, ie, "bindMatrixInverse");
      const je = ie.skeleton;
      je && (ce.floatVertexTextures ? (je.boneTexture === null && je.computeBoneTexture(), Ge.setValue(O, "boneTexture", je.boneTexture, re), Ge.setValue(O, "boneTextureSize", je.boneTextureSize)) : Ge.setOptional(O, je, "boneMatrices"));
    }
    return (Ye || Me.receiveShadow !== ie.receiveShadow) && (Me.receiveShadow = ie.receiveShadow, Ge.setValue(O, "receiveShadow", ie.receiveShadow)), Ye && (Ge.setValue(O, "toneMappingExposure", m.toneMappingExposure), Me.needsLights && Xe(tt, rt), ge && Y.fog && $.refreshFogUniforms(tt, ge), $.refreshMaterialUniforms(tt, Y, z, B, I), WebGLUniforms.upload(O, Me.uniformsList, tt, re)), Y.isShaderMaterial && Y.uniformsNeedUpdate === !0 && (WebGLUniforms.upload(O, Me.uniformsList, tt, re), Y.uniformsNeedUpdate = !1), Y.isSpriteMaterial && Ge.setValue(O, "center", ie.center), Ge.setValue(O, "modelViewMatrix", ie.modelViewMatrix), Ge.setValue(O, "normalMatrix", ie.normalMatrix), Ge.setValue(O, "modelMatrix", ie.matrixWorld), Ne;
  }
  function Xe(C, K) {
    C.ambientLightColor.needsUpdate = K, C.lightProbe.needsUpdate = K, C.directionalLights.needsUpdate = K, C.directionalLightShadows.needsUpdate = K, C.pointLights.needsUpdate = K, C.pointLightShadows.needsUpdate = K, C.spotLights.needsUpdate = K, C.spotLightShadows.needsUpdate = K, C.rectAreaLights.needsUpdate = K, C.hemisphereLights.needsUpdate = K;
  }
  function qe(C) {
    return C.isMeshLambertMaterial || C.isMeshToonMaterial || C.isMeshPhongMaterial || C.isMeshStandardMaterial || C.isShadowMaterial || C.isShaderMaterial && C.lights === !0;
  }
  this.getActiveCubeFace = function() {
    return y;
  }, this.getActiveMipmapLevel = function() {
    return g;
  }, this.getRenderTarget = function() {
    return _;
  }, this.setRenderTarget = function(C, K = 0, Y = 0) {
    _ = C, y = K, g = Y, C && G.get(C).__webglFramebuffer === void 0 && re.setupRenderTarget(C);
    let ie = null, ge = !1, Ae = !1;
    if (C) {
      const _e = C.texture;
      (_e.isDataTexture3D || _e.isDataTexture2DArray) && (Ae = !0);
      const De = G.get(C).__webglFramebuffer;
      C.isWebGLCubeRenderTarget ? (ie = De[K], ge = !0) : C.isWebGLMultisampleRenderTarget ? ie = G.get(C).__webglMultisampledFramebuffer : ie = De, x.copy(C.viewport), M.copy(C.scissor), w = C.scissorTest;
    } else
      x.copy(R).multiplyScalar(z).floor(), M.copy(L).multiplyScalar(z).floor(), w = A;
    if (he.bindFramebuffer(36160, ie) && ce.drawBuffers) {
      let _e = !1;
      if (C)
        if (C.isWebGLMultipleRenderTargets) {
          const De = C.texture;
          if (k.length !== De.length || k[0] !== 36064) {
            for (let Me = 0, Be = De.length; Me < Be; Me++)
              k[Me] = 36064 + Me;
            k.length = De.length, _e = !0;
          }
        } else
          (k.length !== 1 || k[0] !== 36064) && (k[0] = 36064, k.length = 1, _e = !0);
      else
        (k.length !== 1 || k[0] !== 1029) && (k[0] = 1029, k.length = 1, _e = !0);
      _e && (ce.isWebGL2 ? O.drawBuffers(k) : ne.get("WEBGL_draw_buffers").drawBuffersWEBGL(k));
    }
    if (he.viewport(x), he.scissor(M), he.setScissorTest(w), ge) {
      const _e = G.get(C.texture);
      O.framebufferTexture2D(36160, 36064, 34069 + K, _e.__webglTexture, Y);
    } else if (Ae) {
      const _e = G.get(C.texture), De = K || 0;
      O.framebufferTextureLayer(36160, 36064, _e.__webglTexture, Y || 0, De);
    }
  }, this.readRenderTargetPixels = function(C, K, Y, ie, ge, Ae, be) {
    if (!(C && C.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let _e = G.get(C).__webglFramebuffer;
    if (C.isWebGLCubeRenderTarget && be !== void 0 && (_e = _e[be]), _e) {
      he.bindFramebuffer(36160, _e);
      try {
        const De = C.texture, Me = De.format, Be = De.type;
        if (Me !== RGBAFormat && ee.convert(Me) !== O.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const Ce = Be === HalfFloatType && (ne.has("EXT_color_buffer_half_float") || ce.isWebGL2 && ne.has("EXT_color_buffer_float"));
        if (Be !== UnsignedByteType && ee.convert(Be) !== O.getParameter(35738) && // Edge and Chrome Mac < 52 (#9513)
        !(Be === FloatType && (ce.isWebGL2 || ne.has("OES_texture_float") || ne.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
        !Ce) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        O.checkFramebufferStatus(36160) === 36053 ? K >= 0 && K <= C.width - ie && Y >= 0 && Y <= C.height - ge && O.readPixels(K, Y, ie, ge, ee.convert(Me), ee.convert(Be), Ae) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
      } finally {
        const De = _ !== null ? G.get(_).__webglFramebuffer : null;
        he.bindFramebuffer(36160, De);
      }
    }
  }, this.copyFramebufferToTexture = function(C, K, Y = 0) {
    const ie = Math.pow(2, -Y), ge = Math.floor(K.image.width * ie), Ae = Math.floor(K.image.height * ie);
    let be = ee.convert(K.format);
    ce.isWebGL2 && (be === 6407 && (be = 32849), be === 6408 && (be = 32856)), re.setTexture2D(K, 0), O.copyTexImage2D(3553, Y, be, C.x, C.y, ge, Ae, 0), he.unbindTexture();
  }, this.copyTextureToTexture = function(C, K, Y, ie = 0) {
    const ge = K.image.width, Ae = K.image.height, be = ee.convert(Y.format), _e = ee.convert(Y.type);
    re.setTexture2D(Y, 0), O.pixelStorei(37440, Y.flipY), O.pixelStorei(37441, Y.premultiplyAlpha), O.pixelStorei(3317, Y.unpackAlignment), K.isDataTexture ? O.texSubImage2D(3553, ie, C.x, C.y, ge, Ae, be, _e, K.image.data) : K.isCompressedTexture ? O.compressedTexSubImage2D(3553, ie, C.x, C.y, K.mipmaps[0].width, K.mipmaps[0].height, be, K.mipmaps[0].data) : O.texSubImage2D(3553, ie, C.x, C.y, be, _e, K.image), ie === 0 && Y.generateMipmaps && O.generateMipmap(3553), he.unbindTexture();
  }, this.copyTextureToTexture3D = function(C, K, Y, ie, ge = 0) {
    if (m.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const Ae = C.max.x - C.min.x + 1, be = C.max.y - C.min.y + 1, _e = C.max.z - C.min.z + 1, De = ee.convert(ie.format), Me = ee.convert(ie.type);
    let Be;
    if (ie.isDataTexture3D)
      re.setTexture3D(ie, 0), Be = 32879;
    else if (ie.isDataTexture2DArray)
      re.setTexture2DArray(ie, 0), Be = 35866;
    else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    O.pixelStorei(37440, ie.flipY), O.pixelStorei(37441, ie.premultiplyAlpha), O.pixelStorei(3317, ie.unpackAlignment);
    const Ce = O.getParameter(3314), Ne = O.getParameter(32878), Ze = O.getParameter(3316), Ye = O.getParameter(3315), rt = O.getParameter(32877), Ge = Y.isCompressedTexture ? Y.mipmaps[0] : Y.image;
    O.pixelStorei(3314, Ge.width), O.pixelStorei(32878, Ge.height), O.pixelStorei(3316, C.min.x), O.pixelStorei(3315, C.min.y), O.pixelStorei(32877, C.min.z), Y.isDataTexture || Y.isDataTexture3D ? O.texSubImage3D(Be, ge, K.x, K.y, K.z, Ae, be, _e, De, Me, Ge.data) : Y.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), O.compressedTexSubImage3D(Be, ge, K.x, K.y, K.z, Ae, be, _e, De, Ge.data)) : O.texSubImage3D(Be, ge, K.x, K.y, K.z, Ae, be, _e, De, Me, Ge), O.pixelStorei(3314, Ce), O.pixelStorei(32878, Ne), O.pixelStorei(3316, Ze), O.pixelStorei(3315, Ye), O.pixelStorei(32877, rt), ge === 0 && ie.generateMipmaps && O.generateMipmap(Be), he.unbindTexture();
  }, this.initTexture = function(C) {
    re.setTexture2D(C, 0), he.unbindTexture();
  }, this.resetState = function() {
    y = 0, g = 0, _ = null, he.reset(), J.reset();
  }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
class WebGL1Renderer extends WebGLRenderer$1 {
}
WebGL1Renderer.prototype.isWebGL1Renderer = !0;
class FogExp2 {
  constructor(e, t = 25e-5) {
    this.name = "", this.color = new Color(e), this.density = t;
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
}
FogExp2.prototype.isFogExp2 = !0;
class Fog {
  constructor(e, t = 1, i = 1e3) {
    this.name = "", this.color = new Color(e), this.near = t, this.far = i;
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
Fog.prototype.isFog = !0;
let Scene$1 = class extends Object3D {
  constructor() {
    super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
  }
};
Scene$1.prototype.isScene = !0;
class InterleavedBuffer {
  constructor(e, t) {
    this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = StaticDrawUsage, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = generateUUID$1();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, i) {
    e *= this.stride, i *= t.stride;
    for (let n = 0, r = this.stride; n < r; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID$1()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID$1()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
InterleavedBuffer.prototype.isInterleavedBuffer = !0;
const _vector$6 = /* @__PURE__ */ new Vector3();
class InterleavedBufferAttribute {
  constructor(e, t, i, n = !1) {
    this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = n === !0;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      _vector$6.x = this.getX(t), _vector$6.y = this.getY(t), _vector$6.z = this.getZ(t), _vector$6.applyMatrix4(e), this.setXYZ(t, _vector$6.x, _vector$6.y, _vector$6.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      _vector$6.x = this.getX(t), _vector$6.y = this.getY(t), _vector$6.z = this.getZ(t), _vector$6.applyNormalMatrix(e), this.setXYZ(t, _vector$6.x, _vector$6.y, _vector$6.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      _vector$6.x = this.getX(t), _vector$6.y = this.getY(t), _vector$6.z = this.getZ(t), _vector$6.transformDirection(e), this.setXYZ(t, _vector$6.x, _vector$6.y, _vector$6.z);
    return this;
  }
  setX(e, t) {
    return this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    return this.data.array[e * this.data.stride + this.offset];
  }
  getY(e) {
    return this.data.array[e * this.data.stride + this.offset + 1];
  }
  getZ(e) {
    return this.data.array[e * this.data.stride + this.offset + 2];
  }
  getW(e) {
    return this.data.array[e * this.data.stride + this.offset + 3];
  }
  setXY(e, t, i) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, n) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this;
  }
  setXYZW(e, t, i, n, r) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const n = i * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[n + r]);
      }
      return new BufferAttribute(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new InterleavedBufferAttribute(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const n = i * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[n + r]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = !0;
class SpriteMaterial extends Material {
  constructor(e) {
    super(), this.type = "SpriteMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this;
  }
}
SpriteMaterial.prototype.isSpriteMaterial = !0;
let _geometry;
const _intersectPoint = /* @__PURE__ */ new Vector3(), _worldScale = /* @__PURE__ */ new Vector3(), _mvPosition = /* @__PURE__ */ new Vector3(), _alignedPosition = /* @__PURE__ */ new Vector2(), _rotatedPosition = /* @__PURE__ */ new Vector2(), _viewWorldMatrix = /* @__PURE__ */ new Matrix4(), _vA = /* @__PURE__ */ new Vector3(), _vB = /* @__PURE__ */ new Vector3(), _vC = /* @__PURE__ */ new Vector3(), _uvA = /* @__PURE__ */ new Vector2(), _uvB = /* @__PURE__ */ new Vector2(), _uvC = /* @__PURE__ */ new Vector2();
class Sprite extends Object3D {
  constructor(e) {
    if (super(), this.type = "Sprite", _geometry === void 0) {
      _geometry = new BufferGeometry();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), i = new InterleavedBuffer(t, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]), _geometry.setAttribute("position", new InterleavedBufferAttribute(i, 3, 0, !1)), _geometry.setAttribute("uv", new InterleavedBufferAttribute(i, 2, 3, !1));
    }
    this.geometry = _geometry, this.material = e !== void 0 ? e : new SpriteMaterial(), this.center = new Vector2(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), _worldScale.setFromMatrixScale(this.matrixWorld), _viewWorldMatrix.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), _mvPosition.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && _worldScale.multiplyScalar(-_mvPosition.z);
    const i = this.material.rotation;
    let n, r;
    i !== 0 && (r = Math.cos(i), n = Math.sin(i));
    const s = this.center;
    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, s, _worldScale, n, r), transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, s, _worldScale, n, r), transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, s, _worldScale, n, r), _uvA.set(0, 0), _uvB.set(1, 0), _uvC.set(1, 1);
    let a = e.ray.intersectTriangle(_vA, _vB, _vC, !1, _intersectPoint);
    if (a === null && (transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, s, _worldScale, n, r), _uvB.set(0, 1), a = e.ray.intersectTriangle(_vA, _vC, _vB, !1, _intersectPoint), a === null))
      return;
    const l = e.ray.origin.distanceTo(_intersectPoint);
    l < e.near || l > e.far || t.push({
      distance: l,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
      face: null,
      object: this
    });
  }
  copy(e) {
    return super.copy(e), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
Sprite.prototype.isSprite = !0;
function transformVertex(o, e, t, i, n, r) {
  _alignedPosition.subVectors(o, t).addScalar(0.5).multiply(i), n !== void 0 ? (_rotatedPosition.x = r * _alignedPosition.x - n * _alignedPosition.y, _rotatedPosition.y = n * _alignedPosition.x + r * _alignedPosition.y) : _rotatedPosition.copy(_alignedPosition), o.copy(e), o.x += _rotatedPosition.x, o.y += _rotatedPosition.y, o.applyMatrix4(_viewWorldMatrix);
}
const _v1$2 = /* @__PURE__ */ new Vector3(), _v2$1 = /* @__PURE__ */ new Vector3();
class LOD extends Object3D {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i];
      this.addLevel(r.object.clone(), r.distance);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let n;
    for (n = 0; n < i.length && !(t < i[n].distance); n++)
      ;
    return i.splice(n, 0, { distance: t, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let i, n;
      for (i = 1, n = t.length; i < n && !(e < t[i].distance); i++)
        ;
      return t[i - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      _v1$2.setFromMatrixPosition(this.matrixWorld);
      const n = e.ray.origin.distanceTo(_v1$2);
      this.getObjectForDistance(n).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      _v1$2.setFromMatrixPosition(e.matrixWorld), _v2$1.setFromMatrixPosition(this.matrixWorld);
      const i = _v1$2.distanceTo(_v2$1) / e.zoom;
      t[0].object.visible = !0;
      let n, r;
      for (n = 1, r = t.length; n < r && i >= t[n].distance; n++)
        t[n - 1].object.visible = !1, t[n].object.visible = !0;
      for (this._currentLevel = n - 1; n < r; n++)
        t[n].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const i = this.levels;
    for (let n = 0, r = i.length; n < r; n++) {
      const s = i[n];
      t.object.levels.push({
        object: s.object.uuid,
        distance: s.distance
      });
    }
    return t;
  }
}
const _basePosition = /* @__PURE__ */ new Vector3(), _skinIndex = /* @__PURE__ */ new Vector4(), _skinWeight = /* @__PURE__ */ new Vector4(), _vector$5 = /* @__PURE__ */ new Vector3(), _matrix = /* @__PURE__ */ new Matrix4();
class SkinnedMesh extends Mesh {
  constructor(e, t) {
    super(e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Matrix4(), this.bindMatrixInverse = new Matrix4();
  }
  copy(e) {
    return super.copy(e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Vector4(), t = this.geometry.attributes.skinWeight;
    for (let i = 0, n = t.count; i < n; i++) {
      e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.w = t.getW(i);
      const r = 1 / e.manhattanLength();
      r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  boneTransform(e, t) {
    const i = this.skeleton, n = this.geometry;
    _skinIndex.fromBufferAttribute(n.attributes.skinIndex, e), _skinWeight.fromBufferAttribute(n.attributes.skinWeight, e), _basePosition.fromBufferAttribute(n.attributes.position, e).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let r = 0; r < 4; r++) {
      const s = _skinWeight.getComponent(r);
      if (s !== 0) {
        const a = _skinIndex.getComponent(r);
        _matrix.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]), t.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), s);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
SkinnedMesh.prototype.isSkinnedMesh = !0;
class Bone extends Object3D {
  constructor() {
    super(), this.type = "Bone";
  }
}
Bone.prototype.isBone = !0;
class DataTexture extends Texture {
  constructor(e = null, t = 1, i = 1, n, r, s, a, l, c = NearestFilter, u = NearestFilter, h, d) {
    super(null, s, a, l, c, u, n, r, h, d), this.image = { data: e, width: t, height: i }, this.magFilter = c, this.minFilter = u, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0;
  }
}
DataTexture.prototype.isDataTexture = !0;
const _offsetMatrix = /* @__PURE__ */ new Matrix4(), _identityMatrix = /* @__PURE__ */ new Matrix4();
class Skeleton {
  constructor(e = [], t = []) {
    this.uuid = generateUUID$1(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let i = 0, n = this.bones.length; i < n; i++)
        this.boneInverses.push(new Matrix4());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new Matrix4();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, i = this.boneMatrices, n = this.boneTexture;
    for (let r = 0, s = e.length; r < s; r++) {
      const a = e[r] ? e[r].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(a, t[r]), _offsetMatrix.toArray(i, r * 16);
    }
    n !== null && (n.needsUpdate = !0);
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = ceilPowerOfTwo(e), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new DataTexture(t, e, e, RGBAFormat, FloatType);
    return this.boneMatrices = t, this.boneTexture = i, this.boneTextureSize = e, this;
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const n = this.bones[t];
      if (n.name === e)
        return n;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, n = e.bones.length; i < n; i++) {
      const r = e.bones[i];
      let s = t[r];
      s === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), s = new Bone()), this.bones.push(s), this.boneInverses.push(new Matrix4().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, i = this.boneInverses;
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      e.bones.push(s.uuid);
      const a = i[n];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
const _instanceLocalMatrix = /* @__PURE__ */ new Matrix4(), _instanceWorldMatrix = /* @__PURE__ */ new Matrix4(), _instanceIntersects = [], _mesh = /* @__PURE__ */ new Mesh();
class InstancedMesh extends Mesh {
  constructor(e, t, i) {
    super(e, t), this.instanceMatrix = new BufferAttribute(new Float32Array(i * 16), 16), this.instanceColor = null, this.count = i, this.frustumCulled = !1;
  }
  copy(e) {
    return super.copy(e), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const i = this.matrixWorld, n = this.count;
    if (_mesh.geometry = this.geometry, _mesh.material = this.material, _mesh.material !== void 0)
      for (let r = 0; r < n; r++) {
        this.getMatrixAt(r, _instanceLocalMatrix), _instanceWorldMatrix.multiplyMatrices(i, _instanceLocalMatrix), _mesh.matrixWorld = _instanceWorldMatrix, _mesh.raycast(e, _instanceIntersects);
        for (let s = 0, a = _instanceIntersects.length; s < a; s++) {
          const l = _instanceIntersects[s];
          l.instanceId = r, l.object = this, t.push(l);
        }
        _instanceIntersects.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
InstancedMesh.prototype.isInstancedMesh = !0;
class LineBasicMaterial extends Material {
  constructor(e) {
    super(), this.type = "LineBasicMaterial", this.color = new Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.morphTargets = e.morphTargets, this;
  }
}
LineBasicMaterial.prototype.isLineBasicMaterial = !0;
const _start$1 = /* @__PURE__ */ new Vector3(), _end$1 = /* @__PURE__ */ new Vector3(), _inverseMatrix$1 = /* @__PURE__ */ new Matrix4(), _ray$1 = /* @__PURE__ */ new Ray(), _sphere$1 = /* @__PURE__ */ new Sphere();
class Line extends Object3D {
  constructor(e = new BufferGeometry(), t = new LineBasicMaterial()) {
    super(), this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e) {
    return super.copy(e), this.material = e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.isBufferGeometry)
      if (e.index === null) {
        const t = e.attributes.position, i = [0];
        for (let n = 1, r = t.count; n < r; n++)
          _start$1.fromBufferAttribute(t, n - 1), _end$1.fromBufferAttribute(t, n), i[n] = i[n - 1], i[n] += _start$1.distanceTo(_end$1);
        e.setAttribute("lineDistance", new Float32BufferAttribute(i, 1));
      } else
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    return this;
  }
  raycast(e, t) {
    const i = this.geometry, n = this.matrixWorld, r = e.params.Line.threshold, s = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), _sphere$1.copy(i.boundingSphere), _sphere$1.applyMatrix4(n), _sphere$1.radius += r, e.ray.intersectsSphere(_sphere$1) === !1) return;
    _inverseMatrix$1.copy(n).invert(), _ray$1.copy(e.ray).applyMatrix4(_inverseMatrix$1);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = new Vector3(), u = new Vector3(), h = new Vector3(), d = new Vector3(), f = this.isLineSegments ? 2 : 1;
    if (i.isBufferGeometry) {
      const p = i.index, v = i.attributes.position;
      if (p !== null) {
        const y = Math.max(0, s.start), g = Math.min(p.count, s.start + s.count);
        for (let _ = y, b = g - 1; _ < b; _ += f) {
          const S = p.getX(_), x = p.getX(_ + 1);
          if (c.fromBufferAttribute(v, S), u.fromBufferAttribute(v, x), _ray$1.distanceSqToSegment(c, u, d, h) > l) continue;
          d.applyMatrix4(this.matrixWorld);
          const w = e.ray.origin.distanceTo(d);
          w < e.near || w > e.far || t.push({
            distance: w,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: h.clone().applyMatrix4(this.matrixWorld),
            index: _,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const y = Math.max(0, s.start), g = Math.min(v.count, s.start + s.count);
        for (let _ = y, b = g - 1; _ < b; _ += f) {
          if (c.fromBufferAttribute(v, _), u.fromBufferAttribute(v, _ + 1), _ray$1.distanceSqToSegment(c, u, d, h) > l) continue;
          d.applyMatrix4(this.matrixWorld);
          const x = e.ray.origin.distanceTo(d);
          x < e.near || x > e.far || t.push({
            distance: x,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: h.clone().applyMatrix4(this.matrixWorld),
            index: _,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else i.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  }
  updateMorphTargets() {
    const e = this.geometry;
    if (e.isBufferGeometry) {
      const t = e.morphAttributes, i = Object.keys(t);
      if (i.length > 0) {
        const n = t[i[0]];
        if (n !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let r = 0, s = n.length; r < s; r++) {
            const a = n[r].name || String(r);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
          }
        }
      }
    } else {
      const t = e.morphTargets;
      t !== void 0 && t.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
}
Line.prototype.isLine = !0;
const _start = /* @__PURE__ */ new Vector3(), _end = /* @__PURE__ */ new Vector3();
class LineSegments extends Line {
  constructor(e, t) {
    super(e, t), this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.isBufferGeometry)
      if (e.index === null) {
        const t = e.attributes.position, i = [];
        for (let n = 0, r = t.count; n < r; n += 2)
          _start.fromBufferAttribute(t, n), _end.fromBufferAttribute(t, n + 1), i[n] = n === 0 ? 0 : i[n - 1], i[n + 1] = i[n] + _start.distanceTo(_end);
        e.setAttribute("lineDistance", new Float32BufferAttribute(i, 1));
      } else
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    return this;
  }
}
LineSegments.prototype.isLineSegments = !0;
class LineLoop extends Line {
  constructor(e, t) {
    super(e, t), this.type = "LineLoop";
  }
}
LineLoop.prototype.isLineLoop = !0;
class PointsMaterial extends Material {
  constructor(e) {
    super(), this.type = "PointsMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this;
  }
}
PointsMaterial.prototype.isPointsMaterial = !0;
const _inverseMatrix = /* @__PURE__ */ new Matrix4(), _ray = /* @__PURE__ */ new Ray(), _sphere = /* @__PURE__ */ new Sphere(), _position$2 = /* @__PURE__ */ new Vector3();
class Points extends Object3D {
  constructor(e = new BufferGeometry(), t = new PointsMaterial()) {
    super(), this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e) {
    return super.copy(e), this.material = e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const i = this.geometry, n = this.matrixWorld, r = e.params.Points.threshold, s = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), _sphere.copy(i.boundingSphere), _sphere.applyMatrix4(n), _sphere.radius += r, e.ray.intersectsSphere(_sphere) === !1) return;
    _inverseMatrix.copy(n).invert(), _ray.copy(e.ray).applyMatrix4(_inverseMatrix);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a;
    if (i.isBufferGeometry) {
      const c = i.index, h = i.attributes.position;
      if (c !== null) {
        const d = Math.max(0, s.start), f = Math.min(c.count, s.start + s.count);
        for (let p = d, m = f; p < m; p++) {
          const v = c.getX(p);
          _position$2.fromBufferAttribute(h, v), testPoint(_position$2, v, l, n, e, t, this);
        }
      } else {
        const d = Math.max(0, s.start), f = Math.min(h.count, s.start + s.count);
        for (let p = d, m = f; p < m; p++)
          _position$2.fromBufferAttribute(h, p), testPoint(_position$2, p, l, n, e, t, this);
      }
    } else
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  }
  updateMorphTargets() {
    const e = this.geometry;
    if (e.isBufferGeometry) {
      const t = e.morphAttributes, i = Object.keys(t);
      if (i.length > 0) {
        const n = t[i[0]];
        if (n !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let r = 0, s = n.length; r < s; r++) {
            const a = n[r].name || String(r);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
          }
        }
      }
    } else {
      const t = e.morphTargets;
      t !== void 0 && t.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
}
Points.prototype.isPoints = !0;
function testPoint(o, e, t, i, n, r, s) {
  const a = _ray.distanceSqToPoint(o);
  if (a < t) {
    const l = new Vector3();
    _ray.closestPointToPoint(o, l), l.applyMatrix4(i);
    const c = n.ray.origin.distanceTo(l);
    if (c < n.near || c > n.far) return;
    r.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      object: s
    });
  }
}
class VideoTexture extends Texture {
  constructor(e, t, i, n, r, s, a, l, c) {
    super(e, t, i, n, r, s, a, l, c), this.format = a !== void 0 ? a : RGBFormat, this.minFilter = s !== void 0 ? s : LinearFilter, this.magFilter = r !== void 0 ? r : LinearFilter, this.generateMipmaps = !1;
    const u = this;
    function h() {
      u.needsUpdate = !0, e.requestVideoFrameCallback(h);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
VideoTexture.prototype.isVideoTexture = !0;
class CompressedTexture extends Texture {
  constructor(e, t, i, n, r, s, a, l, c, u, h, d) {
    super(null, s, a, l, c, u, n, r, h, d), this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
CompressedTexture.prototype.isCompressedTexture = !0;
class CanvasTexture extends Texture {
  constructor(e, t, i, n, r, s, a, l, c) {
    super(e, t, i, n, r, s, a, l, c), this.needsUpdate = !0;
  }
}
CanvasTexture.prototype.isCanvasTexture = !0;
class DepthTexture extends Texture {
  constructor(e, t, i, n, r, s, a, l, c, u) {
    if (u = u !== void 0 ? u : DepthFormat, u !== DepthFormat && u !== DepthStencilFormat)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && u === DepthFormat && (i = UnsignedShortType), i === void 0 && u === DepthStencilFormat && (i = UnsignedInt248Type), super(null, n, r, s, a, l, u, i, c), this.image = { width: e, height: t }, this.magFilter = a !== void 0 ? a : NearestFilter, this.minFilter = l !== void 0 ? l : NearestFilter, this.flipY = !1, this.generateMipmaps = !1;
  }
}
DepthTexture.prototype.isDepthTexture = !0;
class CircleGeometry extends BufferGeometry {
  constructor(e = 1, t = 8, i = 0, n = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: i,
      thetaLength: n
    }, t = Math.max(3, t);
    const r = [], s = [], a = [], l = [], c = new Vector3(), u = new Vector2();
    s.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let h = 0, d = 3; h <= t; h++, d += 3) {
      const f = i + h / t * n;
      c.x = e * Math.cos(f), c.y = e * Math.sin(f), s.push(c.x, c.y, c.z), a.push(0, 0, 1), u.x = (s[d] / e + 1) / 2, u.y = (s[d + 1] / e + 1) / 2, l.push(u.x, u.y);
    }
    for (let h = 1; h <= t; h++)
      r.push(h, h + 1, 0);
    this.setIndex(r), this.setAttribute("position", new Float32BufferAttribute(s, 3)), this.setAttribute("normal", new Float32BufferAttribute(a, 3)), this.setAttribute("uv", new Float32BufferAttribute(l, 2));
  }
  static fromJSON(e) {
    return new CircleGeometry(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class CylinderGeometry extends BufferGeometry {
  constructor(e = 1, t = 1, i = 1, n = 8, r = 1, s = !1, a = 0, l = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: i,
      radialSegments: n,
      heightSegments: r,
      openEnded: s,
      thetaStart: a,
      thetaLength: l
    };
    const c = this;
    n = Math.floor(n), r = Math.floor(r);
    const u = [], h = [], d = [], f = [];
    let p = 0;
    const m = [], v = i / 2;
    let y = 0;
    g(), s === !1 && (e > 0 && _(!0), t > 0 && _(!1)), this.setIndex(u), this.setAttribute("position", new Float32BufferAttribute(h, 3)), this.setAttribute("normal", new Float32BufferAttribute(d, 3)), this.setAttribute("uv", new Float32BufferAttribute(f, 2));
    function g() {
      const b = new Vector3(), S = new Vector3();
      let x = 0;
      const M = (t - e) / i;
      for (let w = 0; w <= r; w++) {
        const D = [], B = w / r, z = B * (t - e) + e;
        for (let F = 0; F <= n; F++) {
          const P = F / n, R = P * l + a, L = Math.sin(R), A = Math.cos(R);
          S.x = z * L, S.y = -B * i + v, S.z = z * A, h.push(S.x, S.y, S.z), b.set(L, M, A).normalize(), d.push(b.x, b.y, b.z), f.push(P, 1 - B), D.push(p++);
        }
        m.push(D);
      }
      for (let w = 0; w < n; w++)
        for (let D = 0; D < r; D++) {
          const B = m[D][w], z = m[D + 1][w], F = m[D + 1][w + 1], P = m[D][w + 1];
          u.push(B, z, P), u.push(z, F, P), x += 6;
        }
      c.addGroup(y, x, 0), y += x;
    }
    function _(b) {
      const S = p, x = new Vector2(), M = new Vector3();
      let w = 0;
      const D = b === !0 ? e : t, B = b === !0 ? 1 : -1;
      for (let F = 1; F <= n; F++)
        h.push(0, v * B, 0), d.push(0, B, 0), f.push(0.5, 0.5), p++;
      const z = p;
      for (let F = 0; F <= n; F++) {
        const R = F / n * l + a, L = Math.cos(R), A = Math.sin(R);
        M.x = D * A, M.y = v * B, M.z = D * L, h.push(M.x, M.y, M.z), d.push(0, B, 0), x.x = L * 0.5 + 0.5, x.y = A * 0.5 * B + 0.5, f.push(x.x, x.y), p++;
      }
      for (let F = 0; F < n; F++) {
        const P = S + F, R = z + F;
        b === !0 ? u.push(R, R + 1, P) : u.push(R + 1, R, P), w += 3;
      }
      c.addGroup(y, w, b === !0 ? 1 : 2), y += w;
    }
  }
  static fromJSON(e) {
    return new CylinderGeometry(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(e = 1, t = 1, i = 8, n = 1, r = !1, s = 0, a = Math.PI * 2) {
    super(0, e, t, i, n, r, s, a), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: i,
      heightSegments: n,
      openEnded: r,
      thetaStart: s,
      thetaLength: a
    };
  }
  static fromJSON(e) {
    return new ConeGeometry(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class PolyhedronGeometry extends BufferGeometry {
  constructor(e, t, i = 1, n = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: i,
      detail: n
    };
    const r = [], s = [];
    a(n), c(i), u(), this.setAttribute("position", new Float32BufferAttribute(r, 3)), this.setAttribute("normal", new Float32BufferAttribute(r.slice(), 3)), this.setAttribute("uv", new Float32BufferAttribute(s, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(g) {
      const _ = new Vector3(), b = new Vector3(), S = new Vector3();
      for (let x = 0; x < t.length; x += 3)
        f(t[x + 0], _), f(t[x + 1], b), f(t[x + 2], S), l(_, b, S, g);
    }
    function l(g, _, b, S) {
      const x = S + 1, M = [];
      for (let w = 0; w <= x; w++) {
        M[w] = [];
        const D = g.clone().lerp(b, w / x), B = _.clone().lerp(b, w / x), z = x - w;
        for (let F = 0; F <= z; F++)
          F === 0 && w === x ? M[w][F] = D : M[w][F] = D.clone().lerp(B, F / z);
      }
      for (let w = 0; w < x; w++)
        for (let D = 0; D < 2 * (x - w) - 1; D++) {
          const B = Math.floor(D / 2);
          D % 2 === 0 ? (d(M[w][B + 1]), d(M[w + 1][B]), d(M[w][B])) : (d(M[w][B + 1]), d(M[w + 1][B + 1]), d(M[w + 1][B]));
        }
    }
    function c(g) {
      const _ = new Vector3();
      for (let b = 0; b < r.length; b += 3)
        _.x = r[b + 0], _.y = r[b + 1], _.z = r[b + 2], _.normalize().multiplyScalar(g), r[b + 0] = _.x, r[b + 1] = _.y, r[b + 2] = _.z;
    }
    function u() {
      const g = new Vector3();
      for (let _ = 0; _ < r.length; _ += 3) {
        g.x = r[_ + 0], g.y = r[_ + 1], g.z = r[_ + 2];
        const b = v(g) / 2 / Math.PI + 0.5, S = y(g) / Math.PI + 0.5;
        s.push(b, 1 - S);
      }
      p(), h();
    }
    function h() {
      for (let g = 0; g < s.length; g += 6) {
        const _ = s[g + 0], b = s[g + 2], S = s[g + 4], x = Math.max(_, b, S), M = Math.min(_, b, S);
        x > 0.9 && M < 0.1 && (_ < 0.2 && (s[g + 0] += 1), b < 0.2 && (s[g + 2] += 1), S < 0.2 && (s[g + 4] += 1));
      }
    }
    function d(g) {
      r.push(g.x, g.y, g.z);
    }
    function f(g, _) {
      const b = g * 3;
      _.x = e[b + 0], _.y = e[b + 1], _.z = e[b + 2];
    }
    function p() {
      const g = new Vector3(), _ = new Vector3(), b = new Vector3(), S = new Vector3(), x = new Vector2(), M = new Vector2(), w = new Vector2();
      for (let D = 0, B = 0; D < r.length; D += 9, B += 6) {
        g.set(r[D + 0], r[D + 1], r[D + 2]), _.set(r[D + 3], r[D + 4], r[D + 5]), b.set(r[D + 6], r[D + 7], r[D + 8]), x.set(s[B + 0], s[B + 1]), M.set(s[B + 2], s[B + 3]), w.set(s[B + 4], s[B + 5]), S.copy(g).add(_).add(b).divideScalar(3);
        const z = v(S);
        m(x, B + 0, g, z), m(M, B + 2, _, z), m(w, B + 4, b, z);
      }
    }
    function m(g, _, b, S) {
      S < 0 && g.x === 1 && (s[_] = g.x - 1), b.x === 0 && b.z === 0 && (s[_] = S / 2 / Math.PI + 0.5);
    }
    function v(g) {
      return Math.atan2(g.z, -g.x);
    }
    function y(g) {
      return Math.atan2(-g.y, Math.sqrt(g.x * g.x + g.z * g.z));
    }
  }
  static fromJSON(e) {
    return new PolyhedronGeometry(e.vertices, e.indices, e.radius, e.details);
  }
}
class DodecahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2, n = 1 / i, r = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -n,
      -i,
      0,
      -n,
      i,
      0,
      n,
      -i,
      0,
      n,
      i,
      // (1/, , 0)
      -n,
      -i,
      0,
      -n,
      i,
      0,
      n,
      -i,
      0,
      n,
      i,
      0,
      // (, 0, 1/)
      -i,
      0,
      -n,
      i,
      0,
      -n,
      -i,
      0,
      n,
      i,
      0,
      n
    ], s = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(r, s, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new DodecahedronGeometry(e.radius, e.detail);
  }
}
const _v0 = new Vector3(), _v1$1 = new Vector3(), _normal = new Vector3(), _triangle = new Triangle();
class EdgesGeometry extends BufferGeometry {
  constructor(e, t) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      thresholdAngle: t
    }, t = t !== void 0 ? t : 1, e.isGeometry === !0) {
      console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return;
    }
    const n = Math.pow(10, 4), r = Math.cos(DEG2RAD * t), s = e.getIndex(), a = e.getAttribute("position"), l = s ? s.count : a.count, c = [0, 0, 0], u = ["a", "b", "c"], h = new Array(3), d = {}, f = [];
    for (let p = 0; p < l; p += 3) {
      s ? (c[0] = s.getX(p), c[1] = s.getX(p + 1), c[2] = s.getX(p + 2)) : (c[0] = p, c[1] = p + 1, c[2] = p + 2);
      const { a: m, b: v, c: y } = _triangle;
      if (m.fromBufferAttribute(a, c[0]), v.fromBufferAttribute(a, c[1]), y.fromBufferAttribute(a, c[2]), _triangle.getNormal(_normal), h[0] = `${Math.round(m.x * n)},${Math.round(m.y * n)},${Math.round(m.z * n)}`, h[1] = `${Math.round(v.x * n)},${Math.round(v.y * n)},${Math.round(v.z * n)}`, h[2] = `${Math.round(y.x * n)},${Math.round(y.y * n)},${Math.round(y.z * n)}`, !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
        for (let g = 0; g < 3; g++) {
          const _ = (g + 1) % 3, b = h[g], S = h[_], x = _triangle[u[g]], M = _triangle[u[_]], w = `${b}_${S}`, D = `${S}_${b}`;
          D in d && d[D] ? (_normal.dot(d[D].normal) <= r && (f.push(x.x, x.y, x.z), f.push(M.x, M.y, M.z)), d[D] = null) : w in d || (d[w] = {
            index0: c[g],
            index1: c[_],
            normal: _normal.clone()
          });
        }
    }
    for (const p in d)
      if (d[p]) {
        const { index0: m, index1: v } = d[p];
        _v0.fromBufferAttribute(a, m), _v1$1.fromBufferAttribute(a, v), f.push(_v0.x, _v0.y, _v0.z), f.push(_v1$1.x, _v1$1.y, _v1$1.z);
      }
    this.setAttribute("position", new Float32BufferAttribute(f, 3));
  }
}
class Curve {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPointAt(i / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i, n = this.getPoint(0), r = 0;
    t.push(0);
    for (let s = 1; s <= e; s++)
      i = this.getPoint(s / e), r += i.distanceTo(n), t.push(r), n = i;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let n = 0;
    const r = i.length;
    let s;
    t ? s = t : s = e * i[r - 1];
    let a = 0, l = r - 1, c;
    for (; a <= l; )
      if (n = Math.floor(a + (l - a) / 2), c = i[n] - s, c < 0)
        a = n + 1;
      else if (c > 0)
        l = n - 1;
      else {
        l = n;
        break;
      }
    if (n = l, i[n] === s)
      return n / (r - 1);
    const u = i[n], d = i[n + 1] - u, f = (s - u) / d;
    return (n + f) / (r - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let n = e - 1e-4, r = e + 1e-4;
    n < 0 && (n = 0), r > 1 && (r = 1);
    const s = this.getPoint(n), a = this.getPoint(r), l = t || (s.isVector2 ? new Vector2() : new Vector3());
    return l.copy(a).sub(s).normalize(), l;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new Vector3(), n = [], r = [], s = [], a = new Vector3(), l = new Matrix4();
    for (let f = 0; f <= e; f++) {
      const p = f / e;
      n[f] = this.getTangentAt(p, new Vector3()), n[f].normalize();
    }
    r[0] = new Vector3(), s[0] = new Vector3();
    let c = Number.MAX_VALUE;
    const u = Math.abs(n[0].x), h = Math.abs(n[0].y), d = Math.abs(n[0].z);
    u <= c && (c = u, i.set(1, 0, 0)), h <= c && (c = h, i.set(0, 1, 0)), d <= c && i.set(0, 0, 1), a.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], a), s[0].crossVectors(n[0], r[0]);
    for (let f = 1; f <= e; f++) {
      if (r[f] = r[f - 1].clone(), s[f] = s[f - 1].clone(), a.crossVectors(n[f - 1], n[f]), a.length() > Number.EPSILON) {
        a.normalize();
        const p = Math.acos(clamp(n[f - 1].dot(n[f]), -1, 1));
        r[f].applyMatrix4(l.makeRotationAxis(a, p));
      }
      s[f].crossVectors(n[f], r[f]);
    }
    if (t === !0) {
      let f = Math.acos(clamp(r[0].dot(r[e]), -1, 1));
      f /= e, n[0].dot(a.crossVectors(r[0], r[e])) > 0 && (f = -f);
      for (let p = 1; p <= e; p++)
        r[p].applyMatrix4(l.makeRotationAxis(n[p], f * p)), s[p].crossVectors(n[p], r[p]);
    }
    return {
      tangents: n,
      normals: r,
      binormals: s
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class EllipseCurve extends Curve {
  constructor(e = 0, t = 0, i = 1, n = 1, r = 0, s = Math.PI * 2, a = !1, l = 0) {
    super(), this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = a, this.aRotation = l;
  }
  getPoint(e, t) {
    const i = t || new Vector2(), n = Math.PI * 2;
    let r = this.aEndAngle - this.aStartAngle;
    const s = Math.abs(r) < Number.EPSILON;
    for (; r < 0; ) r += n;
    for (; r > n; ) r -= n;
    r < Number.EPSILON && (s ? r = 0 : r = n), this.aClockwise === !0 && !s && (r === n ? r = -n : r = r - n);
    const a = this.aStartAngle + e * r;
    let l = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation), h = Math.sin(this.aRotation), d = l - this.aX, f = c - this.aY;
      l = d * u - f * h + this.aX, c = d * h + f * u + this.aY;
    }
    return i.set(l, c);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
EllipseCurve.prototype.isEllipseCurve = !0;
class ArcCurve extends EllipseCurve {
  constructor(e, t, i, n, r, s) {
    super(e, t, i, i, n, r, s), this.type = "ArcCurve";
  }
}
ArcCurve.prototype.isArcCurve = !0;
function CubicPoly() {
  let o = 0, e = 0, t = 0, i = 0;
  function n(r, s, a, l) {
    o = r, e = a, t = -3 * r + 3 * s - 2 * a - l, i = 2 * r - 2 * s + a + l;
  }
  return {
    initCatmullRom: function(r, s, a, l, c) {
      n(s, a, c * (a - r), c * (l - s));
    },
    initNonuniformCatmullRom: function(r, s, a, l, c, u, h) {
      let d = (s - r) / c - (a - r) / (c + u) + (a - s) / u, f = (a - s) / u - (l - s) / (u + h) + (l - a) / h;
      d *= u, f *= u, n(s, a, d, f);
    },
    calc: function(r) {
      const s = r * r, a = s * r;
      return o + e * r + t * s + i * a;
    }
  };
}
const tmp = new Vector3(), px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
class CatmullRomCurve3 extends Curve {
  constructor(e = [], t = !1, i = "centripetal", n = 0.5) {
    super(), this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = n;
  }
  getPoint(e, t = new Vector3()) {
    const i = t, n = this.points, r = n.length, s = (r - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(s), l = s - a;
    this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r : l === 0 && a === r - 1 && (a = r - 2, l = 1);
    let c, u;
    this.closed || a > 0 ? c = n[(a - 1) % r] : (tmp.subVectors(n[0], n[1]).add(n[0]), c = tmp);
    const h = n[a % r], d = n[(a + 1) % r];
    if (this.closed || a + 2 < r ? u = n[(a + 2) % r] : (tmp.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), u = tmp), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let p = Math.pow(c.distanceToSquared(h), f), m = Math.pow(h.distanceToSquared(d), f), v = Math.pow(d.distanceToSquared(u), f);
      m < 1e-4 && (m = 1), p < 1e-4 && (p = m), v < 1e-4 && (v = m), px.initNonuniformCatmullRom(c.x, h.x, d.x, u.x, p, m, v), py.initNonuniformCatmullRom(c.y, h.y, d.y, u.y, p, m, v), pz.initNonuniformCatmullRom(c.z, h.z, d.z, u.z, p, m, v);
    } else this.curveType === "catmullrom" && (px.initCatmullRom(c.x, h.x, d.x, u.x, this.tension), py.initCatmullRom(c.y, h.y, d.y, u.y, this.tension), pz.initCatmullRom(c.z, h.z, d.z, u.z, this.tension));
    return i.set(
      px.calc(l),
      py.calc(l),
      pz.calc(l)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(new Vector3().fromArray(n));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
CatmullRomCurve3.prototype.isCatmullRomCurve3 = !0;
function CatmullRom(o, e, t, i, n) {
  const r = (i - e) * 0.5, s = (n - t) * 0.5, a = o * o, l = o * a;
  return (2 * t - 2 * i + r + s) * l + (-3 * t + 3 * i - 2 * r - s) * a + r * o + t;
}
function QuadraticBezierP0(o, e) {
  const t = 1 - o;
  return t * t * e;
}
function QuadraticBezierP1(o, e) {
  return 2 * (1 - o) * o * e;
}
function QuadraticBezierP2(o, e) {
  return o * o * e;
}
function QuadraticBezier(o, e, t, i) {
  return QuadraticBezierP0(o, e) + QuadraticBezierP1(o, t) + QuadraticBezierP2(o, i);
}
function CubicBezierP0(o, e) {
  const t = 1 - o;
  return t * t * t * e;
}
function CubicBezierP1(o, e) {
  const t = 1 - o;
  return 3 * t * t * o * e;
}
function CubicBezierP2(o, e) {
  return 3 * (1 - o) * o * o * e;
}
function CubicBezierP3(o, e) {
  return o * o * o * e;
}
function CubicBezier(o, e, t, i, n) {
  return CubicBezierP0(o, e) + CubicBezierP1(o, t) + CubicBezierP2(o, i) + CubicBezierP3(o, n);
}
class CubicBezierCurve extends Curve {
  constructor(e = new Vector2(), t = new Vector2(), i = new Vector2(), n = new Vector2()) {
    super(), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n;
  }
  getPoint(e, t = new Vector2()) {
    const i = t, n = this.v0, r = this.v1, s = this.v2, a = this.v3;
    return i.set(
      CubicBezier(e, n.x, r.x, s.x, a.x),
      CubicBezier(e, n.y, r.y, s.y, a.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
CubicBezierCurve.prototype.isCubicBezierCurve = !0;
class CubicBezierCurve3 extends Curve {
  constructor(e = new Vector3(), t = new Vector3(), i = new Vector3(), n = new Vector3()) {
    super(), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n;
  }
  getPoint(e, t = new Vector3()) {
    const i = t, n = this.v0, r = this.v1, s = this.v2, a = this.v3;
    return i.set(
      CubicBezier(e, n.x, r.x, s.x, a.x),
      CubicBezier(e, n.y, r.y, s.y, a.y),
      CubicBezier(e, n.z, r.z, s.z, a.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
CubicBezierCurve3.prototype.isCubicBezierCurve3 = !0;
class LineCurve extends Curve {
  constructor(e = new Vector2(), t = new Vector2()) {
    super(), this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Vector2()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t) {
    const i = t || new Vector2();
    return i.copy(this.v2).sub(this.v1).normalize(), i;
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
LineCurve.prototype.isLineCurve = !0;
class LineCurve3 extends Curve {
  constructor(e = new Vector3(), t = new Vector3()) {
    super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Vector3()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class QuadraticBezierCurve extends Curve {
  constructor(e = new Vector2(), t = new Vector2(), i = new Vector2()) {
    super(), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new Vector2()) {
    const i = t, n = this.v0, r = this.v1, s = this.v2;
    return i.set(
      QuadraticBezier(e, n.x, r.x, s.x),
      QuadraticBezier(e, n.y, r.y, s.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = !0;
class QuadraticBezierCurve3 extends Curve {
  constructor(e = new Vector3(), t = new Vector3(), i = new Vector3()) {
    super(), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new Vector3()) {
    const i = t, n = this.v0, r = this.v1, s = this.v2;
    return i.set(
      QuadraticBezier(e, n.x, r.x, s.x),
      QuadraticBezier(e, n.y, r.y, s.y),
      QuadraticBezier(e, n.z, r.z, s.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = !0;
class SplineCurve extends Curve {
  constructor(e = []) {
    super(), this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new Vector2()) {
    const i = t, n = this.points, r = (n.length - 1) * e, s = Math.floor(r), a = r - s, l = n[s === 0 ? s : s - 1], c = n[s], u = n[s > n.length - 2 ? n.length - 1 : s + 1], h = n[s > n.length - 3 ? n.length - 1 : s + 2];
    return i.set(
      CatmullRom(a, l.x, c.x, u.x, h.x),
      CatmullRom(a, l.y, c.y, u.y, h.y)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const n = this.points[t];
      e.points.push(n.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const n = e.points[t];
      this.points.push(new Vector2().fromArray(n));
    }
    return this;
  }
}
SplineCurve.prototype.isSplineCurve = !0;
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
const Earcut = {
  triangulate: function(o, e, t = 2) {
    const i = e && e.length, n = i ? e[0] * t : o.length;
    let r = linkedList(o, 0, n, t, !0);
    const s = [];
    if (!r || r.next === r.prev) return s;
    let a, l, c, u, h, d, f;
    if (i && (r = eliminateHoles(o, e, r, t)), o.length > 80 * t) {
      a = c = o[0], l = u = o[1];
      for (let p = t; p < n; p += t)
        h = o[p], d = o[p + 1], h < a && (a = h), d < l && (l = d), h > c && (c = h), d > u && (u = d);
      f = Math.max(c - a, u - l), f = f !== 0 ? 1 / f : 0;
    }
    return earcutLinked(r, s, t, a, l, f), s;
  }
};
function linkedList(o, e, t, i, n) {
  let r, s;
  if (n === signedArea(o, e, t, i) > 0)
    for (r = e; r < t; r += i) s = insertNode(r, o[r], o[r + 1], s);
  else
    for (r = t - i; r >= e; r -= i) s = insertNode(r, o[r], o[r + 1], s);
  return s && equals(s, s.next) && (removeNode(s), s = s.next), s;
}
function filterPoints(o, e) {
  if (!o) return o;
  e || (e = o);
  let t = o, i;
  do
    if (i = !1, !t.steiner && (equals(t, t.next) || area(t.prev, t, t.next) === 0)) {
      if (removeNode(t), t = e = t.prev, t === t.next) break;
      i = !0;
    } else
      t = t.next;
  while (i || t !== e);
  return e;
}
function earcutLinked(o, e, t, i, n, r, s) {
  if (!o) return;
  !s && r && indexCurve(o, i, n, r);
  let a = o, l, c;
  for (; o.prev !== o.next; ) {
    if (l = o.prev, c = o.next, r ? isEarHashed(o, i, n, r) : isEar(o)) {
      e.push(l.i / t), e.push(o.i / t), e.push(c.i / t), removeNode(o), o = c.next, a = c.next;
      continue;
    }
    if (o = c, o === a) {
      s ? s === 1 ? (o = cureLocalIntersections(filterPoints(o), e, t), earcutLinked(o, e, t, i, n, r, 2)) : s === 2 && splitEarcut(o, e, t, i, n, r) : earcutLinked(filterPoints(o), e, t, i, n, r, 1);
      break;
    }
  }
}
function isEar(o) {
  const e = o.prev, t = o, i = o.next;
  if (area(e, t, i) >= 0) return !1;
  let n = o.next.next;
  for (; n !== o.prev; ) {
    if (pointInTriangle(e.x, e.y, t.x, t.y, i.x, i.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return !1;
    n = n.next;
  }
  return !0;
}
function isEarHashed(o, e, t, i) {
  const n = o.prev, r = o, s = o.next;
  if (area(n, r, s) >= 0) return !1;
  const a = n.x < r.x ? n.x < s.x ? n.x : s.x : r.x < s.x ? r.x : s.x, l = n.y < r.y ? n.y < s.y ? n.y : s.y : r.y < s.y ? r.y : s.y, c = n.x > r.x ? n.x > s.x ? n.x : s.x : r.x > s.x ? r.x : s.x, u = n.y > r.y ? n.y > s.y ? n.y : s.y : r.y > s.y ? r.y : s.y, h = zOrder(a, l, e, t, i), d = zOrder(c, u, e, t, i);
  let f = o.prevZ, p = o.nextZ;
  for (; f && f.z >= h && p && p.z <= d; ) {
    if (f !== o.prev && f !== o.next && pointInTriangle(n.x, n.y, r.x, r.y, s.x, s.y, f.x, f.y) && area(f.prev, f, f.next) >= 0 || (f = f.prevZ, p !== o.prev && p !== o.next && pointInTriangle(n.x, n.y, r.x, r.y, s.x, s.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)) return !1;
    p = p.nextZ;
  }
  for (; f && f.z >= h; ) {
    if (f !== o.prev && f !== o.next && pointInTriangle(n.x, n.y, r.x, r.y, s.x, s.y, f.x, f.y) && area(f.prev, f, f.next) >= 0) return !1;
    f = f.prevZ;
  }
  for (; p && p.z <= d; ) {
    if (p !== o.prev && p !== o.next && pointInTriangle(n.x, n.y, r.x, r.y, s.x, s.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
    p = p.nextZ;
  }
  return !0;
}
function cureLocalIntersections(o, e, t) {
  let i = o;
  do {
    const n = i.prev, r = i.next.next;
    !equals(n, r) && intersects(n, i, i.next, r) && locallyInside(n, r) && locallyInside(r, n) && (e.push(n.i / t), e.push(i.i / t), e.push(r.i / t), removeNode(i), removeNode(i.next), i = o = r), i = i.next;
  } while (i !== o);
  return filterPoints(i);
}
function splitEarcut(o, e, t, i, n, r) {
  let s = o;
  do {
    let a = s.next.next;
    for (; a !== s.prev; ) {
      if (s.i !== a.i && isValidDiagonal(s, a)) {
        let l = splitPolygon(s, a);
        s = filterPoints(s, s.next), l = filterPoints(l, l.next), earcutLinked(s, e, t, i, n, r), earcutLinked(l, e, t, i, n, r);
        return;
      }
      a = a.next;
    }
    s = s.next;
  } while (s !== o);
}
function eliminateHoles(o, e, t, i) {
  const n = [];
  let r, s, a, l, c;
  for (r = 0, s = e.length; r < s; r++)
    a = e[r] * i, l = r < s - 1 ? e[r + 1] * i : o.length, c = linkedList(o, a, l, i, !1), c === c.next && (c.steiner = !0), n.push(getLeftmost(c));
  for (n.sort(compareX), r = 0; r < n.length; r++)
    eliminateHole(n[r], t), t = filterPoints(t, t.next);
  return t;
}
function compareX(o, e) {
  return o.x - e.x;
}
function eliminateHole(o, e) {
  if (e = findHoleBridge(o, e), e) {
    const t = splitPolygon(e, o);
    filterPoints(e, e.next), filterPoints(t, t.next);
  }
}
function findHoleBridge(o, e) {
  let t = e;
  const i = o.x, n = o.y;
  let r = -1 / 0, s;
  do {
    if (n <= t.y && n >= t.next.y && t.next.y !== t.y) {
      const d = t.x + (n - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (d <= i && d > r) {
        if (r = d, d === i) {
          if (n === t.y) return t;
          if (n === t.next.y) return t.next;
        }
        s = t.x < t.next.x ? t : t.next;
      }
    }
    t = t.next;
  } while (t !== e);
  if (!s) return null;
  if (i === r) return s;
  const a = s, l = s.x, c = s.y;
  let u = 1 / 0, h;
  t = s;
  do
    i >= t.x && t.x >= l && i !== t.x && pointInTriangle(n < c ? i : r, n, l, c, n < c ? r : i, n, t.x, t.y) && (h = Math.abs(n - t.y) / (i - t.x), locallyInside(t, o) && (h < u || h === u && (t.x > s.x || t.x === s.x && sectorContainsSector(s, t))) && (s = t, u = h)), t = t.next;
  while (t !== a);
  return s;
}
function sectorContainsSector(o, e) {
  return area(o.prev, o, e.prev) < 0 && area(e.next, o, o.next) < 0;
}
function indexCurve(o, e, t, i) {
  let n = o;
  do
    n.z === null && (n.z = zOrder(n.x, n.y, e, t, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== o);
  n.prevZ.nextZ = null, n.prevZ = null, sortLinked(n);
}
function sortLinked(o) {
  let e, t, i, n, r, s, a, l, c = 1;
  do {
    for (t = o, o = null, r = null, s = 0; t; ) {
      for (s++, i = t, a = 0, e = 0; e < c && (a++, i = i.nextZ, !!i); e++)
        ;
      for (l = c; a > 0 || l > 0 && i; )
        a !== 0 && (l === 0 || !i || t.z <= i.z) ? (n = t, t = t.nextZ, a--) : (n = i, i = i.nextZ, l--), r ? r.nextZ = n : o = n, n.prevZ = r, r = n;
      t = i;
    }
    r.nextZ = null, c *= 2;
  } while (s > 1);
  return o;
}
function zOrder(o, e, t, i, n) {
  return o = 32767 * (o - t) * n, e = 32767 * (e - i) * n, o = (o | o << 8) & 16711935, o = (o | o << 4) & 252645135, o = (o | o << 2) & 858993459, o = (o | o << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, o | e << 1;
}
function getLeftmost(o) {
  let e = o, t = o;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== o);
  return t;
}
function pointInTriangle(o, e, t, i, n, r, s, a) {
  return (n - s) * (e - a) - (o - s) * (r - a) >= 0 && (o - s) * (i - a) - (t - s) * (e - a) >= 0 && (t - s) * (r - a) - (n - s) * (i - a) >= 0;
}
function isValidDiagonal(o, e) {
  return o.next.i !== e.i && o.prev.i !== e.i && !intersectsPolygon(o, e) && // dones't intersect other edges
  (locallyInside(o, e) && locallyInside(e, o) && middleInside(o, e) && // locally visible
  (area(o.prev, o, e.prev) || area(o, e.prev, e)) || // does not create opposite-facing sectors
  equals(o, e) && area(o.prev, o, o.next) > 0 && area(e.prev, e, e.next) > 0);
}
function area(o, e, t) {
  return (e.y - o.y) * (t.x - e.x) - (e.x - o.x) * (t.y - e.y);
}
function equals(o, e) {
  return o.x === e.x && o.y === e.y;
}
function intersects(o, e, t, i) {
  const n = sign(area(o, e, t)), r = sign(area(o, e, i)), s = sign(area(t, i, o)), a = sign(area(t, i, e));
  return !!(n !== r && s !== a || n === 0 && onSegment(o, t, e) || r === 0 && onSegment(o, i, e) || s === 0 && onSegment(t, o, i) || a === 0 && onSegment(t, e, i));
}
function onSegment(o, e, t) {
  return e.x <= Math.max(o.x, t.x) && e.x >= Math.min(o.x, t.x) && e.y <= Math.max(o.y, t.y) && e.y >= Math.min(o.y, t.y);
}
function sign(o) {
  return o > 0 ? 1 : o < 0 ? -1 : 0;
}
function intersectsPolygon(o, e) {
  let t = o;
  do {
    if (t.i !== o.i && t.next.i !== o.i && t.i !== e.i && t.next.i !== e.i && intersects(t, t.next, o, e)) return !0;
    t = t.next;
  } while (t !== o);
  return !1;
}
function locallyInside(o, e) {
  return area(o.prev, o, o.next) < 0 ? area(o, e, o.next) >= 0 && area(o, o.prev, e) >= 0 : area(o, e, o.prev) < 0 || area(o, o.next, e) < 0;
}
function middleInside(o, e) {
  let t = o, i = !1;
  const n = (o.x + e.x) / 2, r = (o.y + e.y) / 2;
  do
    t.y > r != t.next.y > r && t.next.y !== t.y && n < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
  while (t !== o);
  return i;
}
function splitPolygon(o, e) {
  const t = new Node(o.i, o.x, o.y), i = new Node(e.i, e.x, e.y), n = o.next, r = e.prev;
  return o.next = e, e.prev = o, t.next = n, n.prev = t, i.next = t, t.prev = i, r.next = i, i.prev = r, i;
}
function insertNode(o, e, t, i) {
  const n = new Node(o, e, t);
  return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n;
}
function removeNode(o) {
  o.next.prev = o.prev, o.prev.next = o.next, o.prevZ && (o.prevZ.nextZ = o.nextZ), o.nextZ && (o.nextZ.prevZ = o.prevZ);
}
function Node(o, e, t) {
  this.i = o, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function signedArea(o, e, t, i) {
  let n = 0;
  for (let r = e, s = t - i; r < t; r += i)
    n += (o[s] - o[r]) * (o[r + 1] + o[s + 1]), s = r;
  return n;
}
class ShapeUtils {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let n = t - 1, r = 0; r < t; n = r++)
      i += e[n].x * e[r].y - e[r].x * e[n].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return ShapeUtils.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [], n = [], r = [];
    removeDupEndPts(e), addContour(i, e);
    let s = e.length;
    t.forEach(removeDupEndPts);
    for (let l = 0; l < t.length; l++)
      n.push(s), s += t[l].length, addContour(i, t[l]);
    const a = Earcut.triangulate(i, n);
    for (let l = 0; l < a.length; l += 3)
      r.push(a.slice(l, l + 3));
    return r;
  }
}
function removeDupEndPts(o) {
  const e = o.length;
  e > 2 && o[e - 1].equals(o[0]) && o.pop();
}
function addContour(o, e) {
  for (let t = 0; t < e.length; t++)
    o.push(e[t].x), o.push(e[t].y);
}
class ExtrudeGeometry extends BufferGeometry {
  constructor(e, t) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const i = this, n = [], r = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a];
      s(c);
    }
    this.setAttribute("position", new Float32BufferAttribute(n, 3)), this.setAttribute("uv", new Float32BufferAttribute(r, 2)), this.computeVertexNormals();
    function s(a) {
      const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, u = t.steps !== void 0 ? t.steps : 1;
      let h = t.depth !== void 0 ? t.depth : 100, d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, f = t.bevelThickness !== void 0 ? t.bevelThickness : 6, p = t.bevelSize !== void 0 ? t.bevelSize : f - 2, m = t.bevelOffset !== void 0 ? t.bevelOffset : 0, v = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const y = t.extrudePath, g = t.UVGenerator !== void 0 ? t.UVGenerator : WorldUVGenerator;
      t.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), h = t.amount);
      let _, b = !1, S, x, M, w;
      y && (_ = y.getSpacedPoints(u), b = !0, d = !1, S = y.computeFrenetFrames(u, !1), x = new Vector3(), M = new Vector3(), w = new Vector3()), d || (v = 0, f = 0, p = 0, m = 0);
      const D = a.extractPoints(c);
      let B = D.shape;
      const z = D.holes;
      if (!ShapeUtils.isClockWise(B)) {
        B = B.reverse();
        for (let G = 0, re = z.length; G < re; G++) {
          const se = z[G];
          ShapeUtils.isClockWise(se) && (z[G] = se.reverse());
        }
      }
      const P = ShapeUtils.triangulateShape(B, z), R = B;
      for (let G = 0, re = z.length; G < re; G++) {
        const se = z[G];
        B = B.concat(se);
      }
      function L(G, re, se) {
        return re || console.error("THREE.ExtrudeGeometry: vec does not exist"), re.clone().multiplyScalar(se).add(G);
      }
      const A = B.length, k = P.length;
      function Q(G, re, se) {
        let ae, oe, E;
        const T = G.x - re.x, $ = G.y - re.y, Z = se.x - G.x, j = se.y - G.y, de = T * T + $ * $, ue = T * j - $ * Z;
        if (Math.abs(ue) > Number.EPSILON) {
          const pe = Math.sqrt(de), fe = Math.sqrt(Z * Z + j * j), ve = re.x - $ / pe, N = re.y + T / pe, ee = se.x - j / fe, J = se.y + Z / fe, ye = ((ee - ve) * j - (J - N) * Z) / (T * j - $ * Z);
          ae = ve + T * ye - G.x, oe = N + $ * ye - G.y;
          const me = ae * ae + oe * oe;
          if (me <= 2)
            return new Vector2(ae, oe);
          E = Math.sqrt(me / 2);
        } else {
          let pe = !1;
          T > Number.EPSILON ? Z > Number.EPSILON && (pe = !0) : T < -Number.EPSILON ? Z < -Number.EPSILON && (pe = !0) : Math.sign($) === Math.sign(j) && (pe = !0), pe ? (ae = -$, oe = T, E = Math.sqrt(de)) : (ae = T, oe = $, E = Math.sqrt(de / 2));
        }
        return new Vector2(ae / E, oe / E);
      }
      const U = [];
      for (let G = 0, re = R.length, se = re - 1, ae = G + 1; G < re; G++, se++, ae++)
        se === re && (se = 0), ae === re && (ae = 0), U[G] = Q(R[G], R[se], R[ae]);
      const H = [];
      let I, V = U.concat();
      for (let G = 0, re = z.length; G < re; G++) {
        const se = z[G];
        I = [];
        for (let ae = 0, oe = se.length, E = oe - 1, T = ae + 1; ae < oe; ae++, E++, T++)
          E === oe && (E = 0), T === oe && (T = 0), I[ae] = Q(se[ae], se[E], se[T]);
        H.push(I), V = V.concat(I);
      }
      for (let G = 0; G < v; G++) {
        const re = G / v, se = f * Math.cos(re * Math.PI / 2), ae = p * Math.sin(re * Math.PI / 2) + m;
        for (let oe = 0, E = R.length; oe < E; oe++) {
          const T = L(R[oe], U[oe], ae);
          te(T.x, T.y, -se);
        }
        for (let oe = 0, E = z.length; oe < E; oe++) {
          const T = z[oe];
          I = H[oe];
          for (let $ = 0, Z = T.length; $ < Z; $++) {
            const j = L(T[$], I[$], ae);
            te(j.x, j.y, -se);
          }
        }
      }
      const W = p + m;
      for (let G = 0; G < A; G++) {
        const re = d ? L(B[G], V[G], W) : B[G];
        b ? (M.copy(S.normals[0]).multiplyScalar(re.x), x.copy(S.binormals[0]).multiplyScalar(re.y), w.copy(_[0]).add(M).add(x), te(w.x, w.y, w.z)) : te(re.x, re.y, 0);
      }
      for (let G = 1; G <= u; G++)
        for (let re = 0; re < A; re++) {
          const se = d ? L(B[re], V[re], W) : B[re];
          b ? (M.copy(S.normals[G]).multiplyScalar(se.x), x.copy(S.binormals[G]).multiplyScalar(se.y), w.copy(_[G]).add(M).add(x), te(w.x, w.y, w.z)) : te(se.x, se.y, h / u * G);
        }
      for (let G = v - 1; G >= 0; G--) {
        const re = G / v, se = f * Math.cos(re * Math.PI / 2), ae = p * Math.sin(re * Math.PI / 2) + m;
        for (let oe = 0, E = R.length; oe < E; oe++) {
          const T = L(R[oe], U[oe], ae);
          te(T.x, T.y, h + se);
        }
        for (let oe = 0, E = z.length; oe < E; oe++) {
          const T = z[oe];
          I = H[oe];
          for (let $ = 0, Z = T.length; $ < Z; $++) {
            const j = L(T[$], I[$], ae);
            b ? te(j.x, j.y + _[u - 1].y, _[u - 1].x + se) : te(j.x, j.y, h + se);
          }
        }
      }
      X(), q();
      function X() {
        const G = n.length / 3;
        if (d) {
          let re = 0, se = A * re;
          for (let ae = 0; ae < k; ae++) {
            const oe = P[ae];
            ne(oe[2] + se, oe[1] + se, oe[0] + se);
          }
          re = u + v * 2, se = A * re;
          for (let ae = 0; ae < k; ae++) {
            const oe = P[ae];
            ne(oe[0] + se, oe[1] + se, oe[2] + se);
          }
        } else {
          for (let re = 0; re < k; re++) {
            const se = P[re];
            ne(se[2], se[1], se[0]);
          }
          for (let re = 0; re < k; re++) {
            const se = P[re];
            ne(se[0] + A * u, se[1] + A * u, se[2] + A * u);
          }
        }
        i.addGroup(G, n.length / 3 - G, 0);
      }
      function q() {
        const G = n.length / 3;
        let re = 0;
        O(R, re), re += R.length;
        for (let se = 0, ae = z.length; se < ae; se++) {
          const oe = z[se];
          O(oe, re), re += oe.length;
        }
        i.addGroup(G, n.length / 3 - G, 1);
      }
      function O(G, re) {
        let se = G.length;
        for (; --se >= 0; ) {
          const ae = se;
          let oe = se - 1;
          oe < 0 && (oe = G.length - 1);
          for (let E = 0, T = u + v * 2; E < T; E++) {
            const $ = A * E, Z = A * (E + 1), j = re + ae + $, de = re + oe + $, ue = re + oe + Z, pe = re + ae + Z;
            ce(j, de, ue, pe);
          }
        }
      }
      function te(G, re, se) {
        l.push(G), l.push(re), l.push(se);
      }
      function ne(G, re, se) {
        he(G), he(re), he(se);
        const ae = n.length / 3, oe = g.generateTopUV(i, n, ae - 3, ae - 2, ae - 1);
        le(oe[0]), le(oe[1]), le(oe[2]);
      }
      function ce(G, re, se, ae) {
        he(G), he(re), he(ae), he(re), he(se), he(ae);
        const oe = n.length / 3, E = g.generateSideWallUV(i, n, oe - 6, oe - 3, oe - 2, oe - 1);
        le(E[0]), le(E[1]), le(E[3]), le(E[1]), le(E[2]), le(E[3]);
      }
      function he(G) {
        n.push(l[G * 3 + 0]), n.push(l[G * 3 + 1]), n.push(l[G * 3 + 2]);
      }
      function le(G) {
        r.push(G.x), r.push(G.y);
      }
    }
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, i = this.parameters.options;
    return toJSON$1(t, i, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const a = t[e.shapes[r]];
      i.push(a);
    }
    const n = e.options.extrudePath;
    return n !== void 0 && (e.options.extrudePath = new Curves[n.type]().fromJSON(n)), new ExtrudeGeometry(i, e.options);
  }
}
const WorldUVGenerator = {
  generateTopUV: function(o, e, t, i, n) {
    const r = e[t * 3], s = e[t * 3 + 1], a = e[i * 3], l = e[i * 3 + 1], c = e[n * 3], u = e[n * 3 + 1];
    return [
      new Vector2(r, s),
      new Vector2(a, l),
      new Vector2(c, u)
    ];
  },
  generateSideWallUV: function(o, e, t, i, n, r) {
    const s = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], c = e[i * 3], u = e[i * 3 + 1], h = e[i * 3 + 2], d = e[n * 3], f = e[n * 3 + 1], p = e[n * 3 + 2], m = e[r * 3], v = e[r * 3 + 1], y = e[r * 3 + 2];
    return Math.abs(a - u) < Math.abs(s - c) ? [
      new Vector2(s, 1 - l),
      new Vector2(c, 1 - h),
      new Vector2(d, 1 - p),
      new Vector2(m, 1 - y)
    ] : [
      new Vector2(a, 1 - l),
      new Vector2(u, 1 - h),
      new Vector2(f, 1 - p),
      new Vector2(v, 1 - y)
    ];
  }
};
function toJSON$1(o, e, t) {
  if (t.shapes = [], Array.isArray(o))
    for (let i = 0, n = o.length; i < n; i++) {
      const r = o[i];
      t.shapes.push(r.uuid);
    }
  else
    t.shapes.push(o.uuid);
  return e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2, n = [
      -1,
      i,
      0,
      1,
      i,
      0,
      -1,
      -i,
      0,
      1,
      -i,
      0,
      0,
      -1,
      i,
      0,
      1,
      i,
      0,
      -1,
      -i,
      0,
      1,
      -i,
      i,
      0,
      -1,
      i,
      0,
      1,
      -i,
      0,
      -1,
      -i,
      0,
      1
    ], r = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(n, r, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new IcosahedronGeometry(e.radius, e.detail);
  }
}
class LatheGeometry extends BufferGeometry {
  constructor(e, t = 12, i = 0, n = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: i,
      phiLength: n
    }, t = Math.floor(t), n = clamp(n, 0, Math.PI * 2);
    const r = [], s = [], a = [], l = 1 / t, c = new Vector3(), u = new Vector2();
    for (let h = 0; h <= t; h++) {
      const d = i + h * l * n, f = Math.sin(d), p = Math.cos(d);
      for (let m = 0; m <= e.length - 1; m++)
        c.x = e[m].x * f, c.y = e[m].y, c.z = e[m].x * p, s.push(c.x, c.y, c.z), u.x = h / t, u.y = m / (e.length - 1), a.push(u.x, u.y);
    }
    for (let h = 0; h < t; h++)
      for (let d = 0; d < e.length - 1; d++) {
        const f = d + h * e.length, p = f, m = f + e.length, v = f + e.length + 1, y = f + 1;
        r.push(p, m, y), r.push(m, v, y);
      }
    if (this.setIndex(r), this.setAttribute("position", new Float32BufferAttribute(s, 3)), this.setAttribute("uv", new Float32BufferAttribute(a, 2)), this.computeVertexNormals(), n === Math.PI * 2) {
      const h = this.attributes.normal.array, d = new Vector3(), f = new Vector3(), p = new Vector3(), m = t * e.length * 3;
      for (let v = 0, y = 0; v < e.length; v++, y += 3)
        d.x = h[y + 0], d.y = h[y + 1], d.z = h[y + 2], f.x = h[m + y + 0], f.y = h[m + y + 1], f.z = h[m + y + 2], p.addVectors(d, f).normalize(), h[y + 0] = h[m + y + 0] = p.x, h[y + 1] = h[m + y + 1] = p.y, h[y + 2] = h[m + y + 2] = p.z;
    }
  }
  static fromJSON(e) {
    return new LatheGeometry(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, t = 0) {
    const i = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], n = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(i, n, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new OctahedronGeometry(e.radius, e.detail);
  }
}
class ParametricGeometry extends BufferGeometry {
  constructor(e, t, i) {
    super(), this.type = "ParametricGeometry", this.parameters = {
      func: e,
      slices: t,
      stacks: i
    };
    const n = [], r = [], s = [], a = [], l = 1e-5, c = new Vector3(), u = new Vector3(), h = new Vector3(), d = new Vector3(), f = new Vector3();
    e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
    const p = t + 1;
    for (let m = 0; m <= i; m++) {
      const v = m / i;
      for (let y = 0; y <= t; y++) {
        const g = y / t;
        e(g, v, u), r.push(u.x, u.y, u.z), g - l >= 0 ? (e(g - l, v, h), d.subVectors(u, h)) : (e(g + l, v, h), d.subVectors(h, u)), v - l >= 0 ? (e(g, v - l, h), f.subVectors(u, h)) : (e(g, v + l, h), f.subVectors(h, u)), c.crossVectors(d, f).normalize(), s.push(c.x, c.y, c.z), a.push(g, v);
      }
    }
    for (let m = 0; m < i; m++)
      for (let v = 0; v < t; v++) {
        const y = m * p + v, g = m * p + v + 1, _ = (m + 1) * p + v + 1, b = (m + 1) * p + v;
        n.push(y, g, b), n.push(g, _, b);
      }
    this.setIndex(n), this.setAttribute("position", new Float32BufferAttribute(r, 3)), this.setAttribute("normal", new Float32BufferAttribute(s, 3)), this.setAttribute("uv", new Float32BufferAttribute(a, 2));
  }
}
class RingGeometry extends BufferGeometry {
  constructor(e = 0.5, t = 1, i = 8, n = 1, r = 0, s = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: i,
      phiSegments: n,
      thetaStart: r,
      thetaLength: s
    }, i = Math.max(3, i), n = Math.max(1, n);
    const a = [], l = [], c = [], u = [];
    let h = e;
    const d = (t - e) / n, f = new Vector3(), p = new Vector2();
    for (let m = 0; m <= n; m++) {
      for (let v = 0; v <= i; v++) {
        const y = r + v / i * s;
        f.x = h * Math.cos(y), f.y = h * Math.sin(y), l.push(f.x, f.y, f.z), c.push(0, 0, 1), p.x = (f.x / t + 1) / 2, p.y = (f.y / t + 1) / 2, u.push(p.x, p.y);
      }
      h += d;
    }
    for (let m = 0; m < n; m++) {
      const v = m * (i + 1);
      for (let y = 0; y < i; y++) {
        const g = y + v, _ = g, b = g + i + 1, S = g + i + 2, x = g + 1;
        a.push(_, b, x), a.push(b, S, x);
      }
    }
    this.setIndex(a), this.setAttribute("position", new Float32BufferAttribute(l, 3)), this.setAttribute("normal", new Float32BufferAttribute(c, 3)), this.setAttribute("uv", new Float32BufferAttribute(u, 2));
  }
  static fromJSON(e) {
    return new RingGeometry(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class ShapeGeometry extends BufferGeometry {
  constructor(e, t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const i = [], n = [], r = [], s = [];
    let a = 0, l = 0;
    if (Array.isArray(e) === !1)
      c(e);
    else
      for (let u = 0; u < e.length; u++)
        c(e[u]), this.addGroup(a, l, u), a += l, l = 0;
    this.setIndex(i), this.setAttribute("position", new Float32BufferAttribute(n, 3)), this.setAttribute("normal", new Float32BufferAttribute(r, 3)), this.setAttribute("uv", new Float32BufferAttribute(s, 2));
    function c(u) {
      const h = n.length / 3, d = u.extractPoints(t);
      let f = d.shape;
      const p = d.holes;
      ShapeUtils.isClockWise(f) === !1 && (f = f.reverse());
      for (let v = 0, y = p.length; v < y; v++) {
        const g = p[v];
        ShapeUtils.isClockWise(g) === !0 && (p[v] = g.reverse());
      }
      const m = ShapeUtils.triangulateShape(f, p);
      for (let v = 0, y = p.length; v < y; v++) {
        const g = p[v];
        f = f.concat(g);
      }
      for (let v = 0, y = f.length; v < y; v++) {
        const g = f[v];
        n.push(g.x, g.y, 0), r.push(0, 0, 1), s.push(g.x, g.y);
      }
      for (let v = 0, y = m.length; v < y; v++) {
        const g = m[v], _ = g[0] + h, b = g[1] + h, S = g[2] + h;
        i.push(_, b, S), l += 3;
      }
    }
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return toJSON(t, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let n = 0, r = e.shapes.length; n < r; n++) {
      const s = t[e.shapes[n]];
      i.push(s);
    }
    return new ShapeGeometry(i, e.curveSegments);
  }
}
function toJSON(o, e) {
  if (e.shapes = [], Array.isArray(o))
    for (let t = 0, i = o.length; t < i; t++) {
      const n = o[t];
      e.shapes.push(n.uuid);
    }
  else
    e.shapes.push(o.uuid);
  return e;
}
class SphereGeometry extends BufferGeometry {
  constructor(e = 1, t = 8, i = 6, n = 0, r = Math.PI * 2, s = 0, a = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: i,
      phiStart: n,
      phiLength: r,
      thetaStart: s,
      thetaLength: a
    }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
    const l = Math.min(s + a, Math.PI);
    let c = 0;
    const u = [], h = new Vector3(), d = new Vector3(), f = [], p = [], m = [], v = [];
    for (let y = 0; y <= i; y++) {
      const g = [], _ = y / i;
      let b = 0;
      y == 0 && s == 0 ? b = 0.5 / t : y == i && l == Math.PI && (b = -0.5 / t);
      for (let S = 0; S <= t; S++) {
        const x = S / t;
        h.x = -e * Math.cos(n + x * r) * Math.sin(s + _ * a), h.y = e * Math.cos(s + _ * a), h.z = e * Math.sin(n + x * r) * Math.sin(s + _ * a), p.push(h.x, h.y, h.z), d.copy(h).normalize(), m.push(d.x, d.y, d.z), v.push(x + b, 1 - _), g.push(c++);
      }
      u.push(g);
    }
    for (let y = 0; y < i; y++)
      for (let g = 0; g < t; g++) {
        const _ = u[y][g + 1], b = u[y][g], S = u[y + 1][g], x = u[y + 1][g + 1];
        (y !== 0 || s > 0) && f.push(_, b, x), (y !== i - 1 || l < Math.PI) && f.push(b, S, x);
      }
    this.setIndex(f), this.setAttribute("position", new Float32BufferAttribute(p, 3)), this.setAttribute("normal", new Float32BufferAttribute(m, 3)), this.setAttribute("uv", new Float32BufferAttribute(v, 2));
  }
  static fromJSON(e) {
    return new SphereGeometry(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class TetrahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, t = 0) {
    const i = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], n = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(i, n, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new TetrahedronGeometry(e.radius, e.detail);
  }
}
class TextGeometry extends ExtrudeGeometry {
  constructor(e, t = {}) {
    const i = t.font;
    if (!(i && i.isFont))
      return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new BufferGeometry();
    const n = i.generateShapes(e, t.size);
    t.depth = t.height !== void 0 ? t.height : 50, t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = !1), super(n, t), this.type = "TextGeometry";
  }
}
class TorusGeometry extends BufferGeometry {
  constructor(e = 1, t = 0.4, i = 8, n = 6, r = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: i,
      tubularSegments: n,
      arc: r
    }, i = Math.floor(i), n = Math.floor(n);
    const s = [], a = [], l = [], c = [], u = new Vector3(), h = new Vector3(), d = new Vector3();
    for (let f = 0; f <= i; f++)
      for (let p = 0; p <= n; p++) {
        const m = p / n * r, v = f / i * Math.PI * 2;
        h.x = (e + t * Math.cos(v)) * Math.cos(m), h.y = (e + t * Math.cos(v)) * Math.sin(m), h.z = t * Math.sin(v), a.push(h.x, h.y, h.z), u.x = e * Math.cos(m), u.y = e * Math.sin(m), d.subVectors(h, u).normalize(), l.push(d.x, d.y, d.z), c.push(p / n), c.push(f / i);
      }
    for (let f = 1; f <= i; f++)
      for (let p = 1; p <= n; p++) {
        const m = (n + 1) * f + p - 1, v = (n + 1) * (f - 1) + p - 1, y = (n + 1) * (f - 1) + p, g = (n + 1) * f + p;
        s.push(m, v, g), s.push(v, y, g);
      }
    this.setIndex(s), this.setAttribute("position", new Float32BufferAttribute(a, 3)), this.setAttribute("normal", new Float32BufferAttribute(l, 3)), this.setAttribute("uv", new Float32BufferAttribute(c, 2));
  }
  static fromJSON(e) {
    return new TorusGeometry(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class TorusKnotGeometry extends BufferGeometry {
  constructor(e = 1, t = 0.4, i = 64, n = 8, r = 2, s = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: i,
      radialSegments: n,
      p: r,
      q: s
    }, i = Math.floor(i), n = Math.floor(n);
    const a = [], l = [], c = [], u = [], h = new Vector3(), d = new Vector3(), f = new Vector3(), p = new Vector3(), m = new Vector3(), v = new Vector3(), y = new Vector3();
    for (let _ = 0; _ <= i; ++_) {
      const b = _ / i * r * Math.PI * 2;
      g(b, r, s, e, f), g(b + 0.01, r, s, e, p), v.subVectors(p, f), y.addVectors(p, f), m.crossVectors(v, y), y.crossVectors(m, v), m.normalize(), y.normalize();
      for (let S = 0; S <= n; ++S) {
        const x = S / n * Math.PI * 2, M = -t * Math.cos(x), w = t * Math.sin(x);
        h.x = f.x + (M * y.x + w * m.x), h.y = f.y + (M * y.y + w * m.y), h.z = f.z + (M * y.z + w * m.z), l.push(h.x, h.y, h.z), d.subVectors(h, f).normalize(), c.push(d.x, d.y, d.z), u.push(_ / i), u.push(S / n);
      }
    }
    for (let _ = 1; _ <= i; _++)
      for (let b = 1; b <= n; b++) {
        const S = (n + 1) * (_ - 1) + (b - 1), x = (n + 1) * _ + (b - 1), M = (n + 1) * _ + b, w = (n + 1) * (_ - 1) + b;
        a.push(S, x, w), a.push(x, M, w);
      }
    this.setIndex(a), this.setAttribute("position", new Float32BufferAttribute(l, 3)), this.setAttribute("normal", new Float32BufferAttribute(c, 3)), this.setAttribute("uv", new Float32BufferAttribute(u, 2));
    function g(_, b, S, x, M) {
      const w = Math.cos(_), D = Math.sin(_), B = S / b * _, z = Math.cos(B);
      M.x = x * (2 + z) * 0.5 * w, M.y = x * (2 + z) * D * 0.5, M.z = x * Math.sin(B) * 0.5;
    }
  }
  static fromJSON(e) {
    return new TorusKnotGeometry(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class TubeGeometry extends BufferGeometry {
  constructor(e, t = 64, i = 1, n = 8, r = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: i,
      radialSegments: n,
      closed: r
    };
    const s = e.computeFrenetFrames(t, r);
    this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
    const a = new Vector3(), l = new Vector3(), c = new Vector2();
    let u = new Vector3();
    const h = [], d = [], f = [], p = [];
    m(), this.setIndex(p), this.setAttribute("position", new Float32BufferAttribute(h, 3)), this.setAttribute("normal", new Float32BufferAttribute(d, 3)), this.setAttribute("uv", new Float32BufferAttribute(f, 2));
    function m() {
      for (let _ = 0; _ < t; _++)
        v(_);
      v(r === !1 ? t : 0), g(), y();
    }
    function v(_) {
      u = e.getPointAt(_ / t, u);
      const b = s.normals[_], S = s.binormals[_];
      for (let x = 0; x <= n; x++) {
        const M = x / n * Math.PI * 2, w = Math.sin(M), D = -Math.cos(M);
        l.x = D * b.x + w * S.x, l.y = D * b.y + w * S.y, l.z = D * b.z + w * S.z, l.normalize(), d.push(l.x, l.y, l.z), a.x = u.x + i * l.x, a.y = u.y + i * l.y, a.z = u.z + i * l.z, h.push(a.x, a.y, a.z);
      }
    }
    function y() {
      for (let _ = 1; _ <= t; _++)
        for (let b = 1; b <= n; b++) {
          const S = (n + 1) * (_ - 1) + (b - 1), x = (n + 1) * _ + (b - 1), M = (n + 1) * _ + b, w = (n + 1) * (_ - 1) + b;
          p.push(S, x, w), p.push(x, M, w);
        }
    }
    function g() {
      for (let _ = 0; _ <= t; _++)
        for (let b = 0; b <= n; b++)
          c.x = _ / t, c.y = b / n, f.push(c.x, c.y);
    }
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new TubeGeometry(
      new Curves[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class WireframeGeometry extends BufferGeometry {
  constructor(e) {
    if (super(), this.type = "WireframeGeometry", e.isGeometry === !0) {
      console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return;
    }
    const t = [], i = [0, 0], n = {}, r = new Vector3();
    if (e.index !== null) {
      const s = e.attributes.position, a = e.index;
      let l = e.groups;
      l.length === 0 && (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
      for (let c = 0, u = l.length; c < u; ++c) {
        const h = l[c], d = h.start, f = h.count;
        for (let p = d, m = d + f; p < m; p += 3)
          for (let v = 0; v < 3; v++) {
            const y = a.getX(p + v), g = a.getX(p + (v + 1) % 3);
            i[0] = Math.min(y, g), i[1] = Math.max(y, g);
            const _ = i[0] + "," + i[1];
            n[_] === void 0 && (n[_] = { index1: i[0], index2: i[1] });
          }
      }
      for (const c in n) {
        const u = n[c];
        r.fromBufferAttribute(s, u.index1), t.push(r.x, r.y, r.z), r.fromBufferAttribute(s, u.index2), t.push(r.x, r.y, r.z);
      }
    } else {
      const s = e.attributes.position;
      for (let a = 0, l = s.count / 3; a < l; a++)
        for (let c = 0; c < 3; c++) {
          const u = 3 * a + c;
          r.fromBufferAttribute(s, u), t.push(r.x, r.y, r.z);
          const h = 3 * a + (c + 1) % 3;
          r.fromBufferAttribute(s, h), t.push(r.x, r.y, r.z);
        }
    }
    this.setAttribute("position", new Float32BufferAttribute(t, 3));
  }
}
var Geometries = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry,
  BoxBufferGeometry: BoxGeometry,
  CircleGeometry,
  CircleBufferGeometry: CircleGeometry,
  ConeGeometry,
  ConeBufferGeometry: ConeGeometry,
  CylinderGeometry,
  CylinderBufferGeometry: CylinderGeometry,
  DodecahedronGeometry,
  DodecahedronBufferGeometry: DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  ExtrudeBufferGeometry: ExtrudeGeometry,
  IcosahedronGeometry,
  IcosahedronBufferGeometry: IcosahedronGeometry,
  LatheGeometry,
  LatheBufferGeometry: LatheGeometry,
  OctahedronGeometry,
  OctahedronBufferGeometry: OctahedronGeometry,
  ParametricGeometry,
  ParametricBufferGeometry: ParametricGeometry,
  PlaneGeometry,
  PlaneBufferGeometry: PlaneGeometry,
  PolyhedronGeometry,
  PolyhedronBufferGeometry: PolyhedronGeometry,
  RingGeometry,
  RingBufferGeometry: RingGeometry,
  ShapeGeometry,
  ShapeBufferGeometry: ShapeGeometry,
  SphereGeometry,
  SphereBufferGeometry: SphereGeometry,
  TetrahedronGeometry,
  TetrahedronBufferGeometry: TetrahedronGeometry,
  TextGeometry,
  TextBufferGeometry: TextGeometry,
  TorusGeometry,
  TorusBufferGeometry: TorusGeometry,
  TorusKnotGeometry,
  TorusKnotBufferGeometry: TorusKnotGeometry,
  TubeGeometry,
  TubeBufferGeometry: TubeGeometry,
  WireframeGeometry
});
class ShadowMaterial extends Material {
  constructor(e) {
    super(), this.type = "ShadowMaterial", this.color = new Color(0), this.transparent = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this;
  }
}
ShadowMaterial.prototype.isShadowMaterial = !0;
class RawShaderMaterial extends ShaderMaterial {
  constructor(e) {
    super(e), this.type = "RawShaderMaterial";
  }
}
RawShaderMaterial.prototype.isRawShaderMaterial = !0;
class MeshStandardMaterial extends Material {
  constructor(e) {
    super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Color(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.vertexTangents = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this.vertexTangents = e.vertexTangents, this;
  }
}
MeshStandardMaterial.prototype.isMeshStandardMaterial = !0;
class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(e) {
    super(), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2(1, 1), this.clearcoatNormalMap = null, this.reflectivity = 0.5, Object.defineProperty(this, "ior", {
      get: function() {
        return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
      },
      set: function(t) {
        this.reflectivity = clamp(2.5 * (t - 1) / (t + 1), 0, 1);
      }
    }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.thickness = 0.01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Color(1, 1, 1), this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.reflectivity = e.reflectivity, e.sheen ? this.sheen = (this.sheen || new Color()).copy(e.sheen) : this.sheen = null, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this;
  }
}
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = !0;
class MeshPhongMaterial extends Material {
  constructor(e) {
    super(), this.type = "MeshPhongMaterial", this.color = new Color(16777215), this.specular = new Color(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this;
  }
}
MeshPhongMaterial.prototype.isMeshPhongMaterial = !0;
class MeshToonMaterial extends Material {
  constructor(e) {
    super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Color(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
  }
}
MeshToonMaterial.prototype.isMeshToonMaterial = !0;
class MeshNormalMaterial extends Material {
  constructor(e) {
    super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this;
  }
}
MeshNormalMaterial.prototype.isMeshNormalMaterial = !0;
class MeshLambertMaterial extends Material {
  constructor(e) {
    super(), this.type = "MeshLambertMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
  }
}
MeshLambertMaterial.prototype.isMeshLambertMaterial = !0;
class MeshMatcapMaterial extends Material {
  constructor(e) {
    super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Color(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this;
  }
}
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = !0;
class LineDashedMaterial extends LineBasicMaterial {
  constructor(e) {
    super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
LineDashedMaterial.prototype.isLineDashedMaterial = !0;
var Materials = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ShadowMaterial,
  SpriteMaterial,
  RawShaderMaterial,
  ShaderMaterial,
  PointsMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshPhongMaterial,
  MeshToonMaterial,
  MeshNormalMaterial,
  MeshLambertMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshBasicMaterial,
  MeshMatcapMaterial,
  LineDashedMaterial,
  LineBasicMaterial,
  Material
});
const AnimationUtils = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function(o, e, t) {
    return AnimationUtils.isTypedArray(o) ? new o.constructor(o.subarray(e, t !== void 0 ? t : o.length)) : o.slice(e, t);
  },
  // converts an array to a specific type
  convertArray: function(o, e, t) {
    return !o || // let 'undefined' and 'null' pass
    !t && o.constructor === e ? o : typeof e.BYTES_PER_ELEMENT == "number" ? new e(o) : Array.prototype.slice.call(o);
  },
  isTypedArray: function(o) {
    return ArrayBuffer.isView(o) && !(o instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function(o) {
    function e(n, r) {
      return o[n] - o[r];
    }
    const t = o.length, i = new Array(t);
    for (let n = 0; n !== t; ++n) i[n] = n;
    return i.sort(e), i;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function(o, e, t) {
    const i = o.length, n = new o.constructor(i);
    for (let r = 0, s = 0; s !== i; ++r) {
      const a = t[r] * e;
      for (let l = 0; l !== e; ++l)
        n[s++] = o[a + l];
    }
    return n;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function(o, e, t, i) {
    let n = 1, r = o[0];
    for (; r !== void 0 && r[i] === void 0; )
      r = o[n++];
    if (r === void 0) return;
    let s = r[i];
    if (s !== void 0)
      if (Array.isArray(s))
        do
          s = r[i], s !== void 0 && (e.push(r.time), t.push.apply(t, s)), r = o[n++];
        while (r !== void 0);
      else if (s.toArray !== void 0)
        do
          s = r[i], s !== void 0 && (e.push(r.time), s.toArray(t, t.length)), r = o[n++];
        while (r !== void 0);
      else
        do
          s = r[i], s !== void 0 && (e.push(r.time), t.push(s)), r = o[n++];
        while (r !== void 0);
  },
  subclip: function(o, e, t, i, n = 30) {
    const r = o.clone();
    r.name = e;
    const s = [];
    for (let l = 0; l < r.tracks.length; ++l) {
      const c = r.tracks[l], u = c.getValueSize(), h = [], d = [];
      for (let f = 0; f < c.times.length; ++f) {
        const p = c.times[f] * n;
        if (!(p < t || p >= i)) {
          h.push(c.times[f]);
          for (let m = 0; m < u; ++m)
            d.push(c.values[f * u + m]);
        }
      }
      h.length !== 0 && (c.times = AnimationUtils.convertArray(h, c.times.constructor), c.values = AnimationUtils.convertArray(d, c.values.constructor), s.push(c));
    }
    r.tracks = s;
    let a = 1 / 0;
    for (let l = 0; l < r.tracks.length; ++l)
      a > r.tracks[l].times[0] && (a = r.tracks[l].times[0]);
    for (let l = 0; l < r.tracks.length; ++l)
      r.tracks[l].shift(-1 * a);
    return r.resetDuration(), r;
  },
  makeClipAdditive: function(o, e = 0, t = o, i = 30) {
    i <= 0 && (i = 30);
    const n = t.tracks.length, r = e / i;
    for (let s = 0; s < n; ++s) {
      const a = t.tracks[s], l = a.ValueTypeName;
      if (l === "bool" || l === "string") continue;
      const c = o.tracks.find(function(y) {
        return y.name === a.name && y.ValueTypeName === l;
      });
      if (c === void 0) continue;
      let u = 0;
      const h = a.getValueSize();
      a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = h / 3);
      let d = 0;
      const f = c.getValueSize();
      c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = f / 3);
      const p = a.times.length - 1;
      let m;
      if (r <= a.times[0]) {
        const y = u, g = h - u;
        m = AnimationUtils.arraySlice(a.values, y, g);
      } else if (r >= a.times[p]) {
        const y = p * h + u, g = y + h - u;
        m = AnimationUtils.arraySlice(a.values, y, g);
      } else {
        const y = a.createInterpolant(), g = u, _ = h - u;
        y.evaluate(r), m = AnimationUtils.arraySlice(y.resultBuffer, g, _);
      }
      l === "quaternion" && new Quaternion().fromArray(m).normalize().conjugate().toArray(m);
      const v = c.times.length;
      for (let y = 0; y < v; ++y) {
        const g = y * f + d;
        if (l === "quaternion")
          Quaternion.multiplyQuaternionsFlat(
            c.values,
            g,
            m,
            0,
            c.values,
            g
          );
        else {
          const _ = f - d * 2;
          for (let b = 0; b < _; ++b)
            c.values[g + b] -= m[b];
        }
      }
    }
    return o.blendMode = AdditiveAnimationBlendMode, o;
  }
};
class Interpolant {
  constructor(e, t, i, n) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = n !== void 0 ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex, n = t[i], r = t[i - 1];
    e: {
      t: {
        let s;
        n: {
          i: if (!(e < n)) {
            for (let a = i + 2; ; ) {
              if (n === void 0) {
                if (e < r) break i;
                return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, e, r);
              }
              if (i === a) break;
              if (r = n, n = t[++i], e < n)
                break t;
            }
            s = t.length;
            break n;
          }
          if (!(e >= r)) {
            const a = t[1];
            e < a && (i = 2, r = a);
            for (let l = i - 2; ; ) {
              if (r === void 0)
                return this._cachedIndex = 0, this.beforeStart_(0, e, n);
              if (i === l) break;
              if (n = r, r = t[--i - 1], e >= r)
                break t;
            }
            s = i, i = 0;
            break n;
          }
          break e;
        }
        for (; i < s; ) {
          const a = i + s >>> 1;
          e < t[a] ? s = a : i = a + 1;
        }
        if (n = t[i], r = t[i - 1], r === void 0)
          return this._cachedIndex = 0, this.beforeStart_(0, e, n);
        if (n === void 0)
          return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, r, e);
      }
      this._cachedIndex = i, this.intervalChanged_(i, r, n);
    }
    return this.interpolate_(i, r, e, n);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n;
    for (let s = 0; s !== n; ++s)
      t[s] = i[r + s];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
class CubicInterpolant extends Interpolant {
  constructor(e, t, i, n) {
    super(e, t, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(e, t, i) {
    const n = this.parameterPositions;
    let r = e - 2, s = e + 1, a = n[r], l = n[s];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          r = e, a = 2 * t - i;
          break;
        case WrapAroundEnding:
          r = n.length - 2, a = t + n[r] - n[r + 1];
          break;
        default:
          r = e, a = i;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          s = e, l = 2 * i - t;
          break;
        case WrapAroundEnding:
          s = 1, l = i + n[1] - n[0];
          break;
        default:
          s = e - 1, l = t;
      }
    const c = (i - t) * 0.5, u = this.valueSize;
    this._weightPrev = c / (t - a), this._weightNext = c / (l - i), this._offsetPrev = r * u, this._offsetNext = s * u;
  }
  interpolate_(e, t, i, n) {
    const r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, u = this._offsetPrev, h = this._offsetNext, d = this._weightPrev, f = this._weightNext, p = (i - t) / (n - t), m = p * p, v = m * p, y = -d * v + 2 * d * m - d * p, g = (1 + d) * v + (-1.5 - 2 * d) * m + (-0.5 + d) * p + 1, _ = (-1 - f) * v + (1.5 + f) * m + 0.5 * p, b = f * v - f * m;
    for (let S = 0; S !== a; ++S)
      r[S] = y * s[u + S] + g * s[c + S] + _ * s[l + S] + b * s[h + S];
    return r;
  }
}
class LinearInterpolant extends Interpolant {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e, t, i, n) {
    const r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, u = (i - t) / (n - t), h = 1 - u;
    for (let d = 0; d !== a; ++d)
      r[d] = s[c + d] * h + s[l + d] * u;
    return r;
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class KeyframeTrack {
  constructor(e, t, i, n) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = AnimationUtils.convertArray(t, this.TimeBufferType), this.values = AnimationUtils.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON)
      i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: AnimationUtils.convertArray(e.times, Array),
        values: AnimationUtils.convertArray(e.values, Array)
      };
      const n = e.getInterpolation();
      n !== e.DefaultInterpolation && (i.interpolation = n);
    }
    return i.type = e.ValueTypeName, i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case InterpolateDiscrete:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, n = t.length; i !== n; ++i)
        t[i] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, n = t.length; i !== n; ++i)
        t[i] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const i = this.times, n = i.length;
    let r = 0, s = n - 1;
    for (; r !== n && i[r] < e; )
      ++r;
    for (; s !== -1 && i[s] > t; )
      --s;
    if (++s, r !== 0 || s !== n) {
      r >= s && (s = Math.max(s, 1), r = s - 1);
      const a = this.getValueSize();
      this.times = AnimationUtils.arraySlice(i, r, s), this.values = AnimationUtils.arraySlice(this.values, r * a, s * a);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const i = this.times, n = this.values, r = i.length;
    r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let s = null;
    for (let a = 0; a !== r; a++) {
      const l = i[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1;
        break;
      }
      if (s !== null && s > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, s), e = !1;
        break;
      }
      s = l;
    }
    if (n !== void 0 && AnimationUtils.isTypedArray(n))
      for (let a = 0, l = n.length; a !== l; ++a) {
        const c = n[a];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = AnimationUtils.arraySlice(this.times), t = AnimationUtils.arraySlice(this.values), i = this.getValueSize(), n = this.getInterpolation() === InterpolateSmooth, r = e.length - 1;
    let s = 1;
    for (let a = 1; a < r; ++a) {
      let l = !1;
      const c = e[a], u = e[a + 1];
      if (c !== u && (a !== 1 || c !== e[0]))
        if (n)
          l = !0;
        else {
          const h = a * i, d = h - i, f = h + i;
          for (let p = 0; p !== i; ++p) {
            const m = t[h + p];
            if (m !== t[d + p] || m !== t[f + p]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== s) {
          e[s] = e[a];
          const h = a * i, d = s * i;
          for (let f = 0; f !== i; ++f)
            t[d + f] = t[h + f];
        }
        ++s;
      }
    }
    if (r > 0) {
      e[s] = e[r];
      for (let a = r * i, l = s * i, c = 0; c !== i; ++c)
        t[l + c] = t[a + c];
      ++s;
    }
    return s !== e.length ? (this.times = AnimationUtils.arraySlice(e, 0, s), this.values = AnimationUtils.arraySlice(t, 0, s * i)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = AnimationUtils.arraySlice(this.times, 0), t = AnimationUtils.arraySlice(this.values, 0), i = this.constructor, n = new i(this.name, e, t);
    return n.createInterpolant = this.createInterpolant, n;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e, t, i, n) {
    const r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, l = (i - t) / (n - t);
    let c = e * a;
    for (let u = c + a; c !== u; c += 4)
      Quaternion.slerpFlat(r, 0, s, c - a, s, c, l);
    return r;
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(e) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), e);
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(e, t = -1, i, n = NormalAnimationBlendMode) {
    this.name = e, this.tracks = i, this.duration = t, this.blendMode = n, this.uuid = generateUUID$1(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], i = e.tracks, n = 1 / (e.fps || 1);
    for (let s = 0, a = i.length; s !== a; ++s)
      t.push(parseKeyframeTrack(i[s]).scale(n));
    const r = new this(e.name, e.duration, t, e.blendMode);
    return r.uuid = e.uuid, r;
  }
  static toJSON(e) {
    const t = [], i = e.tracks, n = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let r = 0, s = i.length; r !== s; ++r)
      t.push(KeyframeTrack.toJSON(i[r]));
    return n;
  }
  static CreateFromMorphTargetSequence(e, t, i, n) {
    const r = t.length, s = [];
    for (let a = 0; a < r; a++) {
      let l = [], c = [];
      l.push(
        (a + r - 1) % r,
        a,
        (a + 1) % r
      ), c.push(0, 1, 0);
      const u = AnimationUtils.getKeyframeOrder(l);
      l = AnimationUtils.sortedArray(l, 1, u), c = AnimationUtils.sortedArray(c, 1, u), !n && l[0] === 0 && (l.push(r), c.push(c[0])), s.push(
        new NumberKeyframeTrack(
          ".morphTargetInfluences[" + t[a].name + "]",
          l,
          c
        ).scale(1 / i)
      );
    }
    return new this(e, -1, s);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const n = e;
      i = n.geometry && n.geometry.animations || n.animations;
    }
    for (let n = 0; n < i.length; n++)
      if (i[n].name === t)
        return i[n];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const n = {}, r = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a], u = c.name.match(r);
      if (u && u.length > 1) {
        const h = u[1];
        let d = n[h];
        d || (n[h] = d = []), d.push(c);
      }
    }
    const s = [];
    for (const a in n)
      s.push(this.CreateFromMorphTargetSequence(a, n[a], t, i));
    return s;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const i = function(h, d, f, p, m) {
      if (f.length !== 0) {
        const v = [], y = [];
        AnimationUtils.flattenJSON(f, v, y, p), v.length !== 0 && m.push(new h(d, v, y));
      }
    }, n = [], r = e.name || "default", s = e.fps || 30, a = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let h = 0; h < c.length; h++) {
      const d = c[h].keys;
      if (!(!d || d.length === 0))
        if (d[0].morphTargets) {
          const f = {};
          let p;
          for (p = 0; p < d.length; p++)
            if (d[p].morphTargets)
              for (let m = 0; m < d[p].morphTargets.length; m++)
                f[d[p].morphTargets[m]] = -1;
          for (const m in f) {
            const v = [], y = [];
            for (let g = 0; g !== d[p].morphTargets.length; ++g) {
              const _ = d[p];
              v.push(_.time), y.push(_.morphTarget === m ? 1 : 0);
            }
            n.push(new NumberKeyframeTrack(".morphTargetInfluence[" + m + "]", v, y));
          }
          l = f.length * (s || 1);
        } else {
          const f = ".bones[" + t[h].name + "]";
          i(
            VectorKeyframeTrack,
            f + ".position",
            d,
            "pos",
            n
          ), i(
            QuaternionKeyframeTrack,
            f + ".quaternion",
            d,
            "rot",
            n
          ), i(
            VectorKeyframeTrack,
            f + ".scale",
            d,
            "scl",
            n
          );
        }
    }
    return n.length === 0 ? null : new this(r, l, n, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, n = e.length; i !== n; ++i) {
      const r = this.tracks[i];
      t = Math.max(t, r.times[r.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(o) {
  switch (o.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + o);
}
function parseKeyframeTrack(o) {
  if (o.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = getTrackTypeForValueTypeName(o.type);
  if (o.times === void 0) {
    const t = [], i = [];
    AnimationUtils.flattenJSON(o.keys, t, i, "value"), o.times = t, o.values = i;
  }
  return e.parse !== void 0 ? e.parse(o) : new e(o.name, o.times, o.values, o.interpolation);
}
const Cache = {
  enabled: !1,
  files: {},
  add: function(o, e) {
    this.enabled !== !1 && (this.files[o] = e);
  },
  get: function(o) {
    if (this.enabled !== !1)
      return this.files[o];
  },
  remove: function(o) {
    delete this.files[o];
  },
  clear: function() {
    this.files = {};
  }
};
class LoadingManager {
  constructor(e, t, i) {
    const n = this;
    let r = !1, s = 0, a = 0, l;
    const c = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(u) {
      a++, r === !1 && n.onStart !== void 0 && n.onStart(u, s, a), r = !0;
    }, this.itemEnd = function(u) {
      s++, n.onProgress !== void 0 && n.onProgress(u, s, a), s === a && (r = !1, n.onLoad !== void 0 && n.onLoad());
    }, this.itemError = function(u) {
      n.onError !== void 0 && n.onError(u);
    }, this.resolveURL = function(u) {
      return l ? l(u) : u;
    }, this.setURLModifier = function(u) {
      return l = u, this;
    }, this.addHandler = function(u, h) {
      return c.push(u, h), this;
    }, this.removeHandler = function(u) {
      const h = c.indexOf(u);
      return h !== -1 && c.splice(h, 2), this;
    }, this.getHandler = function(u) {
      for (let h = 0, d = c.length; h < d; h += 2) {
        const f = c[h], p = c[h + 1];
        if (f.global && (f.lastIndex = 0), f.test(u))
          return p;
      }
      return null;
    };
  }
}
const DefaultLoadingManager = new LoadingManager();
class Loader {
  constructor(e) {
    this.manager = e !== void 0 ? e : DefaultLoadingManager, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const i = this;
    return new Promise(function(n, r) {
      i.load(e, n, t, r);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
const loading = {};
class FileLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, s = Cache.get(e);
    if (s !== void 0)
      return r.manager.itemStart(e), setTimeout(function() {
        t && t(s), r.manager.itemEnd(e);
      }, 0), s;
    if (loading[e] !== void 0) {
      loading[e].push({
        onLoad: t,
        onProgress: i,
        onError: n
      });
      return;
    }
    const a = /^data:(.*?)(;base64)?,(.*)$/, l = e.match(a);
    let c;
    if (l) {
      const u = l[1], h = !!l[2];
      let d = l[3];
      d = decodeURIComponent(d), h && (d = atob(d));
      try {
        let f;
        const p = (this.responseType || "").toLowerCase();
        switch (p) {
          case "arraybuffer":
          case "blob":
            const m = new Uint8Array(d.length);
            for (let y = 0; y < d.length; y++)
              m[y] = d.charCodeAt(y);
            p === "blob" ? f = new Blob([m.buffer], { type: u }) : f = m.buffer;
            break;
          case "document":
            f = new DOMParser().parseFromString(d, u);
            break;
          case "json":
            f = JSON.parse(d);
            break;
          default:
            f = d;
            break;
        }
        setTimeout(function() {
          t && t(f), r.manager.itemEnd(e);
        }, 0);
      } catch (f) {
        setTimeout(function() {
          n && n(f), r.manager.itemError(e), r.manager.itemEnd(e);
        }, 0);
      }
    } else {
      loading[e] = [], loading[e].push({
        onLoad: t,
        onProgress: i,
        onError: n
      }), c = new XMLHttpRequest(), c.open("GET", e, !0), c.addEventListener("load", function(u) {
        const h = this.response, d = loading[e];
        if (delete loading[e], this.status === 200 || this.status === 0) {
          this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), Cache.add(e, h);
          for (let f = 0, p = d.length; f < p; f++) {
            const m = d[f];
            m.onLoad && m.onLoad(h);
          }
          r.manager.itemEnd(e);
        } else {
          for (let f = 0, p = d.length; f < p; f++) {
            const m = d[f];
            m.onError && m.onError(u);
          }
          r.manager.itemError(e), r.manager.itemEnd(e);
        }
      }, !1), c.addEventListener("progress", function(u) {
        const h = loading[e];
        for (let d = 0, f = h.length; d < f; d++) {
          const p = h[d];
          p.onProgress && p.onProgress(u);
        }
      }, !1), c.addEventListener("error", function(u) {
        const h = loading[e];
        delete loading[e];
        for (let d = 0, f = h.length; d < f; d++) {
          const p = h[d];
          p.onError && p.onError(u);
        }
        r.manager.itemError(e), r.manager.itemEnd(e);
      }, !1), c.addEventListener("abort", function(u) {
        const h = loading[e];
        delete loading[e];
        for (let d = 0, f = h.length; d < f; d++) {
          const p = h[d];
          p.onError && p.onError(u);
        }
        r.manager.itemError(e), r.manager.itemEnd(e);
      }, !1), this.responseType !== void 0 && (c.responseType = this.responseType), this.withCredentials !== void 0 && (c.withCredentials = this.withCredentials), c.overrideMimeType && c.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (const u in this.requestHeader)
        c.setRequestHeader(u, this.requestHeader[u]);
      c.send(null);
    }
    return r.manager.itemStart(e), c;
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class AnimationLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, s = new FileLoader(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function(a) {
      try {
        t(r.parse(JSON.parse(a)));
      } catch (l) {
        n ? n(l) : console.error(l), r.manager.itemError(e);
      }
    }, i, n);
  }
  parse(e) {
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const n = AnimationClip.parse(e[i]);
      t.push(n);
    }
    return t;
  }
}
class CompressedTextureLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, s = [], a = new CompressedTexture(), l = new FileLoader(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(r.withCredentials);
    let c = 0;
    function u(h) {
      l.load(e[h], function(d) {
        const f = r.parse(d, !0);
        s[h] = {
          width: f.width,
          height: f.height,
          format: f.format,
          mipmaps: f.mipmaps
        }, c += 1, c === 6 && (f.mipmapCount === 1 && (a.minFilter = LinearFilter), a.image = s, a.format = f.format, a.needsUpdate = !0, t && t(a));
      }, i, n);
    }
    if (Array.isArray(e))
      for (let h = 0, d = e.length; h < d; ++h)
        u(h);
    else
      l.load(e, function(h) {
        const d = r.parse(h, !0);
        if (d.isCubemap) {
          const f = d.mipmaps.length / d.mipmapCount;
          for (let p = 0; p < f; p++) {
            s[p] = { mipmaps: [] };
            for (let m = 0; m < d.mipmapCount; m++)
              s[p].mipmaps.push(d.mipmaps[p * d.mipmapCount + m]), s[p].format = d.format, s[p].width = d.width, s[p].height = d.height;
          }
          a.image = s;
        } else
          a.image.width = d.width, a.image.height = d.height, a.mipmaps = d.mipmaps;
        d.mipmapCount === 1 && (a.minFilter = LinearFilter), a.format = d.format, a.needsUpdate = !0, t && t(a);
      }, i, n);
    return a;
  }
}
class ImageLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, s = Cache.get(e);
    if (s !== void 0)
      return r.manager.itemStart(e), setTimeout(function() {
        t && t(s), r.manager.itemEnd(e);
      }, 0), s;
    const a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function l() {
      a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1), Cache.add(e, this), t && t(this), r.manager.itemEnd(e);
    }
    function c(u) {
      a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1), n && n(u), r.manager.itemError(e), r.manager.itemEnd(e);
    }
    return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), e.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a;
  }
}
class CubeTextureLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = new CubeTexture(), s = new ImageLoader(this.manager);
    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
    let a = 0;
    function l(c) {
      s.load(e[c], function(u) {
        r.images[c] = u, a++, a === 6 && (r.needsUpdate = !0, t && t(r));
      }, void 0, n);
    }
    for (let c = 0; c < e.length; ++c)
      l(c);
    return r;
  }
}
class DataTextureLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, s = new DataTexture(), a = new FileLoader(this.manager);
    return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(e, function(l) {
      const c = r.parse(l);
      c && (c.image !== void 0 ? s.image = c.image : c.data !== void 0 && (s.image.width = c.width, s.image.height = c.height, s.image.data = c.data), s.wrapS = c.wrapS !== void 0 ? c.wrapS : ClampToEdgeWrapping, s.wrapT = c.wrapT !== void 0 ? c.wrapT : ClampToEdgeWrapping, s.magFilter = c.magFilter !== void 0 ? c.magFilter : LinearFilter, s.minFilter = c.minFilter !== void 0 ? c.minFilter : LinearFilter, s.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.encoding !== void 0 && (s.encoding = c.encoding), c.flipY !== void 0 && (s.flipY = c.flipY), c.format !== void 0 && (s.format = c.format), c.type !== void 0 && (s.type = c.type), c.mipmaps !== void 0 && (s.mipmaps = c.mipmaps, s.minFilter = LinearMipmapLinearFilter), c.mipmapCount === 1 && (s.minFilter = LinearFilter), c.generateMipmaps !== void 0 && (s.generateMipmaps = c.generateMipmaps), s.needsUpdate = !0, t && t(s, c));
    }, i, n), s;
  }
}
class TextureLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = new Texture(), s = new ImageLoader(this.manager);
    return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, function(a) {
      r.image = a;
      const l = e.search(/\.jpe?g($|\?)/i) > 0 || e.search(/^data\:image\/jpeg/) === 0;
      r.format = l ? RGBFormat : RGBAFormat, r.needsUpdate = !0, t !== void 0 && t(r);
    }, i, n), r;
  }
}
class CurvePath extends Curve {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new LineCurve(t, e));
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e) {
    const t = e * this.getLength(), i = this.getCurveLengths();
    let n = 0;
    for (; n < i.length; ) {
      if (i[n] >= t) {
        const r = i[n] - t, s = this.curves[n], a = s.getLength(), l = a === 0 ? 0 : 1 - r / a;
        return s.getPointAt(l);
      }
      n++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, n = this.curves.length; i < n; i++)
      t += this.curves[i].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let n = 0, r = this.curves; n < r.length; n++) {
      const s = r[n], a = s && s.isEllipseCurve ? e * 2 : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? e * s.points.length : e, l = s.getPoints(a);
      for (let c = 0; c < l.length; c++) {
        const u = l[c];
        i && i.equals(u) || (t.push(u), i = u);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const n = e.curves[t];
      this.curves.push(n.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const n = this.curves[t];
      e.curves.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const n = e.curves[t];
      this.curves.push(new Curves[n.type]().fromJSON(n));
    }
    return this;
  }
}
class Path extends CurvePath {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Vector2(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const i = new LineCurve(this.currentPoint.clone(), new Vector2(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, i, n) {
    const r = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2(e, t),
      new Vector2(i, n)
    );
    return this.curves.push(r), this.currentPoint.set(i, n), this;
  }
  bezierCurveTo(e, t, i, n, r, s) {
    const a = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2(e, t),
      new Vector2(i, n),
      new Vector2(r, s)
    );
    return this.curves.push(a), this.currentPoint.set(r, s), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), i = new SplineCurve(t);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, i, n, r, s) {
    const a = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(
      e + a,
      t + l,
      i,
      n,
      r,
      s
    ), this;
  }
  absarc(e, t, i, n, r, s) {
    return this.absellipse(e, t, i, i, n, r, s), this;
  }
  ellipse(e, t, i, n, r, s, a, l) {
    const c = this.currentPoint.x, u = this.currentPoint.y;
    return this.absellipse(e + c, t + u, i, n, r, s, a, l), this;
  }
  absellipse(e, t, i, n, r, s, a, l) {
    const c = new EllipseCurve(e, t, i, n, r, s, a, l);
    if (this.curves.length > 0) {
      const h = c.getPoint(0);
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
    }
    this.curves.push(c);
    const u = c.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
let Shape$1 = class extends Path {
  constructor(e) {
    super(e), this.uuid = generateUUID$1(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, n = this.holes.length; i < n; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const n = e.holes[t];
      this.holes.push(n.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const n = this.holes[t];
      e.holes.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const n = e.holes[t];
      this.holes.push(new Path().fromJSON(n));
    }
    return this;
  }
};
class Light extends Object3D {
  constructor(e, t = 1) {
    super(), this.type = "Light", this.color = new Color(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
Light.prototype.isLight = !0;
class HemisphereLight extends Light {
  constructor(e, t, i) {
    super(e, i), this.type = "HemisphereLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.groundColor = new Color(t);
  }
  copy(e) {
    return Light.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this;
  }
}
HemisphereLight.prototype.isHemisphereLight = !0;
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4(), _lightPositionWorld$1 = /* @__PURE__ */ new Vector3(), _lookTarget$1 = /* @__PURE__ */ new Vector3();
class LightShadow {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new Vector2(512, 512), this.map = null, this.mapPass = null, this.matrix = new Matrix4(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Frustum(), this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, i = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(e.matrixWorld), t.position.copy(_lightPositionWorld$1), _lookTarget$1.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(_lookTarget$1), t.updateMatrixWorld(), _projScreenMatrix$1.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix$1), i.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), i.multiply(t.projectionMatrix), i.multiply(t.matrixWorldInverse);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500)), this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, i = RAD2DEG * 2 * e.angle * this.focus, n = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
    (i !== t.fov || n !== t.aspect || r !== t.far) && (t.fov = i, t.aspect = n, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
SpotLightShadow.prototype.isSpotLightShadow = !0;
class SpotLight extends Light {
  constructor(e, t, i = 0, n = Math.PI / 3, r = 0, s = 1) {
    super(e, t), this.type = "SpotLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D(), this.distance = i, this.angle = n, this.penumbra = r, this.decay = s, this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
SpotLight.prototype.isSpotLight = !0;
const _projScreenMatrix = /* @__PURE__ */ new Matrix4(), _lightPositionWorld = /* @__PURE__ */ new Vector3(), _lookTarget = /* @__PURE__ */ new Vector3();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500)), this._frameExtents = new Vector2(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Vector4(2, 1, 1, 1),
      // negative X
      new Vector4(0, 1, 1, 1),
      // positive Z
      new Vector4(3, 1, 1, 1),
      // negative Z
      new Vector4(1, 1, 1, 1),
      // positive Y
      new Vector4(3, 0, 1, 1),
      // negative Y
      new Vector4(1, 0, 1, 1)
    ], this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ], this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const i = this.camera, n = this.matrix, r = e.distance || i.far;
    r !== i.far && (i.far = r, i.updateProjectionMatrix()), _lightPositionWorld.setFromMatrixPosition(e.matrixWorld), i.position.copy(_lightPositionWorld), _lookTarget.copy(i.position), _lookTarget.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(_lookTarget), i.updateMatrixWorld(), n.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z), _projScreenMatrix.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
PointLightShadow.prototype.isPointLightShadow = !0;
class PointLight extends Light {
  constructor(e, t, i = 0, n = 1) {
    super(e, t), this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
PointLight.prototype.isPointLight = !0;
class OrthographicCamera extends Camera$1 {
  constructor(e = -1, t = 1, i = 1, n = -1, r = 0.1, s = 2e3) {
    super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = r, this.far = s, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, i, n, r, s) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = s, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
    let r = i - e, s = i + e, a = n + t, l = n - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r += c * this.view.offsetX, s = r + c * this.view.width, a -= u * this.view.offsetY, l = a - u * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(r, s, a, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
OrthographicCamera.prototype.isOrthographicCamera = !0;
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
}
DirectionalLightShadow.prototype.isDirectionalLightShadow = !0;
class DirectionalLight extends Light {
  constructor(e, t) {
    super(e, t), this.type = "DirectionalLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D(), this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
DirectionalLight.prototype.isDirectionalLight = !0;
class AmbientLight extends Light {
  constructor(e, t) {
    super(e, t), this.type = "AmbientLight";
  }
}
AmbientLight.prototype.isAmbientLight = !0;
class RectAreaLight extends Light {
  constructor(e, t, i = 10, n = 10) {
    super(e, t), this.type = "RectAreaLight", this.width = i, this.height = n;
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
RectAreaLight.prototype.isRectAreaLight = !0;
class SphericalHarmonics3 {
  constructor() {
    this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new Vector3());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const i = e.x, n = e.y, r = e.z, s = this.coefficients;
    return t.copy(s[0]).multiplyScalar(0.282095), t.addScaledVector(s[1], 0.488603 * n), t.addScaledVector(s[2], 0.488603 * r), t.addScaledVector(s[3], 0.488603 * i), t.addScaledVector(s[4], 1.092548 * (i * n)), t.addScaledVector(s[5], 1.092548 * (n * r)), t.addScaledVector(s[6], 0.315392 * (3 * r * r - 1)), t.addScaledVector(s[7], 1.092548 * (i * r)), t.addScaledVector(s[8], 0.546274 * (i * i - n * n)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const i = e.x, n = e.y, r = e.z, s = this.coefficients;
    return t.copy(s[0]).multiplyScalar(0.886227), t.addScaledVector(s[1], 2 * 0.511664 * n), t.addScaledVector(s[2], 2 * 0.511664 * r), t.addScaledVector(s[3], 2 * 0.511664 * i), t.addScaledVector(s[4], 2 * 0.429043 * i * n), t.addScaledVector(s[5], 2 * 0.429043 * n * r), t.addScaledVector(s[6], 0.743125 * r * r - 0.247708), t.addScaledVector(s[7], 2 * 0.429043 * i * r), t.addScaledVector(s[8], 0.429043 * (i * i - n * n)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].lerp(e.coefficients[i], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const i = this.coefficients;
    for (let n = 0; n < 9; n++)
      i[n].fromArray(e, t + n * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients;
    for (let n = 0; n < 9; n++)
      i[n].toArray(e, t + n * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const i = e.x, n = e.y, r = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * n, t[2] = 0.488603 * r, t[3] = 0.488603 * i, t[4] = 1.092548 * i * n, t[5] = 1.092548 * n * r, t[6] = 0.315392 * (3 * r * r - 1), t[7] = 1.092548 * i * r, t[8] = 0.546274 * (i * i - n * n);
  }
}
SphericalHarmonics3.prototype.isSphericalHarmonics3 = !0;
class LightProbe extends Light {
  constructor(e = new SphericalHarmonics3(), t = 1) {
    super(void 0, t), this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
LightProbe.prototype.isLightProbe = !0;
class MaterialLoader extends Loader {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, i, n) {
    const r = this, s = new FileLoader(r.manager);
    s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(e, function(a) {
      try {
        t(r.parse(JSON.parse(a)));
      } catch (l) {
        n ? n(l) : console.error(l), r.manager.itemError(e);
      }
    }, i, n);
  }
  parse(e) {
    const t = this.textures;
    function i(r) {
      return t[r] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", r), t[r];
    }
    const n = new Materials[e.type]();
    if (e.uuid !== void 0 && (n.uuid = e.uuid), e.name !== void 0 && (n.name = e.name), e.color !== void 0 && n.color !== void 0 && n.color.setHex(e.color), e.roughness !== void 0 && (n.roughness = e.roughness), e.metalness !== void 0 && (n.metalness = e.metalness), e.sheen !== void 0 && (n.sheen = new Color().setHex(e.sheen)), e.emissive !== void 0 && n.emissive !== void 0 && n.emissive.setHex(e.emissive), e.specular !== void 0 && n.specular !== void 0 && n.specular.setHex(e.specular), e.shininess !== void 0 && (n.shininess = e.shininess), e.clearcoat !== void 0 && (n.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = e.clearcoatRoughness), e.transmission !== void 0 && (n.transmission = e.transmission), e.thickness !== void 0 && (n.thickness = e.thickness), e.attenuationDistance !== void 0 && (n.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && n.attenuationColor !== void 0 && n.attenuationColor.setHex(e.attenuationColor), e.fog !== void 0 && (n.fog = e.fog), e.flatShading !== void 0 && (n.flatShading = e.flatShading), e.blending !== void 0 && (n.blending = e.blending), e.combine !== void 0 && (n.combine = e.combine), e.side !== void 0 && (n.side = e.side), e.shadowSide !== void 0 && (n.shadowSide = e.shadowSide), e.opacity !== void 0 && (n.opacity = e.opacity), e.transparent !== void 0 && (n.transparent = e.transparent), e.alphaTest !== void 0 && (n.alphaTest = e.alphaTest), e.depthTest !== void 0 && (n.depthTest = e.depthTest), e.depthWrite !== void 0 && (n.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (n.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (n.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (n.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (n.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (n.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (n.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (n.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (n.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (n.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (n.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (n.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (n.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (n.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (n.rotation = e.rotation), e.linewidth !== 1 && (n.linewidth = e.linewidth), e.dashSize !== void 0 && (n.dashSize = e.dashSize), e.gapSize !== void 0 && (n.gapSize = e.gapSize), e.scale !== void 0 && (n.scale = e.scale), e.polygonOffset !== void 0 && (n.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (n.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (n.polygonOffsetUnits = e.polygonOffsetUnits), e.morphTargets !== void 0 && (n.morphTargets = e.morphTargets), e.morphNormals !== void 0 && (n.morphNormals = e.morphNormals), e.dithering !== void 0 && (n.dithering = e.dithering), e.alphaToCoverage !== void 0 && (n.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (n.premultipliedAlpha = e.premultipliedAlpha), e.vertexTangents !== void 0 && (n.vertexTangents = e.vertexTangents), e.visible !== void 0 && (n.visible = e.visible), e.toneMapped !== void 0 && (n.toneMapped = e.toneMapped), e.userData !== void 0 && (n.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? n.vertexColors = e.vertexColors > 0 : n.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const r in e.uniforms) {
        const s = e.uniforms[r];
        switch (n.uniforms[r] = {}, s.type) {
          case "t":
            n.uniforms[r].value = i(s.value);
            break;
          case "c":
            n.uniforms[r].value = new Color().setHex(s.value);
            break;
          case "v2":
            n.uniforms[r].value = new Vector2().fromArray(s.value);
            break;
          case "v3":
            n.uniforms[r].value = new Vector3().fromArray(s.value);
            break;
          case "v4":
            n.uniforms[r].value = new Vector4().fromArray(s.value);
            break;
          case "m3":
            n.uniforms[r].value = new Matrix3().fromArray(s.value);
            break;
          case "m4":
            n.uniforms[r].value = new Matrix4().fromArray(s.value);
            break;
          default:
            n.uniforms[r].value = s.value;
        }
      }
    if (e.defines !== void 0 && (n.defines = e.defines), e.vertexShader !== void 0 && (n.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (n.fragmentShader = e.fragmentShader), e.extensions !== void 0)
      for (const r in e.extensions)
        n.extensions[r] = e.extensions[r];
    if (e.shading !== void 0 && (n.flatShading = e.shading === 1), e.size !== void 0 && (n.size = e.size), e.sizeAttenuation !== void 0 && (n.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (n.map = i(e.map)), e.matcap !== void 0 && (n.matcap = i(e.matcap)), e.alphaMap !== void 0 && (n.alphaMap = i(e.alphaMap)), e.bumpMap !== void 0 && (n.bumpMap = i(e.bumpMap)), e.bumpScale !== void 0 && (n.bumpScale = e.bumpScale), e.normalMap !== void 0 && (n.normalMap = i(e.normalMap)), e.normalMapType !== void 0 && (n.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let r = e.normalScale;
      Array.isArray(r) === !1 && (r = [r, r]), n.normalScale = new Vector2().fromArray(r);
    }
    return e.displacementMap !== void 0 && (n.displacementMap = i(e.displacementMap)), e.displacementScale !== void 0 && (n.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (n.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (n.roughnessMap = i(e.roughnessMap)), e.metalnessMap !== void 0 && (n.metalnessMap = i(e.metalnessMap)), e.emissiveMap !== void 0 && (n.emissiveMap = i(e.emissiveMap)), e.emissiveIntensity !== void 0 && (n.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (n.specularMap = i(e.specularMap)), e.envMap !== void 0 && (n.envMap = i(e.envMap)), e.envMapIntensity !== void 0 && (n.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (n.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (n.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (n.lightMap = i(e.lightMap)), e.lightMapIntensity !== void 0 && (n.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (n.aoMap = i(e.aoMap)), e.aoMapIntensity !== void 0 && (n.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (n.gradientMap = i(e.gradientMap)), e.clearcoatMap !== void 0 && (n.clearcoatMap = i(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (n.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (n.clearcoatNormalMap = i(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (n.clearcoatNormalScale = new Vector2().fromArray(e.clearcoatNormalScale)), e.transmissionMap !== void 0 && (n.transmissionMap = i(e.transmissionMap)), e.thicknessMap !== void 0 && (n.thicknessMap = i(e.thicknessMap)), n;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
}
class LoaderUtils {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, n = e.length; i < n; i++)
      t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.substr(0, t + 1);
  }
}
class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = super.toJSON(this);
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
InstancedBufferGeometry.prototype.isInstancedBufferGeometry = !0;
class InstancedBufferAttribute extends BufferAttribute {
  constructor(e, t, i, n = 1) {
    typeof i == "number" && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, t, i), this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
InstancedBufferAttribute.prototype.isInstancedBufferAttribute = !0;
class BufferGeometryLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, s = new FileLoader(r.manager);
    s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(e, function(a) {
      try {
        t(r.parse(JSON.parse(a)));
      } catch (l) {
        n ? n(l) : console.error(l), r.manager.itemError(e);
      }
    }, i, n);
  }
  parse(e) {
    const t = {}, i = {};
    function n(f, p) {
      if (t[p] !== void 0) return t[p];
      const v = f.interleavedBuffers[p], y = r(f, v.buffer), g = getTypedArray(v.type, y), _ = new InterleavedBuffer(g, v.stride);
      return _.uuid = v.uuid, t[p] = _, _;
    }
    function r(f, p) {
      if (i[p] !== void 0) return i[p];
      const v = f.arrayBuffers[p], y = new Uint32Array(v).buffer;
      return i[p] = y, y;
    }
    const s = e.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry(), a = e.data.index;
    if (a !== void 0) {
      const f = getTypedArray(a.type, a.array);
      s.setIndex(new BufferAttribute(f, 1));
    }
    const l = e.data.attributes;
    for (const f in l) {
      const p = l[f];
      let m;
      if (p.isInterleavedBufferAttribute) {
        const v = n(e.data, p.data);
        m = new InterleavedBufferAttribute(v, p.itemSize, p.offset, p.normalized);
      } else {
        const v = getTypedArray(p.type, p.array), y = p.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
        m = new y(v, p.itemSize, p.normalized);
      }
      p.name !== void 0 && (m.name = p.name), p.usage !== void 0 && m.setUsage(p.usage), p.updateRange !== void 0 && (m.updateRange.offset = p.updateRange.offset, m.updateRange.count = p.updateRange.count), s.setAttribute(f, m);
    }
    const c = e.data.morphAttributes;
    if (c)
      for (const f in c) {
        const p = c[f], m = [];
        for (let v = 0, y = p.length; v < y; v++) {
          const g = p[v];
          let _;
          if (g.isInterleavedBufferAttribute) {
            const b = n(e.data, g.data);
            _ = new InterleavedBufferAttribute(b, g.itemSize, g.offset, g.normalized);
          } else {
            const b = getTypedArray(g.type, g.array);
            _ = new BufferAttribute(b, g.itemSize, g.normalized);
          }
          g.name !== void 0 && (_.name = g.name), m.push(_);
        }
        s.morphAttributes[f] = m;
      }
    e.data.morphTargetsRelative && (s.morphTargetsRelative = !0);
    const h = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (h !== void 0)
      for (let f = 0, p = h.length; f !== p; ++f) {
        const m = h[f];
        s.addGroup(m.start, m.count, m.materialIndex);
      }
    const d = e.data.boundingSphere;
    if (d !== void 0) {
      const f = new Vector3();
      d.center !== void 0 && f.fromArray(d.center), s.boundingSphere = new Sphere(f, d.radius);
    }
    return e.name && (s.name = e.name), e.userData && (s.userData = e.userData), s;
  }
}
class ObjectLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, s = this.path === "" ? LoaderUtils.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || s;
    const a = new FileLoader(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
      let c = null;
      try {
        c = JSON.parse(l);
      } catch (h) {
        n !== void 0 && n(h), console.error("THREE:ObjectLoader: Can't parse " + e + ".", h.message);
        return;
      }
      const u = c.metadata;
      if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      r.parse(c, t);
    }, i, n);
  }
  async loadAsync(e, t) {
    const i = this, n = this.path === "" ? LoaderUtils.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || n;
    const r = new FileLoader(this.manager);
    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
    const s = await r.loadAsync(e, t), a = JSON.parse(s), l = a.metadata;
    if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await i.parseAsync(a);
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, n), s = this.parseImages(e.images, function() {
      t !== void 0 && t(c);
    }), a = this.parseTextures(e.textures, s), l = this.parseMaterials(e.materials, a), c = this.parseObject(e.object, r, l, a, i), u = this.parseSkeletons(e.skeletons, c);
    if (this.bindSkeletons(c, u), t !== void 0) {
      let h = !1;
      for (const d in s)
        if (s[d] instanceof HTMLImageElement) {
          h = !0;
          break;
        }
      h === !1 && t(c);
    }
    return c;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), n = this.parseGeometries(e.geometries, i), r = await this.parseImagesAsync(e.images), s = this.parseTextures(e.textures, r), a = this.parseMaterials(e.materials, s), l = this.parseObject(e.object, n, a, s, t), c = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, c), l;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0, n = e.length; i < n; i++) {
        const r = new Shape$1().fromJSON(e[i]);
        t[r.uuid] = r;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const i = {}, n = {};
    if (t.traverse(function(r) {
      r.isBone && (n[r.uuid] = r);
    }), e !== void 0)
      for (let r = 0, s = e.length; r < s; r++) {
        const a = new Skeleton().fromJSON(e[r], n);
        i[a.uuid] = a;
      }
    return i;
  }
  parseGeometries(e, t) {
    const i = {};
    if (e !== void 0) {
      const n = new BufferGeometryLoader();
      for (let r = 0, s = e.length; r < s; r++) {
        let a;
        const l = e[r];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = n.parse(l);
            break;
          case "Geometry":
            console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
            break;
          default:
            l.type in Geometries ? a = Geometries[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`);
        }
        a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), a.isBufferGeometry === !0 && l.userData !== void 0 && (a.userData = l.userData), i[l.uuid] = a;
      }
    }
    return i;
  }
  parseMaterials(e, t) {
    const i = {}, n = {};
    if (e !== void 0) {
      const r = new MaterialLoader();
      r.setTextures(t);
      for (let s = 0, a = e.length; s < a; s++) {
        const l = e[s];
        if (l.type === "MultiMaterial") {
          const c = [];
          for (let u = 0; u < l.materials.length; u++) {
            const h = l.materials[u];
            i[h.uuid] === void 0 && (i[h.uuid] = r.parse(h)), c.push(i[h.uuid]);
          }
          n[l.uuid] = c;
        } else
          i[l.uuid] === void 0 && (i[l.uuid] = r.parse(l)), n[l.uuid] = i[l.uuid];
      }
    }
    return n;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0; i < e.length; i++) {
        const n = e[i], r = AnimationClip.parse(n);
        t[r.uuid] = r;
      }
    return t;
  }
  parseImages(e, t) {
    const i = this, n = {};
    let r;
    function s(l) {
      return i.manager.itemStart(l), r.load(l, function() {
        i.manager.itemEnd(l);
      }, void 0, function() {
        i.manager.itemError(l), i.manager.itemEnd(l);
      });
    }
    function a(l) {
      if (typeof l == "string") {
        const c = l, u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : i.resourcePath + c;
        return s(u);
      } else
        return l.data ? {
          data: getTypedArray(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new LoadingManager(t);
      r = new ImageLoader(l), r.setCrossOrigin(this.crossOrigin);
      for (let c = 0, u = e.length; c < u; c++) {
        const h = e[c], d = h.url;
        if (Array.isArray(d)) {
          n[h.uuid] = [];
          for (let f = 0, p = d.length; f < p; f++) {
            const m = d[f], v = a(m);
            v !== null && (v instanceof HTMLImageElement ? n[h.uuid].push(v) : n[h.uuid].push(new DataTexture(v.data, v.width, v.height)));
          }
        } else {
          const f = a(h.url);
          f !== null && (n[h.uuid] = f);
        }
      }
    }
    return n;
  }
  async parseImagesAsync(e) {
    const t = this, i = {};
    let n;
    async function r(s) {
      if (typeof s == "string") {
        const a = s, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await n.loadAsync(l);
      } else
        return s.data ? {
          data: getTypedArray(s.type, s.data),
          width: s.width,
          height: s.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      n = new ImageLoader(this.manager), n.setCrossOrigin(this.crossOrigin);
      for (let s = 0, a = e.length; s < a; s++) {
        const l = e[s], c = l.url;
        if (Array.isArray(c)) {
          i[l.uuid] = [];
          for (let u = 0, h = c.length; u < h; u++) {
            const d = c[u], f = await r(d);
            f !== null && (f instanceof HTMLImageElement ? i[l.uuid].push(f) : i[l.uuid].push(new DataTexture(f.data, f.width, f.height)));
          }
        } else {
          const u = await r(l.url);
          u !== null && (i[l.uuid] = u);
        }
      }
    }
    return i;
  }
  parseTextures(e, t) {
    function i(r, s) {
      return typeof r == "number" ? r : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", r), s[r]);
    }
    const n = {};
    if (e !== void 0)
      for (let r = 0, s = e.length; r < s; r++) {
        const a = e[r];
        a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
        let l;
        const c = t[a.image];
        Array.isArray(c) ? (l = new CubeTexture(c), c.length === 6 && (l.needsUpdate = !0)) : (c && c.data ? l = new DataTexture(c.data, c.width, c.height) : l = new Texture(c), c && (l.needsUpdate = !0)), l.uuid = a.uuid, a.name !== void 0 && (l.name = a.name), a.mapping !== void 0 && (l.mapping = i(a.mapping, TEXTURE_MAPPING)), a.offset !== void 0 && l.offset.fromArray(a.offset), a.repeat !== void 0 && l.repeat.fromArray(a.repeat), a.center !== void 0 && l.center.fromArray(a.center), a.rotation !== void 0 && (l.rotation = a.rotation), a.wrap !== void 0 && (l.wrapS = i(a.wrap[0], TEXTURE_WRAPPING), l.wrapT = i(a.wrap[1], TEXTURE_WRAPPING)), a.format !== void 0 && (l.format = a.format), a.type !== void 0 && (l.type = a.type), a.encoding !== void 0 && (l.encoding = a.encoding), a.minFilter !== void 0 && (l.minFilter = i(a.minFilter, TEXTURE_FILTER)), a.magFilter !== void 0 && (l.magFilter = i(a.magFilter, TEXTURE_FILTER)), a.anisotropy !== void 0 && (l.anisotropy = a.anisotropy), a.flipY !== void 0 && (l.flipY = a.flipY), a.premultiplyAlpha !== void 0 && (l.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (l.unpackAlignment = a.unpackAlignment), n[a.uuid] = l;
      }
    return n;
  }
  parseObject(e, t, i, n, r) {
    let s;
    function a(d) {
      return t[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", d), t[d];
    }
    function l(d) {
      if (d !== void 0) {
        if (Array.isArray(d)) {
          const f = [];
          for (let p = 0, m = d.length; p < m; p++) {
            const v = d[p];
            i[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", v), f.push(i[v]);
          }
          return f;
        }
        return i[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", d), i[d];
      }
    }
    function c(d) {
      return n[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", d), n[d];
    }
    let u, h;
    switch (e.type) {
      case "Scene":
        s = new Scene$1(), e.background !== void 0 && (Number.isInteger(e.background) ? s.background = new Color(e.background) : s.background = c(e.background)), e.environment !== void 0 && (s.environment = c(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? s.fog = new Fog(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (s.fog = new FogExp2(e.fog.color, e.fog.density)));
        break;
      case "PerspectiveCamera":
        s = new PerspectiveCamera(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (s.focus = e.focus), e.zoom !== void 0 && (s.zoom = e.zoom), e.filmGauge !== void 0 && (s.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (s.filmOffset = e.filmOffset), e.view !== void 0 && (s.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        s = new OrthographicCamera(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (s.zoom = e.zoom), e.view !== void 0 && (s.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        s = new AmbientLight(e.color, e.intensity);
        break;
      case "DirectionalLight":
        s = new DirectionalLight(e.color, e.intensity);
        break;
      case "PointLight":
        s = new PointLight(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        s = new RectAreaLight(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        s = new SpotLight(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        s = new HemisphereLight(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        s = new LightProbe().fromJSON(e);
        break;
      case "SkinnedMesh":
        u = a(e.geometry), h = l(e.material), s = new SkinnedMesh(u, h), e.bindMode !== void 0 && (s.bindMode = e.bindMode), e.bindMatrix !== void 0 && s.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (s.skeleton = e.skeleton);
        break;
      case "Mesh":
        u = a(e.geometry), h = l(e.material), s = new Mesh(u, h);
        break;
      case "InstancedMesh":
        u = a(e.geometry), h = l(e.material);
        const d = e.count, f = e.instanceMatrix, p = e.instanceColor;
        s = new InstancedMesh(u, h, d), s.instanceMatrix = new BufferAttribute(new Float32Array(f.array), 16), p !== void 0 && (s.instanceColor = new BufferAttribute(new Float32Array(p.array), p.itemSize));
        break;
      case "LOD":
        s = new LOD();
        break;
      case "Line":
        s = new Line(a(e.geometry), l(e.material));
        break;
      case "LineLoop":
        s = new LineLoop(a(e.geometry), l(e.material));
        break;
      case "LineSegments":
        s = new LineSegments(a(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        s = new Points(a(e.geometry), l(e.material));
        break;
      case "Sprite":
        s = new Sprite(l(e.material));
        break;
      case "Group":
        s = new Group();
        break;
      case "Bone":
        s = new Bone();
        break;
      default:
        s = new Object3D();
    }
    if (s.uuid = e.uuid, e.name !== void 0 && (s.name = e.name), e.matrix !== void 0 ? (s.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (s.matrixAutoUpdate = e.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (e.position !== void 0 && s.position.fromArray(e.position), e.rotation !== void 0 && s.rotation.fromArray(e.rotation), e.quaternion !== void 0 && s.quaternion.fromArray(e.quaternion), e.scale !== void 0 && s.scale.fromArray(e.scale)), e.castShadow !== void 0 && (s.castShadow = e.castShadow), e.receiveShadow !== void 0 && (s.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (s.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (s.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (s.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && s.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (s.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (s.visible = e.visible), e.frustumCulled !== void 0 && (s.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (s.renderOrder = e.renderOrder), e.userData !== void 0 && (s.userData = e.userData), e.layers !== void 0 && (s.layers.mask = e.layers), e.children !== void 0) {
      const d = e.children;
      for (let f = 0; f < d.length; f++)
        s.add(this.parseObject(d[f], t, i, n, r));
    }
    if (e.animations !== void 0) {
      const d = e.animations;
      for (let f = 0; f < d.length; f++) {
        const p = d[f];
        s.animations.push(r[p]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (s.autoUpdate = e.autoUpdate);
      const d = e.levels;
      for (let f = 0; f < d.length; f++) {
        const p = d[f], m = s.getObjectByProperty("uuid", p.object);
        m !== void 0 && s.addLevel(m, p.distance);
      }
    }
    return s;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(i) {
      if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
        const n = t[i.skeleton];
        n === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(n, i.bindMatrix);
      }
    });
  }
  /* DEPRECATED */
  setTexturePath(e) {
    return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e);
  }
}
const TEXTURE_MAPPING = {
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  CubeUVReflectionMapping,
  CubeUVRefractionMapping
}, TEXTURE_WRAPPING = {
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping
}, TEXTURE_FILTER = {
  NearestFilter,
  NearestMipmapNearestFilter,
  NearestMipmapLinearFilter,
  LinearFilter,
  LinearMipmapNearestFilter,
  LinearMipmapLinearFilter
};
class ImageBitmapLoader extends Loader {
  constructor(e) {
    super(e), typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, i, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, s = Cache.get(e);
    if (s !== void 0)
      return r.manager.itemStart(e), setTimeout(function() {
        t && t(s), r.manager.itemEnd(e);
      }, 0), s;
    const a = {};
    a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then(function(l) {
      return l.blob();
    }).then(function(l) {
      return createImageBitmap(l, Object.assign(r.options, { colorSpaceConversion: "none" }));
    }).then(function(l) {
      Cache.add(e, l), t && t(l), r.manager.itemEnd(e);
    }).catch(function(l) {
      n && n(l), r.manager.itemError(e), r.manager.itemEnd(e);
    }), r.manager.itemStart(e);
  }
}
ImageBitmapLoader.prototype.isImageBitmapLoader = !0;
class ShapePath {
  constructor() {
    this.type = "ShapePath", this.color = new Color(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new Path(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, i, n) {
    return this.currentPath.quadraticCurveTo(e, t, i, n), this;
  }
  bezierCurveTo(e, t, i, n, r, s) {
    return this.currentPath.bezierCurveTo(e, t, i, n, r, s), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e, t) {
    function i(g) {
      const _ = [];
      for (let b = 0, S = g.length; b < S; b++) {
        const x = g[b], M = new Shape$1();
        M.curves = x.curves, _.push(M);
      }
      return _;
    }
    function n(g, _) {
      const b = _.length;
      let S = !1;
      for (let x = b - 1, M = 0; M < b; x = M++) {
        let w = _[x], D = _[M], B = D.x - w.x, z = D.y - w.y;
        if (Math.abs(z) > Number.EPSILON) {
          if (z < 0 && (w = _[M], B = -B, D = _[x], z = -z), g.y < w.y || g.y > D.y) continue;
          if (g.y === w.y) {
            if (g.x === w.x) return !0;
          } else {
            const F = z * (g.x - w.x) - B * (g.y - w.y);
            if (F === 0) return !0;
            if (F < 0) continue;
            S = !S;
          }
        } else {
          if (g.y !== w.y) continue;
          if (D.x <= g.x && g.x <= w.x || w.x <= g.x && g.x <= D.x) return !0;
        }
      }
      return S;
    }
    const r = ShapeUtils.isClockWise, s = this.subPaths;
    if (s.length === 0) return [];
    if (t === !0) return i(s);
    let a, l, c;
    const u = [];
    if (s.length === 1)
      return l = s[0], c = new Shape$1(), c.curves = l.curves, u.push(c), u;
    let h = !r(s[0].getPoints());
    h = e ? !h : h;
    const d = [], f = [];
    let p = [], m = 0, v;
    f[m] = void 0, p[m] = [];
    for (let g = 0, _ = s.length; g < _; g++)
      l = s[g], v = l.getPoints(), a = r(v), a = e ? !a : a, a ? (!h && f[m] && m++, f[m] = { s: new Shape$1(), p: v }, f[m].s.curves = l.curves, h && m++, p[m] = []) : p[m].push({ h: l, p: v[0] });
    if (!f[0]) return i(s);
    if (f.length > 1) {
      let g = !1;
      const _ = [];
      for (let b = 0, S = f.length; b < S; b++)
        d[b] = [];
      for (let b = 0, S = f.length; b < S; b++) {
        const x = p[b];
        for (let M = 0; M < x.length; M++) {
          const w = x[M];
          let D = !0;
          for (let B = 0; B < f.length; B++)
            n(w.p, f[B].p) && (b !== B && _.push({ froms: b, tos: B, hole: M }), D ? (D = !1, d[B].push(w)) : g = !0);
          D && d[b].push(w);
        }
      }
      _.length > 0 && (g || (p = d));
    }
    let y;
    for (let g = 0, _ = f.length; g < _; g++) {
      c = f[g].s, u.push(c), y = p[g];
      for (let b = 0, S = y.length; b < S; b++)
        c.holes.push(y[b].h);
    }
    return u;
  }
}
class Font {
  constructor(e) {
    this.type = "Font", this.data = e;
  }
  generateShapes(e, t = 100) {
    const i = [], n = createPaths(e, t, this.data);
    for (let r = 0, s = n.length; r < s; r++)
      Array.prototype.push.apply(i, n[r].toShapes());
    return i;
  }
}
function createPaths(o, e, t) {
  const i = Array.from(o), n = e / t.resolution, r = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * n, s = [];
  let a = 0, l = 0;
  for (let c = 0; c < i.length; c++) {
    const u = i[c];
    if (u === `
`)
      a = 0, l -= r;
    else {
      const h = createPath(u, n, a, l, t);
      a += h.offsetX, s.push(h.path);
    }
  }
  return s;
}
function createPath(o, e, t, i, n) {
  const r = n.glyphs[o] || n.glyphs["?"];
  if (!r) {
    console.error('THREE.Font: character "' + o + '" does not exists in font family ' + n.familyName + ".");
    return;
  }
  const s = new ShapePath();
  let a, l, c, u, h, d, f, p;
  if (r.o) {
    const m = r._cachedOutline || (r._cachedOutline = r.o.split(" "));
    for (let v = 0, y = m.length; v < y; )
      switch (m[v++]) {
        case "m":
          a = m[v++] * e + t, l = m[v++] * e + i, s.moveTo(a, l);
          break;
        case "l":
          a = m[v++] * e + t, l = m[v++] * e + i, s.lineTo(a, l);
          break;
        case "q":
          c = m[v++] * e + t, u = m[v++] * e + i, h = m[v++] * e + t, d = m[v++] * e + i, s.quadraticCurveTo(h, d, c, u);
          break;
        case "b":
          c = m[v++] * e + t, u = m[v++] * e + i, h = m[v++] * e + t, d = m[v++] * e + i, f = m[v++] * e + t, p = m[v++] * e + i, s.bezierCurveTo(h, d, f, p, c, u);
          break;
      }
  }
  return { offsetX: r.ha * e, path: s };
}
Font.prototype.isFont = !0;
class FontLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, s = new FileLoader(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(r.withCredentials), s.load(e, function(a) {
      let l;
      try {
        l = JSON.parse(a);
      } catch {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), l = JSON.parse(a.substring(65, a.length - 2));
      }
      const c = r.parse(l);
      t && t(c);
    }, i, n);
  }
  parse(e) {
    return new Font(e);
  }
}
let _context;
const AudioContext = {
  getContext: function() {
    return _context === void 0 && (_context = new (window.AudioContext || window.webkitAudioContext)()), _context;
  },
  setContext: function(o) {
    _context = o;
  }
};
class AudioLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const r = this, s = new FileLoader(this.manager);
    s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function(a) {
      try {
        const l = a.slice(0);
        AudioContext.getContext().decodeAudioData(l, function(u) {
          t(u);
        });
      } catch (l) {
        n ? n(l) : console.error(l), r.manager.itemError(e);
      }
    }, i, n);
  }
}
class HemisphereLightProbe extends LightProbe {
  constructor(e, t, i = 1) {
    super(void 0, i);
    const n = new Color().set(e), r = new Color().set(t), s = new Vector3(n.r, n.g, n.b), a = new Vector3(r.r, r.g, r.b), l = Math.sqrt(Math.PI), c = l * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(s).add(a).multiplyScalar(l), this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(c);
  }
}
HemisphereLightProbe.prototype.isHemisphereLightProbe = !0;
class AmbientLightProbe extends LightProbe {
  constructor(e, t = 1) {
    super(void 0, t);
    const i = new Color().set(e);
    this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
AmbientLightProbe.prototype.isAmbientLightProbe = !0;
const _eyeRight = /* @__PURE__ */ new Matrix4(), _eyeLeft = /* @__PURE__ */ new Matrix4();
class StereoCamera {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new PerspectiveCamera(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new PerspectiveCamera(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep;
      const n = e.projectionMatrix.clone(), r = t.eyeSep / 2, s = r * t.near / t.focus, a = t.near * Math.tan(DEG2RAD * t.fov * 0.5) / t.zoom;
      let l, c;
      _eyeLeft.elements[12] = -r, _eyeRight.elements[12] = r, l = -a * t.aspect + s, c = a * t.aspect + s, n.elements[0] = 2 * t.near / (c - l), n.elements[8] = (c + l) / (c - l), this.cameraL.projectionMatrix.copy(n), l = -a * t.aspect - s, c = a * t.aspect - s, n.elements[0] = 2 * t.near / (c - l), n.elements[8] = (c + l) / (c - l), this.cameraR.projectionMatrix.copy(n);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(_eyeLeft), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(_eyeRight);
  }
}
class Clock {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = now$3(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = now$3();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function now$3() {
  return (typeof performance > "u" ? Date : performance).now();
}
const _position$1 = /* @__PURE__ */ new Vector3(), _quaternion$1 = /* @__PURE__ */ new Quaternion(), _scale$1 = /* @__PURE__ */ new Vector3(), _orientation$1 = /* @__PURE__ */ new Vector3();
class AudioListener extends Object3D {
  constructor() {
    super(), this.type = "AudioListener", this.context = AudioContext.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Clock();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, i = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1), _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1), t.positionX) {
      const n = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(_position$1.x, n), t.positionY.linearRampToValueAtTime(_position$1.y, n), t.positionZ.linearRampToValueAtTime(_position$1.z, n), t.forwardX.linearRampToValueAtTime(_orientation$1.x, n), t.forwardY.linearRampToValueAtTime(_orientation$1.y, n), t.forwardZ.linearRampToValueAtTime(_orientation$1.z, n), t.upX.linearRampToValueAtTime(i.x, n), t.upY.linearRampToValueAtTime(i.y, n), t.upZ.linearRampToValueAtTime(i.z, n);
    } else
      t.setPosition(_position$1.x, _position$1.y, _position$1.z), t.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, i.x, i.y, i.z);
  }
}
let Audio$1 = class extends Object3D {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else
      this.source.disconnect(this.getOutput());
    return this._connected = !1, this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
};
const _position = /* @__PURE__ */ new Vector3(), _quaternion = /* @__PURE__ */ new Quaternion(), _scale = /* @__PURE__ */ new Vector3(), _orientation = /* @__PURE__ */ new Vector3();
class PositionalAudio extends Audio$1 {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, i) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
    this.matrixWorld.decompose(_position, _quaternion, _scale), _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
    const t = this.panner;
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(_position.x, i), t.positionY.linearRampToValueAtTime(_position.y, i), t.positionZ.linearRampToValueAtTime(_position.z, i), t.orientationX.linearRampToValueAtTime(_orientation.x, i), t.orientationY.linearRampToValueAtTime(_orientation.y, i), t.orientationZ.linearRampToValueAtTime(_orientation.z, i);
    } else
      t.setPosition(_position.x, _position.y, _position.z), t.setOrientation(_orientation.x, _orientation.y, _orientation.z);
  }
}
class AudioAnalyser {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let i = 0; i < t.length; i++)
      e += t[i];
    return e / t.length;
  }
}
class PropertyMixer {
  constructor(e, t, i) {
    this.binding = e, this.valueSize = i;
    let n, r, s;
    switch (t) {
      case "quaternion":
        n = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        n = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5);
        break;
      default:
        n = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5);
    }
    this._mixBufferRegion = n, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const i = this.buffer, n = this.valueSize, r = e * n + n;
    let s = this.cumulativeWeight;
    if (s === 0) {
      for (let a = 0; a !== n; ++a)
        i[r + a] = i[a];
      s = t;
    } else {
      s += t;
      const a = t / s;
      this._mixBufferRegion(i, r, 0, a, n);
    }
    this.cumulativeWeight = s;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, i = this.valueSize, n = i * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, n, 0, e, i), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, i = this.buffer, n = e * t + t, r = this.cumulativeWeight, s = this.cumulativeWeightAdditive, a = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
      const l = t * this._origIndex;
      this._mixBufferRegion(
        i,
        n,
        l,
        1 - r,
        t
      );
    }
    s > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * t, 1, t);
    for (let l = t, c = t + t; l !== c; ++l)
      if (i[l] !== i[l + t]) {
        a.setValue(i, n);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, i = this.valueSize, n = i * this._origIndex;
    e.getValue(t, n);
    for (let r = i, s = n; r !== s; ++r)
      t[r] = t[n + r % i];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let i = e; i < t; i++)
      this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  // mix functions
  _select(e, t, i, n, r) {
    if (n >= 0.5)
      for (let s = 0; s !== r; ++s)
        e[t + s] = e[i + s];
  }
  _slerp(e, t, i, n) {
    Quaternion.slerpFlat(e, t, e, t, e, i, n);
  }
  _slerpAdditive(e, t, i, n, r) {
    const s = this._workIndex * r;
    Quaternion.multiplyQuaternionsFlat(e, s, e, t, e, i), Quaternion.slerpFlat(e, t, e, t, e, s, n);
  }
  _lerp(e, t, i, n, r) {
    const s = 1 - n;
    for (let a = 0; a !== r; ++a) {
      const l = t + a;
      e[l] = e[l] * s + e[i + a] * n;
    }
  }
  _lerpAdditive(e, t, i, n, r) {
    for (let s = 0; s !== r; ++s) {
      const a = t + s;
      e[a] = e[a] + e[i + s] * n;
    }
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/", _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g"), _wordChar = "[^" + _RESERVED_CHARS_RE + "]", _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]", _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar), _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot), _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar), _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar), _trackRe = new RegExp(
  "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
), _supportedObjectNames = ["material", "materials", "bones"];
class Composite {
  constructor(e, t, i) {
    const n = i || PropertyBinding.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, n);
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_, n = this._bindings[i];
    n !== void 0 && n.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
      i[n].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class PropertyBinding {
  constructor(e, t, i) {
    this.path = t, this.parsedPath = i || PropertyBinding.parseTrackName(t), this.node = PropertyBinding.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup ? new PropertyBinding.Composite(e, t, i) : new PropertyBinding(e, t, i);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(e) {
    const t = _trackRe.exec(e);
    if (!t)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, n = i.nodeName && i.nodeName.lastIndexOf(".");
    if (n !== void 0 && n !== -1) {
      const r = i.nodeName.substring(n + 1);
      _supportedObjectNames.indexOf(r) !== -1 && (i.nodeName = i.nodeName.substring(0, n), i.objectName = r);
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return i;
  }
  static findNode(e, t) {
    if (!t || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0)
        return i;
    }
    if (e.children) {
      const i = function(r) {
        for (let s = 0; s < r.length; s++) {
          const a = r[s];
          if (a.name === t || a.uuid === t)
            return a;
          const l = i(a.children);
          if (l) return l;
        }
        return null;
      }, n = i(e.children);
      if (n)
        return n;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.node[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n)
      e[t++] = i[n];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n)
      i[n] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n)
      i[n] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n)
      i[n] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, i = t.objectName, n = t.propertyName;
    let r = t.propertyIndex;
    if (e || (e = PropertyBinding.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (i) {
      let c = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === c) {
              c = u;
              break;
            }
          break;
        default:
          if (e[i] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[i];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[c];
      }
    }
    const s = e[n];
    if (s === void 0) {
      const c = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + n + " but it wasn't found.", e);
      return;
    }
    let a = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (r !== void 0) {
      if (n === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (e.geometry.isBufferGeometry) {
          if (!e.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r;
    } else s.fromArray !== void 0 && s.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (l = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class AnimationObjectGroup {
  constructor() {
    this.uuid = generateUUID$1(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let i = 0, n = arguments.length; i !== n; ++i)
      e[arguments[i].uuid] = i;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, i = this._paths, n = this._parsedPaths, r = this._bindings, s = r.length;
    let a, l = e.length, c = this.nCachedObjects_;
    for (let u = 0, h = arguments.length; u !== h; ++u) {
      const d = arguments[u], f = d.uuid;
      let p = t[f];
      if (p === void 0) {
        p = l++, t[f] = p, e.push(d);
        for (let m = 0, v = s; m !== v; ++m)
          r[m].push(new PropertyBinding(d, i[m], n[m]));
      } else if (p < c) {
        a = e[p];
        const m = --c, v = e[m];
        t[v.uuid] = p, e[p] = v, t[f] = m, e[m] = d;
        for (let y = 0, g = s; y !== g; ++y) {
          const _ = r[y], b = _[m];
          let S = _[p];
          _[p] = b, S === void 0 && (S = new PropertyBinding(d, i[y], n[y])), _[m] = S;
        }
      } else e[p] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = c;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, i = this._bindings, n = i.length;
    let r = this.nCachedObjects_;
    for (let s = 0, a = arguments.length; s !== a; ++s) {
      const l = arguments[s], c = l.uuid, u = t[c];
      if (u !== void 0 && u >= r) {
        const h = r++, d = e[h];
        t[d.uuid] = u, e[u] = d, t[c] = h, e[h] = l;
        for (let f = 0, p = n; f !== p; ++f) {
          const m = i[f], v = m[h], y = m[u];
          m[u] = v, m[h] = y;
        }
      }
    }
    this.nCachedObjects_ = r;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, i = this._bindings, n = i.length;
    let r = this.nCachedObjects_, s = e.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const c = arguments[a], u = c.uuid, h = t[u];
      if (h !== void 0)
        if (delete t[u], h < r) {
          const d = --r, f = e[d], p = --s, m = e[p];
          t[f.uuid] = h, e[h] = f, t[m.uuid] = d, e[d] = m, e.pop();
          for (let v = 0, y = n; v !== y; ++v) {
            const g = i[v], _ = g[d], b = g[p];
            g[h] = _, g[d] = b, g.pop();
          }
        } else {
          const d = --s, f = e[d];
          d > 0 && (t[f.uuid] = h), e[h] = f, e.pop();
          for (let p = 0, m = n; p !== m; ++p) {
            const v = i[p];
            v[h] = v[d], v.pop();
          }
        }
    }
    this.nCachedObjects_ = r;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const i = this._bindingsIndicesByPath;
    let n = i[e];
    const r = this._bindings;
    if (n !== void 0) return r[n];
    const s = this._paths, a = this._parsedPaths, l = this._objects, c = l.length, u = this.nCachedObjects_, h = new Array(c);
    n = r.length, i[e] = n, s.push(e), a.push(t), r.push(h);
    for (let d = u, f = l.length; d !== f; ++d) {
      const p = l[d];
      h[d] = new PropertyBinding(p, e, t);
    }
    return h;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, i = t[e];
    if (i !== void 0) {
      const n = this._paths, r = this._parsedPaths, s = this._bindings, a = s.length - 1, l = s[a], c = e[a];
      t[c] = i, s[i] = l, s.pop(), r[i] = r[a], r.pop(), n[i] = n[a], n.pop();
    }
  }
}
AnimationObjectGroup.prototype.isAnimationObjectGroup = !0;
class AnimationAction {
  constructor(e, t, i = null, n = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = n;
    const r = t.tracks, s = r.length, a = new Array(s), l = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let c = 0; c !== s; ++c) {
      const u = r[c].createInterpolant(null);
      a[c] = u, u.settings = l;
    }
    this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = LoopRepeat, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if (e.fadeOut(t), this.fadeIn(t), i) {
      const n = this._clip.duration, r = e._clip.duration, s = r / n, a = n / r;
      e.warp(1, s, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const n = this._mixer, r = n.time, s = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null && (a = n._lendControlInterpolant(), this._timeScaleInterpolant = a);
    const l = a.parameterPositions, c = a.sampleValues;
    return l[0] = r, l[1] = r + i, c[0] = e / s, c[1] = t / s, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, i, n) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const r = this._startTime;
    if (r !== null) {
      const l = (e - r) * i;
      if (l < 0 || i === 0)
        return;
      this._startTime = null, t = i * l;
    }
    t *= this._updateTimeScale(e);
    const s = this._updateTime(t), a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants, c = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let u = 0, h = l.length; u !== h; ++u)
            l[u].evaluate(s), c[u].accumulateAdditive(a);
          break;
        case NormalAnimationBlendMode:
        default:
          for (let u = 0, h = l.length; u !== h; ++u)
            l[u].evaluate(s), c[u].accumulate(n, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const n = i.evaluate(e)[0];
        t *= n, e > i.parameterPositions[1] && (this.stopFading(), n === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const n = i.evaluate(e)[0];
        t *= n, e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, i = this.loop;
    let n = this.time + e, r = this._loopCount;
    const s = i === LoopPingPong;
    if (e === 0)
      return r === -1 ? n : s && (r & 1) === 1 ? t - n : n;
    if (i === LoopOnce) {
      r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (n >= t)
          n = t;
        else if (n < 0)
          n = 0;
        else {
          this.time = n;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = n, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, s)) : this._setEndings(this.repetitions === 0, !0, s)), n >= t || n < 0) {
        const a = Math.floor(n / t);
        n -= t * a, r += Math.abs(a);
        const l = this.repetitions - r;
        if (l <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, n = e > 0 ? t : 0, this.time = n, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, s);
          } else
            this._setEndings(!1, !1, s);
          this._loopCount = r, this.time = n, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: a
          });
        }
      } else
        this.time = n;
      if (s && (r & 1) === 1)
        return t - n;
    }
    return n;
  }
  _setEndings(e, t, i) {
    const n = this._interpolantSettings;
    i ? (n.endingStart = ZeroSlopeEnding, n.endingEnd = ZeroSlopeEnding) : (e ? n.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding : n.endingStart = WrapAroundEnding, t ? n.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding : n.endingEnd = WrapAroundEnding);
  }
  _scheduleFading(e, t, i) {
    const n = this._mixer, r = n.time;
    let s = this._weightInterpolant;
    s === null && (s = n._lendControlInterpolant(), this._weightInterpolant = s);
    const a = s.parameterPositions, l = s.sampleValues;
    return a[0] = r, l[0] = t, a[1] = r + e, l[1] = i, this;
  }
}
class AnimationMixer extends EventDispatcher$1 {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root, n = e._clip.tracks, r = n.length, s = e._propertyBindings, a = e._interpolants, l = i.uuid, c = this._bindingsByRootAndName;
    let u = c[l];
    u === void 0 && (u = {}, c[l] = u);
    for (let h = 0; h !== r; ++h) {
      const d = n[h], f = d.name;
      let p = u[f];
      if (p !== void 0)
        s[h] = p;
      else {
        if (p = s[h], p !== void 0) {
          p._cacheIndex === null && (++p.referenceCount, this._addInactiveBinding(p, l, f));
          continue;
        }
        const m = t && t._propertyBindings[h].binding.parsedPath;
        p = new PropertyMixer(
          PropertyBinding.create(i, f, m),
          d.ValueTypeName,
          d.getValueSize()
        ), ++p.referenceCount, this._addInactiveBinding(p, l, f), s[h] = p;
      }
      a[h].resultBuffer = p.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid, n = e._clip.uuid, r = this._actionsByClip[n];
        this._bindAction(
          e,
          r && r.knownActions[0]
        ), this._addInactiveAction(e, n, i);
      }
      const t = e._propertyBindings;
      for (let i = 0, n = t.length; i !== n; ++i) {
        const r = t[i];
        r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, n = t.length; i !== n; ++i) {
        const r = t[i];
        --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const n = this._actions, r = this._actionsByClip;
    let s = r[t];
    if (s === void 0)
      s = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, r[t] = s;
    else {
      const a = s.knownActions;
      e._byClipCacheIndex = a.length, a.push(e);
    }
    e._cacheIndex = n.length, n.push(e), s.actionByRoot[i] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, i = t[t.length - 1], n = e._cacheIndex;
    i._cacheIndex = n, t[n] = i, t.pop(), e._cacheIndex = null;
    const r = e._clip.uuid, s = this._actionsByClip, a = s[r], l = a.knownActions, c = l[l.length - 1], u = e._byClipCacheIndex;
    c._byClipCacheIndex = u, l[u] = c, l.pop(), e._byClipCacheIndex = null;
    const h = a.actionByRoot, d = (e._localRoot || this._root).uuid;
    delete h[d], l.length === 0 && delete s[r], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, n = t.length; i !== n; ++i) {
      const r = t[i];
      --r.referenceCount === 0 && this._removeInactiveBinding(r);
    }
  }
  _lendAction(e) {
    const t = this._actions, i = e._cacheIndex, n = this._nActiveActions++, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  }
  _takeBackAction(e) {
    const t = this._actions, i = e._cacheIndex, n = --this._nActiveActions, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, i) {
    const n = this._bindingsByRootAndName, r = this._bindings;
    let s = n[t];
    s === void 0 && (s = {}, n[t] = s), s[i] = e, e._cacheIndex = r.length, r.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, i = e.binding, n = i.rootNode.uuid, r = i.path, s = this._bindingsByRootAndName, a = s[n], l = t[t.length - 1], c = e._cacheIndex;
    l._cacheIndex = c, t[c] = l, t.pop(), delete a[r], Object.keys(a).length === 0 && delete s[n];
  }
  _lendBinding(e) {
    const t = this._bindings, i = e._cacheIndex, n = this._nActiveBindings++, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  }
  _takeBackBinding(e) {
    const t = this._bindings, i = e._cacheIndex, n = --this._nActiveBindings, r = t[n];
    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let i = e[t];
    return i === void 0 && (i = new LinearInterpolant(
      new Float32Array(2),
      new Float32Array(2),
      1,
      this._controlInterpolantsResultBuffer
    ), i.__cacheIndex = t, e[t] = i), i;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, i = e.__cacheIndex, n = --this._nActiveControlInterpolants, r = t[n];
    e.__cacheIndex = n, t[n] = e, r.__cacheIndex = i, t[i] = r;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, i) {
    const n = t || this._root, r = n.uuid;
    let s = typeof e == "string" ? AnimationClip.findByName(n, e) : e;
    const a = s !== null ? s.uuid : e, l = this._actionsByClip[a];
    let c = null;
    if (i === void 0 && (s !== null ? i = s.blendMode : i = NormalAnimationBlendMode), l !== void 0) {
      const h = l.actionByRoot[r];
      if (h !== void 0 && h.blendMode === i)
        return h;
      c = l.knownActions[0], s === null && (s = c._clip);
    }
    if (s === null) return null;
    const u = new AnimationAction(this, s, t, i);
    return this._bindAction(u, c), this._addInactiveAction(u, a, r), u;
  }
  // get an existing action
  existingAction(e, t) {
    const i = t || this._root, n = i.uuid, r = typeof e == "string" ? AnimationClip.findByName(i, e) : e, s = r ? r.uuid : e, a = this._actionsByClip[s];
    return a !== void 0 && a.actionByRoot[n] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i)
      e[i].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), s = this._accuIndex ^= 1;
    for (let c = 0; c !== i; ++c)
      t[c]._update(n, e, r, s);
    const a = this._bindings, l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c)
      a[c].apply(s);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, i = e.uuid, n = this._actionsByClip, r = n[i];
    if (r !== void 0) {
      const s = r.knownActions;
      for (let a = 0, l = s.length; a !== l; ++a) {
        const c = s[a];
        this._deactivateAction(c);
        const u = c._cacheIndex, h = t[t.length - 1];
        c._cacheIndex = null, c._byClipCacheIndex = null, h._cacheIndex = u, t[u] = h, t.pop(), this._removeInactiveBindingsForAction(c);
      }
      delete n[i];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, i = this._actionsByClip;
    for (const s in i) {
      const a = i[s].actionByRoot, l = a[t];
      l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const n = this._bindingsByRootAndName, r = n[t];
    if (r !== void 0)
      for (const s in r) {
        const a = r[s];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
class Uniform {
  constructor(e) {
    typeof e == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e;
  }
  clone() {
    return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
  constructor(e, t, i = 1) {
    super(e, t), this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = !0;
class GLBufferAttribute {
  constructor(e, t, i, n, r) {
    this.buffer = e, this.type = t, this.itemSize = i, this.elementSize = n, this.count = r, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
GLBufferAttribute.prototype.isGLBufferAttribute = !0;
let Raycaster$1 = class {
  constructor(e, t, i = 0, n = 1 / 0) {
    this.ray = new Ray(e, t), this.near = i, this.far = n, this.camera = null, this.layers = new Layers(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !1, i = []) {
    return intersectObject(e, this, i, t), i.sort(ascSort), i;
  }
  intersectObjects(e, t = !1, i = []) {
    for (let n = 0, r = e.length; n < r; n++)
      intersectObject(e[n], this, i, t);
    return i.sort(ascSort), i;
  }
};
function ascSort(o, e) {
  return o.distance - e.distance;
}
function intersectObject(o, e, t, i) {
  if (o.layers.test(e.layers) && o.raycast(e, t), i === !0) {
    const n = o.children;
    for (let r = 0, s = n.length; r < s; r++)
      intersectObject(n[r], e, t, !0);
  }
}
class Spherical {
  constructor(e = 1, t = 0, i = 0) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  set(e, t, i) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be betwee EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(clamp(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Cylindrical {
  constructor(e = 1, t = 0, i = 0) {
    return this.radius = e, this.theta = t, this.y = i, this;
  }
  set(e, t, i) {
    return this.radius = e, this.theta = t, this.y = i, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$4 = /* @__PURE__ */ new Vector2();
class Box2 {
  constructor(e = new Vector2(1 / 0, 1 / 0), t = new Vector2(-1 / 0, -1 / 0)) {
    this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = _vector$4.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return _vector$4.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
Box2.prototype.isBox2 = !0;
const _startP = /* @__PURE__ */ new Vector3(), _startEnd = /* @__PURE__ */ new Vector3();
class Line3 {
  constructor(e = new Vector3(), t = new Vector3()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    _startP.subVectors(e, this.start), _startEnd.subVectors(this.end, this.start);
    const i = _startEnd.dot(_startEnd);
    let r = _startEnd.dot(_startP) / i;
    return t && (r = clamp(r, 0, 1)), r;
  }
  closestPointToPoint(e, t, i) {
    const n = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(n).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ImmediateRenderObject extends Object3D {
  constructor(e) {
    super(), this.material = e, this.render = function() {
    }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
  }
}
ImmediateRenderObject.prototype.isImmediateRenderObject = !0;
const _vector$3 = /* @__PURE__ */ new Vector3();
class SpotLightHelper extends Object3D {
  constructor(e, t) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
    const i = new BufferGeometry(), n = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let s = 0, a = 1, l = 32; s < l; s++, a++) {
      const c = s / l * Math.PI * 2, u = a / l * Math.PI * 2;
      n.push(
        Math.cos(c),
        Math.sin(c),
        1,
        Math.cos(u),
        Math.sin(u),
        1
      );
    }
    i.setAttribute("position", new Float32BufferAttribute(n, 3));
    const r = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
    this.cone = new LineSegments(i, r), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateMatrixWorld();
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), _vector$3.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(_vector$3), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const _vector$2 = /* @__PURE__ */ new Vector3(), _boneMatrix = /* @__PURE__ */ new Matrix4(), _matrixWorldInv = /* @__PURE__ */ new Matrix4();
class SkeletonHelper extends LineSegments {
  constructor(e) {
    const t = getBoneList(e), i = new BufferGeometry(), n = [], r = [], s = new Color(0, 0, 1), a = new Color(0, 1, 0);
    for (let c = 0; c < t.length; c++) {
      const u = t[c];
      u.parent && u.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b));
    }
    i.setAttribute("position", new Float32BufferAttribute(n, 3)), i.setAttribute("color", new Float32BufferAttribute(r, 3));
    const l = new LineBasicMaterial({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(i, l), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, i = this.geometry, n = i.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let r = 0, s = 0; r < t.length; r++) {
      const a = t[r];
      a.parent && a.parent.isBone && (_boneMatrix.multiplyMatrices(_matrixWorldInv, a.matrixWorld), _vector$2.setFromMatrixPosition(_boneMatrix), n.setXYZ(s, _vector$2.x, _vector$2.y, _vector$2.z), _boneMatrix.multiplyMatrices(_matrixWorldInv, a.parent.matrixWorld), _vector$2.setFromMatrixPosition(_boneMatrix), n.setXYZ(s + 1, _vector$2.x, _vector$2.y, _vector$2.z), s += 2);
    }
    i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
}
function getBoneList(o) {
  const e = [];
  o && o.isBone && e.push(o);
  for (let t = 0; t < o.children.length; t++)
    e.push.apply(e, getBoneList(o.children[t]));
  return e;
}
class PointLightHelper extends Mesh {
  constructor(e, t, i) {
    const n = new SphereGeometry(t, 4, 2), r = new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(n, r), this.light = e, this.light.updateMatrixWorld(), this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const _vector$1 = /* @__PURE__ */ new Vector3(), _color1 = /* @__PURE__ */ new Color(), _color2 = /* @__PURE__ */ new Color();
class HemisphereLightHelper extends Object3D {
  constructor(e, t, i) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i;
    const n = new OctahedronGeometry(t);
    n.rotateY(Math.PI * 0.5), this.material = new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const r = n.getAttribute("position"), s = new Float32Array(r.count * 3);
    n.setAttribute("color", new BufferAttribute(s, 3)), this.add(new Mesh(n, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      _color1.copy(this.light.color), _color2.copy(this.light.groundColor);
      for (let i = 0, n = t.count; i < n; i++) {
        const r = i < n / 2 ? _color1 : _color2;
        t.setXYZ(i, r.r, r.g, r.b);
      }
      t.needsUpdate = !0;
    }
    e.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class GridHelper extends LineSegments {
  constructor(e = 10, t = 10, i = 4473924, n = 8947848) {
    i = new Color(i), n = new Color(n);
    const r = t / 2, s = e / t, a = e / 2, l = [], c = [];
    for (let d = 0, f = 0, p = -a; d <= t; d++, p += s) {
      l.push(-a, 0, p, a, 0, p), l.push(p, 0, -a, p, 0, a);
      const m = d === r ? i : n;
      m.toArray(c, f), f += 3, m.toArray(c, f), f += 3, m.toArray(c, f), f += 3, m.toArray(c, f), f += 3;
    }
    const u = new BufferGeometry();
    u.setAttribute("position", new Float32BufferAttribute(l, 3)), u.setAttribute("color", new Float32BufferAttribute(c, 3));
    const h = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
    super(u, h), this.type = "GridHelper";
  }
}
class PolarGridHelper extends LineSegments {
  constructor(e = 10, t = 16, i = 8, n = 64, r = 4473924, s = 8947848) {
    r = new Color(r), s = new Color(s);
    const a = [], l = [];
    for (let h = 0; h <= t; h++) {
      const d = h / t * (Math.PI * 2), f = Math.sin(d) * e, p = Math.cos(d) * e;
      a.push(0, 0, 0), a.push(f, 0, p);
      const m = h & 1 ? r : s;
      l.push(m.r, m.g, m.b), l.push(m.r, m.g, m.b);
    }
    for (let h = 0; h <= i; h++) {
      const d = h & 1 ? r : s, f = e - e / i * h;
      for (let p = 0; p < n; p++) {
        let m = p / n * (Math.PI * 2), v = Math.sin(m) * f, y = Math.cos(m) * f;
        a.push(v, 0, y), l.push(d.r, d.g, d.b), m = (p + 1) / n * (Math.PI * 2), v = Math.sin(m) * f, y = Math.cos(m) * f, a.push(v, 0, y), l.push(d.r, d.g, d.b);
      }
    }
    const c = new BufferGeometry();
    c.setAttribute("position", new Float32BufferAttribute(a, 3)), c.setAttribute("color", new Float32BufferAttribute(l, 3));
    const u = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
    super(c, u), this.type = "PolarGridHelper";
  }
}
const _v1 = /* @__PURE__ */ new Vector3(), _v2 = /* @__PURE__ */ new Vector3(), _v3 = /* @__PURE__ */ new Vector3();
class DirectionalLightHelper extends Object3D {
  constructor(e, t, i) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, t === void 0 && (t = 1);
    let n = new BufferGeometry();
    n.setAttribute("position", new Float32BufferAttribute([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const r = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
    this.lightPlane = new Line(n, r), this.add(this.lightPlane), n = new BufferGeometry(), n.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Line(n, r), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    _v1.setFromMatrixPosition(this.light.matrixWorld), _v2.setFromMatrixPosition(this.light.target.matrixWorld), _v3.subVectors(_v2, _v1), this.lightPlane.lookAt(_v2), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(_v2), this.targetLine.scale.z = _v3.length();
  }
}
const _vector = /* @__PURE__ */ new Vector3(), _camera = /* @__PURE__ */ new Camera$1();
class CameraHelper extends LineSegments {
  constructor(e) {
    const t = new BufferGeometry(), i = new LineBasicMaterial({ color: 16777215, vertexColors: !0, toneMapped: !1 }), n = [], r = [], s = {}, a = new Color(16755200), l = new Color(16711680), c = new Color(43775), u = new Color(16777215), h = new Color(3355443);
    d("n1", "n2", a), d("n2", "n4", a), d("n4", "n3", a), d("n3", "n1", a), d("f1", "f2", a), d("f2", "f4", a), d("f4", "f3", a), d("f3", "f1", a), d("n1", "f1", a), d("n2", "f2", a), d("n3", "f3", a), d("n4", "f4", a), d("p", "n1", l), d("p", "n2", l), d("p", "n3", l), d("p", "n4", l), d("u1", "u2", c), d("u2", "u3", c), d("u3", "u1", c), d("c", "t", u), d("p", "c", h), d("cn1", "cn2", h), d("cn3", "cn4", h), d("cf1", "cf2", h), d("cf3", "cf4", h);
    function d(p, m, v) {
      f(p, v), f(m, v);
    }
    function f(p, m) {
      n.push(0, 0, 0), r.push(m.r, m.g, m.b), s[p] === void 0 && (s[p] = []), s[p].push(n.length / 3 - 1);
    }
    t.setAttribute("position", new Float32BufferAttribute(n, 3)), t.setAttribute("color", new Float32BufferAttribute(r, 3)), super(t, i), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update();
  }
  update() {
    const e = this.geometry, t = this.pointMap, i = 1, n = 1;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), setPoint("c", t, e, _camera, 0, 0, -1), setPoint("t", t, e, _camera, 0, 0, 1), setPoint("n1", t, e, _camera, -i, -n, -1), setPoint("n2", t, e, _camera, i, -n, -1), setPoint("n3", t, e, _camera, -i, n, -1), setPoint("n4", t, e, _camera, i, n, -1), setPoint("f1", t, e, _camera, -i, -n, 1), setPoint("f2", t, e, _camera, i, -n, 1), setPoint("f3", t, e, _camera, -i, n, 1), setPoint("f4", t, e, _camera, i, n, 1), setPoint("u1", t, e, _camera, i * 0.7, n * 1.1, -1), setPoint("u2", t, e, _camera, -i * 0.7, n * 1.1, -1), setPoint("u3", t, e, _camera, 0, n * 2, -1), setPoint("cf1", t, e, _camera, -i, 0, 1), setPoint("cf2", t, e, _camera, i, 0, 1), setPoint("cf3", t, e, _camera, 0, -n, 1), setPoint("cf4", t, e, _camera, 0, n, 1), setPoint("cn1", t, e, _camera, -i, 0, -1), setPoint("cn2", t, e, _camera, i, 0, -1), setPoint("cn3", t, e, _camera, 0, -n, -1), setPoint("cn4", t, e, _camera, 0, n, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function setPoint(o, e, t, i, n, r, s) {
  _vector.set(n, r, s).unproject(i);
  const a = e[o];
  if (a !== void 0) {
    const l = t.getAttribute("position");
    for (let c = 0, u = a.length; c < u; c++)
      l.setXYZ(a[c], _vector.x, _vector.y, _vector.z);
  }
}
const _box = /* @__PURE__ */ new Box3();
class BoxHelper extends LineSegments {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = new Float32Array(8 * 3), r = new BufferGeometry();
    r.setIndex(new BufferAttribute(i, 1)), r.setAttribute("position", new BufferAttribute(n, 3)), super(r, new LineBasicMaterial({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && _box.setFromObject(this.object), _box.isEmpty()) return;
    const t = _box.min, i = _box.max, n = this.geometry.attributes.position, r = n.array;
    r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = t.x, r[4] = i.y, r[5] = i.z, r[6] = t.x, r[7] = t.y, r[8] = i.z, r[9] = i.x, r[10] = t.y, r[11] = i.z, r[12] = i.x, r[13] = i.y, r[14] = t.z, r[15] = t.x, r[16] = i.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = i.x, r[22] = t.y, r[23] = t.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e) {
    return LineSegments.prototype.copy.call(this, e), this.object = e.object, this;
  }
}
class Box3Helper extends LineSegments {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], r = new BufferGeometry();
    r.setIndex(new BufferAttribute(i, 1)), r.setAttribute("position", new Float32BufferAttribute(n, 3)), super(r, new LineBasicMaterial({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
}
class PlaneHelper extends Line {
  constructor(e, t = 1, i = 16776960) {
    const n = i, r = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], s = new BufferGeometry();
    s.setAttribute("position", new Float32BufferAttribute(r, 3)), s.computeBoundingSphere(), super(s, new LineBasicMaterial({ color: n, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const a = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], l = new BufferGeometry();
    l.setAttribute("position", new Float32BufferAttribute(a, 3)), l.computeBoundingSphere(), this.add(new Mesh(l, new MeshBasicMaterial({ color: n, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    let t = -this.plane.constant;
    Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, t), this.children[0].material.side = t < 0 ? BackSide : FrontSide, this.lookAt(this.plane.normal), super.updateMatrixWorld(e);
  }
}
const _axis = /* @__PURE__ */ new Vector3();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
  // dir is assumed to be normalized
  constructor(e = new Vector3(0, 0, 1), t = new Vector3(0, 0, 0), i = 1, n = 16776960, r = i * 0.2, s = r * 0.2) {
    super(), this.type = "ArrowHelper", _lineGeometry === void 0 && (_lineGeometry = new BufferGeometry(), _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3)), _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1), _coneGeometry.translate(0, -0.5, 0)), this.position.copy(t), this.line = new Line(_lineGeometry, new LineBasicMaterial({ color: n, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color: n, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, r, s);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      _axis.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(_axis, t);
    }
  }
  setLength(e, t = e * 0.2, i = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
}
class AxesHelper extends LineSegments {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], i = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], n = new BufferGeometry();
    n.setAttribute("position", new Float32BufferAttribute(t, 3)), n.setAttribute("color", new Float32BufferAttribute(i, 3));
    const r = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
    super(n, r), this.type = "AxesHelper";
  }
  setColors(e, t, i) {
    const n = new Color(), r = this.geometry.attributes.color.array;
    return n.set(e), n.toArray(r, 0), n.toArray(r, 3), n.set(t), n.toArray(r, 6), n.toArray(r, 9), n.set(i), n.toArray(r, 12), n.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const _floatView = new Float32Array(1), _int32View = new Int32Array(_floatView.buffer);
class DataUtils {
  // Converts float32 to float16 (stored as uint16 value).
  static toHalfFloat(e) {
    _floatView[0] = e;
    const t = _int32View[0];
    let i = t >> 16 & 32768, n = t >> 12 & 2047;
    const r = t >> 23 & 255;
    return r < 103 ? i : r > 142 ? (i |= 31744, i |= (r == 255 ? 0 : 1) && t & 8388607, i) : r < 113 ? (n |= 2048, i |= (n >> 114 - r) + (n >> 113 - r & 1), i) : (i |= r - 112 << 10 | n >> 1, i += n & 1, i);
  }
}
const LOD_MIN = 4, LOD_MAX = 8, SIZE_MAX = Math.pow(2, LOD_MAX), EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length, MAX_SAMPLES = 20, ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
}, backgroundMaterial = new MeshBasicMaterial({
  side: BackSide,
  depthWrite: !1,
  depthTest: !1
}), backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial), _flatCamera = /* @__PURE__ */ new OrthographicCamera(), { _lodPlanes, _sizeLods, _sigmas } = /* @__PURE__ */ _createPlanes(), _clearColor = /* @__PURE__ */ new Color();
let _oldTarget = null;
const PHI = (1 + Math.sqrt(5)) / 2, INV_PHI = 1 / PHI, _axisDirections = [
  /* @__PURE__ */ new Vector3(1, 1, 1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
];
function convertLinearToRGBE(o) {
  const e = Math.max(o.r, o.g, o.b), t = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
  return o.multiplyScalar(Math.pow(2, -t)), (t + 128) / 255;
}
class PMREMGenerator {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = _getBlurShader(MAX_SAMPLES), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, i = 0.1, n = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    const r = this._allocateTargets();
    return this._sceneToCubeUV(e, i, n, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e) {
    return this._fromTexture(e);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e) {
    return this._fromTexture(e);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapShader === null && (this._cubemapShader = _getCubemapShader(), this._compileMaterial(this._cubemapShader));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectShader === null && (this._equirectShader = _getEquirectShader(), this._compileMaterial(this._equirectShader));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._blurMaterial.dispose(), this._cubemapShader !== null && this._cubemapShader.dispose(), this._equirectShader !== null && this._equirectShader.dispose();
    for (let e = 0; e < _lodPlanes.length; e++)
      _lodPlanes[e].dispose();
  }
  // private interface
  _cleanup(e) {
    this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(_oldTarget), e.scissorTest = !1, _setViewport(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e) {
    _oldTarget = this._renderer.getRenderTarget();
    const t = this._allocateTargets(e);
    return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t;
  }
  _allocateTargets(e) {
    const t = {
      magFilter: NearestFilter,
      minFilter: NearestFilter,
      generateMipmaps: !1,
      type: UnsignedByteType,
      format: RGBEFormat,
      encoding: _isLDR(e) ? e.encoding : RGBEEncoding,
      depthBuffer: !1
    }, i = _createRenderTarget(t);
    return i.depthBuffer = !e, this._pingPongRenderTarget = _createRenderTarget(t), i;
  }
  _compileMaterial(e) {
    const t = new Mesh(_lodPlanes[0], e);
    this._renderer.compile(t, _flatCamera);
  }
  _sceneToCubeUV(e, t, i, n) {
    const a = new PerspectiveCamera(90, 1, t, i), l = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], u = this._renderer, h = u.autoClear, d = u.outputEncoding, f = u.toneMapping;
    u.getClearColor(_clearColor), u.toneMapping = NoToneMapping, u.outputEncoding = LinearEncoding, u.autoClear = !1;
    let p = !1;
    const m = e.background;
    if (m) {
      if (m.isColor) {
        backgroundMaterial.color.copy(m).convertSRGBToLinear(), e.background = null;
        const v = convertLinearToRGBE(backgroundMaterial.color);
        backgroundMaterial.opacity = v, p = !0;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();
      const v = convertLinearToRGBE(backgroundMaterial.color);
      backgroundMaterial.opacity = v, p = !0;
    }
    for (let v = 0; v < 6; v++) {
      const y = v % 3;
      y == 0 ? (a.up.set(0, l[v], 0), a.lookAt(c[v], 0, 0)) : y == 1 ? (a.up.set(0, 0, l[v]), a.lookAt(0, c[v], 0)) : (a.up.set(0, l[v], 0), a.lookAt(0, 0, c[v])), _setViewport(
        n,
        y * SIZE_MAX,
        v > 2 ? SIZE_MAX : 0,
        SIZE_MAX,
        SIZE_MAX
      ), u.setRenderTarget(n), p && u.render(backgroundBox, a), u.render(e, a);
    }
    u.toneMapping = f, u.outputEncoding = d, u.autoClear = h;
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer;
    e.isCubeTexture ? this._cubemapShader == null && (this._cubemapShader = _getCubemapShader()) : this._equirectShader == null && (this._equirectShader = _getEquirectShader());
    const n = e.isCubeTexture ? this._cubemapShader : this._equirectShader, r = new Mesh(_lodPlanes[0], n), s = n.uniforms;
    s.envMap.value = e, e.isCubeTexture || s.texelSize.value.set(1 / e.image.width, 1 / e.image.height), s.inputEncoding.value = ENCODINGS[e.encoding], s.outputEncoding.value = ENCODINGS[t.texture.encoding], _setViewport(t, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX), i.setRenderTarget(t), i.render(r, _flatCamera);
  }
  _applyPMREM(e) {
    const t = this._renderer, i = t.autoClear;
    t.autoClear = !1;
    for (let n = 1; n < TOTAL_LODS; n++) {
      const r = Math.sqrt(_sigmas[n] * _sigmas[n] - _sigmas[n - 1] * _sigmas[n - 1]), s = _axisDirections[(n - 1) % _axisDirections.length];
      this._blur(e, n - 1, n, r, s);
    }
    t.autoClear = i;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, i, n, r) {
    const s = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      s,
      t,
      i,
      n,
      "latitudinal",
      r
    ), this._halfBlur(
      s,
      e,
      i,
      i,
      n,
      "longitudinal",
      r
    );
  }
  _halfBlur(e, t, i, n, r, s, a) {
    const l = this._renderer, c = this._blurMaterial;
    s !== "latitudinal" && s !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const u = 3, h = new Mesh(_lodPlanes[n], c), d = c.uniforms, f = _sizeLods[i] - 1, p = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * MAX_SAMPLES - 1), m = r / p, v = isFinite(r) ? 1 + Math.floor(u * m) : MAX_SAMPLES;
    v > MAX_SAMPLES && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${MAX_SAMPLES}`);
    const y = [];
    let g = 0;
    for (let x = 0; x < MAX_SAMPLES; ++x) {
      const M = x / m, w = Math.exp(-M * M / 2);
      y.push(w), x == 0 ? g += w : x < v && (g += 2 * w);
    }
    for (let x = 0; x < y.length; x++)
      y[x] = y[x] / g;
    d.envMap.value = e.texture, d.samples.value = v, d.weights.value = y, d.latitudinal.value = s === "latitudinal", a && (d.poleAxis.value = a), d.dTheta.value = p, d.mipInt.value = LOD_MAX - i, d.inputEncoding.value = ENCODINGS[e.texture.encoding], d.outputEncoding.value = ENCODINGS[e.texture.encoding];
    const _ = _sizeLods[n], b = 3 * Math.max(0, SIZE_MAX - 2 * _), S = (n === 0 ? 0 : 2 * SIZE_MAX) + 2 * _ * (n > LOD_MAX - LOD_MIN ? n - LOD_MAX + LOD_MIN : 0);
    _setViewport(t, b, S, 3 * _, 2 * _), l.setRenderTarget(t), l.render(h, _flatCamera);
  }
}
function _isLDR(o) {
  return o === void 0 || o.type !== UnsignedByteType ? !1 : o.encoding === LinearEncoding || o.encoding === sRGBEncoding || o.encoding === GammaEncoding;
}
function _createPlanes() {
  const o = [], e = [], t = [];
  let i = LOD_MAX;
  for (let n = 0; n < TOTAL_LODS; n++) {
    const r = Math.pow(2, i);
    e.push(r);
    let s = 1 / r;
    n > LOD_MAX - LOD_MIN ? s = EXTRA_LOD_SIGMA[n - LOD_MAX + LOD_MIN - 1] : n == 0 && (s = 0), t.push(s);
    const a = 1 / (r - 1), l = -a / 2, c = 1 + a / 2, u = [l, l, c, l, c, c, l, l, c, c, l, c], h = 6, d = 6, f = 3, p = 2, m = 1, v = new Float32Array(f * d * h), y = new Float32Array(p * d * h), g = new Float32Array(m * d * h);
    for (let b = 0; b < h; b++) {
      const S = b % 3 * 2 / 3 - 1, x = b > 2 ? 0 : -1, M = [
        S,
        x,
        0,
        S + 2 / 3,
        x,
        0,
        S + 2 / 3,
        x + 1,
        0,
        S,
        x,
        0,
        S + 2 / 3,
        x + 1,
        0,
        S,
        x + 1,
        0
      ];
      v.set(M, f * d * b), y.set(u, p * d * b);
      const w = [b, b, b, b, b, b];
      g.set(w, m * d * b);
    }
    const _ = new BufferGeometry();
    _.setAttribute("position", new BufferAttribute(v, f)), _.setAttribute("uv", new BufferAttribute(y, p)), _.setAttribute("faceIndex", new BufferAttribute(g, m)), o.push(_), i > LOD_MIN && i--;
  }
  return { _lodPlanes: o, _sizeLods: e, _sigmas: t };
}
function _createRenderTarget(o) {
  const e = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, o);
  return e.texture.mapping = CubeUVReflectionMapping, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e;
}
function _setViewport(o, e, t, i, n) {
  o.viewport.set(e, t, i, n), o.scissor.set(e, t, i, n);
}
function _getBlurShader(o) {
  const e = new Float32Array(o), t = new Vector3(0, 1, 0);
  return new RawShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: { n: o },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: e },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: t },
      inputEncoding: { value: ENCODINGS[LinearEncoding] },
      outputEncoding: { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`
    ),
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1
  });
}
function _getEquirectShader() {
  const o = new Vector2(1, 1);
  return new RawShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null },
      texelSize: { value: o },
      inputEncoding: { value: ENCODINGS[LinearEncoding] },
      outputEncoding: { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`
    ),
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1
  });
}
function _getCubemapShader() {
  return new RawShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      inputEncoding: { value: ENCODINGS[LinearEncoding] },
      outputEncoding: { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`
    ),
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1
  });
}
function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function _getEncodings() {
  return (
    /* glsl */
    `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`
  );
}
const LineStrip = 0, LinePieces = 1, NoColors = 0, FaceColors = 1, VertexColors = 2;
function MeshFaceMaterial(o) {
  return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), o;
}
function MultiMaterial(o = []) {
  return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), o.isMultiMaterial = !0, o.materials = o, o.clone = function() {
    return o.slice();
  }, o;
}
function PointCloud(o, e) {
  return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Points(o, e);
}
function Particle(o) {
  return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Sprite(o);
}
function ParticleSystem(o, e) {
  return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Points(o, e);
}
function PointCloudMaterial(o) {
  return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new PointsMaterial(o);
}
function ParticleBasicMaterial(o) {
  return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new PointsMaterial(o);
}
function ParticleSystemMaterial(o) {
  return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new PointsMaterial(o);
}
function Vertex(o, e, t) {
  return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Vector3(o, e, t);
}
function DynamicBufferAttribute(o, e) {
  return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new BufferAttribute(o, e).setUsage(DynamicDrawUsage);
}
function Int8Attribute(o, e) {
  return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Int8BufferAttribute(o, e);
}
function Uint8Attribute(o, e) {
  return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Uint8BufferAttribute(o, e);
}
function Uint8ClampedAttribute(o, e) {
  return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Uint8ClampedBufferAttribute(o, e);
}
function Int16Attribute(o, e) {
  return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Int16BufferAttribute(o, e);
}
function Uint16Attribute(o, e) {
  return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Uint16BufferAttribute(o, e);
}
function Int32Attribute(o, e) {
  return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Int32BufferAttribute(o, e);
}
function Uint32Attribute(o, e) {
  return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Uint32BufferAttribute(o, e);
}
function Float32Attribute(o, e) {
  return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Float32BufferAttribute(o, e);
}
function Float64Attribute(o, e) {
  return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Float64BufferAttribute(o, e);
}
Curve.create = function(o, e) {
  return console.log("THREE.Curve.create() has been deprecated"), o.prototype = Object.create(Curve.prototype), o.prototype.constructor = o, o.prototype.getPoint = e, o;
};
Path.prototype.fromPoints = function(o) {
  return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(o);
};
function AxisHelper(o) {
  return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new AxesHelper(o);
}
function BoundingBoxHelper(o, e) {
  return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new BoxHelper(o, e);
}
function EdgesHelper(o, e) {
  return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new LineSegments(new EdgesGeometry(o.geometry), new LineBasicMaterial({ color: e !== void 0 ? e : 16777215 }));
}
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
function WireframeHelper(o, e) {
  return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new LineSegments(new WireframeGeometry(o.geometry), new LineBasicMaterial({ color: e !== void 0 ? e : 16777215 }));
}
Loader.prototype.extractUrlBase = function(o) {
  return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), LoaderUtils.extractUrlBase(o);
};
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
function XHRLoader(o) {
  return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new FileLoader(o);
}
function BinaryTextureLoader(o) {
  return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new DataTextureLoader(o);
}
Box2.prototype.center = function(o) {
  return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(o);
};
Box2.prototype.empty = function() {
  return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
};
Box2.prototype.isIntersectionBox = function(o) {
  return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(o);
};
Box2.prototype.size = function(o) {
  return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(o);
};
Box3.prototype.center = function(o) {
  return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(o);
};
Box3.prototype.empty = function() {
  return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(o) {
  return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(o);
};
Box3.prototype.isIntersectionSphere = function(o) {
  return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(o);
};
Box3.prototype.size = function(o) {
  return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(o);
};
Sphere.prototype.empty = function() {
  return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
};
Frustum.prototype.setFromMatrix = function(o) {
  return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(o);
};
Line3.prototype.center = function(o) {
  return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(o);
};
Matrix3.prototype.flattenToArrayOffset = function(o, e) {
  return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(o, e);
};
Matrix3.prototype.multiplyVector3 = function(o) {
  return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), o.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Matrix3.prototype.applyToBufferAttribute = function(o) {
  return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), o.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Matrix3.prototype.getInverse = function(o) {
  return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(o).invert();
};
Matrix4.prototype.extractPosition = function(o) {
  return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(o);
};
Matrix4.prototype.flattenToArrayOffset = function(o, e) {
  return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(o, e);
};
Matrix4.prototype.getPosition = function() {
  return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new Vector3().setFromMatrixColumn(this, 3);
};
Matrix4.prototype.setRotationFromQuaternion = function(o) {
  return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(o);
};
Matrix4.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Matrix4.prototype.multiplyVector3 = function(o) {
  return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), o.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector4 = function(o) {
  return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), o.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Matrix4.prototype.rotateAxis = function(o) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), o.transformDirection(this);
};
Matrix4.prototype.crossVector = function(o) {
  return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), o.applyMatrix4(this);
};
Matrix4.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Matrix4.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Matrix4.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Matrix4.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Matrix4.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Matrix4.prototype.applyToBufferAttribute = function(o) {
  return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), o.applyMatrix4(this);
};
Matrix4.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Matrix4.prototype.makeFrustum = function(o, e, t, i, n, r) {
  return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(o, e, i, t, n, r);
};
Matrix4.prototype.getInverse = function(o) {
  return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(o).invert();
};
Plane.prototype.isIntersectionLine = function(o) {
  return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(o);
};
Quaternion.prototype.multiplyVector3 = function(o) {
  return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), o.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
  return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
};
Ray.prototype.isIntersectionBox = function(o) {
  return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(o);
};
Ray.prototype.isIntersectionPlane = function(o) {
  return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(o);
};
Ray.prototype.isIntersectionSphere = function(o) {
  return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(o);
};
Triangle.prototype.area = function() {
  return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(o, e) {
  return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(o, e);
};
Triangle.prototype.midpoint = function(o) {
  return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(o);
};
Triangle.prototypenormal = function(o) {
  return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(o);
};
Triangle.prototype.plane = function(o) {
  return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(o);
};
Triangle.barycoordFromPoint = function(o, e, t, i, n) {
  return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Triangle.getBarycoord(o, e, t, i, n);
};
Triangle.normal = function(o, e, t, i) {
  return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Triangle.getNormal(o, e, t, i);
};
Shape$1.prototype.extractAllPoints = function(o) {
  return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(o);
};
Shape$1.prototype.extrude = function(o) {
  return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new ExtrudeGeometry(this, o);
};
Shape$1.prototype.makeGeometry = function(o) {
  return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ShapeGeometry(this, o);
};
Vector2.prototype.fromAttribute = function(o, e, t) {
  return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(o, e, t);
};
Vector2.prototype.distanceToManhattan = function(o) {
  return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(o);
};
Vector2.prototype.lengthManhattan = function() {
  return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
};
Vector3.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
Vector3.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
Vector3.prototype.getPositionFromMatrix = function(o) {
  return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(o);
};
Vector3.prototype.getScaleFromMatrix = function(o) {
  return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(o);
};
Vector3.prototype.getColumnFromMatrix = function(o, e) {
  return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, o);
};
Vector3.prototype.applyProjection = function(o) {
  return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(o);
};
Vector3.prototype.fromAttribute = function(o, e, t) {
  return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(o, e, t);
};
Vector3.prototype.distanceToManhattan = function(o) {
  return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(o);
};
Vector3.prototype.lengthManhattan = function() {
  return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
};
Vector4.prototype.fromAttribute = function(o, e, t) {
  return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(o, e, t);
};
Vector4.prototype.lengthManhattan = function() {
  return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
};
Object3D.prototype.getChildByName = function(o) {
  return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(o);
};
Object3D.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
Object3D.prototype.translate = function(o, e) {
  return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, o);
};
Object3D.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
Object3D.prototype.applyMatrix = function(o) {
  return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(o);
};
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
    },
    set: function(o) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = o;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Mesh.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function() {
      return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
PerspectiveCamera.prototype.setLens = function(o, e) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), e !== void 0 && (this.filmGauge = e), this.setFocalLength(o);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(o) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = o;
    }
  },
  shadowCameraLeft: {
    set: function(o) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = o;
    }
  },
  shadowCameraRight: {
    set: function(o) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = o;
    }
  },
  shadowCameraTop: {
    set: function(o) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = o;
    }
  },
  shadowCameraBottom: {
    set: function(o) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = o;
    }
  },
  shadowCameraNear: {
    set: function(o) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = o;
    }
  },
  shadowCameraFar: {
    set: function(o) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = o;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(o) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = o;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(o) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = o;
    }
  },
  shadowMapHeight: {
    set: function(o) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = o;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
    }
  },
  dynamic: {
    get: function() {
      return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(DynamicDrawUsage);
    }
  }
});
BufferAttribute.prototype.setDynamic = function(o) {
  return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(o === !0 ? DynamicDrawUsage : StaticDrawUsage), this;
};
BufferAttribute.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, BufferAttribute.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
BufferGeometry.prototype.addIndex = function(o) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(o);
};
BufferGeometry.prototype.addAttribute = function(o, e) {
  return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute) ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(o, new BufferAttribute(arguments[1], arguments[2]))) : o === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(o, e);
};
BufferGeometry.prototype.addDrawCall = function(o, e, t) {
  t !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(o, e);
};
BufferGeometry.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
};
BufferGeometry.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
BufferGeometry.prototype.removeAttribute = function(o) {
  return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(o);
};
BufferGeometry.prototype.applyMatrix = function(o) {
  return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(o);
};
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
    }
  },
  offsets: {
    get: function() {
      return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
    }
  }
});
InterleavedBuffer.prototype.setDynamic = function(o) {
  return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(o === !0 ? DynamicDrawUsage : StaticDrawUsage), this;
};
InterleavedBuffer.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
ExtrudeGeometry.prototype.getArrays = function() {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
ExtrudeGeometry.prototype.addShapeList = function() {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
ExtrudeGeometry.prototype.addShape = function() {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Scene$1.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Uniform.prototype.onUpdate = function() {
  return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
};
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      return console.warn("THREE.Material: .wrapRGB has been removed."), new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(o) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = o === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
    },
    set: function(o) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = o;
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
    },
    set: function(o) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = o;
    }
  }
});
WebGLRenderer$1.prototype.clearTarget = function(o, e, t, i) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(o), this.clear(e, t, i);
};
WebGLRenderer$1.prototype.animate = function(o) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(o);
};
WebGLRenderer$1.prototype.getCurrentRenderTarget = function() {
  return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
};
WebGLRenderer$1.prototype.getMaxAnisotropy = function() {
  return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
};
WebGLRenderer$1.prototype.getPrecision = function() {
  return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
};
WebGLRenderer$1.prototype.resetGLState = function() {
  return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
};
WebGLRenderer$1.prototype.supportsFloatTextures = function() {
  return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
};
WebGLRenderer$1.prototype.supportsHalfFloatTextures = function() {
  return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
};
WebGLRenderer$1.prototype.supportsStandardDerivatives = function() {
  return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
};
WebGLRenderer$1.prototype.supportsCompressedTextureS3TC = function() {
  return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
};
WebGLRenderer$1.prototype.supportsCompressedTexturePVRTC = function() {
  return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
WebGLRenderer$1.prototype.supportsBlendMinMax = function() {
  return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
};
WebGLRenderer$1.prototype.supportsVertexTextures = function() {
  return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
};
WebGLRenderer$1.prototype.supportsInstancedArrays = function() {
  return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
};
WebGLRenderer$1.prototype.enableScissorTest = function(o) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(o);
};
WebGLRenderer$1.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
WebGLRenderer$1.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
WebGLRenderer$1.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
WebGLRenderer$1.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
WebGLRenderer$1.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
WebGLRenderer$1.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
WebGLRenderer$1.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
WebGLRenderer$1.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
WebGLRenderer$1.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
WebGLRenderer$1.prototype.getActiveMipMapLevel = function() {
  return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer$1.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(o) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = o;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(o) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = o;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
    }
  },
  vr: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
    }
  },
  gammaInput: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1;
    },
    set: function(o) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = o === !0 ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
function WebGLRenderTargetCube(o, e, t) {
  return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new WebGLCubeRenderTarget(o, t);
}
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
    },
    set: function(o) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = o;
    }
  },
  wrapT: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
    },
    set: function(o) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = o;
    }
  },
  magFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
    },
    set: function(o) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = o;
    }
  },
  minFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
    },
    set: function(o) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = o;
    }
  },
  anisotropy: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
    },
    set: function(o) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = o;
    }
  },
  offset: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
    },
    set: function(o) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = o;
    }
  },
  repeat: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
    },
    set: function(o) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = o;
    }
  },
  format: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
    },
    set: function(o) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = o;
    }
  },
  type: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
    },
    set: function(o) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = o;
    }
  },
  generateMipmaps: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
    },
    set: function(o) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = o;
    }
  }
});
Audio$1.prototype.load = function(o) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  const e = this;
  return new AudioLoader().load(o, function(i) {
    e.setBuffer(i);
  }), this;
};
AudioAnalyser.prototype.getData = function() {
  return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
};
CubeCamera.prototype.updateCubeMap = function(o, e) {
  return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(o, e);
};
CubeCamera.prototype.clear = function(o, e, t, i) {
  return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(o, e, t, i);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(o, e, t, i) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const n = new TextureLoader();
  n.setCrossOrigin(this.crossOrigin);
  const r = n.load(o, t, void 0, i);
  return e && (r.mapping = e), r;
};
ImageUtils.loadTextureCube = function(o, e, t, i) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const n = new CubeTextureLoader();
  n.setCrossOrigin(this.crossOrigin);
  const r = n.load(o, t, void 0, i);
  return e && (r.mapping = e), r;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
function CanvasRenderer() {
  console.error("THREE.CanvasRenderer has been removed");
}
function JSONLoader() {
  console.error("THREE.JSONLoader has been removed.");
}
const SceneUtils = {
  createMultiMaterialObject: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  },
  detach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  },
  attach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  }
};
function LensFlare() {
  console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: REVISION
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = REVISION);
const THREE$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping,
  AddEquation,
  AddOperation,
  AdditiveAnimationBlendMode,
  AdditiveBlending,
  AlphaFormat,
  AlwaysDepth,
  AlwaysStencilFunc,
  AmbientLight,
  AmbientLightProbe,
  AnimationClip,
  AnimationLoader,
  AnimationMixer,
  AnimationObjectGroup,
  AnimationUtils,
  ArcCurve,
  ArrayCamera,
  ArrowHelper,
  Audio: Audio$1,
  AudioAnalyser,
  AudioContext,
  AudioListener,
  AudioLoader,
  AxesHelper,
  AxisHelper,
  BackSide,
  BasicDepthPacking,
  BasicShadowMap,
  BinaryTextureLoader,
  Bone,
  BooleanKeyframeTrack,
  BoundingBoxHelper,
  Box2,
  Box3,
  Box3Helper,
  BoxBufferGeometry: BoxGeometry,
  BoxGeometry,
  BoxHelper,
  BufferAttribute,
  BufferGeometry,
  BufferGeometryLoader,
  ByteType,
  Cache,
  Camera: Camera$1,
  CameraHelper,
  CanvasRenderer,
  CanvasTexture,
  CatmullRomCurve3,
  CineonToneMapping,
  CircleBufferGeometry: CircleGeometry,
  CircleGeometry,
  ClampToEdgeWrapping,
  Clock,
  Color,
  ColorKeyframeTrack,
  CompressedTexture,
  CompressedTextureLoader,
  ConeBufferGeometry: ConeGeometry,
  ConeGeometry,
  CubeCamera,
  CubeReflectionMapping,
  CubeRefractionMapping,
  CubeTexture,
  CubeTextureLoader,
  CubeUVReflectionMapping,
  CubeUVRefractionMapping,
  CubicBezierCurve,
  CubicBezierCurve3,
  CubicInterpolant,
  CullFaceBack,
  CullFaceFront,
  CullFaceFrontBack,
  CullFaceNone,
  Curve,
  CurvePath,
  CustomBlending,
  CustomToneMapping,
  CylinderBufferGeometry: CylinderGeometry,
  CylinderGeometry,
  Cylindrical,
  DataTexture,
  DataTexture2DArray,
  DataTexture3D,
  DataTextureLoader,
  DataUtils,
  DecrementStencilOp,
  DecrementWrapStencilOp,
  DefaultLoadingManager,
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  DirectionalLight,
  DirectionalLightHelper,
  DiscreteInterpolant,
  DodecahedronBufferGeometry: DodecahedronGeometry,
  DodecahedronGeometry,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  DynamicBufferAttribute,
  DynamicCopyUsage,
  DynamicDrawUsage,
  DynamicReadUsage,
  EdgesGeometry,
  EdgesHelper,
  EllipseCurve,
  EqualDepth,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  Euler,
  EventDispatcher: EventDispatcher$1,
  ExtrudeBufferGeometry: ExtrudeGeometry,
  ExtrudeGeometry,
  FaceColors,
  FileLoader,
  FlatShading,
  Float16BufferAttribute,
  Float32Attribute,
  Float32BufferAttribute,
  Float64Attribute,
  Float64BufferAttribute,
  FloatType,
  Fog,
  FogExp2,
  Font,
  FontLoader,
  FrontSide,
  Frustum,
  GLBufferAttribute,
  GLSL1,
  GLSL3,
  GammaEncoding,
  GreaterDepth,
  GreaterEqualDepth,
  GreaterEqualStencilFunc,
  GreaterStencilFunc,
  GridHelper,
  Group,
  HalfFloatType,
  HemisphereLight,
  HemisphereLightHelper,
  HemisphereLightProbe,
  IcosahedronBufferGeometry: IcosahedronGeometry,
  IcosahedronGeometry,
  ImageBitmapLoader,
  ImageLoader,
  ImageUtils,
  ImmediateRenderObject,
  IncrementStencilOp,
  IncrementWrapStencilOp,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  InstancedMesh,
  Int16Attribute,
  Int16BufferAttribute,
  Int32Attribute,
  Int32BufferAttribute,
  Int8Attribute,
  Int8BufferAttribute,
  IntType,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  InterpolateSmooth,
  InvertStencilOp,
  JSONLoader,
  KeepStencilOp,
  KeyframeTrack,
  LOD,
  LatheBufferGeometry: LatheGeometry,
  LatheGeometry,
  Layers,
  LensFlare,
  LessDepth,
  LessEqualDepth,
  LessEqualStencilFunc,
  LessStencilFunc,
  Light,
  LightProbe,
  Line,
  Line3,
  LineBasicMaterial,
  LineCurve,
  LineCurve3,
  LineDashedMaterial,
  LineLoop,
  LinePieces,
  LineSegments,
  LineStrip,
  LinearEncoding,
  LinearFilter,
  LinearInterpolant,
  LinearMipMapLinearFilter,
  LinearMipMapNearestFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LinearToneMapping,
  Loader,
  LoaderUtils,
  LoadingManager,
  LogLuvEncoding,
  LoopOnce,
  LoopPingPong,
  LoopRepeat,
  LuminanceAlphaFormat,
  LuminanceFormat,
  MOUSE,
  Material,
  MaterialLoader,
  Math: MathUtils,
  MathUtils,
  Matrix3,
  Matrix4,
  MaxEquation,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshFaceMaterial,
  MeshLambertMaterial,
  MeshMatcapMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  MinEquation,
  MirroredRepeatWrapping,
  MixOperation,
  MultiMaterial,
  MultiplyBlending,
  MultiplyOperation,
  NearestFilter,
  NearestMipMapLinearFilter,
  NearestMipMapNearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NeverDepth,
  NeverStencilFunc,
  NoBlending,
  NoColors,
  NoToneMapping,
  NormalAnimationBlendMode,
  NormalBlending,
  NotEqualDepth,
  NotEqualStencilFunc,
  NumberKeyframeTrack,
  Object3D,
  ObjectLoader,
  ObjectSpaceNormalMap,
  OctahedronBufferGeometry: OctahedronGeometry,
  OctahedronGeometry,
  OneFactor,
  OneMinusDstAlphaFactor,
  OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor,
  OrthographicCamera,
  PCFShadowMap,
  PCFSoftShadowMap,
  PMREMGenerator,
  ParametricBufferGeometry: ParametricGeometry,
  ParametricGeometry,
  Particle,
  ParticleBasicMaterial,
  ParticleSystem,
  ParticleSystemMaterial,
  Path,
  PerspectiveCamera,
  Plane,
  PlaneBufferGeometry: PlaneGeometry,
  PlaneGeometry,
  PlaneHelper,
  PointCloud,
  PointCloudMaterial,
  PointLight,
  PointLightHelper,
  Points,
  PointsMaterial,
  PolarGridHelper,
  PolyhedronBufferGeometry: PolyhedronGeometry,
  PolyhedronGeometry,
  PositionalAudio,
  PropertyBinding,
  PropertyMixer,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  Quaternion,
  QuaternionKeyframeTrack,
  QuaternionLinearInterpolant,
  REVISION,
  RGBADepthPacking,
  RGBAFormat,
  RGBAIntegerFormat,
  RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format,
  RGBDEncoding,
  RGBEEncoding,
  RGBEFormat,
  RGBFormat,
  RGBIntegerFormat,
  RGBM16Encoding,
  RGBM7Encoding,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGFormat,
  RGIntegerFormat,
  RawShaderMaterial,
  Ray,
  Raycaster: Raycaster$1,
  RectAreaLight,
  RedFormat,
  RedIntegerFormat,
  ReinhardToneMapping,
  RepeatWrapping,
  ReplaceStencilOp,
  ReverseSubtractEquation,
  RingBufferGeometry: RingGeometry,
  RingGeometry,
  SRGB8_ALPHA8_ASTC_10x10_Format,
  SRGB8_ALPHA8_ASTC_10x5_Format,
  SRGB8_ALPHA8_ASTC_10x6_Format,
  SRGB8_ALPHA8_ASTC_10x8_Format,
  SRGB8_ALPHA8_ASTC_12x10_Format,
  SRGB8_ALPHA8_ASTC_12x12_Format,
  SRGB8_ALPHA8_ASTC_4x4_Format,
  SRGB8_ALPHA8_ASTC_5x4_Format,
  SRGB8_ALPHA8_ASTC_5x5_Format,
  SRGB8_ALPHA8_ASTC_6x5_Format,
  SRGB8_ALPHA8_ASTC_6x6_Format,
  SRGB8_ALPHA8_ASTC_8x5_Format,
  SRGB8_ALPHA8_ASTC_8x6_Format,
  SRGB8_ALPHA8_ASTC_8x8_Format,
  Scene: Scene$1,
  SceneUtils,
  ShaderChunk,
  ShaderLib,
  ShaderMaterial,
  ShadowMaterial,
  Shape: Shape$1,
  ShapeBufferGeometry: ShapeGeometry,
  ShapeGeometry,
  ShapePath,
  ShapeUtils,
  ShortType,
  Skeleton,
  SkeletonHelper,
  SkinnedMesh,
  SmoothShading,
  Sphere,
  SphereBufferGeometry: SphereGeometry,
  SphereGeometry,
  Spherical,
  SphericalHarmonics3,
  SplineCurve,
  SpotLight,
  SpotLightHelper,
  Sprite,
  SpriteMaterial,
  SrcAlphaFactor,
  SrcAlphaSaturateFactor,
  SrcColorFactor,
  StaticCopyUsage,
  StaticDrawUsage,
  StaticReadUsage,
  StereoCamera,
  StreamCopyUsage,
  StreamDrawUsage,
  StreamReadUsage,
  StringKeyframeTrack,
  SubtractEquation,
  SubtractiveBlending,
  TOUCH,
  TangentSpaceNormalMap,
  TetrahedronBufferGeometry: TetrahedronGeometry,
  TetrahedronGeometry,
  TextBufferGeometry: TextGeometry,
  TextGeometry,
  Texture,
  TextureLoader,
  TorusBufferGeometry: TorusGeometry,
  TorusGeometry,
  TorusKnotBufferGeometry: TorusKnotGeometry,
  TorusKnotGeometry,
  Triangle,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  TrianglesDrawMode,
  TubeBufferGeometry: TubeGeometry,
  TubeGeometry,
  UVMapping,
  Uint16Attribute,
  Uint16BufferAttribute,
  Uint32Attribute,
  Uint32BufferAttribute,
  Uint8Attribute,
  Uint8BufferAttribute,
  Uint8ClampedAttribute,
  Uint8ClampedBufferAttribute,
  Uniform,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedInt248Type,
  UnsignedIntType,
  UnsignedShort4444Type,
  UnsignedShort5551Type,
  UnsignedShort565Type,
  UnsignedShortType,
  VSMShadowMap,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  Vertex,
  VertexColors,
  VideoTexture,
  WebGL1Renderer,
  WebGLCubeRenderTarget,
  WebGLMultipleRenderTargets,
  WebGLMultisampleRenderTarget,
  WebGLRenderTarget,
  WebGLRenderTargetCube,
  WebGLRenderer: WebGLRenderer$1,
  WebGLUtils,
  WireframeGeometry,
  WireframeHelper,
  WrapAroundEnding,
  XHRLoader,
  ZeroCurvatureEnding,
  ZeroFactor,
  ZeroSlopeEnding,
  ZeroStencilOp,
  sRGBEncoding
}, Symbol.toStringTag, { value: "Module" }));
class ARButton {
  static createButton(e, t = {}) {
    const i = document.createElement("button");
    function n() {
      if (t.domOverlay === void 0) {
        var l = document.createElement("div");
        l.style.display = "none", document.body.appendChild(l);
        var c = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        c.setAttribute("width", 38), c.setAttribute("height", 38), c.style.position = "absolute", c.style.right = "20px", c.style.top = "20px", c.addEventListener("click", function() {
          h.end();
        }), l.appendChild(c);
        var u = document.createElementNS("http://www.w3.org/2000/svg", "path");
        u.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28"), u.setAttribute("stroke", "#fff"), u.setAttribute("stroke-width", 2), c.appendChild(u), t.optionalFeatures === void 0 && (t.optionalFeatures = []), t.optionalFeatures.push("dom-overlay"), t.domOverlay = { root: l };
      }
      let h = null;
      async function d(p) {
        p.addEventListener("end", f), e.xr.setReferenceSpaceType("local"), await e.xr.setSession(p), i.textContent = "STOP AR", t.domOverlay.root.style.display = "", h = p;
      }
      function f() {
        h.removeEventListener("end", f), i.textContent = "START AR", t.domOverlay.root.style.display = "none", h = null;
      }
      i.style.display = "", i.style.cursor = "pointer", i.style.left = "calc(50% - 50px)", i.style.width = "100px", i.textContent = "START AR", i.onmouseenter = function() {
        i.style.opacity = "1.0";
      }, i.onmouseleave = function() {
        i.style.opacity = "0.5";
      }, i.onclick = function() {
        h === null ? navigator.xr.requestSession("immersive-ar", t).then(d) : h.end();
      };
    }
    function r() {
      i.style.display = "", i.style.cursor = "auto", i.style.left = "calc(50% - 75px)", i.style.width = "150px", i.onmouseenter = null, i.onmouseleave = null, i.onclick = null;
    }
    function s() {
      r(), i.textContent = "AR NOT SUPPORTED";
    }
    function a(l) {
      l.style.position = "absolute", l.style.bottom = "20px", l.style.padding = "12px 6px", l.style.border = "1px solid #fff", l.style.borderRadius = "4px", l.style.background = "rgba(0,0,0,0.1)", l.style.color = "#fff", l.style.font = "normal 13px sans-serif", l.style.textAlign = "center", l.style.opacity = "0.5", l.style.outline = "none", l.style.zIndex = "999";
    }
    if ("xr" in navigator)
      return i.id = "ARButton", i.style.display = "none", a(i), navigator.xr.isSessionSupported("immersive-ar").then(function(l) {
        l ? n() : s();
      }).catch(s), i;
    {
      const l = document.createElement("a");
      return window.isSecureContext === !1 ? (l.href = document.location.href.replace(/^http:/, "https:"), l.innerHTML = "WEBXR NEEDS HTTPS") : (l.href = "https://immersiveweb.dev/", l.innerHTML = "WEBXR NOT AVAILABLE"), l.style.left = "calc(50% - 90px)", l.style.width = "180px", l.style.textDecoration = "none", a(l), l;
    }
  }
}
function getName(o) {
  return o.name;
}
function queryKey(o) {
  for (var e = [], t = 0; t < o.length; t++) {
    var i = o[t];
    if (typeof i == "object") {
      var n = i.operator === "not" ? "!" : i.operator;
      e.push(n + getName(i.Component));
    } else
      e.push(getName(i));
  }
  return e.sort().join("-");
}
const hasWindow = typeof window < "u", now$2 = hasWindow && typeof window.performance < "u" ? performance.now.bind(performance) : Date.now.bind(Date);
class SystemManager {
  constructor(e) {
    this._systems = [], this._executeSystems = [], this.world = e, this.lastExecutedSystem = null;
  }
  registerSystem(e, t) {
    if (!e.isSystem)
      throw new Error(
        `System '${e.name}' does not extend 'System' class`
      );
    if (this.getSystem(e) !== void 0)
      return console.warn(`System '${e.getName()}' already registered.`), this;
    var i = new e(this.world, t);
    return i.init && i.init(t), i.order = this._systems.length, this._systems.push(i), i.execute && (this._executeSystems.push(i), this.sortSystems()), this;
  }
  unregisterSystem(e) {
    let t = this.getSystem(e);
    return t === void 0 ? (console.warn(
      `Can unregister system '${e.getName()}'. It doesn't exist.`
    ), this) : (this._systems.splice(this._systems.indexOf(t), 1), t.execute && this._executeSystems.splice(this._executeSystems.indexOf(t), 1), this);
  }
  sortSystems() {
    this._executeSystems.sort((e, t) => e.priority - t.priority || e.order - t.order);
  }
  getSystem(e) {
    return this._systems.find((t) => t instanceof e);
  }
  getSystems() {
    return this._systems;
  }
  removeSystem(e) {
    var t = this._systems.indexOf(e);
    ~t && this._systems.splice(t, 1);
  }
  executeSystem(e, t, i) {
    if (e.initialized && e.canExecute()) {
      let n = now$2();
      e.execute(t, i), e.executeTime = now$2() - n, this.lastExecutedSystem = e, e.clearEvents();
    }
  }
  stop() {
    this._executeSystems.forEach((e) => e.stop());
  }
  execute(e, t, i) {
    this._executeSystems.forEach(
      (n) => (i || n.enabled) && this.executeSystem(n, e, t)
    );
  }
  stats() {
    for (var e = {
      numSystems: this._systems.length,
      systems: {}
    }, t = 0; t < this._systems.length; t++) {
      var i = this._systems[t], n = e.systems[i.getName()] = {
        queries: {},
        executeTime: i.executeTime
      };
      for (var r in i.ctx)
        n.queries[r] = i.ctx[r].stats();
    }
    return e;
  }
}
class ObjectPool {
  // @todo Add initial size
  constructor(e, t) {
    this.freeList = [], this.count = 0, this.T = e, this.isObjectPool = !0, typeof t < "u" && this.expand(t);
  }
  acquire() {
    this.freeList.length <= 0 && this.expand(Math.round(this.count * 0.2) + 1);
    var e = this.freeList.pop();
    return e;
  }
  release(e) {
    e.reset(), this.freeList.push(e);
  }
  expand(e) {
    for (var t = 0; t < e; t++) {
      var i = new this.T();
      i._pool = this, this.freeList.push(i);
    }
    this.count += e;
  }
  totalSize() {
    return this.count;
  }
  totalFree() {
    return this.freeList.length;
  }
  totalUsed() {
    return this.count - this.freeList.length;
  }
}
class EventDispatcher {
  constructor() {
    this._listeners = {}, this.stats = {
      fired: 0,
      handled: 0
    };
  }
  /**
   * Add an event listener
   * @param {String} eventName Name of the event to listen
   * @param {Function} listener Callback to trigger when the event is fired
   */
  addEventListener(e, t) {
    let i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  /**
   * Check if an event listener is already added to the list of listeners
   * @param {String} eventName Name of the event to check
   * @param {Function} listener Callback for the specified event
   */
  hasEventListener(e, t) {
    return this._listeners[e] !== void 0 && this._listeners[e].indexOf(t) !== -1;
  }
  /**
   * Remove an event listener
   * @param {String} eventName Name of the event to remove
   * @param {Function} listener Callback for the specified event
   */
  removeEventListener(e, t) {
    var i = this._listeners[e];
    if (i !== void 0) {
      var n = i.indexOf(t);
      n !== -1 && i.splice(n, 1);
    }
  }
  /**
   * Dispatch an event
   * @param {String} eventName Name of the event to dispatch
   * @param {Entity} entity (Optional) Entity to emit
   * @param {Component} component
   */
  dispatchEvent(e, t, i) {
    this.stats.fired++;
    var n = this._listeners[e];
    if (n !== void 0)
      for (var r = n.slice(0), s = 0; s < r.length; s++)
        r[s].call(this, t, i);
  }
  /**
   * Reset stats counters
   */
  resetCounters() {
    this.stats.fired = this.stats.handled = 0;
  }
}
class Query {
  /**
   * @param {Array(Component)} Components List of types of components to query
   */
  constructor(e, t) {
    if (this.Components = [], this.NotComponents = [], e.forEach((r) => {
      typeof r == "object" ? this.NotComponents.push(r.Component) : this.Components.push(r);
    }), this.Components.length === 0)
      throw new Error("Can't create a query without components");
    this.entities = [], this.eventDispatcher = new EventDispatcher(), this.reactive = !1, this.key = queryKey(e);
    for (var i = 0; i < t._entities.length; i++) {
      var n = t._entities[i];
      this.match(n) && (n.queries.push(this), this.entities.push(n));
    }
  }
  /**
   * Add entity to this query
   * @param {Entity} entity
   */
  addEntity(e) {
    e.queries.push(this), this.entities.push(e), this.eventDispatcher.dispatchEvent(Query.prototype.ENTITY_ADDED, e);
  }
  /**
   * Remove entity from this query
   * @param {Entity} entity
   */
  removeEntity(e) {
    let t = this.entities.indexOf(e);
    ~t && (this.entities.splice(t, 1), t = e.queries.indexOf(this), e.queries.splice(t, 1), this.eventDispatcher.dispatchEvent(
      Query.prototype.ENTITY_REMOVED,
      e
    ));
  }
  match(e) {
    return e.hasAllComponents(this.Components) && !e.hasAnyComponents(this.NotComponents);
  }
  toJSON() {
    return {
      key: this.key,
      reactive: this.reactive,
      components: {
        included: this.Components.map((e) => e.name),
        not: this.NotComponents.map((e) => e.name)
      },
      numEntities: this.entities.length
    };
  }
  /**
   * Return stats for this query
   */
  stats() {
    return {
      numComponents: this.Components.length,
      numEntities: this.entities.length
    };
  }
}
Query.prototype.ENTITY_ADDED = "Query#ENTITY_ADDED";
Query.prototype.ENTITY_REMOVED = "Query#ENTITY_REMOVED";
Query.prototype.COMPONENT_CHANGED = "Query#COMPONENT_CHANGED";
class QueryManager {
  constructor(e) {
    this._world = e, this._queries = {};
  }
  onEntityRemoved(e) {
    for (var t in this._queries) {
      var i = this._queries[t];
      e.queries.indexOf(i) !== -1 && i.removeEntity(e);
    }
  }
  /**
   * Callback when a component is added to an entity
   * @param {Entity} entity Entity that just got the new component
   * @param {Component} Component Component added to the entity
   */
  onEntityComponentAdded(e, t) {
    for (var i in this._queries) {
      var n = this._queries[i];
      if (~n.NotComponents.indexOf(t) && ~n.entities.indexOf(e)) {
        n.removeEntity(e);
        continue;
      }
      !~n.Components.indexOf(t) || !n.match(e) || ~n.entities.indexOf(e) || n.addEntity(e);
    }
  }
  /**
   * Callback when a component is removed from an entity
   * @param {Entity} entity Entity to remove the component from
   * @param {Component} Component Component to remove from the entity
   */
  onEntityComponentRemoved(e, t) {
    for (var i in this._queries) {
      var n = this._queries[i];
      if (~n.NotComponents.indexOf(t) && !~n.entities.indexOf(e) && n.match(e)) {
        n.addEntity(e);
        continue;
      }
      if (~n.Components.indexOf(t) && ~n.entities.indexOf(e) && !n.match(e)) {
        n.removeEntity(e);
        continue;
      }
    }
  }
  /**
   * Get a query for the specified components
   * @param {Component} Components Components that the query should have
   */
  getQuery(e) {
    var t = queryKey(e), i = this._queries[t];
    return i || (this._queries[t] = i = new Query(e, this._world)), i;
  }
  /**
   * Return some stats from this class
   */
  stats() {
    var e = {};
    for (var t in this._queries)
      e[t] = this._queries[t].stats();
    return e;
  }
}
let Component$1 = class {
  constructor(e) {
    if (e !== !1) {
      const t = this.constructor.schema;
      for (const i in t)
        if (e && e.hasOwnProperty(i))
          this[i] = e[i];
        else {
          const n = t[i];
          if (n.hasOwnProperty("default"))
            this[i] = n.type.clone(n.default);
          else {
            const r = n.type;
            this[i] = r.clone(r.default);
          }
        }
    }
    this._pool = null;
  }
  copy(e) {
    const t = this.constructor.schema;
    for (const i in t) {
      const n = t[i];
      e.hasOwnProperty(i) && (this[i] = n.type.copy(e[i], this[i]));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  reset() {
    const e = this.constructor.schema;
    for (const t in e) {
      const i = e[t];
      if (i.hasOwnProperty("default"))
        this[t] = i.type.copy(i.default, this[t]);
      else {
        const n = i.type;
        this[t] = n.copy(n.default, this[t]);
      }
    }
  }
  dispose() {
    this._pool && this._pool.release(this);
  }
  getName() {
    return this.constructor.getName();
  }
};
Component$1.schema = {};
Component$1.isComponent = !0;
Component$1.getName = function() {
  return this.displayName || this.name;
};
class SystemStateComponent extends Component$1 {
}
SystemStateComponent.isSystemStateComponent = !0;
class EntityPool extends ObjectPool {
  constructor(e, t, i) {
    super(t, void 0), this.entityManager = e, typeof i < "u" && this.expand(i);
  }
  expand(e) {
    for (var t = 0; t < e; t++) {
      var i = new this.T(this.entityManager);
      i._pool = this, this.freeList.push(i);
    }
    this.count += e;
  }
}
class EntityManager {
  constructor(e) {
    this.world = e, this.componentsManager = e.componentsManager, this._entities = [], this._nextEntityId = 0, this._entitiesByNames = {}, this._queryManager = new QueryManager(this), this.eventDispatcher = new EventDispatcher(), this._entityPool = new EntityPool(
      this,
      this.world.options.entityClass,
      this.world.options.entityPoolSize
    ), this.entitiesWithComponentsToRemove = [], this.entitiesToRemove = [], this.deferredRemovalEnabled = !0;
  }
  getEntityByName(e) {
    return this._entitiesByNames[e];
  }
  /**
   * Create a new entity
   */
  createEntity(e) {
    var t = this._entityPool.acquire();
    return t.alive = !0, t.name = e || "", e && (this._entitiesByNames[e] ? console.warn(`Entity name '${e}' already exist`) : this._entitiesByNames[e] = t), this._entities.push(t), this.eventDispatcher.dispatchEvent(ENTITY_CREATED, t), t;
  }
  // COMPONENTS
  /**
   * Add a component to an entity
   * @param {Entity} entity Entity where the component will be added
   * @param {Component} Component Component to be added to the entity
   * @param {Object} values Optional values to replace the default attributes
   */
  entityAddComponent(e, t, i) {
    if (typeof t._typeId > "u" && !this.world.componentsManager._ComponentsMap[t._typeId])
      throw new Error(
        `Attempted to add unregistered component "${t.getName()}"`
      );
    if (~e._ComponentTypes.indexOf(t)) {
      console.warn(
        "Component type already exists on entity.",
        e,
        t.getName()
      );
      return;
    }
    e._ComponentTypes.push(t), t.__proto__ === SystemStateComponent && e.numStateComponents++;
    var n = this.world.componentsManager.getComponentsPool(
      t
    ), r = n ? n.acquire() : new t(i);
    n && i && r.copy(i), e._components[t._typeId] = r, this._queryManager.onEntityComponentAdded(e, t), this.world.componentsManager.componentAddedToEntity(t), this.eventDispatcher.dispatchEvent(COMPONENT_ADDED, e, t);
  }
  /**
   * Remove a component from an entity
   * @param {Entity} entity Entity which will get removed the component
   * @param {*} Component Component to remove from the entity
   * @param {Bool} immediately If you want to remove the component immediately instead of deferred (Default is false)
   */
  entityRemoveComponent(e, t, i) {
    var n = e._ComponentTypes.indexOf(t);
    ~n && (this.eventDispatcher.dispatchEvent(COMPONENT_REMOVE, e, t), i ? this._entityRemoveComponentSync(e, t, n) : (e._ComponentTypesToRemove.length === 0 && this.entitiesWithComponentsToRemove.push(e), e._ComponentTypes.splice(n, 1), e._ComponentTypesToRemove.push(t), e._componentsToRemove[t._typeId] = e._components[t._typeId], delete e._components[t._typeId]), this._queryManager.onEntityComponentRemoved(e, t), t.__proto__ === SystemStateComponent && (e.numStateComponents--, e.numStateComponents === 0 && !e.alive && e.remove()));
  }
  _entityRemoveComponentSync(e, t, i) {
    e._ComponentTypes.splice(i, 1);
    var n = e._components[t._typeId];
    delete e._components[t._typeId], n.dispose(), this.world.componentsManager.componentRemovedFromEntity(t);
  }
  /**
   * Remove all the components from an entity
   * @param {Entity} entity Entity from which the components will be removed
   */
  entityRemoveAllComponents(e, t) {
    let i = e._ComponentTypes;
    for (let n = i.length - 1; n >= 0; n--)
      i[n].__proto__ !== SystemStateComponent && this.entityRemoveComponent(e, i[n], t);
  }
  /**
   * Remove the entity from this manager. It will clear also its components
   * @param {Entity} entity Entity to remove from the manager
   * @param {Bool} immediately If you want to remove the component immediately instead of deferred (Default is false)
   */
  removeEntity(e, t) {
    var i = this._entities.indexOf(e);
    if (!~i) throw new Error("Tried to remove entity not in list");
    e.alive = !1, e.numStateComponents === 0 && (this.eventDispatcher.dispatchEvent(ENTITY_REMOVED, e), this._queryManager.onEntityRemoved(e), t === !0 ? this._releaseEntity(e, i) : this.entitiesToRemove.push(e)), this.entityRemoveAllComponents(e, t);
  }
  _releaseEntity(e, t) {
    this._entities.splice(t, 1), this._entitiesByNames[e.name] && delete this._entitiesByNames[e.name], e._pool.release(e);
  }
  /**
   * Remove all entities from this manager
   */
  removeAllEntities() {
    for (var e = this._entities.length - 1; e >= 0; e--)
      this.removeEntity(this._entities[e]);
  }
  processDeferredRemoval() {
    if (this.deferredRemovalEnabled) {
      for (let t = 0; t < this.entitiesToRemove.length; t++) {
        let i = this.entitiesToRemove[t], n = this._entities.indexOf(i);
        this._releaseEntity(i, n);
      }
      this.entitiesToRemove.length = 0;
      for (let t = 0; t < this.entitiesWithComponentsToRemove.length; t++) {
        let i = this.entitiesWithComponentsToRemove[t];
        for (; i._ComponentTypesToRemove.length > 0; ) {
          let n = i._ComponentTypesToRemove.pop();
          var e = i._componentsToRemove[n._typeId];
          delete i._componentsToRemove[n._typeId], e.dispose(), this.world.componentsManager.componentRemovedFromEntity(n);
        }
      }
      this.entitiesWithComponentsToRemove.length = 0;
    }
  }
  /**
   * Get a query based on a list of components
   * @param {Array(Component)} Components List of components that will form the query
   */
  queryComponents(e) {
    return this._queryManager.getQuery(e);
  }
  // EXTRAS
  /**
   * Return number of entities
   */
  count() {
    return this._entities.length;
  }
  /**
   * Return some stats
   */
  stats() {
    var e = {
      numEntities: this._entities.length,
      numQueries: Object.keys(this._queryManager._queries).length,
      queries: this._queryManager.stats(),
      numComponentPool: Object.keys(this.componentsManager._componentPool).length,
      componentPool: {},
      eventDispatcher: this.eventDispatcher.stats
    };
    for (var t in this.componentsManager._componentPool) {
      var i = this.componentsManager._componentPool[t];
      e.componentPool[t] = {
        used: i.totalUsed(),
        size: i.count
      };
    }
    return e;
  }
}
const ENTITY_CREATED = "EntityManager#ENTITY_CREATE", ENTITY_REMOVED = "EntityManager#ENTITY_REMOVED", COMPONENT_ADDED = "EntityManager#COMPONENT_ADDED", COMPONENT_REMOVE = "EntityManager#COMPONENT_REMOVE";
class ComponentManager {
  constructor() {
    this.Components = [], this._ComponentsMap = {}, this._componentPool = {}, this.numComponents = {}, this.nextComponentId = 0;
  }
  registerComponent(e, t) {
    if (this.Components.indexOf(e) !== -1) {
      console.warn(
        `Component type: '${e.getName()}' already registered.`
      );
      return;
    }
    const i = e.schema;
    if (!i)
      throw new Error(
        `Component "${e.getName()}" has no schema property.`
      );
    for (const n in i)
      if (!i[n].type)
        throw new Error(
          `Invalid schema for component "${e.getName()}". Missing type for "${n}" property.`
        );
    e._typeId = this.nextComponentId++, this.Components.push(e), this._ComponentsMap[e._typeId] = e, this.numComponents[e._typeId] = 0, t === void 0 ? t = new ObjectPool(e) : t === !1 && (t = void 0), this._componentPool[e._typeId] = t;
  }
  componentAddedToEntity(e) {
    this.numComponents[e._typeId]++;
  }
  componentRemovedFromEntity(e) {
    this.numComponents[e._typeId]--;
  }
  getComponentsPool(e) {
    return this._componentPool[e._typeId];
  }
}
const Version = "0.3.1";
class Entity {
  constructor(e) {
    this._entityManager = e || null, this.id = e._nextEntityId++, this._ComponentTypes = [], this._components = {}, this._componentsToRemove = {}, this.queries = [], this._ComponentTypesToRemove = [], this.alive = !1, this.numStateComponents = 0;
  }
  // COMPONENTS
  getComponent(e, t) {
    var i = this._components[e._typeId];
    return !i && t === !0 && (i = this._componentsToRemove[e._typeId]), i;
  }
  getRemovedComponent(e) {
    return this._componentsToRemove[e._typeId];
  }
  getComponents() {
    return this._components;
  }
  getComponentsToRemove() {
    return this._componentsToRemove;
  }
  getComponentTypes() {
    return this._ComponentTypes;
  }
  getMutableComponent(e) {
    for (var t = this._components[e._typeId], i = 0; i < this.queries.length; i++) {
      var n = this.queries[i];
      n.reactive && n.Components.indexOf(e) !== -1 && n.eventDispatcher.dispatchEvent(
        Query.prototype.COMPONENT_CHANGED,
        this,
        t
      );
    }
    return t;
  }
  addComponent(e, t) {
    return this._entityManager.entityAddComponent(this, e, t), this;
  }
  removeComponent(e, t) {
    return this._entityManager.entityRemoveComponent(this, e, t), this;
  }
  hasComponent(e, t) {
    return !!~this._ComponentTypes.indexOf(e) || t === !0 && this.hasRemovedComponent(e);
  }
  hasRemovedComponent(e) {
    return !!~this._ComponentTypesToRemove.indexOf(e);
  }
  hasAllComponents(e) {
    for (var t = 0; t < e.length; t++)
      if (!this.hasComponent(e[t])) return !1;
    return !0;
  }
  hasAnyComponents(e) {
    for (var t = 0; t < e.length; t++)
      if (this.hasComponent(e[t])) return !0;
    return !1;
  }
  removeAllComponents(e) {
    return this._entityManager.entityRemoveAllComponents(this, e);
  }
  copy(e) {
    for (var t in e._components) {
      var i = e._components[t];
      this.addComponent(i.constructor);
      var n = this.getComponent(i.constructor);
      n.copy(i);
    }
    return this;
  }
  clone() {
    return new Entity(this._entityManager).copy(this);
  }
  reset() {
    this.id = this._entityManager._nextEntityId++, this._ComponentTypes.length = 0, this.queries.length = 0;
    for (var e in this._components)
      delete this._components[e];
  }
  remove(e) {
    return this._entityManager.removeEntity(this, e);
  }
}
const DEFAULT_OPTIONS = {
  entityPoolSize: 0,
  entityClass: Entity
};
class World {
  constructor(e = {}) {
    if (this.options = Object.assign({}, DEFAULT_OPTIONS, e), this.componentsManager = new ComponentManager(this), this.entityManager = new EntityManager(this), this.systemManager = new SystemManager(this), this.enabled = !0, this.eventQueues = {}, hasWindow && typeof CustomEvent < "u") {
      var t = new CustomEvent("ecsy-world-created", {
        detail: { world: this, version: Version }
      });
      window.dispatchEvent(t);
    }
    this.lastTime = now$2();
  }
  registerComponent(e, t) {
    return this.componentsManager.registerComponent(e, t), this;
  }
  registerSystem(e, t) {
    return this.systemManager.registerSystem(e, t), this;
  }
  unregisterSystem(e) {
    return this.systemManager.unregisterSystem(e), this;
  }
  getSystem(e) {
    return this.systemManager.getSystem(e);
  }
  getSystems() {
    return this.systemManager.getSystems();
  }
  execute(e, t) {
    e || (t = now$2(), e = t - this.lastTime, this.lastTime = t), this.enabled && (this.systemManager.execute(e, t), this.entityManager.processDeferredRemoval());
  }
  stop() {
    this.enabled = !1;
  }
  play() {
    this.enabled = !0;
  }
  createEntity(e) {
    return this.entityManager.createEntity(e);
  }
  stats() {
    var e = {
      entities: this.entityManager.stats(),
      system: this.systemManager.stats()
    };
    console.log(JSON.stringify(e, null, 2));
  }
}
class System {
  canExecute() {
    if (this._mandatoryQueries.length === 0) return !0;
    for (let t = 0; t < this._mandatoryQueries.length; t++) {
      var e = this._mandatoryQueries[t];
      if (e.entities.length === 0)
        return !1;
    }
    return !0;
  }
  getName() {
    return this.constructor.getName();
  }
  constructor(e, t) {
    if (this.world = e, this.enabled = !0, this._queries = {}, this.queries = {}, this.priority = 0, this.executeTime = 0, t && t.priority && (this.priority = t.priority), this._mandatoryQueries = [], this.initialized = !0, this.constructor.queries)
      for (var i in this.constructor.queries) {
        var n = this.constructor.queries[i], r = n.components;
        if (!r || r.length === 0)
          throw new Error("'components' attribute can't be empty in a query");
        var s = this.world.entityManager.queryComponents(r);
        this._queries[i] = s, n.mandatory === !0 && this._mandatoryQueries.push(s), this.queries[i] = {
          results: s.entities
        };
        var a = ["added", "removed", "changed"];
        const l = {
          added: Query.prototype.ENTITY_ADDED,
          removed: Query.prototype.ENTITY_REMOVED,
          changed: Query.prototype.COMPONENT_CHANGED
          // Query.prototype.ENTITY_CHANGED
        };
        n.listen && a.forEach((c) => {
          if (this.execute || console.warn(
            `System '${this.getName()}' has defined listen events (${a.join(
              ", "
            )}) for query '${i}' but it does not implement the 'execute' method.`
          ), n.listen[c]) {
            let u = n.listen[c];
            if (c === "changed") {
              if (s.reactive = !0, u === !0) {
                let h = this.queries[i][c] = [];
                s.eventDispatcher.addEventListener(
                  Query.prototype.COMPONENT_CHANGED,
                  (d) => {
                    h.indexOf(d) === -1 && h.push(d);
                  }
                );
              } else if (Array.isArray(u)) {
                let h = this.queries[i][c] = [];
                s.eventDispatcher.addEventListener(
                  Query.prototype.COMPONENT_CHANGED,
                  (d, f) => {
                    u.indexOf(f.constructor) !== -1 && h.indexOf(d) === -1 && h.push(d);
                  }
                );
              }
            } else {
              let h = this.queries[i][c] = [];
              s.eventDispatcher.addEventListener(
                l[c],
                (d) => {
                  h.indexOf(d) === -1 && h.push(d);
                }
              );
            }
          }
        });
      }
  }
  stop() {
    this.executeTime = 0, this.enabled = !1;
  }
  play() {
    this.enabled = !0;
  }
  // @question rename to clear queues?
  clearEvents() {
    for (let t in this.queries) {
      var e = this.queries[t];
      if (e.added && (e.added.length = 0), e.removed && (e.removed.length = 0), e.changed)
        if (Array.isArray(e.changed))
          e.changed.length = 0;
        else
          for (let i in e.changed)
            e.changed[i].length = 0;
    }
  }
  toJSON() {
    var e = {
      name: this.getName(),
      enabled: this.enabled,
      executeTime: this.executeTime,
      priority: this.priority,
      queries: {}
    };
    if (this.constructor.queries) {
      var t = this.constructor.queries;
      for (let i in t) {
        let n = this.queries[i], r = t[i], s = e.queries[i] = {
          key: this._queries[i].key
        };
        s.mandatory = r.mandatory === !0, s.reactive = r.listen && (r.listen.added === !0 || r.listen.removed === !0 || r.listen.changed === !0 || Array.isArray(r.listen.changed)), s.reactive && (s.listen = {}, ["added", "removed", "changed"].forEach((l) => {
          n[l] && (s.listen[l] = {
            entities: n[l].length
          });
        }));
      }
    }
    return e;
  }
}
System.isSystem = !0;
System.getName = function() {
  return this.displayName || this.name;
};
function Not(o) {
  return {
    operator: "not",
    Component: o
  };
}
class TagComponent extends Component$1 {
  constructor() {
    super(!1);
  }
}
TagComponent.isTagComponent = !0;
const copyValue = (o) => o, cloneValue = (o) => o, copyArray = (o, e) => {
  if (!o)
    return o;
  if (!e)
    return o.slice();
  e.length = 0;
  for (let t = 0; t < o.length; t++)
    e.push(o[t]);
  return e;
}, cloneArray = (o) => o && o.slice(), copyJSON = (o) => JSON.parse(JSON.stringify(o)), cloneJSON = (o) => JSON.parse(JSON.stringify(o)), copyCopyable = (o, e) => o && (e ? e.copy(o) : o.clone()), cloneClonable = (o) => o && o.clone();
function createType(o) {
  var e = ["name", "default", "copy", "clone"], t = e.filter((i) => !o.hasOwnProperty(i));
  if (t.length > 0)
    throw new Error(
      `createType expects a type definition with the following properties: ${t.join(
        ", "
      )}`
    );
  return o.isType = !0, o;
}
const Types = {
  Number: createType({
    name: "Number",
    default: 0,
    copy: copyValue,
    clone: cloneValue
  }),
  Boolean: createType({
    name: "Boolean",
    default: !1,
    copy: copyValue,
    clone: cloneValue
  }),
  String: createType({
    name: "String",
    default: "",
    copy: copyValue,
    clone: cloneValue
  }),
  Array: createType({
    name: "Array",
    default: [],
    copy: copyArray,
    clone: cloneArray
  }),
  Ref: createType({
    name: "Ref",
    default: void 0,
    copy: copyValue,
    clone: cloneValue
  }),
  JSON: createType({
    name: "JSON",
    default: null,
    copy: copyJSON,
    clone: cloneJSON
  })
};
function generateId(o) {
  for (var e = "", t = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", i = t.length, n = 0; n < o; n++)
    e += t.charAt(Math.floor(Math.random() * i));
  return e;
}
function injectScript(o, e) {
  var t = document.createElement("script");
  t.src = o, t.onload = e, (document.head || document.documentElement).appendChild(t);
}
function hookConsoleAndErrors(o) {
  var e = ["error", "warning", "log"];
  e.forEach((t) => {
    if (typeof console[t] == "function") {
      var i = console[t].bind(console);
      console[t] = (...n) => (o.send({
        method: "console",
        type: t,
        args: JSON.stringify(n)
      }), i.apply(null, n));
    }
  }), window.addEventListener("error", (t) => {
    o.send({
      method: "error",
      error: JSON.stringify({
        message: t.error.message,
        stack: t.error.stack
      })
    });
  });
}
function includeRemoteIdHTML(o) {
  let e = document.createElement("div");
  return e.style.cssText = `
    align-items: center;
    background-color: #333;
    color: #aaa;
    display:flex;
    font-family: Arial;
    font-size: 1.1em;
    height: 40px;
    justify-content: center;
    left: 0;
    opacity: 0.9;
    position: absolute;
    right: 0;
    text-align: center;
    top: 0;
  `, e.innerHTML = `Open ECSY devtools to connect to this page using the code:&nbsp;<b style="color: #fff">${o}</b>&nbsp;<button onClick="generateNewCode()">Generate new code</button>`, document.body.appendChild(e), e;
}
function enableRemoteDevtools(remoteId) {
  if (!hasWindow) {
    console.warn("Remote devtools not available outside the browser");
    return;
  }
  window.generateNewCode = () => {
    window.localStorage.clear(), remoteId = generateId(6), window.localStorage.setItem("ecsyRemoteId", remoteId), window.location.reload(!1);
  }, remoteId = remoteId || window.localStorage.getItem("ecsyRemoteId"), remoteId || (remoteId = generateId(6), window.localStorage.setItem("ecsyRemoteId", remoteId));
  let infoDiv = includeRemoteIdHTML(remoteId);
  window.__ECSY_REMOTE_DEVTOOLS_INJECTED = !0, window.__ECSY_REMOTE_DEVTOOLS = {};
  let Version = "", worldsBeforeLoading = [], onWorldCreated = (o) => {
    var e = o.detail.world;
    Version = o.detail.version, worldsBeforeLoading.push(e);
  };
  window.addEventListener("ecsy-world-created", onWorldCreated);
  let onLoaded = () => {
    var peer = new Peer(remoteId);
    peer.on("open", () => {
      peer.on("connection", (connection) => {
        window.__ECSY_REMOTE_DEVTOOLS.connection = connection, connection.on("open", function() {
          infoDiv.innerHTML = "Connected", connection.on("data", function(data) {
            if (data.type === "init") {
              var script = document.createElement("script");
              script.setAttribute("type", "text/javascript"), script.onload = () => {
                script.parentNode.removeChild(script), window.removeEventListener(
                  "ecsy-world-created",
                  onWorldCreated
                ), worldsBeforeLoading.forEach((o) => {
                  var e = new CustomEvent("ecsy-world-created", {
                    detail: { world: o, version: Version }
                  });
                  window.dispatchEvent(e);
                });
              }, script.innerHTML = data.script, (document.head || document.documentElement).appendChild(script), script.onload(), hookConsoleAndErrors(connection);
            } else if (data.type === "executeScript") {
              let value = eval(data.script);
              data.returnEval && connection.send({
                method: "evalReturn",
                value
              });
            }
          });
        });
      });
    });
  };
  injectScript(
    "https://cdn.jsdelivr.net/npm/peerjs@0.3.20/dist/peer.min.js",
    onLoaded
  );
}
hasWindow && new URLSearchParams(window.location.search).has("enable-remote-devtools") && enableRemoteDevtools();
class Object3DComponent extends Component$1 {
}
Object3DComponent.schema = {
  value: { default: null, type: Types.Ref }
};
class ECSYThreeEntity extends Entity {
  addObject3DComponent(e, t) {
    return e.entity = this, this.addComponent(Object3DComponent, { value: e }), this._entityManager.world.object3DInflator.inflate(this, e), t && t.hasComponent(Object3DComponent) && t.getObject3D().add(e), this;
  }
  removeObject3DComponent(e = !0) {
    const t = this.getComponent(Object3DComponent, !0).value;
    e && t.parent && t.parent.remove(t), this.removeComponent(Object3DComponent), this._entityManager.world.object3DInflator.deflate(this, t), t.entity = null;
  }
  remove(e) {
    if (this.hasComponent(Object3DComponent)) {
      const t = this.getObject3D();
      t.traverse((i) => {
        i.entity && this._entityManager.removeEntity(i.entity, e), i.entity = null;
      }), t.parent && t.parent.remove(t);
    }
    this._entityManager.removeEntity(this, e);
  }
  getObject3D() {
    return this.getComponent(Object3DComponent).value;
  }
}
class SceneTagComponent extends TagComponent {
}
class CameraTagComponent extends TagComponent {
}
class MeshTagComponent extends TagComponent {
}
const defaultObject3DInflator = {
  inflate: (o, e) => {
    e.isMesh ? o.addComponent(MeshTagComponent) : e.isScene ? o.addComponent(SceneTagComponent) : e.isCamera && o.addComponent(CameraTagComponent);
  },
  deflate: (o, e) => {
    e.isMesh ? o.removeComponent(MeshTagComponent) : e.isScene ? o.removeComponent(SceneTagComponent) : e.isCamera && o.removeComponent(CameraTagComponent);
  }
};
class ECSYThreeWorld extends World {
  constructor(e) {
    super(Object.assign({}, { entityClass: ECSYThreeEntity }, e)), this.object3DInflator = defaultObject3DInflator;
  }
}
const Vector3Type = createType({
  name: "Vector3",
  default: new Vector3(),
  copy: copyCopyable,
  clone: cloneClonable
}), ThreeTypes = {
  Vector3Type
};
class Active extends TagComponent {
}
class Animation extends Component$1 {
}
Animation.schema = {
  animations: { default: [], type: Types.Array },
  duration: { default: -1, type: Types.Number }
};
class Camera extends Component$1 {
}
Camera.schema = {
  fov: { default: 45, type: Types.Number },
  aspect: { default: 1, type: Types.Number },
  near: { default: 0.1, type: Types.Number },
  far: { default: 1e3, type: Types.Number },
  layers: { default: 0, type: Types.Number },
  handleResize: { default: !0, type: Types.Boolean }
};
class CameraRig extends Component$1 {
}
CameraRig.schema = {
  leftHand: { default: null, type: Types.Ref },
  rightHand: { default: null, type: Types.Ref },
  camera: { default: null, type: Types.Ref }
};
class Colliding extends Component$1 {
}
Colliding.schema = {
  collidingWith: { default: [], type: Types.Array },
  collidingFrame: { default: 0, type: Types.Number }
};
class CollisionStart extends TagComponent {
}
class CollisionStop extends TagComponent {
}
class Draggable extends Component$1 {
}
Draggable.schema = {
  value: { default: !1, type: Types.Boolean }
};
class Dragging extends TagComponent {
}
class Geometry extends Component$1 {
}
Geometry.schema = {
  primitive: { default: "box", type: Types.String },
  width: { default: 0, type: Types.Number },
  height: { default: 0, type: Types.Number },
  depth: { default: 0, type: Types.Number }
};
let GLTFLoader$1 = class extends Component$1 {
};
GLTFLoader$1.schema = {
  url: { default: "", type: Types.String },
  receiveShadow: { default: !1, type: Types.Boolean },
  castShadow: { default: !1, type: Types.Boolean },
  envMapOverride: { default: null, type: Types.Ref },
  append: { default: !0, type: Types.Boolean },
  onLoaded: { default: null, type: Types.Ref },
  parent: { default: null, type: Types.Ref }
};
class GLTFModel extends Component$1 {
}
GLTFModel.schema = {
  value: { default: null, type: Types.Ref }
};
class InputState extends Component$1 {
}
InputState.schema = {
  vrcontrollers: { default: /* @__PURE__ */ new Map(), type: Types.Ref },
  keyboard: { default: {}, type: Types.Ref },
  mouse: { default: {}, type: Types.Ref },
  gamepads: { default: {}, type: Types.Ref }
};
class Parent extends Component$1 {
}
Parent.schema = {
  value: { default: null, type: Types.Ref }
};
class ParentObject3D extends Component$1 {
}
ParentObject3D.schema = {
  value: { default: null, type: Types.Ref }
};
class Play extends TagComponent {
}
class Position extends Component$1 {
}
Position.schema = {
  value: { default: new Vector3(), type: Vector3Type }
};
class RenderPass extends Component$1 {
}
RenderPass.schema = {
  scene: { default: null, type: Types.Ref },
  camera: { default: null, type: Types.Ref }
};
class RigidBody extends Component$1 {
}
RigidBody.schema = {
  object: { default: null, type: Types.Ref },
  weight: { default: 0, type: Types.Number },
  restitution: { default: 1, type: Types.Number },
  friction: { default: 1, type: Types.Number },
  linearDamping: { default: 0, type: Types.Number },
  angularDamping: { default: 0, type: Types.Number },
  linearVelocity: { default: { x: 0, y: 0, z: 0 }, type: Types.Ref }
};
class Rotation extends Component$1 {
}
Rotation.schema = {
  // @fixme
  rotation: { default: new Vector3(), type: Vector3Type }
};
class Scale extends Component$1 {
}
Scale.schema = {
  // @fixme
  value: { default: new Vector3(), type: Vector3Type }
};
class Scene extends Component$1 {
}
Scene.schema = {
  value: { default: null, type: Types.Ref }
};
class Shape extends Component$1 {
}
Shape.schema = {
  primitive: { default: "", type: Types.String },
  width: { default: 0, type: Types.Number },
  height: { default: 0, type: Types.Number },
  depth: { default: 0, type: Types.Number },
  radius: { default: 0, type: Types.Number }
};
class SkyBox extends Component$1 {
}
SkyBox.schema = {
  textureUrl: { default: null, type: Types.String },
  type: { default: 0, type: Types.Number }
};
class Sound extends Component$1 {
}
Sound.schema = {
  sound: { default: null, type: Types.Ref },
  url: { default: "", type: Types.String }
};
class Stop extends TagComponent {
}
let Text$1 = class extends Component$1 {
};
Text$1.schema = {
  text: { default: "", type: Types.String },
  textAlign: { default: "left", type: Types.String },
  // ['left', 'right', 'center']
  anchor: { default: "center", type: Types.String },
  // ['left', 'right', 'center', 'align']
  baseline: { default: "center", type: Types.String },
  // ['top', 'center', 'bottom']
  color: { default: "#FFF", type: Types.String },
  font: { default: "", type: Types.String },
  //"https://code.cdn.mozilla.net/fonts/ttf/ZillaSlab-SemiBold.ttf"
  fontSize: { default: 0.2, type: Types.Number },
  letterSpacing: { default: 0, type: Types.Number },
  lineHeight: { default: 0, type: Types.Number },
  maxWidth: { default: 1 / 0, type: Types.Number },
  overflowWrap: { default: "normal", type: Types.String },
  // ['normal', 'break-word']
  whiteSpace: { default: "normal", type: Types.String },
  // ['normal', 'nowrap']
  opacity: { default: 1, type: Types.Number }
};
class Transform extends Component$1 {
}
Transform.schema = {
  position: { default: new Vector3(), type: Vector3Type },
  rotation: { default: new Vector3(), type: Vector3Type }
};
class Visible extends Component$1 {
}
Visible.schema = {
  value: { default: !0, type: Types.Boolean }
};
class VRController extends Component$1 {
}
VRController.schema = {
  id: { default: 0, type: Types.Number },
  controller: { default: null, type: Types.Ref }
};
class VRControllerBasicBehaviour extends Component$1 {
}
VRControllerBasicBehaviour.schema = {
  select: { default: null, type: Types.Ref },
  selectstart: { default: null, type: Types.Ref },
  selectend: { default: null, type: Types.Ref },
  connected: { default: null, type: Types.Ref },
  disconnected: { default: null, type: Types.Ref },
  squeeze: { default: null, type: Types.Ref },
  squeezestart: { default: null, type: Types.Ref },
  squeezeend: { default: null, type: Types.Ref }
};
class WebGLRenderer extends Component$1 {
}
WebGLRenderer.schema = {
  vr: { default: !1, type: Types.Boolean },
  ar: { default: !1, type: Types.Boolean },
  antialias: { default: !0, type: Types.Boolean },
  handleResize: { default: !0, type: Types.Boolean },
  shadowMap: { default: !0, type: Types.Boolean },
  animationLoop: { default: null, type: Types.Ref }
};
class ControllerConnected extends TagComponent {
}
class OnObject3DAdded extends Component$1 {
}
OnObject3DAdded.schema = {
  callback: { default: null, type: Types.Ref }
};
class UpdateAspectOnResizeTag extends TagComponent {
}
class VRButton {
  static createButton(e, t) {
    t && console.error('THREE.VRButton: The "options" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.');
    const i = document.createElement("button");
    function n() {
      let l = null;
      async function c(h) {
        h.addEventListener("end", u), await e.xr.setSession(h), i.textContent = "EXIT VR", l = h;
      }
      function u() {
        l.removeEventListener("end", u), i.textContent = "ENTER VR", l = null;
      }
      i.style.display = "", i.style.cursor = "pointer", i.style.left = "calc(50% - 50px)", i.style.width = "100px", i.textContent = "ENTER VR", i.onmouseenter = function() {
        i.style.opacity = "1.0";
      }, i.onmouseleave = function() {
        i.style.opacity = "0.5";
      }, i.onclick = function() {
        if (l === null) {
          const h = { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"] };
          navigator.xr.requestSession("immersive-vr", h).then(c);
        } else
          l.end();
      };
    }
    function r() {
      i.style.display = "", i.style.cursor = "auto", i.style.left = "calc(50% - 75px)", i.style.width = "150px", i.onmouseenter = null, i.onmouseleave = null, i.onclick = null;
    }
    function s() {
      r(), i.textContent = "VR NOT SUPPORTED";
    }
    function a(l) {
      l.style.position = "absolute", l.style.bottom = "20px", l.style.padding = "12px 6px", l.style.border = "1px solid #fff", l.style.borderRadius = "4px", l.style.background = "rgba(0,0,0,0.1)", l.style.color = "#fff", l.style.font = "normal 13px sans-serif", l.style.textAlign = "center", l.style.opacity = "0.5", l.style.outline = "none", l.style.zIndex = "999";
    }
    if ("xr" in navigator)
      return i.id = "VRButton", i.style.display = "none", a(i), navigator.xr.isSessionSupported("immersive-vr").then(function(l) {
        l ? n() : s();
      }), i;
    {
      const l = document.createElement("a");
      return window.isSecureContext === !1 ? (l.href = document.location.href.replace(/^http:/, "https:"), l.innerHTML = "WEBXR NEEDS HTTPS") : (l.href = "https://immersiveweb.dev/", l.innerHTML = "WEBXR NOT AVAILABLE"), l.style.left = "calc(50% - 90px)", l.style.width = "180px", l.style.textDecoration = "none", a(l), l;
    }
  }
}
class WebGLRendererContext extends Component$1 {
}
WebGLRendererContext.schema = {
  value: { default: null, type: Types.Ref }
};
class WebGLRendererSystem extends System {
  init() {
    this.world.registerComponent(WebGLRendererContext), window.addEventListener(
      "resize",
      () => {
        this.queries.renderers.results.forEach((e) => {
          var t = e.getMutableComponent(WebGLRenderer);
          t.width = window.innerWidth, t.height = window.innerHeight;
        });
      },
      !1
    );
  }
  execute() {
    this.queries.renderers.results.forEach((t) => {
      var i = t.getComponent(WebGLRendererContext).value;
      this.queries.renderPasses.results.forEach((n) => {
        var r = n.getComponent(RenderPass), s = r.scene.getObject3D();
        this.queries.activeCameras.results.forEach((a) => {
          var l = a.getObject3D();
          i.render(s, l);
        });
      });
    }), this.queries.uninitializedRenderers.results.forEach((t) => {
      var i = t.getComponent(WebGLRenderer), n = new WebGLRenderer$1({
        antialias: i.antialias
      });
      i.animationLoop && n.setAnimationLoop(i.animationLoop), n.setPixelRatio(window.devicePixelRatio), i.handleResize && n.setSize(window.innerWidth, window.innerHeight), n.shadowMap.enabled = i.shadowMap, document.body.appendChild(n.domElement), (i.vr || i.ar) && (n.xr.enabled = !0, i.vr && document.body.appendChild(VRButton.createButton(n)), i.ar && document.body.appendChild(ARButton.createButton(n))), t.addComponent(WebGLRendererContext, { value: n });
    }), this.queries.renderers.changed.forEach((t) => {
      var i = t.getComponent(WebGLRenderer), n = t.getComponent(WebGLRendererContext).value;
      (i.width !== n.width || i.height !== n.height) && n.setSize(i.width, i.height);
    });
  }
}
WebGLRendererSystem.queries = {
  uninitializedRenderers: {
    components: [WebGLRenderer, Not(WebGLRendererContext)]
  },
  renderers: {
    components: [WebGLRenderer, WebGLRendererContext],
    listen: {
      changed: [WebGLRenderer]
    }
  },
  renderPasses: {
    components: [RenderPass]
  },
  activeCameras: {
    components: [CameraTagComponent, Active],
    listen: {
      added: !0
    }
  }
};
class TransformSystem extends System {
  execute() {
    let e = this.queries.parent.added;
    for (var t = 0; t < e.length; t++) {
      var i = e[t];
      if (!i.alive)
        return;
      var n = i.getComponent(Parent).value;
      if (n.hasComponent(Object3DComponent)) {
        var r = n.getObject3D(), s = i.getObject3D();
        r.add(s);
      }
    }
    this.queries.parentObject3D.added.forEach((u) => {
      var h = u.getComponent(ParentObject3D).value, d = u.getObject3D();
      h.add(d);
    });
    var a = this.queries.transforms;
    for (let u = 0; u < a.added.length; u++) {
      let h = a.added[u], d = h.getComponent(Transform), f = h.getObject3D();
      f.position.copy(d.position), f.rotation.set(
        d.rotation.x,
        d.rotation.y,
        d.rotation.z
      );
    }
    for (let u = 0; u < a.changed.length; u++) {
      let h = a.changed[u];
      if (!h.alive)
        continue;
      let d = h.getComponent(Transform), f = h.getObject3D();
      f.position.copy(d.position), f.rotation.set(
        d.rotation.x,
        d.rotation.y,
        d.rotation.z
      );
    }
    let l = this.queries.positions;
    for (let u = 0; u < l.added.length; u++) {
      let h = l.added[u], d = h.getComponent(Position).value, f = h.getObject3D();
      f.position.copy(d), h.getComponent(Position).value = f.position;
    }
    let c = this.queries.scales;
    for (let u = 0; u < c.added.length; u++) {
      let h = c.added[u], d = h.getComponent(Scale).value;
      h.getObject3D().scale.copy(d);
    }
    for (let u = 0; u < c.changed.length; u++) {
      let h = c.changed[u], d = h.getComponent(Scale).value;
      h.getObject3D().scale.copy(d);
    }
  }
}
TransformSystem.queries = {
  parentObject3D: {
    components: [ParentObject3D, Object3DComponent],
    listen: {
      added: !0
    }
  },
  parent: {
    components: [Parent, Object3DComponent],
    listen: {
      added: !0
    }
  },
  transforms: {
    components: [Object3DComponent, Transform],
    listen: {
      added: !0,
      changed: [Transform]
    }
  },
  positions: {
    components: [Object3DComponent, Position],
    listen: {
      added: !0,
      changed: [Position]
    }
  },
  scales: {
    components: [Object3DComponent, Scale],
    listen: {
      added: !0,
      changed: [Scale]
    }
  }
};
class UpdateAspectOnResizeSystem extends System {
  init() {
    this.aspect = window.innerWidth / window.innerHeight, window.addEventListener(
      "resize",
      () => {
        this.aspect = window.innerWidth / window.innerHeight, console.log("resize", this.aspect);
      },
      !1
    );
  }
  execute() {
    let e = this.queries.cameras.results;
    for (let t = 0; t < e.length; t++) {
      let i = e[t].getObject3D();
      i.aspect !== this.aspect && (i.aspect = this.aspect, i.updateProjectionMatrix());
    }
  }
}
UpdateAspectOnResizeSystem.queries = {
  cameras: {
    components: [CameraTagComponent, UpdateAspectOnResizeTag, Object3DComponent]
  }
};
class OnObject3DAddedSystem extends System {
  execute() {
    const e = this.queries.entities.added;
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      i.getComponent(OnObject3DAdded).callback(i.getObject3D());
    }
  }
}
OnObject3DAddedSystem.queries = {
  entities: {
    components: [OnObject3DAdded, Object3DComponent],
    listen: {
      added: !0
    }
  }
};
function initialize(o = new ECSYThreeWorld(), e) {
  if (!(o instanceof ECSYThreeWorld))
    throw new Error(
      "The provided 'world' paremeter is not an instance of 'ECSYThreeWorld'"
    );
  if (o.registerSystem(UpdateAspectOnResizeSystem).registerSystem(TransformSystem).registerSystem(OnObject3DAddedSystem).registerSystem(WebGLRendererSystem), o.registerComponent(OnObject3DAdded).registerComponent(WebGLRenderer).registerComponent(Scene).registerComponent(Active).registerComponent(CameraRig).registerComponent(Parent).registerComponent(Object3DComponent).registerComponent(RenderPass).registerComponent(Camera).registerComponent(SceneTagComponent).registerComponent(CameraTagComponent).registerComponent(MeshTagComponent).registerComponent(UpdateAspectOnResizeTag), e = Object.assign({}, {
    vr: !1,
    defaults: !0
  }, e), !e.defaults)
    return { world: o };
  let i = e.animationLoop;
  if (!i) {
    const c = new Clock();
    i = () => {
      o.execute(c.getDelta(), c.elapsedTime);
    };
  }
  let n = o.createEntity().addComponent(Scene).addObject3DComponent(new Scene$1()), r = o.createEntity().addComponent(WebGLRenderer, {
    ar: e.ar,
    vr: e.vr,
    animationLoop: i
  });
  var s = null, a = null;
  e.ar || e.vr ? a = o.createEntity().addComponent(CameraRig).addComponent(Parent, { value: n }).addComponent(Active) : s = o.createEntity().addComponent(Camera).addComponent(UpdateAspectOnResizeTag).addObject3DComponent(
    new PerspectiveCamera(
      90,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    ),
    n
  ).addComponent(Active);
  let l = o.createEntity().addComponent(RenderPass, {
    scene: n,
    camera: s
  });
  return {
    world: o,
    entities: {
      scene: n,
      camera: s,
      cameraRig: a,
      renderer: r,
      renderPass: l
    }
  };
}
class GeometrySystem extends System {
  execute() {
    this.queries.entities.removed.forEach((e) => {
      var t = e.getRemovedComponent(Object3DComponent).value, i = e.getComponent(Parent, !0).value;
      i.getObject3D().remove(t);
    }), this.queries.entities.added.forEach((e) => {
      var t = e.getComponent(Geometry), i;
      switch (t.primitive) {
        case "torus":
          i = new TorusGeometry(
            t.radius,
            t.tube,
            t.radialSegments,
            t.tubularSegments
          );
          break;
        case "sphere":
          i = new IcosahedronGeometry(t.radius, 1);
          break;
        case "box":
          i = new BoxGeometry(
            t.width,
            t.height,
            t.depth
          );
          break;
      }
      var n = t.primitive === "torus" ? 10066176 : Math.random() * 16777215, r = new MeshLambertMaterial({
        color: n
      }), s = new Mesh(i, r);
      if (s.castShadow = !0, s.receiveShadow = !0, e.hasComponent(Transform)) {
        var a = e.getComponent(Transform);
        s.position.copy(a.position), a.rotation && s.rotation.set(
          a.rotation.x,
          a.rotation.y,
          a.rotation.z
        );
      }
      e.addComponent(Object3DComponent, { value: s });
    });
  }
}
GeometrySystem.queries = {
  entities: {
    components: [Geometry],
    // @todo Transform: As optional, how to define it?
    listen: {
      added: !0,
      removed: !0
    }
  }
};
class GLTFLoader extends Loader {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new GLTFMaterialsClearcoatExtension(t);
    }), this.register(function(t) {
      return new GLTFTextureBasisUExtension(t);
    }), this.register(function(t) {
      return new GLTFTextureWebPExtension(t);
    }), this.register(function(t) {
      return new GLTFMaterialsTransmissionExtension(t);
    }), this.register(function(t) {
      return new GLTFLightsExtension(t);
    }), this.register(function(t) {
      return new GLTFMeshoptCompression(t);
    });
  }
  load(e, t, i, n) {
    const r = this;
    let s;
    this.resourcePath !== "" ? s = this.resourcePath : this.path !== "" ? s = this.path : s = LoaderUtils.extractUrlBase(e), this.manager.itemStart(e);
    const a = function(c) {
      n ? n(c) : console.error(c), r.manager.itemError(e), r.manager.itemEnd(e);
    }, l = new FileLoader(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
      try {
        r.parse(c, s, function(u) {
          t(u), r.manager.itemEnd(e);
        }, a);
      } catch (u) {
        a(u);
      }
    }, i, a);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, i, n) {
    let r;
    const s = {}, a = {};
    if (typeof e == "string")
      r = e;
    else if (LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === BINARY_EXTENSION_HEADER_MAGIC) {
      try {
        s[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(e);
      } catch (h) {
        n && n(h);
        return;
      }
      r = s[EXTENSIONS.KHR_BINARY_GLTF].content;
    } else
      r = LoaderUtils.decodeText(new Uint8Array(e));
    const l = JSON.parse(r);
    if (l.asset === void 0 || l.asset.version[0] < 2) {
      n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const c = new GLTFParser(l, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const h = this.pluginCallbacks[u](c);
      a[h.name] = h, s[h.name] = !0;
    }
    if (l.extensionsUsed)
      for (let u = 0; u < l.extensionsUsed.length; ++u) {
        const h = l.extensionsUsed[u], d = l.extensionsRequired || [];
        switch (h) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            s[h] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            s[h] = new GLTFMaterialsPbrSpecularGlossinessExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            s[h] = new GLTFDracoMeshCompressionExtension(l, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            s[h] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            s[h] = new GLTFMeshQuantizationExtension();
            break;
          default:
            d.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
        }
      }
    c.setExtensions(s), c.setPlugins(a), c.parse(i, n);
  }
}
function GLTFRegistry() {
  let o = {};
  return {
    get: function(e) {
      return o[e];
    },
    add: function(e, t) {
      o[e] = t;
    },
    remove: function(e) {
      delete o[e];
    },
    removeAll: function() {
      o = {};
    }
  };
}
const EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
class GLTFLightsExtension {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let i = 0, n = t.length; i < n; i++) {
      const r = t[i];
      r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, i = "light:" + e;
    let n = t.cache.get(i);
    if (n) return n;
    const r = t.json, l = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
    let c;
    const u = new Color(16777215);
    l.color !== void 0 && u.fromArray(l.color);
    const h = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        c = new DirectionalLight(u), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new PointLight(u), c.distance = h;
        break;
      case "spot":
        c = new SpotLight(u), c.distance = h, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), n = Promise.resolve(c), t.cache.add(i, n), n;
  }
  createNodeAttachment(e) {
    const t = this, i = this.parser, r = i.json.nodes[e], a = (r.extensions && r.extensions[this.name] || {}).light;
    return a === void 0 ? null : this._loadLight(a).then(function(l) {
      return i._getNodeRef(t.cache, a, l);
    });
  }
}
class GLTFMaterialsUnlitExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(e, t, i) {
    const n = [];
    e.color = new Color(1, 1, 1), e.opacity = 1;
    const r = t.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        const s = r.baseColorFactor;
        e.color.fromArray(s), e.opacity = s[3];
      }
      r.baseColorTexture !== void 0 && n.push(i.assignTexture(e, "map", r.baseColorTexture));
    }
    return Promise.all(n);
  }
}
class GLTFMaterialsClearcoatExtension {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], s = n.extensions[this.name];
    if (s.clearcoatFactor !== void 0 && (t.clearcoat = s.clearcoatFactor), s.clearcoatTexture !== void 0 && r.push(i.assignTexture(t, "clearcoatMap", s.clearcoatTexture)), s.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = s.clearcoatRoughnessFactor), s.clearcoatRoughnessTexture !== void 0 && r.push(i.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), s.clearcoatNormalTexture !== void 0 && (r.push(i.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)), s.clearcoatNormalTexture.scale !== void 0)) {
      const a = s.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Vector2(a, -a);
    }
    return Promise.all(r);
  }
}
class GLTFMaterialsTransmissionExtension {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const i = this.parser, n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const r = [], s = n.extensions[this.name];
    return s.transmissionFactor !== void 0 && (t.transmission = s.transmissionFactor), s.transmissionTexture !== void 0 && r.push(i.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(r);
  }
}
class GLTFTextureBasisUExtension {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, i = t.json, n = i.textures[e];
    if (!n.extensions || !n.extensions[this.name])
      return null;
    const r = n.extensions[this.name], s = i.images[r.source], a = t.options.ktx2Loader;
    if (!a) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, s, a);
  }
}
class GLTFTextureWebPExtension {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, i = this.parser, n = i.json, r = n.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const s = r.extensions[t], a = n.images[s.source];
    let l = i.textureLoader;
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return i.loadTextureImage(e, a, l);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class GLTFMeshoptCompression {
  constructor(e) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, i = t.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const n = i.extensions[this.name], r = this.parser.getDependency("buffer", n.buffer), s = this.parser.options.meshoptDecoder;
      if (!s || !s.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return Promise.all([r, s.ready]).then(function(a) {
        const l = n.byteOffset || 0, c = n.byteLength || 0, u = n.count, h = n.byteStride, d = new ArrayBuffer(u * h), f = new Uint8Array(a[0], l, c);
        return s.decodeGltfBuffer(new Uint8Array(d), u, h, f, n.mode, n.filter), d;
      });
    } else
      return null;
  }
}
const BINARY_EXTENSION_HEADER_MAGIC = "glTF", BINARY_EXTENSION_HEADER_LENGTH = 12, BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
class GLTFBinaryExtension {
  constructor(e) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, BINARY_EXTENSION_HEADER_LENGTH);
    if (this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i = this.header.length - BINARY_EXTENSION_HEADER_LENGTH, n = new DataView(e, BINARY_EXTENSION_HEADER_LENGTH);
    let r = 0;
    for (; r < i; ) {
      const s = n.getUint32(r, !0);
      r += 4;
      const a = n.getUint32(r, !0);
      if (r += 4, a === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const l = new Uint8Array(e, BINARY_EXTENSION_HEADER_LENGTH + r, s);
        this.content = LoaderUtils.decodeText(l);
      } else if (a === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const l = BINARY_EXTENSION_HEADER_LENGTH + r;
        this.body = e.slice(l, l + s);
      }
      r += s;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class GLTFDracoMeshCompressionExtension {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const i = this.json, n = this.dracoLoader, r = e.extensions[this.name].bufferView, s = e.extensions[this.name].attributes, a = {}, l = {}, c = {};
    for (const u in s) {
      const h = ATTRIBUTES[u] || u.toLowerCase();
      a[h] = s[u];
    }
    for (const u in e.attributes) {
      const h = ATTRIBUTES[u] || u.toLowerCase();
      if (s[u] !== void 0) {
        const d = i.accessors[e.attributes[u]], f = WEBGL_COMPONENT_TYPES[d.componentType];
        c[h] = f, l[h] = d.normalized === !0;
      }
    }
    return t.getDependency("bufferView", r).then(function(u) {
      return new Promise(function(h) {
        n.decodeDracoFile(u, function(d) {
          for (const f in d.attributes) {
            const p = d.attributes[f], m = l[f];
            m !== void 0 && (p.normalized = m);
          }
          h(d);
        }, a, c);
      });
    });
  }
}
class GLTFTextureTransformExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return t.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class GLTFMeshStandardSGMaterial extends MeshStandardMaterial {
  constructor(e) {
    super(), this.isGLTFSpecularGlossinessMaterial = !0;
    const t = [
      "#ifdef USE_SPECULARMAP",
      "	uniform sampler2D specularMap;",
      "#endif"
    ].join(`
`), i = [
      "#ifdef USE_GLOSSINESSMAP",
      "	uniform sampler2D glossinessMap;",
      "#endif"
    ].join(`
`), n = [
      "vec3 specularFactor = specular;",
      "#ifdef USE_SPECULARMAP",
      "	vec4 texelSpecular = texture2D( specularMap, vUv );",
      "	texelSpecular = sRGBToLinear( texelSpecular );",
      "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	specularFactor *= texelSpecular.rgb;",
      "#endif"
    ].join(`
`), r = [
      "float glossinessFactor = glossiness;",
      "#ifdef USE_GLOSSINESSMAP",
      "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
      "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	glossinessFactor *= texelGlossiness.a;",
      "#endif"
    ].join(`
`), s = [
      "PhysicalMaterial material;",
      "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
      "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
      "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
      "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
      "material.specularRoughness += geometryRoughness;",
      "material.specularRoughness = min( material.specularRoughness, 1.0 );",
      "material.specularColor = specularFactor;"
    ].join(`
`), a = {
      specular: { value: new Color().setHex(16777215) },
      glossiness: { value: 1 },
      specularMap: { value: null },
      glossinessMap: { value: null }
    };
    this._extraUniforms = a, this.onBeforeCompile = function(l) {
      for (const c in a)
        l.uniforms[c] = a[c];
      l.fragmentShader = l.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", i).replace("#include <roughnessmap_fragment>", n).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s);
    }, Object.defineProperties(this, {
      specular: {
        get: function() {
          return a.specular.value;
        },
        set: function(l) {
          a.specular.value = l;
        }
      },
      specularMap: {
        get: function() {
          return a.specularMap.value;
        },
        set: function(l) {
          a.specularMap.value = l, l ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP;
        }
      },
      glossiness: {
        get: function() {
          return a.glossiness.value;
        },
        set: function(l) {
          a.glossiness.value = l;
        }
      },
      glossinessMap: {
        get: function() {
          return a.glossinessMap.value;
        },
        set: function(l) {
          a.glossinessMap.value = l, l ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
        }
      }
    }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
  }
}
class GLTFMaterialsPbrSpecularGlossinessExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = [
      "color",
      "map",
      "lightMap",
      "lightMapIntensity",
      "aoMap",
      "aoMapIntensity",
      "emissive",
      "emissiveIntensity",
      "emissiveMap",
      "bumpMap",
      "bumpScale",
      "normalMap",
      "normalMapType",
      "displacementMap",
      "displacementScale",
      "displacementBias",
      "specularMap",
      "specular",
      "glossinessMap",
      "glossiness",
      "alphaMap",
      "envMap",
      "envMapIntensity",
      "refractionRatio"
    ];
  }
  getMaterialType() {
    return GLTFMeshStandardSGMaterial;
  }
  extendParams(e, t, i) {
    const n = t.extensions[this.name];
    e.color = new Color(1, 1, 1), e.opacity = 1;
    const r = [];
    if (Array.isArray(n.diffuseFactor)) {
      const s = n.diffuseFactor;
      e.color.fromArray(s), e.opacity = s[3];
    }
    if (n.diffuseTexture !== void 0 && r.push(i.assignTexture(e, "map", n.diffuseTexture)), e.emissive = new Color(0, 0, 0), e.glossiness = n.glossinessFactor !== void 0 ? n.glossinessFactor : 1, e.specular = new Color(1, 1, 1), Array.isArray(n.specularFactor) && e.specular.fromArray(n.specularFactor), n.specularGlossinessTexture !== void 0) {
      const s = n.specularGlossinessTexture;
      r.push(i.assignTexture(e, "glossinessMap", s)), r.push(i.assignTexture(e, "specularMap", s));
    }
    return Promise.all(r);
  }
  createMaterial(e) {
    const t = new GLTFMeshStandardSGMaterial(e);
    return t.fog = !0, t.color = e.color, t.map = e.map === void 0 ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = e.aoMap === void 0 ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap, t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = e.normalMap === void 0 ? null : e.normalMap, t.normalMapType = TangentSpaceNormalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = e.specularMap === void 0 ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = e.glossinessMap === void 0 ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = e.envMap === void 0 ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = 0.98, t;
  }
}
class GLTFMeshQuantizationExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
}
class GLTFCubicSplineInterpolant extends Interpolant {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n * 3 + n;
    for (let s = 0; s !== n; s++)
      t[s] = i[r + s];
    return t;
  }
}
GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.interpolate_ = function(o, e, t, i) {
  const n = this.resultBuffer, r = this.sampleValues, s = this.valueSize, a = s * 2, l = s * 3, c = i - e, u = (t - e) / c, h = u * u, d = h * u, f = o * l, p = f - l, m = -2 * d + 3 * h, v = d - h, y = 1 - m, g = v - h + u;
  for (let _ = 0; _ !== s; _++) {
    const b = r[p + _ + s], S = r[p + _ + a] * c, x = r[f + _ + s], M = r[f + _] * c;
    n[_] = y * b + g * S + m * x + v * M;
  }
  return n;
};
const WEBGL_CONSTANTS = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
}, WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
}, WEBGL_TYPE_SIZES = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv2",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
}, ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function resolveURL(o, e) {
  return typeof o != "string" || o === "" ? "" : (/^https?:\/\//i.test(e) && /^\//.test(o) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(o) || /^data:.*,.*$/i.test(o) || /^blob:.*$/i.test(o) ? o : e + o);
}
function createDefaultMaterial(o) {
  return o.DefaultMaterial === void 0 && (o.DefaultMaterial = new MeshStandardMaterial({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: FrontSide
  })), o.DefaultMaterial;
}
function addUnknownExtensionsToUserData(o, e, t) {
  for (const i in t.extensions)
    o[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = t.extensions[i]);
}
function assignExtrasToUserData(o, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(o.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function addMorphTargets(o, e, t) {
  let i = !1, n = !1;
  for (let a = 0, l = e.length; a < l; a++) {
    const c = e[a];
    if (c.POSITION !== void 0 && (i = !0), c.NORMAL !== void 0 && (n = !0), i && n) break;
  }
  if (!i && !n) return Promise.resolve(o);
  const r = [], s = [];
  for (let a = 0, l = e.length; a < l; a++) {
    const c = e[a];
    if (i) {
      const u = c.POSITION !== void 0 ? t.getDependency("accessor", c.POSITION) : o.attributes.position;
      r.push(u);
    }
    if (n) {
      const u = c.NORMAL !== void 0 ? t.getDependency("accessor", c.NORMAL) : o.attributes.normal;
      s.push(u);
    }
  }
  return Promise.all([
    Promise.all(r),
    Promise.all(s)
  ]).then(function(a) {
    const l = a[0], c = a[1];
    return i && (o.morphAttributes.position = l), n && (o.morphAttributes.normal = c), o.morphTargetsRelative = !0, o;
  });
}
function updateMorphTargets(o, e) {
  if (o.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, i = e.weights.length; t < i; t++)
      o.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (o.morphTargetInfluences.length === t.length) {
      o.morphTargetDictionary = {};
      for (let i = 0, n = t.length; i < n; i++)
        o.morphTargetDictionary[t[i]] = i;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function createPrimitiveKey(o) {
  const e = o.extensions && o.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  let t;
  return e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + createAttributesKey(e.attributes) : t = o.indices + ":" + createAttributesKey(o.attributes) + ":" + o.mode, t;
}
function createAttributesKey(o) {
  let e = "";
  const t = Object.keys(o).sort();
  for (let i = 0, n = t.length; i < n; i++)
    e += t[i] + ":" + o[t[i]] + ";";
  return e;
}
function getNormalizedComponentScale(o) {
  switch (o) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
class GLTFParser {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new GLTFRegistry(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.textureCache = {}, this.nodeNamesUsed = {}, typeof createImageBitmap < "u" && /Firefox/.test(navigator.userAgent) === !1 ? this.textureLoader = new ImageBitmapLoader(this.options.manager) : this.textureLoader = new TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const i = this, n = this.json, r = this.extensions;
    this.cache.removeAll(), this._invokeAll(function(s) {
      return s._markDefs && s._markDefs();
    }), Promise.all(this._invokeAll(function(s) {
      return s.beforeRoot && s.beforeRoot();
    })).then(function() {
      return Promise.all([
        i.getDependencies("scene"),
        i.getDependencies("animation"),
        i.getDependencies("camera")
      ]);
    }).then(function(s) {
      const a = {
        scene: s[0][n.scene || 0],
        scenes: s[0],
        animations: s[1],
        cameras: s[2],
        asset: n.asset,
        parser: i,
        userData: {}
      };
      addUnknownExtensionsToUserData(r, a, n), assignExtrasToUserData(a, n), Promise.all(i._invokeAll(function(l) {
        return l.afterRoot && l.afterRoot(a);
      })).then(function() {
        e(a);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], i = this.json.meshes || [];
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n].joints;
      for (let a = 0, l = s.length; a < l; a++)
        e[s[a]].isBone = !0;
    }
    for (let n = 0, r = e.length; n < r; n++) {
      const s = e[n];
      s.mesh !== void 0 && (this._addNodeRef(this.meshCache, s.mesh), s.skin !== void 0 && (i[s.mesh].isSkinnedMesh = !0)), s.camera !== void 0 && this._addNodeRef(this.cameraCache, s.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i;
    const n = i.clone();
    return n.name += "_instance_" + e.uses[t]++, n;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      const n = e(t[i]);
      if (n) return n;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const i = [];
    for (let n = 0; n < t.length; n++) {
      const r = e(t[n]);
      r && i.push(r);
    }
    return i;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const i = e + ":" + t;
    let n = this.cache.get(i);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this.loadNode(t);
          break;
        case "mesh":
          n = this._invokeOne(function(r) {
            return r.loadMesh && r.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function(r) {
            return r.loadBufferView && r.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function(r) {
            return r.loadMaterial && r.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function(r) {
            return r.loadTexture && r.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this.loadAnimation(t);
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          throw new Error("Unknown type: " + e);
      }
      this.cache.add(i, n);
    }
    return n;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const i = this, n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(n.map(function(r, s) {
        return i.getDependency(e, s);
      })), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], i = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function(r, s) {
      i.load(resolveURL(t.uri, n.path), r, void 0, function() {
        s(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(i) {
      const n = t.byteLength || 0, r = t.byteOffset || 0;
      return i.slice(r, r + n);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, i = this.json, n = this.json.accessors[e];
    if (n.bufferView === void 0 && n.sparse === void 0)
      return Promise.resolve(null);
    const r = [];
    return n.bufferView !== void 0 ? r.push(this.getDependency("bufferView", n.bufferView)) : r.push(null), n.sparse !== void 0 && (r.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(r).then(function(s) {
      const a = s[0], l = WEBGL_TYPE_SIZES[n.type], c = WEBGL_COMPONENT_TYPES[n.componentType], u = c.BYTES_PER_ELEMENT, h = u * l, d = n.byteOffset || 0, f = n.bufferView !== void 0 ? i.bufferViews[n.bufferView].byteStride : void 0, p = n.normalized === !0;
      let m, v;
      if (f && f !== h) {
        const y = Math.floor(d / f), g = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + y + ":" + n.count;
        let _ = t.cache.get(g);
        _ || (m = new c(a, y * f, n.count * f / u), _ = new InterleavedBuffer(m, f / u), t.cache.add(g, _)), v = new InterleavedBufferAttribute(_, l, d % f / u, p);
      } else
        a === null ? m = new c(n.count * l) : m = new c(a, d, n.count * l), v = new BufferAttribute(m, l, p);
      if (n.sparse !== void 0) {
        const y = WEBGL_TYPE_SIZES.SCALAR, g = WEBGL_COMPONENT_TYPES[n.sparse.indices.componentType], _ = n.sparse.indices.byteOffset || 0, b = n.sparse.values.byteOffset || 0, S = new g(s[1], _, n.sparse.count * y), x = new c(s[2], b, n.sparse.count * l);
        a !== null && (v = new BufferAttribute(v.array.slice(), v.itemSize, v.normalized));
        for (let M = 0, w = S.length; M < w; M++) {
          const D = S[M];
          if (v.setX(D, x[M * l]), l >= 2 && v.setY(D, x[M * l + 1]), l >= 3 && v.setZ(D, x[M * l + 2]), l >= 4 && v.setW(D, x[M * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return v;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture>}
   */
  loadTexture(e) {
    const t = this.json, i = this.options, n = t.textures[e], r = t.images[n.source];
    let s = this.textureLoader;
    if (r.uri) {
      const a = i.manager.getHandler(r.uri);
      a !== null && (s = a);
    }
    return this.loadTextureImage(e, r, s);
  }
  loadTextureImage(e, t, i) {
    const n = this, r = this.json, s = this.options, a = r.textures[e], l = (t.uri || t.bufferView) + ":" + a.sampler;
    if (this.textureCache[l])
      return this.textureCache[l];
    const c = self.URL || self.webkitURL;
    let u = t.uri || "", h = !1, d = !0;
    const f = u.search(/\.jpe?g($|\?)/i) > 0 || u.search(/^data\:image\/jpeg/) === 0;
    if ((t.mimeType === "image/jpeg" || f) && (d = !1), t.bufferView !== void 0)
      u = n.getDependency("bufferView", t.bufferView).then(function(m) {
        if (t.mimeType === "image/png") {
          const y = new DataView(m, 25, 1).getUint8(0, !1);
          d = y === 6 || y === 4 || y === 3;
        }
        h = !0;
        const v = new Blob([m], { type: t.mimeType });
        return u = c.createObjectURL(v), u;
      });
    else if (t.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const p = Promise.resolve(u).then(function(m) {
      return new Promise(function(v, y) {
        let g = v;
        i.isImageBitmapLoader === !0 && (g = function(_) {
          const b = new Texture(_);
          b.needsUpdate = !0, v(b);
        }), i.load(resolveURL(m, s.path), g, void 0, y);
      });
    }).then(function(m) {
      h === !0 && c.revokeObjectURL(u), m.flipY = !1, a.name && (m.name = a.name), d || (m.format = RGBFormat);
      const y = (r.samplers || {})[a.sampler] || {};
      return m.magFilter = WEBGL_FILTERS[y.magFilter] || LinearFilter, m.minFilter = WEBGL_FILTERS[y.minFilter] || LinearMipmapLinearFilter, m.wrapS = WEBGL_WRAPPINGS[y.wrapS] || RepeatWrapping, m.wrapT = WEBGL_WRAPPINGS[y.wrapT] || RepeatWrapping, n.associations.set(m, {
        type: "textures",
        index: e
      }), m;
    }).catch(function() {
      return console.error("THREE.GLTFLoader: Couldn't load texture", u), null;
    });
    return this.textureCache[l] = p, p;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise}
   */
  assignTexture(e, t, i) {
    const n = this;
    return this.getDependency("texture", i.index).then(function(r) {
      if (i.texCoord !== void 0 && i.texCoord != 0 && !(t === "aoMap" && i.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + t + " not yet supported."), n.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const s = i.extensions !== void 0 ? i.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (s) {
          const a = n.associations.get(r);
          r = n.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(r, s), n.associations.set(r, a);
        }
      }
      e[t] = r;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let i = e.material;
    const n = t.attributes.tangent !== void 0, r = t.attributes.color !== void 0, s = t.attributes.normal === void 0, a = Object.keys(t.morphAttributes).length > 0, l = a && t.morphAttributes.normal !== void 0;
    if (e.isPoints) {
      const c = "PointsMaterial:" + i.uuid;
      let u = this.cache.get(c);
      u || (u = new PointsMaterial(), Material.prototype.copy.call(u, i), u.color.copy(i.color), u.map = i.map, u.sizeAttenuation = !1, this.cache.add(c, u)), i = u;
    } else if (e.isLine) {
      const c = "LineBasicMaterial:" + i.uuid;
      let u = this.cache.get(c);
      u || (u = new LineBasicMaterial(), Material.prototype.copy.call(u, i), u.color.copy(i.color), this.cache.add(c, u)), i = u;
    }
    if (n || r || s || a) {
      let c = "ClonedMaterial:" + i.uuid + ":";
      i.isGLTFSpecularGlossinessMaterial && (c += "specular-glossiness:"), n && (c += "vertex-tangents:"), r && (c += "vertex-colors:"), s && (c += "flat-shading:"), a && (c += "morph-targets:"), l && (c += "morph-normals:");
      let u = this.cache.get(c);
      u || (u = i.clone(), r && (u.vertexColors = !0), s && (u.flatShading = !0), a && (u.morphTargets = !0), l && (u.morphNormals = !0), n && (u.vertexTangents = !0, u.normalScale && (u.normalScale.y *= -1), u.clearcoatNormalScale && (u.clearcoatNormalScale.y *= -1)), this.cache.add(c, u), this.associations.set(u, this.associations.get(i))), i = u;
    }
    i.aoMap && t.attributes.uv2 === void 0 && t.attributes.uv !== void 0 && t.setAttribute("uv2", t.attributes.uv), e.material = i;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, i = this.json, n = this.extensions, r = i.materials[e];
    let s;
    const a = {}, l = r.extensions || {}, c = [];
    if (l[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const h = n[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      s = h.getMaterialType(), c.push(h.extendParams(a, r, t));
    } else if (l[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const h = n[EXTENSIONS.KHR_MATERIALS_UNLIT];
      s = h.getMaterialType(), c.push(h.extendParams(a, r, t));
    } else {
      const h = r.pbrMetallicRoughness || {};
      if (a.color = new Color(1, 1, 1), a.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const d = h.baseColorFactor;
        a.color.fromArray(d), a.opacity = d[3];
      }
      h.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", h.baseColorTexture)), a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))), s = this._invokeOne(function(d) {
        return d.getMaterialType && d.getMaterialType(e);
      }), c.push(Promise.all(this._invokeAll(function(d) {
        return d.extendMaterialParams && d.extendMaterialParams(e, a);
      })));
    }
    r.doubleSided === !0 && (a.side = DoubleSide);
    const u = r.alphaMode || ALPHA_MODES.OPAQUE;
    return u === ALPHA_MODES.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, u === ALPHA_MODES.MASK && (a.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)), r.normalTexture !== void 0 && s !== MeshBasicMaterial && (c.push(t.assignTexture(a, "normalMap", r.normalTexture)), a.normalScale = new Vector2(1, -1), r.normalTexture.scale !== void 0 && a.normalScale.set(r.normalTexture.scale, -r.normalTexture.scale)), r.occlusionTexture !== void 0 && s !== MeshBasicMaterial && (c.push(t.assignTexture(a, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && s !== MeshBasicMaterial && (a.emissive = new Color().fromArray(r.emissiveFactor)), r.emissiveTexture !== void 0 && s !== MeshBasicMaterial && c.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture)), Promise.all(c).then(function() {
      let h;
      return s === GLTFMeshStandardSGMaterial ? h = n[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : h = new s(a), r.name && (h.name = r.name), h.map && (h.map.encoding = sRGBEncoding), h.emissiveMap && (h.emissiveMap.encoding = sRGBEncoding), assignExtrasToUserData(h, r), t.associations.set(h, { type: "materials", index: e }), r.extensions && addUnknownExtensionsToUserData(n, h, r), h;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = PropertyBinding.sanitizeNodeName(e || "");
    let i = t;
    for (let n = 1; this.nodeNamesUsed[i]; ++n)
      i = t + "_" + n;
    return this.nodeNamesUsed[i] = !0, i;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, i = this.extensions, n = this.primitiveCache;
    function r(a) {
      return i[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
        return addPrimitiveAttributes(l, a, t);
      });
    }
    const s = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a], u = createPrimitiveKey(c), h = n[u];
      if (h)
        s.push(h.promise);
      else {
        let d;
        c.extensions && c.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] ? d = r(c) : d = addPrimitiveAttributes(new BufferGeometry(), c, t), n[u] = { primitive: c, promise: d }, s.push(d);
      }
    }
    return Promise.all(s);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, i = this.json, n = this.extensions, r = i.meshes[e], s = r.primitives, a = [];
    for (let l = 0, c = s.length; l < c; l++) {
      const u = s[l].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", s[l].material);
      a.push(u);
    }
    return a.push(t.loadGeometries(s)), Promise.all(a).then(function(l) {
      const c = l.slice(0, l.length - 1), u = l[l.length - 1], h = [];
      for (let f = 0, p = u.length; f < p; f++) {
        const m = u[f], v = s[f];
        let y;
        const g = c[f];
        if (v.mode === WEBGL_CONSTANTS.TRIANGLES || v.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || v.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || v.mode === void 0)
          y = r.isSkinnedMesh === !0 ? new SkinnedMesh(m, g) : new Mesh(m, g), y.isSkinnedMesh === !0 && !y.geometry.attributes.skinWeight.normalized && y.normalizeSkinWeights(), v.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ? y.geometry = toTrianglesDrawMode(y.geometry, TriangleStripDrawMode) : v.mode === WEBGL_CONSTANTS.TRIANGLE_FAN && (y.geometry = toTrianglesDrawMode(y.geometry, TriangleFanDrawMode));
        else if (v.mode === WEBGL_CONSTANTS.LINES)
          y = new LineSegments(m, g);
        else if (v.mode === WEBGL_CONSTANTS.LINE_STRIP)
          y = new Line(m, g);
        else if (v.mode === WEBGL_CONSTANTS.LINE_LOOP)
          y = new LineLoop(m, g);
        else if (v.mode === WEBGL_CONSTANTS.POINTS)
          y = new Points(m, g);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + v.mode);
        Object.keys(y.geometry.morphAttributes).length > 0 && updateMorphTargets(y, r), y.name = t.createUniqueName(r.name || "mesh_" + e), assignExtrasToUserData(y, r), v.extensions && addUnknownExtensionsToUserData(n, y, v), t.assignFinalMaterial(y), h.push(y);
      }
      if (h.length === 1)
        return h[0];
      const d = new Group();
      for (let f = 0, p = h.length; f < p; f++)
        d.add(h[f]);
      return d;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const i = this.json.cameras[e], n = i[i.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return i.type === "perspective" ? t = new PerspectiveCamera(MathUtils.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : i.type === "orthographic" && (t = new OrthographicCamera(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), i.name && (t.name = this.createUniqueName(i.name)), assignExtrasToUserData(t, i), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Object>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], i = { joints: t.joints };
    return t.inverseBindMatrices === void 0 ? Promise.resolve(i) : this.getDependency("accessor", t.inverseBindMatrices).then(function(n) {
      return i.inverseBindMatrices = n, i;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const i = this.json.animations[e], n = [], r = [], s = [], a = [], l = [];
    for (let c = 0, u = i.channels.length; c < u; c++) {
      const h = i.channels[c], d = i.samplers[h.sampler], f = h.target, p = f.node !== void 0 ? f.node : f.id, m = i.parameters !== void 0 ? i.parameters[d.input] : d.input, v = i.parameters !== void 0 ? i.parameters[d.output] : d.output;
      n.push(this.getDependency("node", p)), r.push(this.getDependency("accessor", m)), s.push(this.getDependency("accessor", v)), a.push(d), l.push(f);
    }
    return Promise.all([
      Promise.all(n),
      Promise.all(r),
      Promise.all(s),
      Promise.all(a),
      Promise.all(l)
    ]).then(function(c) {
      const u = c[0], h = c[1], d = c[2], f = c[3], p = c[4], m = [];
      for (let y = 0, g = u.length; y < g; y++) {
        const _ = u[y], b = h[y], S = d[y], x = f[y], M = p[y];
        if (_ === void 0) continue;
        _.updateMatrix(), _.matrixAutoUpdate = !0;
        let w;
        switch (PATH_PROPERTIES[M.path]) {
          case PATH_PROPERTIES.weights:
            w = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES.rotation:
            w = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            w = VectorKeyframeTrack;
            break;
        }
        const D = _.name ? _.name : _.uuid, B = x.interpolation !== void 0 ? INTERPOLATION[x.interpolation] : InterpolateLinear, z = [];
        PATH_PROPERTIES[M.path] === PATH_PROPERTIES.weights ? _.traverse(function(P) {
          P.isMesh === !0 && P.morphTargetInfluences && z.push(P.name ? P.name : P.uuid);
        }) : z.push(D);
        let F = S.array;
        if (S.normalized) {
          const P = getNormalizedComponentScale(F.constructor), R = new Float32Array(F.length);
          for (let L = 0, A = F.length; L < A; L++)
            R[L] = F[L] * P;
          F = R;
        }
        for (let P = 0, R = z.length; P < R; P++) {
          const L = new w(
            z[P] + "." + PATH_PROPERTIES[M.path],
            b.array,
            F,
            B
          );
          x.interpolation === "CUBICSPLINE" && (L.createInterpolant = function(k) {
            return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, k);
          }, L.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), m.push(L);
        }
      }
      const v = i.name ? i.name : "animation_" + e;
      return new AnimationClip(v, void 0, m);
    });
  }
  createNodeMesh(e) {
    const t = this.json, i = this, n = t.nodes[e];
    return n.mesh === void 0 ? null : i.getDependency("mesh", n.mesh).then(function(r) {
      const s = i._getNodeRef(i.meshCache, n.mesh, r);
      return n.weights !== void 0 && s.traverse(function(a) {
        if (a.isMesh)
          for (let l = 0, c = n.weights.length; l < c; l++)
            a.morphTargetInfluences[l] = n.weights[l];
      }), s;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, i = this.extensions, n = this, r = t.nodes[e], s = r.name ? n.createUniqueName(r.name) : "";
    return function() {
      const a = [], l = n._invokeOne(function(c) {
        return c.createNodeMesh && c.createNodeMesh(e);
      });
      return l && a.push(l), r.camera !== void 0 && a.push(n.getDependency("camera", r.camera).then(function(c) {
        return n._getNodeRef(n.cameraCache, r.camera, c);
      })), n._invokeAll(function(c) {
        return c.createNodeAttachment && c.createNodeAttachment(e);
      }).forEach(function(c) {
        a.push(c);
      }), Promise.all(a);
    }().then(function(a) {
      let l;
      if (r.isBone === !0 ? l = new Bone() : a.length > 1 ? l = new Group() : a.length === 1 ? l = a[0] : l = new Object3D(), l !== a[0])
        for (let c = 0, u = a.length; c < u; c++)
          l.add(a[c]);
      if (r.name && (l.userData.name = r.name, l.name = s), assignExtrasToUserData(l, r), r.extensions && addUnknownExtensionsToUserData(i, l, r), r.matrix !== void 0) {
        const c = new Matrix4();
        c.fromArray(r.matrix), l.applyMatrix4(c);
      } else
        r.translation !== void 0 && l.position.fromArray(r.translation), r.rotation !== void 0 && l.quaternion.fromArray(r.rotation), r.scale !== void 0 && l.scale.fromArray(r.scale);
      return n.associations.set(l, { type: "nodes", index: e }), l;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.json, i = this.extensions, n = this.json.scenes[e], r = this, s = new Group();
    n.name && (s.name = r.createUniqueName(n.name)), assignExtrasToUserData(s, n), n.extensions && addUnknownExtensionsToUserData(i, s, n);
    const a = n.nodes || [], l = [];
    for (let c = 0, u = a.length; c < u; c++)
      l.push(buildNodeHierachy(a[c], s, t, r));
    return Promise.all(l).then(function() {
      return s;
    });
  }
}
function buildNodeHierachy(o, e, t, i) {
  const n = t.nodes[o];
  return i.getDependency("node", o).then(function(r) {
    if (n.skin === void 0) return r;
    let s;
    return i.getDependency("skin", n.skin).then(function(a) {
      s = a;
      const l = [];
      for (let c = 0, u = s.joints.length; c < u; c++)
        l.push(i.getDependency("node", s.joints[c]));
      return Promise.all(l);
    }).then(function(a) {
      return r.traverse(function(l) {
        if (!l.isMesh) return;
        const c = [], u = [];
        for (let h = 0, d = a.length; h < d; h++) {
          const f = a[h];
          if (f) {
            c.push(f);
            const p = new Matrix4();
            s.inverseBindMatrices !== void 0 && p.fromArray(s.inverseBindMatrices.array, h * 16), u.push(p);
          } else
            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', s.joints[h]);
        }
        l.bind(new Skeleton(c, u), l.matrixWorld);
      }), r;
    });
  }).then(function(r) {
    e.add(r);
    const s = [];
    if (n.children) {
      const a = n.children;
      for (let l = 0, c = a.length; l < c; l++) {
        const u = a[l];
        s.push(buildNodeHierachy(u, r, t, i));
      }
    }
    return Promise.all(s);
  });
}
function computeBounds(o, e, t) {
  const i = e.attributes, n = new Box3();
  if (i.POSITION !== void 0) {
    const a = t.json.accessors[i.POSITION], l = a.min, c = a.max;
    if (l !== void 0 && c !== void 0) {
      if (n.set(
        new Vector3(l[0], l[1], l[2]),
        new Vector3(c[0], c[1], c[2])
      ), a.normalized) {
        const u = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[a.componentType]);
        n.min.multiplyScalar(u), n.max.multiplyScalar(u);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const r = e.targets;
  if (r !== void 0) {
    const a = new Vector3(), l = new Vector3();
    for (let c = 0, u = r.length; c < u; c++) {
      const h = r[c];
      if (h.POSITION !== void 0) {
        const d = t.json.accessors[h.POSITION], f = d.min, p = d.max;
        if (f !== void 0 && p !== void 0) {
          if (l.setX(Math.max(Math.abs(f[0]), Math.abs(p[0]))), l.setY(Math.max(Math.abs(f[1]), Math.abs(p[1]))), l.setZ(Math.max(Math.abs(f[2]), Math.abs(p[2]))), d.normalized) {
            const m = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[d.componentType]);
            l.multiplyScalar(m);
          }
          a.max(l);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n.expandByVector(a);
  }
  o.boundingBox = n;
  const s = new Sphere();
  n.getCenter(s.center), s.radius = n.min.distanceTo(n.max) / 2, o.boundingSphere = s;
}
function addPrimitiveAttributes(o, e, t) {
  const i = e.attributes, n = [];
  function r(s, a) {
    return t.getDependency("accessor", s).then(function(l) {
      o.setAttribute(a, l);
    });
  }
  for (const s in i) {
    const a = ATTRIBUTES[s] || s.toLowerCase();
    a in o.attributes || n.push(r(i[s], a));
  }
  if (e.indices !== void 0 && !o.index) {
    const s = t.getDependency("accessor", e.indices).then(function(a) {
      o.setIndex(a);
    });
    n.push(s);
  }
  return assignExtrasToUserData(o, e), computeBounds(o, e, t), Promise.all(n).then(function() {
    return e.targets !== void 0 ? addMorphTargets(o, e.targets, t) : o;
  });
}
function toTrianglesDrawMode(o, e) {
  let t = o.getIndex();
  if (t === null) {
    const s = [], a = o.getAttribute("position");
    if (a !== void 0) {
      for (let l = 0; l < a.count; l++)
        s.push(l);
      o.setIndex(s), t = o.getIndex();
    } else
      return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), o;
  }
  const i = t.count - 2, n = [];
  if (e === TriangleFanDrawMode)
    for (let s = 1; s <= i; s++)
      n.push(t.getX(0)), n.push(t.getX(s)), n.push(t.getX(s + 1));
  else
    for (let s = 0; s < i; s++)
      s % 2 === 0 ? (n.push(t.getX(s)), n.push(t.getX(s + 1)), n.push(t.getX(s + 2))) : (n.push(t.getX(s + 2)), n.push(t.getX(s + 1)), n.push(t.getX(s)));
  n.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
  const r = o.clone();
  return r.setIndex(n), r;
}
var loader = new GLTFLoader();
class GLTFLoaderState extends SystemStateComponent {
}
class GLTFLoaderSystem extends System {
  init() {
    this.world.registerComponent(GLTFLoaderState).registerComponent(GLTFModel), this.loaded = [];
  }
  execute() {
    const e = this.queries.toLoad.results;
    for (; e.length; ) {
      const i = e[0];
      i.addComponent(GLTFLoaderState), loader.load(
        i.getComponent(GLTFLoader$1).url,
        (n) => this.loaded.push([i, n])
      );
    }
    for (let i = 0; i < this.loaded.length; i++) {
      const [n, r] = this.loaded[i], s = n.getComponent(GLTFLoader$1);
      r.scene.traverse(function(a) {
        a.isMesh && (a.receiveShadow = s.receiveShadow, a.castShadow = s.castShadow, s.envMapOverride && (a.material.envMap = s.envMapOverride));
      }), n.hasComponent(Object3DComponent) ? s.append && n.getObject3D().add(r.scene) : n.addComponent(GLTFModel, { value: r }).addObject3DComponent(r.scene, s.parent), s.onLoaded && s.onLoaded(r.scene, r);
    }
    this.loaded.length = 0;
    const t = this.queries.toUnload.results;
    for (; t.length; ) {
      const i = t[0];
      i.removeComponent(GLTFLoaderState), i.removeObject3DComponent();
    }
  }
}
GLTFLoaderSystem.queries = {
  toLoad: {
    components: [GLTFLoader$1, Not(GLTFLoaderState)]
  },
  toUnload: {
    components: [GLTFLoaderState, Not(GLTFLoader$1)]
  }
};
class SkyBoxSystem extends System {
  execute() {
    let e = this.queries.entities.results;
    for (let t = 0; t < e.length; t++) {
      let i = e[t], n = i.getComponent(SkyBox), r = new Group(), s = new BoxGeometry(100, 100, 100);
      if (s.scale(1, 1, -1), n.type === "cubemap-stereo") {
        let a = getTexturesFromAtlasFile(n.textureUrl, 12), l = [];
        for (let d = 0; d < 6; d++)
          l.push(new MeshBasicMaterial({ map: a[d] }));
        let c = new Mesh(s, l);
        c.layers.set(1), r.add(c);
        let u = [];
        for (let d = 6; d < 12; d++)
          u.push(new MeshBasicMaterial({ map: a[d] }));
        let h = new Mesh(s, u);
        h.layers.set(2), r.add(h), i.addObject3DComponent(r, !1);
      } else
        console.warn("Unknown skybox type: ", n.type);
    }
  }
}
function getTexturesFromAtlasFile(o, e) {
  let t = [];
  for (let n = 0; n < e; n++)
    t[n] = new Texture();
  return new ImageLoader().load(o, function(n) {
    let r, s, a = n.height;
    for (let l = 0; l < t.length; l++)
      r = document.createElement("canvas"), s = r.getContext("2d"), r.height = a, r.width = a, s.drawImage(
        n,
        a * l,
        0,
        a,
        a,
        0,
        0,
        a,
        a
      ), t[l].image = r, t[l].needsUpdate = !0;
  }), t;
}
SkyBoxSystem.queries = {
  entities: {
    components: [SkyBox, Not(Object3DComponent)]
  }
};
class VisibilitySystem extends System {
  processVisibility(e) {
    e.forEach((t) => {
      t.getObject3D().visible = t.getComponent(Visible).value;
    });
  }
  execute() {
    this.processVisibility(this.queries.entities.added), this.processVisibility(this.queries.entities.changed);
  }
}
VisibilitySystem.queries = {
  entities: {
    components: [Visible, Object3DComponent],
    listen: {
      added: !0,
      changed: [Visible]
    }
  }
};
function workerBootstrap() {
  var o = /* @__PURE__ */ Object.create(null);
  function e(n, r) {
    var s = n.id, a = n.name, l = n.dependencies;
    l === void 0 && (l = []);
    var c = n.init;
    c === void 0 && (c = function() {
    });
    var u = n.getTransferables;
    if (u === void 0 && (u = null), !o[s])
      try {
        l = l.map(function(d) {
          return d && d.isWorkerModule && (e(d, function(f) {
            if (f instanceof Error)
              throw f;
          }), d = o[d.id].value), d;
        }), c = i("<" + a + ">.init", c), u && (u = i("<" + a + ">.getTransferables", u));
        var h = null;
        typeof c == "function" ? h = c.apply(void 0, l) : console.error("worker module init function failed to rehydrate"), o[s] = {
          id: s,
          value: h,
          getTransferables: u
        }, r(h);
      } catch (d) {
        d && d.noLog || console.error(d), r(d);
      }
  }
  function t(n, r) {
    var s, a = n.id, l = n.args;
    (!o[a] || typeof o[a].value != "function") && r(new Error("Worker module " + a + ": not found or its 'init' did not return a function"));
    try {
      var c = (s = o[a]).value.apply(s, l);
      c && typeof c.then == "function" ? c.then(u, function(h) {
        return r(h instanceof Error ? h : new Error("" + h));
      }) : u(c);
    } catch (h) {
      r(h);
    }
    function u(h) {
      try {
        var d = o[a].getTransferables && o[a].getTransferables(h);
        (!d || !Array.isArray(d) || !d.length) && (d = void 0), r(h, d);
      } catch (f) {
        console.error(f), r(f);
      }
    }
  }
  function i(n, r) {
    var s = void 0;
    self.troikaDefine = function(l) {
      return s = l;
    };
    var a = URL.createObjectURL(
      new Blob(
        ["/** " + n.replace(/\*/g, "") + ` **/

troikaDefine(
` + r + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(a);
    } catch (l) {
      console.error(l);
    }
    return URL.revokeObjectURL(a), delete self.troikaDefine, s;
  }
  self.addEventListener("message", function(n) {
    var r = n.data, s = r.messageId, a = r.action, l = r.data;
    try {
      a === "registerModule" && e(l, function(c) {
        c instanceof Error ? postMessage({
          messageId: s,
          success: !1,
          error: c.message
        }) : postMessage({
          messageId: s,
          success: !0,
          result: { isCallable: typeof c == "function" }
        });
      }), a === "callModule" && t(l, function(c, u) {
        c instanceof Error ? postMessage({
          messageId: s,
          success: !1,
          error: c.message
        }) : postMessage({
          messageId: s,
          success: !0,
          result: c
        }, u || void 0);
      });
    } catch (c) {
      postMessage({
        messageId: s,
        success: !1,
        error: c.stack
      });
    }
  });
}
function defineMainThreadModule(o) {
  var e = function() {
    for (var t = [], i = arguments.length; i--; ) t[i] = arguments[i];
    return e._getInitResult().then(function(n) {
      if (typeof n == "function")
        return n.apply(void 0, t);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var t = o.dependencies, i = o.init;
    t = Array.isArray(t) ? t.map(
      function(r) {
        return r && r._getInitResult ? r._getInitResult() : r;
      }
    ) : [];
    var n = Promise.all(t).then(function(r) {
      return i.apply(null, r);
    });
    return e._getInitResult = function() {
      return n;
    }, n;
  }, e;
}
var supportsWorkers = function() {
  var o = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), o = !0;
    } catch (t) {
      typeof process < "u" && process.env.NODE_ENV === "test" || console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]"
      );
    }
  return supportsWorkers = function() {
    return o;
  }, o;
}, _workerModuleId = 0, _messageId = 0, _allowInitAsString = !1, workers = /* @__PURE__ */ Object.create(null), registeredModules = /* @__PURE__ */ Object.create(null), openRequests = /* @__PURE__ */ Object.create(null);
function defineWorkerModule(o) {
  if ((!o || typeof o.init != "function") && !_allowInitAsString)
    throw new Error("requires `options.init` function");
  var e = o.dependencies, t = o.init, i = o.getTransferables, n = o.workerId;
  if (!supportsWorkers())
    return defineMainThreadModule(o);
  n == null && (n = "#default");
  var r = "workerModule" + ++_workerModuleId, s = o.name || r, a = null;
  e = e && e.map(function(c) {
    return typeof c == "function" && !c.workerModuleData && (_allowInitAsString = !0, c = defineWorkerModule({
      workerId: n,
      name: "<" + s + "> function dependency: " + c.name,
      init: `function(){return (
` + stringifyFunction(c) + `
)}`
    }), _allowInitAsString = !1), c && c.workerModuleData && (c = c.workerModuleData), c;
  });
  function l() {
    for (var c = [], u = arguments.length; u--; ) c[u] = arguments[u];
    if (!a) {
      a = callWorker(n, "registerModule", l.workerModuleData);
      var h = function() {
        a = null, registeredModules[n].delete(h);
      };
      (registeredModules[n] || (registeredModules[n] = /* @__PURE__ */ new Set())).add(h);
    }
    return a.then(function(d) {
      var f = d.isCallable;
      if (f)
        return callWorker(n, "callModule", { id: r, args: c });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return l.workerModuleData = {
    isWorkerModule: !0,
    id: r,
    name: s,
    dependencies: e,
    init: stringifyFunction(t),
    getTransferables: i && stringifyFunction(i)
  }, l;
}
function terminateWorker(o) {
  registeredModules[o] && registeredModules[o].forEach(function(e) {
    e();
  }), workers[o] && (workers[o].terminate(), delete workers[o]);
}
function stringifyFunction(o) {
  var e = o.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function getWorker(o) {
  var e = workers[o];
  if (!e) {
    var t = stringifyFunction(workerBootstrap);
    e = workers[o] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + o.replace(/\*/g, "") + ` **/

;(` + t + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(i) {
      var n = i.data, r = n.messageId, s = openRequests[r];
      if (!s)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete openRequests[r], s(n);
    };
  }
  return e;
}
function callWorker(o, e, t) {
  return new Promise(function(i, n) {
    var r = ++_messageId;
    openRequests[r] = function(s) {
      s.success ? i(s.result) : n(new Error("Error in worker " + e + " call: " + s.error));
    }, getWorker(o).postMessage({
      messageId: r,
      action: e,
      data: t
    });
  });
}
function SDFGenerator() {
  var o = function(e) {
    function t(U, H, I, V, W, X, q, O) {
      var te = 1 - q;
      O.x = te * te * U + 2 * te * q * I + q * q * W, O.y = te * te * H + 2 * te * q * V + q * q * X;
    }
    function i(U, H, I, V, W, X, q, O, te, ne) {
      var ce = 1 - te;
      ne.x = ce * ce * ce * U + 3 * ce * ce * te * I + 3 * ce * te * te * W + te * te * te * q, ne.y = ce * ce * ce * H + 3 * ce * ce * te * V + 3 * ce * te * te * X + te * te * te * O;
    }
    function n(U, H) {
      for (var I = /([MLQCZ])([^MLQCZ]*)/g, V, W, X, q, O; V = I.exec(U); ) {
        var te = V[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(ne) {
          return parseFloat(ne);
        });
        switch (V[1]) {
          case "M":
            q = W = te[0], O = X = te[1];
            break;
          case "L":
            (te[0] !== q || te[1] !== O) && H("L", q, O, q = te[0], O = te[1]);
            break;
          case "Q": {
            H("Q", q, O, q = te[2], O = te[3], te[0], te[1]);
            break;
          }
          case "C": {
            H("C", q, O, q = te[4], O = te[5], te[0], te[1], te[2], te[3]);
            break;
          }
          case "Z":
            (q !== W || O !== X) && H("L", q, O, W, X);
            break;
        }
      }
    }
    function r(U, H, I) {
      I === void 0 && (I = 16);
      var V = { x: 0, y: 0 };
      n(U, function(W, X, q, O, te, ne, ce, he, le) {
        switch (W) {
          case "L":
            H(X, q, O, te);
            break;
          case "Q": {
            for (var G = X, re = q, se = 1; se < I; se++)
              t(
                X,
                q,
                ne,
                ce,
                O,
                te,
                se / (I - 1),
                V
              ), H(G, re, V.x, V.y), G = V.x, re = V.y;
            break;
          }
          case "C": {
            for (var ae = X, oe = q, E = 1; E < I; E++)
              i(
                X,
                q,
                ne,
                ce,
                he,
                le,
                O,
                te,
                E / (I - 1),
                V
              ), H(ae, oe, V.x, V.y), ae = V.x, oe = V.y;
            break;
          }
        }
      });
    }
    var s = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", a = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", l = /* @__PURE__ */ new WeakMap(), c = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function u(U, H) {
      var I = U.getContext ? U.getContext("webgl", c) : U, V = l.get(I);
      if (!V) {
        let ce = function(ae) {
          var oe = X[ae];
          if (!oe && (oe = X[ae] = I.getExtension(ae), !oe))
            throw new Error(ae + " not supported");
          return oe;
        }, he = function(ae, oe) {
          var E = I.createShader(oe);
          return I.shaderSource(E, ae), I.compileShader(E), E;
        }, le = function(ae, oe, E, T) {
          if (!q[ae]) {
            var $ = {}, Z = {}, j = I.createProgram();
            I.attachShader(j, he(oe, I.VERTEX_SHADER)), I.attachShader(j, he(E, I.FRAGMENT_SHADER)), I.linkProgram(j), q[ae] = {
              program: j,
              transaction: function(ue) {
                I.useProgram(j), ue({
                  setUniform: function(fe, ve) {
                    for (var N = [], ee = arguments.length - 2; ee-- > 0; ) N[ee] = arguments[ee + 2];
                    var J = Z[ve] || (Z[ve] = I.getUniformLocation(j, ve));
                    I["uniform" + fe].apply(I, [J].concat(N));
                  },
                  setAttribute: function(fe, ve, N, ee, J) {
                    var ye = $[fe];
                    ye || (ye = $[fe] = {
                      buf: I.createBuffer(),
                      // TODO should we destroy our buffers?
                      loc: I.getAttribLocation(j, fe),
                      data: null
                    }), I.bindBuffer(I.ARRAY_BUFFER, ye.buf), I.vertexAttribPointer(ye.loc, ve, I.FLOAT, !1, 0, 0), I.enableVertexAttribArray(ye.loc), W ? I.vertexAttribDivisor(ye.loc, ee) : ce("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(ye.loc, ee), J !== ye.data && (I.bufferData(I.ARRAY_BUFFER, J, N), ye.data = J);
                  }
                });
              }
            };
          }
          q[ae].transaction(T);
        }, G = function(ae, oe) {
          te++;
          try {
            I.activeTexture(I.TEXTURE0 + te);
            var E = O[ae];
            E || (E = O[ae] = I.createTexture(), I.bindTexture(I.TEXTURE_2D, E), I.texParameteri(I.TEXTURE_2D, I.TEXTURE_MIN_FILTER, I.NEAREST), I.texParameteri(I.TEXTURE_2D, I.TEXTURE_MAG_FILTER, I.NEAREST)), I.bindTexture(I.TEXTURE_2D, E), oe(E, te);
          } finally {
            te--;
          }
        }, re = function(ae, oe, E) {
          var T = I.createFramebuffer();
          ne.push(T), I.bindFramebuffer(I.FRAMEBUFFER, T), I.activeTexture(I.TEXTURE0 + oe), I.bindTexture(I.TEXTURE_2D, ae), I.framebufferTexture2D(I.FRAMEBUFFER, I.COLOR_ATTACHMENT0, I.TEXTURE_2D, ae, 0);
          try {
            E(T);
          } finally {
            I.deleteFramebuffer(T), I.bindFramebuffer(I.FRAMEBUFFER, ne[--ne.length - 1] || null);
          }
        }, se = function() {
          X = {}, q = {}, O = {}, te = -1, ne.length = 0;
        };
        var W = typeof WebGL2RenderingContext < "u" && I instanceof WebGL2RenderingContext, X = {}, q = {}, O = {}, te = -1, ne = [];
        I.canvas.addEventListener("webglcontextlost", function(ae) {
          se(), ae.preventDefault();
        }, !1), l.set(I, V = {
          gl: I,
          isWebGL2: W,
          getExtension: ce,
          withProgram: le,
          withTexture: G,
          withTextureFramebuffer: re,
          handleContextLoss: se
        });
      }
      H(V);
    }
    function h(U, H, I, V, W, X, q, O) {
      q === void 0 && (q = 15), O === void 0 && (O = null), u(U, function(te) {
        var ne = te.gl, ce = te.withProgram, he = te.withTexture;
        he("copy", function(le, G) {
          ne.texImage2D(ne.TEXTURE_2D, 0, ne.RGBA, W, X, 0, ne.RGBA, ne.UNSIGNED_BYTE, H), ce("copy", s, a, function(re) {
            var se = re.setUniform, ae = re.setAttribute;
            ae("aUV", 2, ne.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), se("1i", "image", G), ne.bindFramebuffer(ne.FRAMEBUFFER, O || null), ne.disable(ne.BLEND), ne.colorMask(q & 8, q & 4, q & 2, q & 1), ne.viewport(I, V, W, X), ne.scissor(I, V, W, X), ne.drawArrays(ne.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function d(U, H, I) {
      var V = U.width, W = U.height;
      u(U, function(X) {
        var q = X.gl, O = new Uint8Array(V * W * 4);
        q.readPixels(0, 0, V, W, q.RGBA, q.UNSIGNED_BYTE, O), U.width = H, U.height = I, h(q, O, 0, 0, V, W);
      });
    }
    var f = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: u,
      renderImageData: h,
      resizeWebGLCanvasWithoutClearing: d
    });
    function p(U, H, I, V, W, X) {
      X === void 0 && (X = 1);
      var q = new Uint8Array(U * H), O = V[2] - V[0], te = V[3] - V[1], ne = [];
      r(I, function(ae, oe, E, T) {
        ne.push({
          x1: ae,
          y1: oe,
          x2: E,
          y2: T,
          minX: Math.min(ae, E),
          minY: Math.min(oe, T),
          maxX: Math.max(ae, E),
          maxY: Math.max(oe, T)
        });
      }), ne.sort(function(ae, oe) {
        return ae.maxX - oe.maxX;
      });
      for (var ce = 0; ce < U; ce++)
        for (var he = 0; he < H; he++) {
          var le = re(
            V[0] + O * (ce + 0.5) / U,
            V[1] + te * (he + 0.5) / H
          ), G = Math.pow(1 - Math.abs(le) / W, X) / 2;
          le < 0 && (G = 1 - G), G = Math.max(0, Math.min(255, Math.round(G * 255))), q[he * U + ce] = G;
        }
      return q;
      function re(ae, oe) {
        for (var E = 1 / 0, T = 1 / 0, $ = ne.length; $--; ) {
          var Z = ne[$];
          if (Z.maxX + T <= ae)
            break;
          if (ae + T > Z.minX && oe - T < Z.maxY && oe + T > Z.minY) {
            var j = y(ae, oe, Z.x1, Z.y1, Z.x2, Z.y2);
            j < E && (E = j, T = Math.sqrt(E));
          }
        }
        return se(ae, oe) && (T = -T), T;
      }
      function se(ae, oe) {
        for (var E = 0, T = ne.length; T--; ) {
          var $ = ne[T];
          if ($.maxX <= ae)
            break;
          var Z = $.y1 > oe != $.y2 > oe && ae < ($.x2 - $.x1) * (oe - $.y1) / ($.y2 - $.y1) + $.x1;
          Z && (E += $.y1 < $.y2 ? 1 : -1);
        }
        return E !== 0;
      }
    }
    function m(U, H, I, V, W, X, q, O, te, ne) {
      X === void 0 && (X = 1), O === void 0 && (O = 0), te === void 0 && (te = 0), ne === void 0 && (ne = 0), v(U, H, I, V, W, X, q, null, O, te, ne);
    }
    function v(U, H, I, V, W, X, q, O, te, ne, ce) {
      X === void 0 && (X = 1), te === void 0 && (te = 0), ne === void 0 && (ne = 0), ce === void 0 && (ce = 0);
      for (var he = p(U, H, I, V, W, X), le = new Uint8Array(he.length * 4), G = 0; G < he.length; G++)
        le[G * 4 + ce] = he[G];
      h(q, le, te, ne, U, H, 1 << 3 - ce, O);
    }
    function y(U, H, I, V, W, X) {
      var q = W - I, O = X - V, te = q * q + O * O, ne = te ? Math.max(0, Math.min(1, ((U - I) * q + (H - V) * O) / te)) : 0, ce = U - (I + ne * q), he = H - (V + ne * O);
      return ce * ce + he * he;
    }
    var g = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: p,
      generateIntoCanvas: m,
      generateIntoFramebuffer: v
    }), _ = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", b = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", S = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", x = new Float32Array([0, 0, 2, 0, 0, 2]), M = null, w = !1, D = {}, B = /* @__PURE__ */ new WeakMap();
    function z(U) {
      if (!w && !L(U))
        throw new Error("WebGL generation not supported");
    }
    function F(U, H, I, V, W, X, q) {
      if (X === void 0 && (X = 1), q === void 0 && (q = null), !q && (q = M, !q)) {
        var O = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!O)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        q = M = O.getContext("webgl", { depth: !1 });
      }
      z(q);
      var te = new Uint8Array(U * H * 4);
      u(q, function(le) {
        var G = le.gl, re = le.withTexture, se = le.withTextureFramebuffer;
        re("readable", function(ae, oe) {
          G.texImage2D(G.TEXTURE_2D, 0, G.RGBA, U, H, 0, G.RGBA, G.UNSIGNED_BYTE, null), se(ae, oe, function(E) {
            R(
              U,
              H,
              I,
              V,
              W,
              X,
              G,
              E,
              0,
              0,
              0
              // red channel
            ), G.readPixels(0, 0, U, H, G.RGBA, G.UNSIGNED_BYTE, te);
          });
        });
      });
      for (var ne = new Uint8Array(U * H), ce = 0, he = 0; ce < te.length; ce += 4)
        ne[he++] = te[ce];
      return ne;
    }
    function P(U, H, I, V, W, X, q, O, te, ne) {
      X === void 0 && (X = 1), O === void 0 && (O = 0), te === void 0 && (te = 0), ne === void 0 && (ne = 0), R(U, H, I, V, W, X, q, null, O, te, ne);
    }
    function R(U, H, I, V, W, X, q, O, te, ne, ce) {
      X === void 0 && (X = 1), te === void 0 && (te = 0), ne === void 0 && (ne = 0), ce === void 0 && (ce = 0), z(q);
      var he = [];
      r(I, function(le, G, re, se) {
        he.push(le, G, re, se);
      }), he = new Float32Array(he), u(q, function(le) {
        var G = le.gl, re = le.isWebGL2, se = le.getExtension, ae = le.withProgram, oe = le.withTexture, E = le.withTextureFramebuffer, T = le.handleContextLoss;
        if (oe("rawDistances", function($, Z) {
          (U !== $._lastWidth || H !== $._lastHeight) && G.texImage2D(
            G.TEXTURE_2D,
            0,
            G.RGBA,
            $._lastWidth = U,
            $._lastHeight = H,
            0,
            G.RGBA,
            G.UNSIGNED_BYTE,
            null
          ), ae("main", _, b, function(j) {
            var de = j.setAttribute, ue = j.setUniform, pe = !re && se("ANGLE_instanced_arrays"), fe = !re && se("EXT_blend_minmax");
            de("aUV", 2, G.STATIC_DRAW, 0, x), de("aLineSegment", 4, G.DYNAMIC_DRAW, 1, he), ue.apply(void 0, ["4f", "uGlyphBounds"].concat(V)), ue("1f", "uMaxDistance", W), ue("1f", "uExponent", X), E($, Z, function(ve) {
              G.enable(G.BLEND), G.colorMask(!0, !0, !0, !0), G.viewport(0, 0, U, H), G.scissor(0, 0, U, H), G.blendFunc(G.ONE, G.ONE), G.blendEquationSeparate(G.FUNC_ADD, re ? G.MAX : fe.MAX_EXT), G.clear(G.COLOR_BUFFER_BIT), re ? G.drawArraysInstanced(G.TRIANGLES, 0, 3, he.length / 4) : pe.drawArraysInstancedANGLE(G.TRIANGLES, 0, 3, he.length / 4);
            });
          }), ae("post", s, S, function(j) {
            j.setAttribute("aUV", 2, G.STATIC_DRAW, 0, x), j.setUniform("1i", "tex", Z), G.bindFramebuffer(G.FRAMEBUFFER, O), G.disable(G.BLEND), G.colorMask(ce === 0, ce === 1, ce === 2, ce === 3), G.viewport(te, ne, U, H), G.scissor(te, ne, U, H), G.drawArrays(G.TRIANGLES, 0, 3);
          });
        }), G.isContextLost())
          throw T(), new Error("webgl context lost");
      });
    }
    function L(U) {
      var H = !U || U === M ? D : U.canvas || U, I = B.get(H);
      if (I === void 0) {
        w = !0;
        var V = null;
        try {
          var W = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], X = F(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            U
          );
          I = X && W.length === X.length && X.every(function(q, O) {
            return q === W[O];
          }), I || (V = "bad trial run results", console.info(W, X));
        } catch (q) {
          I = !1, V = q.message;
        }
        V && console.warn("WebGL SDF generation not supported:", V), w = !1, B.set(H, I);
      }
      return I;
    }
    var A = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: F,
      generateIntoCanvas: P,
      generateIntoFramebuffer: R,
      isSupported: L
    });
    function k(U, H, I, V, W, X) {
      W === void 0 && (W = Math.max(V[2] - V[0], V[3] - V[1]) / 2), X === void 0 && (X = 1);
      try {
        return F.apply(A, arguments);
      } catch (q) {
        return console.info("WebGL SDF generation failed, falling back to JS", q), p.apply(g, arguments);
      }
    }
    function Q(U, H, I, V, W, X, q, O, te, ne) {
      W === void 0 && (W = Math.max(V[2] - V[0], V[3] - V[1]) / 2), X === void 0 && (X = 1), O === void 0 && (O = 0), te === void 0 && (te = 0), ne === void 0 && (ne = 0);
      try {
        return P.apply(A, arguments);
      } catch (ce) {
        return console.info("WebGL SDF generation failed, falling back to JS", ce), m.apply(g, arguments);
      }
    }
    return e.forEachPathCommand = n, e.generate = k, e.generateIntoCanvas = Q, e.javascript = g, e.pathToLineSegments = r, e.webgl = A, e.webglUtils = f, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return o;
}
function bidiFactory() {
  var o = function(e) {
    var t = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, i = {}, n = {};
    i.L = 1, n[1] = "L", Object.keys(t).forEach(function(T, $) {
      i[T] = 1 << $ + 1, n[i[T]] = T;
    }), Object.freeze(i);
    var r = i.LRI | i.RLI | i.FSI, s = i.L | i.R | i.AL, a = i.B | i.S | i.WS | i.ON | i.FSI | i.LRI | i.RLI | i.PDI, l = i.BN | i.RLE | i.LRE | i.RLO | i.LRO | i.PDF, c = i.S | i.WS | i.B | r | i.PDI | l, u = null;
    function h() {
      if (!u) {
        u = /* @__PURE__ */ new Map();
        var T = function(Z) {
          if (t.hasOwnProperty(Z)) {
            var j = 0;
            t[Z].split(",").forEach(function(de) {
              var ue = de.split("+"), pe = ue[0], fe = ue[1];
              pe = parseInt(pe, 36), fe = fe ? parseInt(fe, 36) : 0, u.set(j += pe, i[Z]);
              for (var ve = 0; ve < fe; ve++)
                u.set(++j, i[Z]);
            });
          }
        };
        for (var $ in t) T($);
      }
    }
    function d(T) {
      return h(), u.get(T.codePointAt(0)) || i.L;
    }
    function f(T) {
      return n[d(T)];
    }
    var p = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function m(T, $) {
      var Z = 36, j = 0, de = /* @__PURE__ */ new Map(), ue = $ && /* @__PURE__ */ new Map(), pe;
      return T.split(",").forEach(function fe(ve) {
        if (ve.indexOf("+") !== -1)
          for (var N = +ve; N--; )
            fe(pe);
        else {
          pe = ve;
          var ee = ve.split(">"), J = ee[0], ye = ee[1];
          J = String.fromCodePoint(j += parseInt(J, Z)), ye = String.fromCodePoint(j += parseInt(ye, Z)), de.set(J, ye), $ && ue.set(ye, J);
        }
      }), { map: de, reverseMap: ue };
    }
    var v, y, g;
    function _() {
      if (!v) {
        var T = m(p.pairs, !0), $ = T.map, Z = T.reverseMap;
        v = $, y = Z, g = m(p.canonical, !1).map;
      }
    }
    function b(T) {
      return _(), v.get(T) || null;
    }
    function S(T) {
      return _(), y.get(T) || null;
    }
    function x(T) {
      return _(), g.get(T) || null;
    }
    var M = i.L, w = i.R, D = i.EN, B = i.ES, z = i.ET, F = i.AN, P = i.CS, R = i.B, L = i.S, A = i.ON, k = i.BN, Q = i.NSM, U = i.AL, H = i.LRO, I = i.RLO, V = i.LRE, W = i.RLE, X = i.PDF, q = i.LRI, O = i.RLI, te = i.FSI, ne = i.PDI;
    function ce(T, $) {
      for (var Z = 125, j = new Uint32Array(T.length), de = 0; de < T.length; de++)
        j[de] = d(T[de]);
      var ue = /* @__PURE__ */ new Map();
      function pe(Ke, it) {
        var Qe = j[Ke];
        j[Ke] = it, ue.set(Qe, ue.get(Qe) - 1), Qe & a && ue.set(a, ue.get(a) - 1), ue.set(it, (ue.get(it) || 0) + 1), it & a && ue.set(a, (ue.get(a) || 0) + 1);
      }
      for (var fe = new Uint8Array(T.length), ve = /* @__PURE__ */ new Map(), N = [], ee = null, J = 0; J < T.length; J++)
        ee || N.push(ee = {
          start: J,
          end: T.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: $ === "rtl" ? 1 : $ === "ltr" ? 0 : pn(J, !1)
        }), j[J] & R && (ee.end = J, ee = null);
      for (var ye = W | V | I | H | r | ne | X | R, me = function(Ke) {
        return Ke + (Ke & 1 ? 1 : 2);
      }, Le = function(Ke) {
        return Ke + (Ke & 1 ? 2 : 1);
      }, Te = 0; Te < N.length; Te++) {
        ee = N[Te];
        var we = [{
          _level: ee.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }], xe = void 0, Pe = 0, Fe = 0, He = 0;
        ue.clear();
        for (var Ve = ee.start; Ve <= ee.end; Ve++) {
          var Ee = j[Ve];
          if (xe = we[we.length - 1], ue.set(Ee, (ue.get(Ee) || 0) + 1), Ee & a && ue.set(a, (ue.get(a) || 0) + 1), Ee & ye)
            if (Ee & (W | V)) {
              fe[Ve] = xe._level;
              var Ue = (Ee === W ? Le : me)(xe._level);
              Ue <= Z && !Pe && !Fe ? we.push({
                _level: Ue,
                _override: 0,
                _isolate: 0
              }) : Pe || Fe++;
            } else if (Ee & (I | H)) {
              fe[Ve] = xe._level;
              var Je = (Ee === I ? Le : me)(xe._level);
              Je <= Z && !Pe && !Fe ? we.push({
                _level: Je,
                _override: Ee & I ? w : M,
                _isolate: 0
              }) : Pe || Fe++;
            } else if (Ee & r) {
              Ee & te && (Ee = pn(Ve + 1, !0) === 1 ? O : q), fe[Ve] = xe._level, xe._override && pe(Ve, xe._override);
              var Oe = (Ee === O ? Le : me)(xe._level);
              Oe <= Z && Pe === 0 && Fe === 0 ? (He++, we.push({
                _level: Oe,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: Ve
              })) : Pe++;
            } else if (Ee & ne) {
              if (Pe > 0)
                Pe--;
              else if (He > 0) {
                for (Fe = 0; !we[we.length - 1]._isolate; )
                  we.pop();
                var Ie = we[we.length - 1]._isolInitIndex;
                Ie != null && (ve.set(Ie, Ve), ve.set(Ve, Ie)), we.pop(), He--;
              }
              xe = we[we.length - 1], fe[Ve] = xe._level, xe._override && pe(Ve, xe._override);
            } else Ee & X ? (Pe === 0 && (Fe > 0 ? Fe-- : !xe._isolate && we.length > 1 && (we.pop(), xe = we[we.length - 1])), fe[Ve] = xe._level) : Ee & R && (fe[Ve] = ee.level);
          else
            fe[Ve] = xe._level, xe._override && Ee !== k && pe(Ve, xe._override);
        }
        for (var We = [], ze = null, Re = ee.start; Re <= ee.end; Re++) {
          var ke = j[Re];
          if (!(ke & l)) {
            var $e = fe[Re], Xe = ke & r, qe = ke === ne;
            ze && $e === ze._level ? (ze._end = Re, ze._endsWithIsolInit = Xe) : We.push(ze = {
              _start: Re,
              _end: Re,
              _level: $e,
              _startsWithPDI: qe,
              _endsWithIsolInit: Xe
            });
          }
        }
        for (var C = [], K = 0; K < We.length; K++) {
          var Y = We[K];
          if (!Y._startsWithPDI || Y._startsWithPDI && !ve.has(Y._start)) {
            for (var ie = [ze = Y], ge = void 0; ze && ze._endsWithIsolInit && (ge = ve.get(ze._end)) != null; )
              for (var Ae = K + 1; Ae < We.length; Ae++)
                if (We[Ae]._start === ge) {
                  ie.push(ze = We[Ae]);
                  break;
                }
            for (var be = [], _e = 0; _e < ie.length; _e++)
              for (var De = ie[_e], Me = De._start; Me <= De._end; Me++)
                be.push(Me);
            for (var Be = fe[be[0]], Ce = ee.level, Ne = be[0] - 1; Ne >= 0; Ne--)
              if (!(j[Ne] & l)) {
                Ce = fe[Ne];
                break;
              }
            var Ze = be[be.length - 1], Ye = fe[Ze], rt = ee.level;
            if (!(j[Ze] & r)) {
              for (var Ge = Ze + 1; Ge <= ee.end; Ge++)
                if (!(j[Ge] & l)) {
                  rt = fe[Ge];
                  break;
                }
            }
            C.push({
              _seqIndices: be,
              _sosType: Math.max(Ce, Be) % 2 ? w : M,
              _eosType: Math.max(rt, Ye) % 2 ? w : M
            });
          }
        }
        for (var tt = 0; tt < C.length; tt++) {
          var je = C[tt], Se = je._seqIndices, st = je._sosType, ct = je._eosType, ut = fe[Se[0]] & 1 ? w : M;
          if (ue.get(Q))
            for (var Mt = 0; Mt < Se.length; Mt++) {
              var Jt = Se[Mt];
              if (j[Jt] & Q) {
                for (var Bt = st, Tt = Mt - 1; Tt >= 0; Tt--)
                  if (!(j[Se[Tt]] & l)) {
                    Bt = j[Se[Tt]];
                    break;
                  }
                pe(Jt, Bt & (r | ne) ? A : Bt);
              }
            }
          if (ue.get(D))
            for (var wt = 0; wt < Se.length; wt++) {
              var Zt = Se[wt];
              if (j[Zt] & D)
                for (var Et = wt - 1; Et >= -1; Et--) {
                  var Kt = Et === -1 ? st : j[Se[Et]];
                  if (Kt & s) {
                    Kt === U && pe(Zt, F);
                    break;
                  }
                }
            }
          if (ue.get(U))
            for (var Ft = 0; Ft < Se.length; Ft++) {
              var Qt = Se[Ft];
              j[Qt] & U && pe(Qt, w);
            }
          if (ue.get(B) || ue.get(P))
            for (var pt = 1; pt < Se.length - 1; pt++) {
              var Nt = Se[pt];
              if (j[Nt] & (B | P)) {
                for (var ht = 0, Ut = 0, Ot = pt - 1; Ot >= 0 && (ht = j[Se[Ot]], !!(ht & l)); Ot--)
                  ;
                for (var Gt = pt + 1; Gt < Se.length && (Ut = j[Se[Gt]], !!(Ut & l)); Gt++)
                  ;
                ht === Ut && (j[Nt] === B ? ht === D : ht & (D | F)) && pe(Nt, ht);
              }
            }
          if (ue.get(D))
            for (var ot = 0; ot < Se.length; ot++) {
              var gn = Se[ot];
              if (j[gn] & D) {
                for (var At = ot - 1; At >= 0 && j[Se[At]] & (z | l); At--)
                  pe(Se[At], D);
                for (ot++; ot < Se.length && j[Se[ot]] & (z | l | D); ot++)
                  j[Se[ot]] !== D && pe(Se[ot], D);
              }
            }
          if (ue.get(z) || ue.get(B) || ue.get(P))
            for (var mt = 0; mt < Se.length; mt++) {
              var en = Se[mt];
              if (j[en] & (z | B | P)) {
                pe(en, A);
                for (var Ct = mt - 1; Ct >= 0 && j[Se[Ct]] & l; Ct--)
                  pe(Se[Ct], A);
                for (var Lt = mt + 1; Lt < Se.length && j[Se[Lt]] & l; Lt++)
                  pe(Se[Lt], A);
              }
            }
          if (ue.get(D))
            for (var Vt = 0, tn = st; Vt < Se.length; Vt++) {
              var nn = Se[Vt], zt = j[nn];
              zt & D ? tn === M && pe(nn, M) : zt & s && (tn = zt);
            }
          if (ue.get(a)) {
            var gt = w | D | F, rn = gt | M, Rt = [];
            {
              for (var dt = [], ft = 0; ft < Se.length; ft++)
                if (j[Se[ft]] & a) {
                  var yt = T[Se[ft]], sn = void 0;
                  if (b(yt) !== null)
                    if (dt.length < 63)
                      dt.push({ char: yt, seqIndex: ft });
                    else
                      break;
                  else if ((sn = S(yt)) !== null)
                    for (var vt = dt.length - 1; vt >= 0; vt--) {
                      var kt = dt[vt].char;
                      if (kt === sn || kt === S(x(yt)) || b(x(kt)) === yt) {
                        Rt.push([dt[vt].seqIndex, ft]), dt.length = vt;
                        break;
                      }
                    }
                }
              Rt.sort(function(Ke, it) {
                return Ke[0] - it[0];
              });
            }
            for (var Ht = 0; Ht < Rt.length; Ht++) {
              for (var on = Rt[Ht], Pt = on[0], Wt = on[1], an = !1, nt = 0, qt = Pt + 1; qt < Wt; qt++) {
                var ln = Se[qt];
                if (j[ln] & rn) {
                  an = !0;
                  var cn = j[ln] & gt ? w : M;
                  if (cn === ut) {
                    nt = cn;
                    break;
                  }
                }
              }
              if (an && !nt) {
                nt = st;
                for (var jt = Pt - 1; jt >= 0; jt--) {
                  var un = Se[jt];
                  if (j[un] & rn) {
                    var hn = j[un] & gt ? w : M;
                    hn !== ut ? nt = hn : nt = ut;
                    break;
                  }
                }
              }
              if (nt) {
                if (j[Se[Pt]] = j[Se[Wt]] = nt, nt !== ut) {
                  for (var _t = Pt + 1; _t < Se.length; _t++)
                    if (!(j[Se[_t]] & l)) {
                      d(T[Se[_t]]) & Q && (j[Se[_t]] = nt);
                      break;
                    }
                }
                if (nt !== ut) {
                  for (var xt = Wt + 1; xt < Se.length; xt++)
                    if (!(j[Se[xt]] & l)) {
                      d(T[Se[xt]]) & Q && (j[Se[xt]] = nt);
                      break;
                    }
                }
              }
            }
            for (var at = 0; at < Se.length; at++)
              if (j[Se[at]] & a) {
                for (var dn = at, $t = at, Xt = st, bt = at - 1; bt >= 0; bt--)
                  if (j[Se[bt]] & l)
                    dn = bt;
                  else {
                    Xt = j[Se[bt]] & gt ? w : M;
                    break;
                  }
                for (var fn = ct, St = at + 1; St < Se.length; St++)
                  if (j[Se[St]] & (a | l))
                    $t = St;
                  else {
                    fn = j[Se[St]] & gt ? w : M;
                    break;
                  }
                for (var Yt = dn; Yt <= $t; Yt++)
                  j[Se[Yt]] = Xt === fn ? Xt : ut;
                at = $t;
              }
          }
        }
        for (var et = ee.start; et <= ee.end; et++) {
          var yn = fe[et], Dt = j[et];
          if (yn & 1 ? Dt & (M | D | F) && fe[et]++ : Dt & w ? fe[et]++ : Dt & (F | D) && (fe[et] += 2), Dt & l && (fe[et] = et === 0 ? ee.level : fe[et - 1]), et === ee.end || d(T[et]) & (L | R))
            for (var It = et; It >= 0 && d(T[It]) & c; It--)
              fe[It] = ee.level;
        }
      }
      return {
        levels: fe,
        paragraphs: N
      };
      function pn(Ke, it) {
        for (var Qe = Ke; Qe < T.length; Qe++) {
          var lt = j[Qe];
          if (lt & (w | U))
            return 1;
          if (lt & (R | M) || it && lt === ne)
            return 0;
          if (lt & r) {
            var mn = vn(Qe);
            Qe = mn === -1 ? T.length : mn;
          }
        }
        return 0;
      }
      function vn(Ke) {
        for (var it = 1, Qe = Ke + 1; Qe < T.length; Qe++) {
          var lt = j[Qe];
          if (lt & R)
            break;
          if (lt & ne) {
            if (--it === 0)
              return Qe;
          } else lt & r && it++;
        }
        return -1;
      }
    }
    var he = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", le;
    function G() {
      if (!le) {
        var T = m(he, !0), $ = T.map, Z = T.reverseMap;
        Z.forEach(function(j, de) {
          $.set(de, j);
        }), le = $;
      }
    }
    function re(T) {
      return G(), le.get(T) || null;
    }
    function se(T, $, Z, j) {
      var de = T.length;
      Z = Math.max(0, Z == null ? 0 : +Z), j = Math.min(de - 1, j == null ? de - 1 : +j);
      for (var ue = /* @__PURE__ */ new Map(), pe = Z; pe <= j; pe++)
        if ($[pe] & 1) {
          var fe = re(T[pe]);
          fe !== null && ue.set(pe, fe);
        }
      return ue;
    }
    function ae(T, $, Z, j) {
      var de = T.length;
      Z = Math.max(0, Z == null ? 0 : +Z), j = Math.min(de - 1, j == null ? de - 1 : +j);
      var ue = [];
      return $.paragraphs.forEach(function(pe) {
        var fe = Math.max(Z, pe.start), ve = Math.min(j, pe.end);
        if (fe < ve) {
          for (var N = $.levels.slice(fe, ve + 1), ee = ve; ee >= fe && d(T[ee]) & c; ee--)
            N[ee] = pe.level;
          for (var J = pe.level, ye = 1 / 0, me = 0; me < N.length; me++) {
            var Le = N[me];
            Le > J && (J = Le), Le < ye && (ye = Le | 1);
          }
          for (var Te = J; Te >= ye; Te--)
            for (var we = 0; we < N.length; we++)
              if (N[we] >= Te) {
                for (var xe = we; we + 1 < N.length && N[we + 1] >= Te; )
                  we++;
                we > xe && ue.push([xe + fe, we + fe]);
              }
        }
      }), ue;
    }
    function oe(T, $, Z, j) {
      var de = E(T, $, Z, j), ue = [].concat(T);
      return de.forEach(function(pe, fe) {
        ue[fe] = ($.levels[pe] & 1 ? re(T[pe]) : null) || T[pe];
      }), ue.join("");
    }
    function E(T, $, Z, j) {
      for (var de = ae(T, $, Z, j), ue = [], pe = 0; pe < T.length; pe++)
        ue[pe] = pe;
      return de.forEach(function(fe) {
        for (var ve = fe[0], N = fe[1], ee = ue.slice(ve, N + 1), J = ee.length; J--; )
          ue[N - J] = ee[J];
      }), ue;
    }
    return e.closingToOpeningBracket = S, e.getBidiCharType = d, e.getBidiCharTypeName = f, e.getCanonicalBracket = x, e.getEmbeddingLevels = ce, e.getMirroredCharacter = re, e.getMirroredCharactersMap = se, e.getReorderSegments = ae, e.getReorderedIndices = E, e.getReorderedString = oe, e.openingToClosingBracket = b, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return o;
}
const voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function expandShaderIncludes(o) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(i, n) {
    let r = ShaderChunk[n];
    return r ? expandShaderIncludes(r) : i;
  }
  return o.replace(e, t);
}
const _lut = [];
for (let o = 0; o < 256; o++)
  _lut[o] = (o < 16 ? "0" : "") + o.toString(16);
function generateUUID() {
  const o = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (_lut[o & 255] + _lut[o >> 8 & 255] + _lut[o >> 16 & 255] + _lut[o >> 24 & 255] + "-" + _lut[e & 255] + _lut[e >> 8 & 255] + "-" + _lut[e >> 16 & 15 | 64] + _lut[e >> 24 & 255] + "-" + _lut[t & 63 | 128] + _lut[t >> 8 & 255] + "-" + _lut[t >> 16 & 255] + _lut[t >> 24 & 255] + _lut[i & 255] + _lut[i >> 8 & 255] + _lut[i >> 16 & 255] + _lut[i >> 24 & 255]).toUpperCase();
}
const assign$1 = Object.assign || function() {
  let o = arguments[0];
  for (let e = 1, t = arguments.length; e < t; e++) {
    let i = arguments[e];
    if (i)
      for (let n in i)
        Object.prototype.hasOwnProperty.call(i, n) && (o[n] = i[n]);
  }
  return o;
}, epoch = Date.now(), CONSTRUCTOR_CACHE = /* @__PURE__ */ new WeakMap(), SHADER_UPGRADE_CACHE = /* @__PURE__ */ new Map();
let materialInstanceId = 1e10;
function createDerivedMaterial(o, e) {
  const t = getKeyForOptions(e);
  let i = CONSTRUCTOR_CACHE.get(o);
  if (i || CONSTRUCTOR_CACHE.set(o, i = /* @__PURE__ */ Object.create(null)), i[t])
    return new i[t]();
  const n = `_onBeforeCompile${t}`, r = function(c, u) {
    o.onBeforeCompile.call(this, c, u);
    const h = this.customProgramCacheKey() + "|" + c.vertexShader + "|" + c.fragmentShader;
    let d = SHADER_UPGRADE_CACHE[h];
    if (!d) {
      const f = upgradeShaders(this, c, e, t);
      d = SHADER_UPGRADE_CACHE[h] = f;
    }
    c.vertexShader = d.vertexShader, c.fragmentShader = d.fragmentShader, assign$1(c.uniforms, this.uniforms), e.timeUniform && (c.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - epoch;
      }
    }), this[n] && this[n](c);
  }, s = function() {
    return a(e.chained ? o : o.clone());
  }, a = function(c) {
    const u = Object.create(c, l);
    return Object.defineProperty(u, "baseMaterial", { value: o }), Object.defineProperty(u, "id", { value: materialInstanceId++ }), u.uuid = generateUUID(), u.uniforms = assign$1({}, c.uniforms, e.uniforms), u.defines = assign$1({}, c.defines, e.defines), u.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", u.extensions = assign$1({}, c.extensions, e.extensions), u._listeners = void 0, u;
  }, l = {
    constructor: { value: s },
    isDerivedMaterial: { value: !0 },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return o.customProgramCacheKey() + "|" + t;
      }
    },
    onBeforeCompile: {
      get() {
        return r;
      },
      set(c) {
        this[n] = c;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(c) {
        return o.copy.call(this, c), !o.isShaderMaterial && !o.isDerivedMaterial && (assign$1(this.extensions, c.extensions), assign$1(this.defines, c.defines), assign$1(this.uniforms, UniformsUtils.clone(c.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const c = new o.constructor();
        return a(c).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let c = this._depthMaterial;
        return c || (c = this._depthMaterial = createDerivedMaterial(
          o.isDerivedMaterial ? o.getDepthMaterial() : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
          e
        ), c.defines.IS_DEPTH_MATERIAL = "", c.uniforms = this.uniforms), c;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let c = this._distanceMaterial;
        return c || (c = this._distanceMaterial = createDerivedMaterial(
          o.isDerivedMaterial ? o.getDistanceMaterial() : new MeshDistanceMaterial(),
          e
        ), c.defines.IS_DISTANCE_MATERIAL = "", c.uniforms = this.uniforms), c;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: c, _distanceMaterial: u } = this;
        c && c.dispose(), u && u.dispose(), o.dispose.call(this);
      }
    }
  };
  return i[t] = s, new s();
}
function upgradeShaders(o, { vertexShader: e, fragmentShader: t }, i, n) {
  let {
    vertexDefs: r,
    vertexMainIntro: s,
    vertexMainOutro: a,
    vertexTransform: l,
    fragmentDefs: c,
    fragmentMainIntro: u,
    fragmentMainOutro: h,
    fragmentColorTransform: d,
    customRewriter: f,
    timeUniform: p
  } = i;
  if (r = r || "", s = s || "", a = a || "", c = c || "", u = u || "", h = h || "", (l || f) && (e = expandShaderIncludes(e)), (d || f) && (t = t.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), t = expandShaderIncludes(t)), f) {
    let m = f({ vertexShader: e, fragmentShader: t });
    e = m.vertexShader, t = m.fragmentShader;
  }
  if (d) {
    let m = [];
    t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (v) => (m.push(v), "")
    ), h = `${d}
${m.join(`
`)}
${h}`;
  }
  if (p) {
    const m = `
uniform float ${p};
`;
    r = m + r, c = m + c;
  }
  return l && (e = `vec3 troika_position_${n};
vec3 troika_normal_${n};
vec2 troika_uv_${n};
${e}
`, r = `${r}
void troikaVertexTransform${n}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${l}
}
`, s = `
troika_position_${n} = vec3(position);
troika_normal_${n} = vec3(normal);
troika_uv_${n} = vec2(uv);
troikaVertexTransform${n}(troika_position_${n}, troika_normal_${n}, troika_uv_${n});
${s}
`, e = e.replace(/\b(position|normal|uv)\b/g, (m, v, y, g) => /\battribute\s+vec[23]\s+$/.test(g.substr(0, y)) ? v : `troika_${v}_${n}`), o.map && o.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${n}`))), e = injectIntoShaderCode(e, n, r, s, a), t = injectIntoShaderCode(t, n, c, u, h), {
    vertexShader: e,
    fragmentShader: t
  };
}
function injectIntoShaderCode(o, e, t, i, n) {
  return (i || n || t) && (o = o.replace(
    voidMainRegExp,
    `
${t}
void troikaOrigMain${e}() {`
  ), o += `
void main() {
  ${i}
  troikaOrigMain${e}();
  ${n}
}`), o;
}
function optionsJsonReplacer(o, e) {
  return o === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let _idCtr = 0;
const optionsHashesToIds = /* @__PURE__ */ new Map();
function getKeyForOptions(o) {
  const e = JSON.stringify(o, optionsJsonReplacer);
  let t = optionsHashesToIds.get(e);
  return t == null && optionsHashesToIds.set(e, t = ++_idCtr), t;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function typrFactory() {
  return typeof window > "u" && (self.window = self), function(o) {
    var e = { parse: function(n) {
      var r = e._bin, s = new Uint8Array(n);
      if (r.readASCII(s, 0, 4) == "ttcf") {
        var a = 4;
        r.readUshort(s, a), a += 2, r.readUshort(s, a), a += 2;
        var l = r.readUint(s, a);
        a += 4;
        for (var c = [], u = 0; u < l; u++) {
          var h = r.readUint(s, a);
          a += 4, c.push(e._readFont(s, h));
        }
        return c;
      }
      return [e._readFont(s, 0)];
    }, _readFont: function(n, r) {
      var s = e._bin, a = r;
      s.readFixed(n, r), r += 4;
      var l = s.readUshort(n, r);
      r += 2, s.readUshort(n, r), r += 2, s.readUshort(n, r), r += 2, s.readUshort(n, r), r += 2;
      for (var c = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], u = { _data: n, _offset: a }, h = {}, d = 0; d < l; d++) {
        var f = s.readASCII(n, r, 4);
        r += 4, s.readUint(n, r), r += 4;
        var p = s.readUint(n, r);
        r += 4;
        var m = s.readUint(n, r);
        r += 4, h[f] = { offset: p, length: m };
      }
      for (d = 0; d < c.length; d++) {
        var v = c[d];
        h[v] && (u[v.trim()] = e[v.trim()].parse(n, h[v].offset, h[v].length, u));
      }
      return u;
    }, _tabOffset: function(n, r, s) {
      for (var a = e._bin, l = a.readUshort(n, s + 4), c = s + 12, u = 0; u < l; u++) {
        var h = a.readASCII(n, c, 4);
        c += 4, a.readUint(n, c), c += 4;
        var d = a.readUint(n, c);
        if (c += 4, a.readUint(n, c), c += 4, h == r) return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(n, r) {
      return (n[r] << 8 | n[r + 1]) + (n[r + 2] << 8 | n[r + 3]) / 65540;
    }, readF2dot14: function(n, r) {
      return e._bin.readShort(n, r) / 16384;
    }, readInt: function(n, r) {
      return e._bin._view(n).getInt32(r);
    }, readInt8: function(n, r) {
      return e._bin._view(n).getInt8(r);
    }, readShort: function(n, r) {
      return e._bin._view(n).getInt16(r);
    }, readUshort: function(n, r) {
      return e._bin._view(n).getUint16(r);
    }, readUshorts: function(n, r, s) {
      for (var a = [], l = 0; l < s; l++) a.push(e._bin.readUshort(n, r + 2 * l));
      return a;
    }, readUint: function(n, r) {
      return e._bin._view(n).getUint32(r);
    }, readUint64: function(n, r) {
      return 4294967296 * e._bin.readUint(n, r) + e._bin.readUint(n, r + 4);
    }, readASCII: function(n, r, s) {
      for (var a = "", l = 0; l < s; l++) a += String.fromCharCode(n[r + l]);
      return a;
    }, readUnicode: function(n, r, s) {
      for (var a = "", l = 0; l < s; l++) {
        var c = n[r++] << 8 | n[r++];
        a += String.fromCharCode(c);
      }
      return a;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(n, r, s) {
      var a = e._bin._tdec;
      return a && r == 0 && s == n.length ? a.decode(n) : e._bin.readASCII(n, r, s);
    }, readBytes: function(n, r, s) {
      for (var a = [], l = 0; l < s; l++) a.push(n[r + l]);
      return a;
    }, readASCIIArray: function(n, r, s) {
      for (var a = [], l = 0; l < s; l++) a.push(String.fromCharCode(n[r + l]));
      return a;
    }, _view: function(n) {
      return n._dataView || (n._dataView = n.buffer ? new DataView(n.buffer, n.byteOffset, n.byteLength) : new DataView(new Uint8Array(n).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(n, r, s, a, l) {
      var c = e._bin, u = {}, h = r;
      c.readFixed(n, r), r += 4;
      var d = c.readUshort(n, r);
      r += 2;
      var f = c.readUshort(n, r);
      r += 2;
      var p = c.readUshort(n, r);
      return r += 2, u.scriptList = e._lctf.readScriptList(n, h + d), u.featureList = e._lctf.readFeatureList(n, h + f), u.lookupList = e._lctf.readLookupList(n, h + p, l), u;
    }, e._lctf.readLookupList = function(n, r, s) {
      var a = e._bin, l = r, c = [], u = a.readUshort(n, r);
      r += 2;
      for (var h = 0; h < u; h++) {
        var d = a.readUshort(n, r);
        r += 2;
        var f = e._lctf.readLookupTable(n, l + d, s);
        c.push(f);
      }
      return c;
    }, e._lctf.readLookupTable = function(n, r, s) {
      var a = e._bin, l = r, c = { tabs: [] };
      c.ltype = a.readUshort(n, r), r += 2, c.flag = a.readUshort(n, r), r += 2;
      var u = a.readUshort(n, r);
      r += 2;
      for (var h = c.ltype, d = 0; d < u; d++) {
        var f = a.readUshort(n, r);
        r += 2;
        var p = s(n, h, l + f, c);
        c.tabs.push(p);
      }
      return c;
    }, e._lctf.numOfOnes = function(n) {
      for (var r = 0, s = 0; s < 32; s++) n >>> s & 1 && r++;
      return r;
    }, e._lctf.readClassDef = function(n, r) {
      var s = e._bin, a = [], l = s.readUshort(n, r);
      if (r += 2, l == 1) {
        var c = s.readUshort(n, r);
        r += 2;
        var u = s.readUshort(n, r);
        r += 2;
        for (var h = 0; h < u; h++) a.push(c + h), a.push(c + h), a.push(s.readUshort(n, r)), r += 2;
      }
      if (l == 2) {
        var d = s.readUshort(n, r);
        for (r += 2, h = 0; h < d; h++) a.push(s.readUshort(n, r)), r += 2, a.push(s.readUshort(n, r)), r += 2, a.push(s.readUshort(n, r)), r += 2;
      }
      return a;
    }, e._lctf.getInterval = function(n, r) {
      for (var s = 0; s < n.length; s += 3) {
        var a = n[s], l = n[s + 1];
        if (n[s + 2], a <= r && r <= l) return s;
      }
      return -1;
    }, e._lctf.readCoverage = function(n, r) {
      var s = e._bin, a = {};
      a.fmt = s.readUshort(n, r), r += 2;
      var l = s.readUshort(n, r);
      return r += 2, a.fmt == 1 && (a.tab = s.readUshorts(n, r, l)), a.fmt == 2 && (a.tab = s.readUshorts(n, r, 3 * l)), a;
    }, e._lctf.coverageIndex = function(n, r) {
      var s = n.tab;
      if (n.fmt == 1) return s.indexOf(r);
      if (n.fmt == 2) {
        var a = e._lctf.getInterval(s, r);
        if (a != -1) return s[a + 2] + (r - s[a]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(n, r) {
      var s = e._bin, a = r, l = [], c = s.readUshort(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = s.readASCII(n, r, 4);
        r += 4;
        var d = s.readUshort(n, r);
        r += 2;
        var f = e._lctf.readFeatureTable(n, a + d);
        f.tag = h.trim(), l.push(f);
      }
      return l;
    }, e._lctf.readFeatureTable = function(n, r) {
      var s = e._bin, a = r, l = {}, c = s.readUshort(n, r);
      r += 2, c > 0 && (l.featureParams = a + c);
      var u = s.readUshort(n, r);
      r += 2, l.tab = [];
      for (var h = 0; h < u; h++) l.tab.push(s.readUshort(n, r + 2 * h));
      return l;
    }, e._lctf.readScriptList = function(n, r) {
      var s = e._bin, a = r, l = {}, c = s.readUshort(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = s.readASCII(n, r, 4);
        r += 4;
        var d = s.readUshort(n, r);
        r += 2, l[h.trim()] = e._lctf.readScriptTable(n, a + d);
      }
      return l;
    }, e._lctf.readScriptTable = function(n, r) {
      var s = e._bin, a = r, l = {}, c = s.readUshort(n, r);
      r += 2, c > 0 && (l.default = e._lctf.readLangSysTable(n, a + c));
      var u = s.readUshort(n, r);
      r += 2;
      for (var h = 0; h < u; h++) {
        var d = s.readASCII(n, r, 4);
        r += 4;
        var f = s.readUshort(n, r);
        r += 2, l[d.trim()] = e._lctf.readLangSysTable(n, a + f);
      }
      return l;
    }, e._lctf.readLangSysTable = function(n, r) {
      var s = e._bin, a = {};
      s.readUshort(n, r), r += 2, a.reqFeature = s.readUshort(n, r), r += 2;
      var l = s.readUshort(n, r);
      return r += 2, a.features = s.readUshorts(n, r, l), a;
    }, e.CFF = {}, e.CFF.parse = function(n, r, s) {
      var a = e._bin;
      (n = new Uint8Array(n.buffer, r, s))[r = 0], n[++r], n[++r], n[++r], r++;
      var l = [];
      r = e.CFF.readIndex(n, r, l);
      for (var c = [], u = 0; u < l.length - 1; u++) c.push(a.readASCII(n, r + l[u], l[u + 1] - l[u]));
      r += l[l.length - 1];
      var h = [];
      r = e.CFF.readIndex(n, r, h);
      var d = [];
      for (u = 0; u < h.length - 1; u++) d.push(e.CFF.readDict(n, r + h[u], r + h[u + 1]));
      r += h[h.length - 1];
      var f = d[0], p = [];
      r = e.CFF.readIndex(n, r, p);
      var m = [];
      for (u = 0; u < p.length - 1; u++) m.push(a.readASCII(n, r + p[u], p[u + 1] - p[u]));
      if (r += p[p.length - 1], e.CFF.readSubrs(n, r, f), f.CharStrings) {
        r = f.CharStrings, p = [], r = e.CFF.readIndex(n, r, p);
        var v = [];
        for (u = 0; u < p.length - 1; u++) v.push(a.readBytes(n, r + p[u], p[u + 1] - p[u]));
        f.CharStrings = v;
      }
      if (f.ROS) {
        r = f.FDArray;
        var y = [];
        for (r = e.CFF.readIndex(n, r, y), f.FDArray = [], u = 0; u < y.length - 1; u++) {
          var g = e.CFF.readDict(n, r + y[u], r + y[u + 1]);
          e.CFF._readFDict(n, g, m), f.FDArray.push(g);
        }
        r += y[y.length - 1], r = f.FDSelect, f.FDSelect = [];
        var _ = n[r];
        if (r++, _ != 3) throw _;
        var b = a.readUshort(n, r);
        for (r += 2, u = 0; u < b + 1; u++) f.FDSelect.push(a.readUshort(n, r), n[r + 2]), r += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(n, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(n, f.charset, f.CharStrings.length)), e.CFF._readFDict(n, f, m), f;
    }, e.CFF._readFDict = function(n, r, s) {
      var a;
      for (var l in r.Private && (a = r.Private[1], r.Private = e.CFF.readDict(n, a, a + r.Private[0]), r.Private.Subrs && e.CFF.readSubrs(n, a + r.Private.Subrs, r.Private)), r) ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(l) != -1 && (r[l] = s[r[l] - 426 + 35]);
    }, e.CFF.readSubrs = function(n, r, s) {
      var a = e._bin, l = [];
      r = e.CFF.readIndex(n, r, l);
      var c, u = l.length;
      c = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, s.Bias = c, s.Subrs = [];
      for (var h = 0; h < l.length - 1; h++) s.Subrs.push(a.readBytes(n, r + l[h], l[h + 1] - l[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(n, r) {
      for (var s = 0; s < n.charset.length; s++) if (n.charset[s] == r) return s;
      return -1;
    }, e.CFF.glyphBySE = function(n, r) {
      return r < 0 || r > 255 ? -1 : e.CFF.glyphByUnicode(n, e.CFF.tableSE[r]);
    }, e.CFF.readEncoding = function(n, r, s) {
      e._bin;
      var a = [".notdef"], l = n[r];
      if (r++, l != 0) throw "error: unknown encoding format: " + l;
      var c = n[r];
      r++;
      for (var u = 0; u < c; u++) a.push(n[r + u]);
      return a;
    }, e.CFF.readCharset = function(n, r, s) {
      var a = e._bin, l = [".notdef"], c = n[r];
      if (r++, c == 0) for (var u = 0; u < s; u++) {
        var h = a.readUshort(n, r);
        r += 2, l.push(h);
      }
      else {
        if (c != 1 && c != 2) throw "error: format: " + c;
        for (; l.length < s; ) {
          h = a.readUshort(n, r), r += 2;
          var d = 0;
          for (c == 1 ? (d = n[r], r++) : (d = a.readUshort(n, r), r += 2), u = 0; u <= d; u++) l.push(h), h++;
        }
      }
      return l;
    }, e.CFF.readIndex = function(n, r, s) {
      var a = e._bin, l = a.readUshort(n, r) + 1, c = n[r += 2];
      if (r++, c == 1) for (var u = 0; u < l; u++) s.push(n[r + u]);
      else if (c == 2) for (u = 0; u < l; u++) s.push(a.readUshort(n, r + 2 * u));
      else if (c == 3) for (u = 0; u < l; u++) s.push(16777215 & a.readUint(n, r + 3 * u - 1));
      else if (l != 1) throw "unsupported offset size: " + c + ", count: " + l;
      return (r += l * c) - 1;
    }, e.CFF.getCharString = function(n, r, s) {
      var a = e._bin, l = n[r], c = n[r + 1];
      n[r + 2], n[r + 3], n[r + 4];
      var u = 1, h = null, d = null;
      l <= 20 && (h = l, u = 1), l == 12 && (h = 100 * l + c, u = 2), 21 <= l && l <= 27 && (h = l, u = 1), l == 28 && (d = a.readShort(n, r + 1), u = 3), 29 <= l && l <= 31 && (h = l, u = 1), 32 <= l && l <= 246 && (d = l - 139, u = 1), 247 <= l && l <= 250 && (d = 256 * (l - 247) + c + 108, u = 2), 251 <= l && l <= 254 && (d = 256 * -(l - 251) - c - 108, u = 2), l == 255 && (d = a.readInt(n, r + 1) / 65535, u = 5), s.val = d ?? "o" + h, s.size = u;
    }, e.CFF.readCharString = function(n, r, s) {
      for (var a = r + s, l = e._bin, c = []; r < a; ) {
        var u = n[r], h = n[r + 1];
        n[r + 2], n[r + 3], n[r + 4];
        var d = 1, f = null, p = null;
        u <= 20 && (f = u, d = 1), u == 12 && (f = 100 * u + h, d = 2), u != 19 && u != 20 || (f = u, d = 2), 21 <= u && u <= 27 && (f = u, d = 1), u == 28 && (p = l.readShort(n, r + 1), d = 3), 29 <= u && u <= 31 && (f = u, d = 1), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255 && (p = l.readInt(n, r + 1) / 65535, d = 5), c.push(p ?? "o" + f), r += d;
      }
      return c;
    }, e.CFF.readDict = function(n, r, s) {
      for (var a = e._bin, l = {}, c = []; r < s; ) {
        var u = n[r], h = n[r + 1];
        n[r + 2], n[r + 3], n[r + 4];
        var d = 1, f = null, p = null;
        if (u == 28 && (p = a.readShort(n, r + 1), d = 3), u == 29 && (p = a.readInt(n, r + 1), d = 5), 32 <= u && u <= 246 && (p = u - 139, d = 1), 247 <= u && u <= 250 && (p = 256 * (u - 247) + h + 108, d = 2), 251 <= u && u <= 254 && (p = 256 * -(u - 251) - h - 108, d = 2), u == 255) throw p = a.readInt(n, r + 1) / 65535, d = 5, "unknown number";
        if (u == 30) {
          var m = [];
          for (d = 1; ; ) {
            var v = n[r + d];
            d++;
            var y = v >> 4, g = 15 & v;
            if (y != 15 && m.push(y), g != 15 && m.push(g), g == 15) break;
          }
          for (var _ = "", b = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], S = 0; S < m.length; S++) _ += b[m[S]];
          p = parseFloat(_);
        }
        u <= 21 && (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], d = 1, u == 12 && (f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2)), f != null ? (l[f] = c.length == 1 ? c[0] : c, c = []) : c.push(p), r += d;
      }
      return l;
    }, e.cmap = {}, e.cmap.parse = function(n, r, s) {
      n = new Uint8Array(n.buffer, r, s), r = 0;
      var a = e._bin, l = {};
      a.readUshort(n, r), r += 2;
      var c = a.readUshort(n, r);
      r += 2;
      var u = [];
      l.tables = [];
      for (var h = 0; h < c; h++) {
        var d = a.readUshort(n, r);
        r += 2;
        var f = a.readUshort(n, r);
        r += 2;
        var p = a.readUint(n, r);
        r += 4;
        var m = "p" + d + "e" + f, v = u.indexOf(p);
        if (v == -1) {
          var y;
          v = l.tables.length, u.push(p);
          var g = a.readUshort(n, p);
          g == 0 ? y = e.cmap.parse0(n, p) : g == 4 ? y = e.cmap.parse4(n, p) : g == 6 ? y = e.cmap.parse6(n, p) : g == 12 ? y = e.cmap.parse12(n, p) : console.debug("unknown format: " + g, d, f, p), l.tables.push(y);
        }
        if (l[m] != null) throw "multiple tables for one platform+encoding";
        l[m] = v;
      }
      return l;
    }, e.cmap.parse0 = function(n, r) {
      var s = e._bin, a = {};
      a.format = s.readUshort(n, r), r += 2;
      var l = s.readUshort(n, r);
      r += 2, s.readUshort(n, r), r += 2, a.map = [];
      for (var c = 0; c < l - 6; c++) a.map.push(n[r + c]);
      return a;
    }, e.cmap.parse4 = function(n, r) {
      var s = e._bin, a = r, l = {};
      l.format = s.readUshort(n, r), r += 2;
      var c = s.readUshort(n, r);
      r += 2, s.readUshort(n, r), r += 2;
      var u = s.readUshort(n, r);
      r += 2;
      var h = u / 2;
      l.searchRange = s.readUshort(n, r), r += 2, l.entrySelector = s.readUshort(n, r), r += 2, l.rangeShift = s.readUshort(n, r), r += 2, l.endCount = s.readUshorts(n, r, h), r += 2 * h, r += 2, l.startCount = s.readUshorts(n, r, h), r += 2 * h, l.idDelta = [];
      for (var d = 0; d < h; d++) l.idDelta.push(s.readShort(n, r)), r += 2;
      for (l.idRangeOffset = s.readUshorts(n, r, h), r += 2 * h, l.glyphIdArray = []; r < a + c; ) l.glyphIdArray.push(s.readUshort(n, r)), r += 2;
      return l;
    }, e.cmap.parse6 = function(n, r) {
      var s = e._bin, a = {};
      a.format = s.readUshort(n, r), r += 2, s.readUshort(n, r), r += 2, s.readUshort(n, r), r += 2, a.firstCode = s.readUshort(n, r), r += 2;
      var l = s.readUshort(n, r);
      r += 2, a.glyphIdArray = [];
      for (var c = 0; c < l; c++) a.glyphIdArray.push(s.readUshort(n, r)), r += 2;
      return a;
    }, e.cmap.parse12 = function(n, r) {
      var s = e._bin, a = {};
      a.format = s.readUshort(n, r), r += 2, r += 2, s.readUint(n, r), r += 4, s.readUint(n, r), r += 4;
      var l = s.readUint(n, r);
      r += 4, a.groups = [];
      for (var c = 0; c < l; c++) {
        var u = r + 12 * c, h = s.readUint(n, u + 0), d = s.readUint(n, u + 4), f = s.readUint(n, u + 8);
        a.groups.push([h, d, f]);
      }
      return a;
    }, e.glyf = {}, e.glyf.parse = function(n, r, s, a) {
      for (var l = [], c = 0; c < a.maxp.numGlyphs; c++) l.push(null);
      return l;
    }, e.glyf._parseGlyf = function(n, r) {
      var s = e._bin, a = n._data, l = e._tabOffset(a, "glyf", n._offset) + n.loca[r];
      if (n.loca[r] == n.loca[r + 1]) return null;
      var c = {};
      if (c.noc = s.readShort(a, l), l += 2, c.xMin = s.readShort(a, l), l += 2, c.yMin = s.readShort(a, l), l += 2, c.xMax = s.readShort(a, l), l += 2, c.yMax = s.readShort(a, l), l += 2, c.xMin >= c.xMax || c.yMin >= c.yMax) return null;
      if (c.noc > 0) {
        c.endPts = [];
        for (var u = 0; u < c.noc; u++) c.endPts.push(s.readUshort(a, l)), l += 2;
        var h = s.readUshort(a, l);
        if (l += 2, a.length - l < h) return null;
        c.instructions = s.readBytes(a, l, h), l += h;
        var d = c.endPts[c.noc - 1] + 1;
        for (c.flags = [], u = 0; u < d; u++) {
          var f = a[l];
          if (l++, c.flags.push(f), (8 & f) != 0) {
            var p = a[l];
            l++;
            for (var m = 0; m < p; m++) c.flags.push(f), u++;
          }
        }
        for (c.xs = [], u = 0; u < d; u++) {
          var v = (2 & c.flags[u]) != 0, y = (16 & c.flags[u]) != 0;
          v ? (c.xs.push(y ? a[l] : -a[l]), l++) : y ? c.xs.push(0) : (c.xs.push(s.readShort(a, l)), l += 2);
        }
        for (c.ys = [], u = 0; u < d; u++)
          v = (4 & c.flags[u]) != 0, y = (32 & c.flags[u]) != 0, v ? (c.ys.push(y ? a[l] : -a[l]), l++) : y ? c.ys.push(0) : (c.ys.push(s.readShort(a, l)), l += 2);
        var g = 0, _ = 0;
        for (u = 0; u < d; u++) g += c.xs[u], _ += c.ys[u], c.xs[u] = g, c.ys[u] = _;
      } else {
        var b;
        c.parts = [];
        do {
          b = s.readUshort(a, l), l += 2;
          var S = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (c.parts.push(S), S.glyphIndex = s.readUshort(a, l), l += 2, 1 & b) {
            var x = s.readShort(a, l);
            l += 2;
            var M = s.readShort(a, l);
            l += 2;
          } else
            x = s.readInt8(a, l), l++, M = s.readInt8(a, l), l++;
          2 & b ? (S.m.tx = x, S.m.ty = M) : (S.p1 = x, S.p2 = M), 8 & b ? (S.m.a = S.m.d = s.readF2dot14(a, l), l += 2) : 64 & b ? (S.m.a = s.readF2dot14(a, l), l += 2, S.m.d = s.readF2dot14(a, l), l += 2) : 128 & b && (S.m.a = s.readF2dot14(a, l), l += 2, S.m.b = s.readF2dot14(a, l), l += 2, S.m.c = s.readF2dot14(a, l), l += 2, S.m.d = s.readF2dot14(a, l), l += 2);
        } while (32 & b);
        if (256 & b) {
          var w = s.readUshort(a, l);
          for (l += 2, c.instr = [], u = 0; u < w; u++) c.instr.push(a[l]), l++;
        }
      }
      return c;
    }, e.GDEF = {}, e.GDEF.parse = function(n, r, s, a) {
      var l = r;
      r += 4;
      var c = e._bin.readUshort(n, r);
      return { glyphClassDef: c === 0 ? null : e._lctf.readClassDef(n, l + c) };
    }, e.GPOS = {}, e.GPOS.parse = function(n, r, s, a) {
      return e._lctf.parse(n, r, s, a, e.GPOS.subt);
    }, e.GPOS.subt = function(n, r, s, a) {
      var l = e._bin, c = s, u = {};
      if (u.fmt = l.readUshort(n, s), s += 2, r == 1 || r == 2 || r == 3 || r == 7 || r == 8 && u.fmt <= 2) {
        var h = l.readUshort(n, s);
        s += 2, u.coverage = e._lctf.readCoverage(n, h + c);
      }
      if (r == 1 && u.fmt == 1) {
        var d = l.readUshort(n, s);
        s += 2, d != 0 && (u.pos = e.GPOS.readValueRecord(n, s, d));
      } else if (r == 2 && u.fmt >= 1 && u.fmt <= 2) {
        d = l.readUshort(n, s), s += 2;
        var f = l.readUshort(n, s);
        s += 2;
        var p = e._lctf.numOfOnes(d), m = e._lctf.numOfOnes(f);
        if (u.fmt == 1) {
          u.pairsets = [];
          var v = l.readUshort(n, s);
          s += 2;
          for (var y = 0; y < v; y++) {
            var g = c + l.readUshort(n, s);
            s += 2;
            var _ = l.readUshort(n, g);
            g += 2;
            for (var b = [], S = 0; S < _; S++) {
              var x = l.readUshort(n, g);
              g += 2, d != 0 && (F = e.GPOS.readValueRecord(n, g, d), g += 2 * p), f != 0 && (P = e.GPOS.readValueRecord(n, g, f), g += 2 * m), b.push({ gid2: x, val1: F, val2: P });
            }
            u.pairsets.push(b);
          }
        }
        if (u.fmt == 2) {
          var M = l.readUshort(n, s);
          s += 2;
          var w = l.readUshort(n, s);
          s += 2;
          var D = l.readUshort(n, s);
          s += 2;
          var B = l.readUshort(n, s);
          for (s += 2, u.classDef1 = e._lctf.readClassDef(n, c + M), u.classDef2 = e._lctf.readClassDef(n, c + w), u.matrix = [], y = 0; y < D; y++) {
            var z = [];
            for (S = 0; S < B; S++) {
              var F = null, P = null;
              d != 0 && (F = e.GPOS.readValueRecord(n, s, d), s += 2 * p), f != 0 && (P = e.GPOS.readValueRecord(n, s, f), s += 2 * m), z.push({ val1: F, val2: P });
            }
            u.matrix.push(z);
          }
        }
      } else if (r == 4 && u.fmt == 1) u.markCoverage = e._lctf.readCoverage(n, l.readUshort(n, s) + c), u.baseCoverage = e._lctf.readCoverage(n, l.readUshort(n, s + 2) + c), u.markClassCount = l.readUshort(n, s + 4), u.markArray = e.GPOS.readMarkArray(n, l.readUshort(n, s + 6) + c), u.baseArray = e.GPOS.readBaseArray(n, l.readUshort(n, s + 8) + c, u.markClassCount);
      else if (r == 6 && u.fmt == 1) u.mark1Coverage = e._lctf.readCoverage(n, l.readUshort(n, s) + c), u.mark2Coverage = e._lctf.readCoverage(n, l.readUshort(n, s + 2) + c), u.markClassCount = l.readUshort(n, s + 4), u.mark1Array = e.GPOS.readMarkArray(n, l.readUshort(n, s + 6) + c), u.mark2Array = e.GPOS.readBaseArray(n, l.readUshort(n, s + 8) + c, u.markClassCount);
      else {
        if (r == 9 && u.fmt == 1) {
          var R = l.readUshort(n, s);
          s += 2;
          var L = l.readUint(n, s);
          if (s += 4, a.ltype == 9) a.ltype = R;
          else if (a.ltype != R) throw "invalid extension substitution";
          return e.GPOS.subt(n, a.ltype, c + L);
        }
        console.debug("unsupported GPOS table LookupType", r, "format", u.fmt);
      }
      return u;
    }, e.GPOS.readValueRecord = function(n, r, s) {
      var a = e._bin, l = [];
      return l.push(1 & s ? a.readShort(n, r) : 0), r += 1 & s ? 2 : 0, l.push(2 & s ? a.readShort(n, r) : 0), r += 2 & s ? 2 : 0, l.push(4 & s ? a.readShort(n, r) : 0), r += 4 & s ? 2 : 0, l.push(8 & s ? a.readShort(n, r) : 0), r += 8 & s ? 2 : 0, l;
    }, e.GPOS.readBaseArray = function(n, r, s) {
      var a = e._bin, l = [], c = r, u = a.readUshort(n, r);
      r += 2;
      for (var h = 0; h < u; h++) {
        for (var d = [], f = 0; f < s; f++) d.push(e.GPOS.readAnchorRecord(n, c + a.readUshort(n, r))), r += 2;
        l.push(d);
      }
      return l;
    }, e.GPOS.readMarkArray = function(n, r) {
      var s = e._bin, a = [], l = r, c = s.readUshort(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = e.GPOS.readAnchorRecord(n, s.readUshort(n, r + 2) + l);
        h.markClass = s.readUshort(n, r), a.push(h), r += 4;
      }
      return a;
    }, e.GPOS.readAnchorRecord = function(n, r) {
      var s = e._bin, a = {};
      return a.fmt = s.readUshort(n, r), a.x = s.readShort(n, r + 2), a.y = s.readShort(n, r + 4), a;
    }, e.GSUB = {}, e.GSUB.parse = function(n, r, s, a) {
      return e._lctf.parse(n, r, s, a, e.GSUB.subt);
    }, e.GSUB.subt = function(n, r, s, a) {
      var l = e._bin, c = s, u = {};
      if (u.fmt = l.readUshort(n, s), s += 2, r != 1 && r != 2 && r != 4 && r != 5 && r != 6) return null;
      if (r == 1 || r == 2 || r == 4 || r == 5 && u.fmt <= 2 || r == 6 && u.fmt <= 2) {
        var h = l.readUshort(n, s);
        s += 2, u.coverage = e._lctf.readCoverage(n, c + h);
      }
      if (r == 1 && u.fmt >= 1 && u.fmt <= 2) {
        if (u.fmt == 1) u.delta = l.readShort(n, s), s += 2;
        else if (u.fmt == 2) {
          var d = l.readUshort(n, s);
          s += 2, u.newg = l.readUshorts(n, s, d), s += 2 * u.newg.length;
        }
      } else if (r == 2 && u.fmt == 1) {
        d = l.readUshort(n, s), s += 2, u.seqs = [];
        for (var f = 0; f < d; f++) {
          var p = l.readUshort(n, s) + c;
          s += 2;
          var m = l.readUshort(n, p);
          u.seqs.push(l.readUshorts(n, p + 2, m));
        }
      } else if (r == 4)
        for (u.vals = [], d = l.readUshort(n, s), s += 2, f = 0; f < d; f++) {
          var v = l.readUshort(n, s);
          s += 2, u.vals.push(e.GSUB.readLigatureSet(n, c + v));
        }
      else if (r == 5 && u.fmt == 2) {
        if (u.fmt == 2) {
          var y = l.readUshort(n, s);
          s += 2, u.cDef = e._lctf.readClassDef(n, c + y), u.scset = [];
          var g = l.readUshort(n, s);
          for (s += 2, f = 0; f < g; f++) {
            var _ = l.readUshort(n, s);
            s += 2, u.scset.push(_ == 0 ? null : e.GSUB.readSubClassSet(n, c + _));
          }
        }
      } else if (r == 6 && u.fmt == 3) {
        if (u.fmt == 3) {
          for (f = 0; f < 3; f++) {
            d = l.readUshort(n, s), s += 2;
            for (var b = [], S = 0; S < d; S++) b.push(e._lctf.readCoverage(n, c + l.readUshort(n, s + 2 * S)));
            s += 2 * d, f == 0 && (u.backCvg = b), f == 1 && (u.inptCvg = b), f == 2 && (u.ahedCvg = b);
          }
          d = l.readUshort(n, s), s += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(n, s, d);
        }
      } else {
        if (r == 7 && u.fmt == 1) {
          var x = l.readUshort(n, s);
          s += 2;
          var M = l.readUint(n, s);
          if (s += 4, a.ltype == 9) a.ltype = x;
          else if (a.ltype != x) throw "invalid extension substitution";
          return e.GSUB.subt(n, a.ltype, c + M);
        }
        console.debug("unsupported GSUB table LookupType", r, "format", u.fmt);
      }
      return u;
    }, e.GSUB.readSubClassSet = function(n, r) {
      var s = e._bin.readUshort, a = r, l = [], c = s(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = s(n, r);
        r += 2, l.push(e.GSUB.readSubClassRule(n, a + h));
      }
      return l;
    }, e.GSUB.readSubClassRule = function(n, r) {
      var s = e._bin.readUshort, a = {}, l = s(n, r), c = s(n, r += 2);
      r += 2, a.input = [];
      for (var u = 0; u < l - 1; u++) a.input.push(s(n, r)), r += 2;
      return a.substLookupRecords = e.GSUB.readSubstLookupRecords(n, r, c), a;
    }, e.GSUB.readSubstLookupRecords = function(n, r, s) {
      for (var a = e._bin.readUshort, l = [], c = 0; c < s; c++) l.push(a(n, r), a(n, r + 2)), r += 4;
      return l;
    }, e.GSUB.readChainSubClassSet = function(n, r) {
      var s = e._bin, a = r, l = [], c = s.readUshort(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = s.readUshort(n, r);
        r += 2, l.push(e.GSUB.readChainSubClassRule(n, a + h));
      }
      return l;
    }, e.GSUB.readChainSubClassRule = function(n, r) {
      for (var s = e._bin, a = {}, l = ["backtrack", "input", "lookahead"], c = 0; c < l.length; c++) {
        var u = s.readUshort(n, r);
        r += 2, c == 1 && u--, a[l[c]] = s.readUshorts(n, r, u), r += 2 * a[l[c]].length;
      }
      return u = s.readUshort(n, r), r += 2, a.subst = s.readUshorts(n, r, 2 * u), r += 2 * a.subst.length, a;
    }, e.GSUB.readLigatureSet = function(n, r) {
      var s = e._bin, a = r, l = [], c = s.readUshort(n, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var h = s.readUshort(n, r);
        r += 2, l.push(e.GSUB.readLigature(n, a + h));
      }
      return l;
    }, e.GSUB.readLigature = function(n, r) {
      var s = e._bin, a = { chain: [] };
      a.nglyph = s.readUshort(n, r), r += 2;
      var l = s.readUshort(n, r);
      r += 2;
      for (var c = 0; c < l - 1; c++) a.chain.push(s.readUshort(n, r)), r += 2;
      return a;
    }, e.head = {}, e.head.parse = function(n, r, s) {
      var a = e._bin, l = {};
      return a.readFixed(n, r), r += 4, l.fontRevision = a.readFixed(n, r), r += 4, a.readUint(n, r), r += 4, a.readUint(n, r), r += 4, l.flags = a.readUshort(n, r), r += 2, l.unitsPerEm = a.readUshort(n, r), r += 2, l.created = a.readUint64(n, r), r += 8, l.modified = a.readUint64(n, r), r += 8, l.xMin = a.readShort(n, r), r += 2, l.yMin = a.readShort(n, r), r += 2, l.xMax = a.readShort(n, r), r += 2, l.yMax = a.readShort(n, r), r += 2, l.macStyle = a.readUshort(n, r), r += 2, l.lowestRecPPEM = a.readUshort(n, r), r += 2, l.fontDirectionHint = a.readShort(n, r), r += 2, l.indexToLocFormat = a.readShort(n, r), r += 2, l.glyphDataFormat = a.readShort(n, r), r += 2, l;
    }, e.hhea = {}, e.hhea.parse = function(n, r, s) {
      var a = e._bin, l = {};
      return a.readFixed(n, r), r += 4, l.ascender = a.readShort(n, r), r += 2, l.descender = a.readShort(n, r), r += 2, l.lineGap = a.readShort(n, r), r += 2, l.advanceWidthMax = a.readUshort(n, r), r += 2, l.minLeftSideBearing = a.readShort(n, r), r += 2, l.minRightSideBearing = a.readShort(n, r), r += 2, l.xMaxExtent = a.readShort(n, r), r += 2, l.caretSlopeRise = a.readShort(n, r), r += 2, l.caretSlopeRun = a.readShort(n, r), r += 2, l.caretOffset = a.readShort(n, r), r += 2, r += 8, l.metricDataFormat = a.readShort(n, r), r += 2, l.numberOfHMetrics = a.readUshort(n, r), r += 2, l;
    }, e.hmtx = {}, e.hmtx.parse = function(n, r, s, a) {
      for (var l = e._bin, c = { aWidth: [], lsBearing: [] }, u = 0, h = 0, d = 0; d < a.maxp.numGlyphs; d++) d < a.hhea.numberOfHMetrics && (u = l.readUshort(n, r), r += 2, h = l.readShort(n, r), r += 2), c.aWidth.push(u), c.lsBearing.push(h);
      return c;
    }, e.kern = {}, e.kern.parse = function(n, r, s, a) {
      var l = e._bin, c = l.readUshort(n, r);
      if (r += 2, c == 1) return e.kern.parseV1(n, r - 2, s, a);
      var u = l.readUshort(n, r);
      r += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < u; d++) {
        r += 2, s = l.readUshort(n, r), r += 2;
        var f = l.readUshort(n, r);
        r += 2;
        var p = f >>> 8;
        if ((p &= 15) != 0) throw "unknown kern table format: " + p;
        r = e.kern.readFormat0(n, r, h);
      }
      return h;
    }, e.kern.parseV1 = function(n, r, s, a) {
      var l = e._bin;
      l.readFixed(n, r), r += 4;
      var c = l.readUint(n, r);
      r += 4;
      for (var u = { glyph1: [], rval: [] }, h = 0; h < c; h++) {
        l.readUint(n, r), r += 4;
        var d = l.readUshort(n, r);
        r += 2, l.readUshort(n, r), r += 2;
        var f = d >>> 8;
        if ((f &= 15) != 0) throw "unknown kern table format: " + f;
        r = e.kern.readFormat0(n, r, u);
      }
      return u;
    }, e.kern.readFormat0 = function(n, r, s) {
      var a = e._bin, l = -1, c = a.readUshort(n, r);
      r += 2, a.readUshort(n, r), r += 2, a.readUshort(n, r), r += 2, a.readUshort(n, r), r += 2;
      for (var u = 0; u < c; u++) {
        var h = a.readUshort(n, r);
        r += 2;
        var d = a.readUshort(n, r);
        r += 2;
        var f = a.readShort(n, r);
        r += 2, h != l && (s.glyph1.push(h), s.rval.push({ glyph2: [], vals: [] }));
        var p = s.rval[s.rval.length - 1];
        p.glyph2.push(d), p.vals.push(f), l = h;
      }
      return r;
    }, e.loca = {}, e.loca.parse = function(n, r, s, a) {
      var l = e._bin, c = [], u = a.head.indexToLocFormat, h = a.maxp.numGlyphs + 1;
      if (u == 0) for (var d = 0; d < h; d++) c.push(l.readUshort(n, r + (d << 1)) << 1);
      if (u == 1) for (d = 0; d < h; d++) c.push(l.readUint(n, r + (d << 2)));
      return c;
    }, e.maxp = {}, e.maxp.parse = function(n, r, s) {
      var a = e._bin, l = {}, c = a.readUint(n, r);
      return r += 4, l.numGlyphs = a.readUshort(n, r), r += 2, c == 65536 && (l.maxPoints = a.readUshort(n, r), r += 2, l.maxContours = a.readUshort(n, r), r += 2, l.maxCompositePoints = a.readUshort(n, r), r += 2, l.maxCompositeContours = a.readUshort(n, r), r += 2, l.maxZones = a.readUshort(n, r), r += 2, l.maxTwilightPoints = a.readUshort(n, r), r += 2, l.maxStorage = a.readUshort(n, r), r += 2, l.maxFunctionDefs = a.readUshort(n, r), r += 2, l.maxInstructionDefs = a.readUshort(n, r), r += 2, l.maxStackElements = a.readUshort(n, r), r += 2, l.maxSizeOfInstructions = a.readUshort(n, r), r += 2, l.maxComponentElements = a.readUshort(n, r), r += 2, l.maxComponentDepth = a.readUshort(n, r), r += 2), l;
    }, e.name = {}, e.name.parse = function(n, r, s) {
      var a = e._bin, l = {};
      a.readUshort(n, r), r += 2;
      var c = a.readUshort(n, r);
      r += 2, a.readUshort(n, r);
      for (var u, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = r += 2, f = 0; f < c; f++) {
        var p = a.readUshort(n, r);
        r += 2;
        var m = a.readUshort(n, r);
        r += 2;
        var v = a.readUshort(n, r);
        r += 2;
        var y = a.readUshort(n, r);
        r += 2;
        var g = a.readUshort(n, r);
        r += 2;
        var _ = a.readUshort(n, r);
        r += 2;
        var b, S = h[y], x = d + 12 * c + _;
        if (p == 0) b = a.readUnicode(n, x, g / 2);
        else if (p == 3 && m == 0) b = a.readUnicode(n, x, g / 2);
        else if (m == 0) b = a.readASCII(n, x, g);
        else if (m == 1) b = a.readUnicode(n, x, g / 2);
        else if (m == 3) b = a.readUnicode(n, x, g / 2);
        else {
          if (p != 1) throw "unknown encoding " + m + ", platformID: " + p;
          b = a.readASCII(n, x, g), console.debug("reading unknown MAC encoding " + m + " as ASCII");
        }
        var M = "p" + p + "," + v.toString(16);
        l[M] == null && (l[M] = {}), l[M][S !== void 0 ? S : y] = b, l[M]._lang = v;
      }
      for (var w in l) if (l[w].postScriptName != null && l[w]._lang == 1033) return l[w];
      for (var w in l) if (l[w].postScriptName != null && l[w]._lang == 0) return l[w];
      for (var w in l) if (l[w].postScriptName != null && l[w]._lang == 3084) return l[w];
      for (var w in l) if (l[w].postScriptName != null) return l[w];
      for (var w in l) {
        u = w;
        break;
      }
      return console.debug("returning name table with languageID " + l[u]._lang), l[u];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(n, r, s) {
      var a = e._bin.readUshort(n, r);
      r += 2;
      var l = {};
      if (a == 0) e["OS/2"].version0(n, r, l);
      else if (a == 1) e["OS/2"].version1(n, r, l);
      else if (a == 2 || a == 3 || a == 4) e["OS/2"].version2(n, r, l);
      else {
        if (a != 5) throw "unknown OS/2 table version: " + a;
        e["OS/2"].version5(n, r, l);
      }
      return l;
    }, e["OS/2"].version0 = function(n, r, s) {
      var a = e._bin;
      return s.xAvgCharWidth = a.readShort(n, r), r += 2, s.usWeightClass = a.readUshort(n, r), r += 2, s.usWidthClass = a.readUshort(n, r), r += 2, s.fsType = a.readUshort(n, r), r += 2, s.ySubscriptXSize = a.readShort(n, r), r += 2, s.ySubscriptYSize = a.readShort(n, r), r += 2, s.ySubscriptXOffset = a.readShort(n, r), r += 2, s.ySubscriptYOffset = a.readShort(n, r), r += 2, s.ySuperscriptXSize = a.readShort(n, r), r += 2, s.ySuperscriptYSize = a.readShort(n, r), r += 2, s.ySuperscriptXOffset = a.readShort(n, r), r += 2, s.ySuperscriptYOffset = a.readShort(n, r), r += 2, s.yStrikeoutSize = a.readShort(n, r), r += 2, s.yStrikeoutPosition = a.readShort(n, r), r += 2, s.sFamilyClass = a.readShort(n, r), r += 2, s.panose = a.readBytes(n, r, 10), r += 10, s.ulUnicodeRange1 = a.readUint(n, r), r += 4, s.ulUnicodeRange2 = a.readUint(n, r), r += 4, s.ulUnicodeRange3 = a.readUint(n, r), r += 4, s.ulUnicodeRange4 = a.readUint(n, r), r += 4, s.achVendID = [a.readInt8(n, r), a.readInt8(n, r + 1), a.readInt8(n, r + 2), a.readInt8(n, r + 3)], r += 4, s.fsSelection = a.readUshort(n, r), r += 2, s.usFirstCharIndex = a.readUshort(n, r), r += 2, s.usLastCharIndex = a.readUshort(n, r), r += 2, s.sTypoAscender = a.readShort(n, r), r += 2, s.sTypoDescender = a.readShort(n, r), r += 2, s.sTypoLineGap = a.readShort(n, r), r += 2, s.usWinAscent = a.readUshort(n, r), r += 2, s.usWinDescent = a.readUshort(n, r), r += 2;
    }, e["OS/2"].version1 = function(n, r, s) {
      var a = e._bin;
      return r = e["OS/2"].version0(n, r, s), s.ulCodePageRange1 = a.readUint(n, r), r += 4, s.ulCodePageRange2 = a.readUint(n, r), r += 4;
    }, e["OS/2"].version2 = function(n, r, s) {
      var a = e._bin;
      return r = e["OS/2"].version1(n, r, s), s.sxHeight = a.readShort(n, r), r += 2, s.sCapHeight = a.readShort(n, r), r += 2, s.usDefault = a.readUshort(n, r), r += 2, s.usBreak = a.readUshort(n, r), r += 2, s.usMaxContext = a.readUshort(n, r), r += 2;
    }, e["OS/2"].version5 = function(n, r, s) {
      var a = e._bin;
      return r = e["OS/2"].version2(n, r, s), s.usLowerOpticalPointSize = a.readUshort(n, r), r += 2, s.usUpperOpticalPointSize = a.readUshort(n, r), r += 2;
    }, e.post = {}, e.post.parse = function(n, r, s) {
      var a = e._bin, l = {};
      return l.version = a.readFixed(n, r), r += 4, l.italicAngle = a.readFixed(n, r), r += 4, l.underlinePosition = a.readShort(n, r), r += 2, l.underlineThickness = a.readShort(n, r), r += 2, l;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(n, r) {
      var s = n.cmap, a = -1;
      if (s.p0e4 != null ? a = s.p0e4 : s.p3e1 != null ? a = s.p3e1 : s.p1e0 != null ? a = s.p1e0 : s.p0e3 != null && (a = s.p0e3), a == -1) throw "no familiar platform and encoding!";
      var l = s.tables[a];
      if (l.format == 0) return r >= l.map.length ? 0 : l.map[r];
      if (l.format == 4) {
        for (var c = -1, u = 0; u < l.endCount.length; u++) if (r <= l.endCount[u]) {
          c = u;
          break;
        }
        return c == -1 || l.startCount[c] > r ? 0 : 65535 & (l.idRangeOffset[c] != 0 ? l.glyphIdArray[r - l.startCount[c] + (l.idRangeOffset[c] >> 1) - (l.idRangeOffset.length - c)] : r + l.idDelta[c]);
      }
      if (l.format == 12) {
        if (r > l.groups[l.groups.length - 1][1]) return 0;
        for (u = 0; u < l.groups.length; u++) {
          var h = l.groups[u];
          if (h[0] <= r && r <= h[1]) return h[2] + (r - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + l.format;
    }, e.U.glyphToPath = function(n, r) {
      var s = { cmds: [], crds: [] };
      if (n.SVG && n.SVG.entries[r]) {
        var a = n.SVG.entries[r];
        return a == null ? s : (typeof a == "string" && (a = e.SVG.toPath(a), n.SVG.entries[r] = a), a);
      }
      if (n.CFF) {
        var l = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: n.CFF.Private ? n.CFF.Private.defaultWidthX : 0, open: !1 }, c = n.CFF, u = n.CFF.Private;
        if (c.ROS) {
          for (var h = 0; c.FDSelect[h + 2] <= r; ) h += 2;
          u = c.FDArray[c.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(n.CFF.CharStrings[r], l, c, u, s);
      } else n.glyf && e.U._drawGlyf(r, n, s);
      return s;
    }, e.U._drawGlyf = function(n, r, s) {
      var a = r.glyf[n];
      a == null && (a = r.glyf[n] = e.glyf._parseGlyf(r, n)), a != null && (a.noc > -1 ? e.U._simpleGlyph(a, s) : e.U._compoGlyph(a, r, s));
    }, e.U._simpleGlyph = function(n, r) {
      for (var s = 0; s < n.noc; s++) {
        for (var a = s == 0 ? 0 : n.endPts[s - 1] + 1, l = n.endPts[s], c = a; c <= l; c++) {
          var u = c == a ? l : c - 1, h = c == l ? a : c + 1, d = 1 & n.flags[c], f = 1 & n.flags[u], p = 1 & n.flags[h], m = n.xs[c], v = n.ys[c];
          if (c == a) if (d) {
            if (!f) {
              e.U.P.moveTo(r, m, v);
              continue;
            }
            e.U.P.moveTo(r, n.xs[u], n.ys[u]);
          } else f ? e.U.P.moveTo(r, n.xs[u], n.ys[u]) : e.U.P.moveTo(r, (n.xs[u] + m) / 2, (n.ys[u] + v) / 2);
          d ? f && e.U.P.lineTo(r, m, v) : p ? e.U.P.qcurveTo(r, m, v, n.xs[h], n.ys[h]) : e.U.P.qcurveTo(r, m, v, (m + n.xs[h]) / 2, (v + n.ys[h]) / 2);
        }
        e.U.P.closePath(r);
      }
    }, e.U._compoGlyph = function(n, r, s) {
      for (var a = 0; a < n.parts.length; a++) {
        var l = { cmds: [], crds: [] }, c = n.parts[a];
        e.U._drawGlyf(c.glyphIndex, r, l);
        for (var u = c.m, h = 0; h < l.crds.length; h += 2) {
          var d = l.crds[h], f = l.crds[h + 1];
          s.crds.push(d * u.a + f * u.b + u.tx), s.crds.push(d * u.c + f * u.d + u.ty);
        }
        for (h = 0; h < l.cmds.length; h++) s.cmds.push(l.cmds[h]);
      }
    }, e.U._getGlyphClass = function(n, r) {
      var s = e._lctf.getInterval(r, n);
      return s == -1 ? 0 : r[s + 2];
    }, e.U._applySubs = function(n, r, s, a) {
      for (var l = n.length - r - 1, c = 0; c < s.tabs.length; c++) if (s.tabs[c] != null) {
        var u, h = s.tabs[c];
        if (!h.coverage || (u = e._lctf.coverageIndex(h.coverage, n[r])) != -1) {
          if (s.ltype == 1) n[r], h.fmt == 1 ? n[r] = n[r] + h.delta : n[r] = h.newg[u];
          else if (s.ltype == 4) for (var d = h.vals[u], f = 0; f < d.length; f++) {
            var p = d[f], m = p.chain.length;
            if (!(m > l)) {
              for (var v = !0, y = 0, g = 0; g < m; g++) {
                for (; n[r + y + (1 + g)] == -1; ) y++;
                p.chain[g] != n[r + y + (1 + g)] && (v = !1);
              }
              if (v) {
                for (n[r] = p.nglyph, g = 0; g < m + y; g++) n[r + g + 1] = -1;
                break;
              }
            }
          }
          else if (s.ltype == 5 && h.fmt == 2) for (var _ = e._lctf.getInterval(h.cDef, n[r]), b = h.cDef[_ + 2], S = h.scset[b], x = 0; x < S.length; x++) {
            var M = S[x], w = M.input;
            if (!(w.length > l)) {
              for (v = !0, g = 0; g < w.length; g++) {
                var D = e._lctf.getInterval(h.cDef, n[r + 1 + g]);
                if (_ == -1 && h.cDef[D + 2] != w[g]) {
                  v = !1;
                  break;
                }
              }
              if (v) {
                var B = M.substLookupRecords;
                for (f = 0; f < B.length; f += 2) B[f], B[f + 1];
              }
            }
          }
          else if (s.ltype == 6 && h.fmt == 3) {
            if (!e.U._glsCovered(n, h.backCvg, r - h.backCvg.length) || !e.U._glsCovered(n, h.inptCvg, r) || !e.U._glsCovered(n, h.ahedCvg, r + h.inptCvg.length)) continue;
            var z = h.lookupRec;
            for (x = 0; x < z.length; x += 2) {
              _ = z[x];
              var F = a[z[x + 1]];
              e.U._applySubs(n, r + _, F, a);
            }
          }
        }
      }
    }, e.U._glsCovered = function(n, r, s) {
      for (var a = 0; a < r.length; a++)
        if (e._lctf.coverageIndex(r[a], n[s + a]) == -1) return !1;
      return !0;
    }, e.U.glyphsToPath = function(n, r, s) {
      for (var a = { cmds: [], crds: [] }, l = 0, c = 0; c < r.length; c++) {
        var u = r[c];
        if (u != -1) {
          for (var h = c < r.length - 1 && r[c + 1] != -1 ? r[c + 1] : 0, d = e.U.glyphToPath(n, u), f = 0; f < d.crds.length; f += 2) a.crds.push(d.crds[f] + l), a.crds.push(d.crds[f + 1]);
          for (s && a.cmds.push(s), f = 0; f < d.cmds.length; f++) a.cmds.push(d.cmds[f]);
          s && a.cmds.push("X"), l += n.hmtx.aWidth[u], c < r.length - 1 && (l += e.U.getPairAdjustment(n, u, h));
        }
      }
      return a;
    }, e.U.P = {}, e.U.P.moveTo = function(n, r, s) {
      n.cmds.push("M"), n.crds.push(r, s);
    }, e.U.P.lineTo = function(n, r, s) {
      n.cmds.push("L"), n.crds.push(r, s);
    }, e.U.P.curveTo = function(n, r, s, a, l, c, u) {
      n.cmds.push("C"), n.crds.push(r, s, a, l, c, u);
    }, e.U.P.qcurveTo = function(n, r, s, a, l) {
      n.cmds.push("Q"), n.crds.push(r, s, a, l);
    }, e.U.P.closePath = function(n) {
      n.cmds.push("Z");
    }, e.U._drawCFF = function(n, r, s, a, l) {
      for (var c = r.stack, u = r.nStems, h = r.haveWidth, d = r.width, f = r.open, p = 0, m = r.x, v = r.y, y = 0, g = 0, _ = 0, b = 0, S = 0, x = 0, M = 0, w = 0, D = 0, B = 0, z = { val: 0, size: 0 }; p < n.length; ) {
        e.CFF.getCharString(n, p, z);
        var F = z.val;
        if (p += z.size, F == "o1" || F == "o18") c.length % 2 != 0 && !h && (d = c.shift() + a.nominalWidthX), u += c.length >> 1, c.length = 0, h = !0;
        else if (F == "o3" || F == "o23")
          c.length % 2 != 0 && !h && (d = c.shift() + a.nominalWidthX), u += c.length >> 1, c.length = 0, h = !0;
        else if (F == "o4") c.length > 1 && !h && (d = c.shift() + a.nominalWidthX, h = !0), f && e.U.P.closePath(l), v += c.pop(), e.U.P.moveTo(l, m, v), f = !0;
        else if (F == "o5") for (; c.length > 0; ) m += c.shift(), v += c.shift(), e.U.P.lineTo(l, m, v);
        else if (F == "o6" || F == "o7") for (var P = c.length, R = F == "o6", L = 0; L < P; L++) {
          var A = c.shift();
          R ? m += A : v += A, R = !R, e.U.P.lineTo(l, m, v);
        }
        else if (F == "o8" || F == "o24") {
          P = c.length;
          for (var k = 0; k + 6 <= P; ) y = m + c.shift(), g = v + c.shift(), _ = y + c.shift(), b = g + c.shift(), m = _ + c.shift(), v = b + c.shift(), e.U.P.curveTo(l, y, g, _, b, m, v), k += 6;
          F == "o24" && (m += c.shift(), v += c.shift(), e.U.P.lineTo(l, m, v));
        } else {
          if (F == "o11") break;
          if (F == "o1234" || F == "o1235" || F == "o1236" || F == "o1237") F == "o1234" && (g = v, _ = (y = m + c.shift()) + c.shift(), B = b = g + c.shift(), x = b, w = v, m = (M = (S = (D = _ + c.shift()) + c.shift()) + c.shift()) + c.shift(), e.U.P.curveTo(l, y, g, _, b, D, B), e.U.P.curveTo(l, S, x, M, w, m, v)), F == "o1235" && (y = m + c.shift(), g = v + c.shift(), _ = y + c.shift(), b = g + c.shift(), D = _ + c.shift(), B = b + c.shift(), S = D + c.shift(), x = B + c.shift(), M = S + c.shift(), w = x + c.shift(), m = M + c.shift(), v = w + c.shift(), c.shift(), e.U.P.curveTo(l, y, g, _, b, D, B), e.U.P.curveTo(l, S, x, M, w, m, v)), F == "o1236" && (y = m + c.shift(), g = v + c.shift(), _ = y + c.shift(), B = b = g + c.shift(), x = b, M = (S = (D = _ + c.shift()) + c.shift()) + c.shift(), w = x + c.shift(), m = M + c.shift(), e.U.P.curveTo(l, y, g, _, b, D, B), e.U.P.curveTo(l, S, x, M, w, m, v)), F == "o1237" && (y = m + c.shift(), g = v + c.shift(), _ = y + c.shift(), b = g + c.shift(), D = _ + c.shift(), B = b + c.shift(), S = D + c.shift(), x = B + c.shift(), M = S + c.shift(), w = x + c.shift(), Math.abs(M - m) > Math.abs(w - v) ? m = M + c.shift() : v = w + c.shift(), e.U.P.curveTo(l, y, g, _, b, D, B), e.U.P.curveTo(l, S, x, M, w, m, v));
          else if (F == "o14") {
            if (c.length > 0 && !h && (d = c.shift() + s.nominalWidthX, h = !0), c.length == 4) {
              var Q = c.shift(), U = c.shift(), H = c.shift(), I = c.shift(), V = e.CFF.glyphBySE(s, H), W = e.CFF.glyphBySE(s, I);
              e.U._drawCFF(s.CharStrings[V], r, s, a, l), r.x = Q, r.y = U, e.U._drawCFF(s.CharStrings[W], r, s, a, l);
            }
            f && (e.U.P.closePath(l), f = !1);
          } else if (F == "o19" || F == "o20")
            c.length % 2 != 0 && !h && (d = c.shift() + a.nominalWidthX), u += c.length >> 1, c.length = 0, h = !0, p += u + 7 >> 3;
          else if (F == "o21") c.length > 2 && !h && (d = c.shift() + a.nominalWidthX, h = !0), v += c.pop(), m += c.pop(), f && e.U.P.closePath(l), e.U.P.moveTo(l, m, v), f = !0;
          else if (F == "o22") c.length > 1 && !h && (d = c.shift() + a.nominalWidthX, h = !0), m += c.pop(), f && e.U.P.closePath(l), e.U.P.moveTo(l, m, v), f = !0;
          else if (F == "o25") {
            for (; c.length > 6; ) m += c.shift(), v += c.shift(), e.U.P.lineTo(l, m, v);
            y = m + c.shift(), g = v + c.shift(), _ = y + c.shift(), b = g + c.shift(), m = _ + c.shift(), v = b + c.shift(), e.U.P.curveTo(l, y, g, _, b, m, v);
          } else if (F == "o26") for (c.length % 2 && (m += c.shift()); c.length > 0; ) y = m, g = v + c.shift(), m = _ = y + c.shift(), v = (b = g + c.shift()) + c.shift(), e.U.P.curveTo(l, y, g, _, b, m, v);
          else if (F == "o27") for (c.length % 2 && (v += c.shift()); c.length > 0; ) g = v, _ = (y = m + c.shift()) + c.shift(), b = g + c.shift(), m = _ + c.shift(), v = b, e.U.P.curveTo(l, y, g, _, b, m, v);
          else if (F == "o10" || F == "o29") {
            var X = F == "o10" ? a : s;
            if (c.length == 0) console.debug("error: empty stack");
            else {
              var q = c.pop(), O = X.Subrs[q + X.Bias];
              r.x = m, r.y = v, r.nStems = u, r.haveWidth = h, r.width = d, r.open = f, e.U._drawCFF(O, r, s, a, l), m = r.x, v = r.y, u = r.nStems, h = r.haveWidth, d = r.width, f = r.open;
            }
          } else if (F == "o30" || F == "o31") {
            var te = c.length, ne = (k = 0, F == "o31");
            for (k += te - (P = -3 & te); k < P; ) ne ? (g = v, _ = (y = m + c.shift()) + c.shift(), v = (b = g + c.shift()) + c.shift(), P - k == 5 ? (m = _ + c.shift(), k++) : m = _, ne = !1) : (y = m, g = v + c.shift(), _ = y + c.shift(), b = g + c.shift(), m = _ + c.shift(), P - k == 5 ? (v = b + c.shift(), k++) : v = b, ne = !0), e.U.P.curveTo(l, y, g, _, b, m, v), k += 4;
          } else {
            if ((F + "").charAt(0) == "o") throw console.debug("Unknown operation: " + F, n), F;
            c.push(F);
          }
        }
      }
      r.x = m, r.y = v, r.nStems = u, r.haveWidth = h, r.width = d, r.open = f;
    };
    var t = e, i = { Typr: t };
    return o.Typr = t, o.default = i, Object.defineProperty(o, "__esModule", { value: !0 }), o;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function woff2otfFactory() {
  return function(o) {
    var e = Uint8Array, t = Uint16Array, i = Uint32Array, n = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), r = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), s = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), a = function(F, P) {
      for (var R = new t(31), L = 0; L < 31; ++L) R[L] = P += 1 << F[L - 1];
      var A = new i(R[30]);
      for (L = 1; L < 30; ++L) for (var k = R[L]; k < R[L + 1]; ++k) A[k] = k - R[L] << 5 | L;
      return [R, A];
    }, l = a(n, 2), c = l[0], u = l[1];
    c[28] = 258, u[258] = 28;
    for (var h = a(r, 0)[0], d = new t(32768), f = 0; f < 32768; ++f) {
      var p = (43690 & f) >>> 1 | (21845 & f) << 1;
      p = (61680 & (p = (52428 & p) >>> 2 | (13107 & p) << 2)) >>> 4 | (3855 & p) << 4, d[f] = ((65280 & p) >>> 8 | (255 & p) << 8) >>> 1;
    }
    var m = function(F, P, R) {
      for (var L = F.length, A = 0, k = new t(P); A < L; ++A) ++k[F[A] - 1];
      var Q, U = new t(P);
      for (A = 0; A < P; ++A) U[A] = U[A - 1] + k[A - 1] << 1;
      {
        Q = new t(1 << P);
        var H = 15 - P;
        for (A = 0; A < L; ++A) if (F[A]) for (var I = A << 4 | F[A], V = P - F[A], W = U[F[A] - 1]++ << V, X = W | (1 << V) - 1; W <= X; ++W) Q[d[W] >>> H] = I;
      }
      return Q;
    }, v = new e(288);
    for (f = 0; f < 144; ++f) v[f] = 8;
    for (f = 144; f < 256; ++f) v[f] = 9;
    for (f = 256; f < 280; ++f) v[f] = 7;
    for (f = 280; f < 288; ++f) v[f] = 8;
    var y = new e(32);
    for (f = 0; f < 32; ++f) y[f] = 5;
    var g = m(v, 9), _ = m(y, 5), b = function(F) {
      for (var P = F[0], R = 1; R < F.length; ++R) F[R] > P && (P = F[R]);
      return P;
    }, S = function(F, P, R) {
      var L = P / 8 | 0;
      return (F[L] | F[L + 1] << 8) >> (7 & P) & R;
    }, x = function(F, P) {
      var R = P / 8 | 0;
      return (F[R] | F[R + 1] << 8 | F[R + 2] << 16) >> (7 & P);
    }, M = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], w = function(F, P, R) {
      var L = new Error(P || M[F]);
      if (L.code = F, Error.captureStackTrace && Error.captureStackTrace(L, w), !R) throw L;
      return L;
    }, D = function(F, P, R) {
      var L = F.length;
      if (!L || R && !R.l && L < 5) return P || new e(0);
      var A = !P || R, k = !R || R.i;
      R || (R = {}), P || (P = new e(3 * L));
      var Q, U = function(xe) {
        var Pe = P.length;
        if (xe > Pe) {
          var Fe = new e(Math.max(2 * Pe, xe));
          Fe.set(P), P = Fe;
        }
      }, H = R.f || 0, I = R.p || 0, V = R.b || 0, W = R.l, X = R.d, q = R.m, O = R.n, te = 8 * L;
      do {
        if (!W) {
          R.f = H = S(F, I, 1);
          var ne = S(F, I + 1, 3);
          if (I += 3, !ne) {
            var ce = F[(Z = ((Q = I) / 8 | 0) + (7 & Q && 1) + 4) - 4] | F[Z - 3] << 8, he = Z + ce;
            if (he > L) {
              k && w(0);
              break;
            }
            A && U(V + ce), P.set(F.subarray(Z, he), V), R.b = V += ce, R.p = I = 8 * he;
            continue;
          }
          if (ne == 1) W = g, X = _, q = 9, O = 5;
          else if (ne == 2) {
            var le = S(F, I, 31) + 257, G = S(F, I + 10, 15) + 4, re = le + S(F, I + 5, 31) + 1;
            I += 14;
            for (var se = new e(re), ae = new e(19), oe = 0; oe < G; ++oe) ae[s[oe]] = S(F, I + 3 * oe, 7);
            I += 3 * G;
            var E = b(ae), T = (1 << E) - 1, $ = m(ae, E);
            for (oe = 0; oe < re; ) {
              var Z, j = $[S(F, I, T)];
              if (I += 15 & j, (Z = j >>> 4) < 16) se[oe++] = Z;
              else {
                var de = 0, ue = 0;
                for (Z == 16 ? (ue = 3 + S(F, I, 3), I += 2, de = se[oe - 1]) : Z == 17 ? (ue = 3 + S(F, I, 7), I += 3) : Z == 18 && (ue = 11 + S(F, I, 127), I += 7); ue--; ) se[oe++] = de;
              }
            }
            var pe = se.subarray(0, le), fe = se.subarray(le);
            q = b(pe), O = b(fe), W = m(pe, q), X = m(fe, O);
          } else w(1);
          if (I > te) {
            k && w(0);
            break;
          }
        }
        A && U(V + 131072);
        for (var ve = (1 << q) - 1, N = (1 << O) - 1, ee = I; ; ee = I) {
          var J = (de = W[x(F, I) & ve]) >>> 4;
          if ((I += 15 & de) > te) {
            k && w(0);
            break;
          }
          if (de || w(2), J < 256) P[V++] = J;
          else {
            if (J == 256) {
              ee = I, W = null;
              break;
            }
            var ye = J - 254;
            if (J > 264) {
              var me = n[oe = J - 257];
              ye = S(F, I, (1 << me) - 1) + c[oe], I += me;
            }
            var Le = X[x(F, I) & N], Te = Le >>> 4;
            if (Le || w(3), I += 15 & Le, fe = h[Te], Te > 3 && (me = r[Te], fe += x(F, I) & (1 << me) - 1, I += me), I > te) {
              k && w(0);
              break;
            }
            A && U(V + 131072);
            for (var we = V + ye; V < we; V += 4) P[V] = P[V - fe], P[V + 1] = P[V + 1 - fe], P[V + 2] = P[V + 2 - fe], P[V + 3] = P[V + 3 - fe];
            V = we;
          }
        }
        R.l = W, R.p = ee, R.b = V, W && (H = 1, R.m = q, R.d = X, R.n = O);
      } while (!H);
      return V == P.length ? P : function(xe, Pe, Fe) {
        (Fe == null || Fe > xe.length) && (Fe = xe.length);
        var He = new (xe instanceof t ? t : xe instanceof i ? i : e)(Fe - Pe);
        return He.set(xe.subarray(Pe, Fe)), He;
      }(P, 0, V);
    }, B = new e(0), z = typeof TextDecoder < "u" && new TextDecoder();
    try {
      z.decode(B, { stream: !0 });
    } catch {
    }
    return o.convert_streams = function(F) {
      var P = new DataView(F), R = 0;
      function L() {
        var le = P.getUint16(R);
        return R += 2, le;
      }
      function A() {
        var le = P.getUint32(R);
        return R += 4, le;
      }
      function k(le) {
        ce.setUint16(he, le), he += 2;
      }
      function Q(le) {
        ce.setUint32(he, le), he += 4;
      }
      for (var U = { signature: A(), flavor: A(), length: A(), numTables: L(), reserved: L(), totalSfntSize: A(), majorVersion: L(), minorVersion: L(), metaOffset: A(), metaLength: A(), metaOrigLength: A(), privOffset: A(), privLength: A() }, H = 0; Math.pow(2, H) <= U.numTables; ) H++;
      H--;
      for (var I = 16 * Math.pow(2, H), V = 16 * U.numTables - I, W = 12, X = [], q = 0; q < U.numTables; q++) X.push({ tag: A(), offset: A(), compLength: A(), origLength: A(), origChecksum: A() }), W += 16;
      var O, te = new Uint8Array(12 + 16 * X.length + X.reduce(function(le, G) {
        return le + G.origLength + 4;
      }, 0)), ne = te.buffer, ce = new DataView(ne), he = 0;
      return Q(U.flavor), k(U.numTables), k(I), k(H), k(V), X.forEach(function(le) {
        Q(le.tag), Q(le.origChecksum), Q(W), Q(le.origLength), le.outOffset = W, (W += le.origLength) % 4 != 0 && (W += 4 - W % 4);
      }), X.forEach(function(le) {
        var G, re = F.slice(le.offset, le.offset + le.compLength);
        if (le.compLength != le.origLength) {
          var se = new Uint8Array(le.origLength);
          G = new Uint8Array(re, 2), D(G, se);
        } else se = new Uint8Array(re);
        te.set(se, le.outOffset);
        var ae = 0;
        (W = le.outOffset + le.origLength) % 4 != 0 && (ae = 4 - W % 4), te.set(new Uint8Array(ae).buffer, le.outOffset + le.origLength), O = W + ae;
      }), ne.slice(0, O);
    }, Object.defineProperty(o, "__esModule", { value: !0 }), o;
  }({}).convert_streams;
}
function parserFactory(o, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, i = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, n = 1, r = 2, s = 4, a = 8, l = 16, c = 32;
  let u;
  function h(M) {
    if (!u) {
      const w = {
        R: r,
        L: n,
        D: s,
        C: l,
        U: c,
        T: a
      };
      u = /* @__PURE__ */ new Map();
      for (let D in i) {
        let B = 0;
        i[D].split(",").forEach((z) => {
          let [F, P] = z.split("+");
          F = parseInt(F, 36), P = P ? parseInt(P, 36) : 0, u.set(B += F, w[D]);
          for (let R = P; R--; )
            u.set(++B, w[D]);
        });
      }
    }
    return u.get(M) || c;
  }
  const d = 1, f = 2, p = 3, m = 4, v = [null, "isol", "init", "fina", "medi"];
  function y(M) {
    const w = new Uint8Array(M.length);
    let D = c, B = d, z = -1;
    for (let F = 0; F < M.length; F++) {
      const P = M.codePointAt(F);
      let R = h(P) | 0, L = d;
      R & a || (D & (n | s | l) ? R & (r | s | l) ? (L = p, (B === d || B === p) && w[z]++) : R & (n | c) && (B === f || B === m) && w[z]-- : D & (r | c) && (B === f || B === m) && w[z]--, B = w[F] = L, D = R, z = F, P > 65535 && F++);
    }
    return w;
  }
  function g(M, w) {
    const D = [];
    for (let z = 0; z < w.length; z++) {
      const F = w.codePointAt(z);
      F > 65535 && z++, D.push(o.U.codeToGlyph(M, F));
    }
    const B = M.GSUB;
    if (B) {
      const { lookupList: z, featureList: F } = B;
      let P;
      const R = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/, L = [];
      F.forEach((A) => {
        if (R.test(A.tag))
          for (let k = 0; k < A.tab.length; k++) {
            if (L[A.tab[k]]) continue;
            L[A.tab[k]] = !0;
            const Q = z[A.tab[k]], U = /^(isol|init|fina|medi)$/.test(A.tag);
            U && !P && (P = y(w));
            for (let H = 0; H < D.length; H++)
              (!P || !U || v[P[H]] === A.tag) && o.U._applySubs(D, H, Q, z);
          }
      });
    }
    return D;
  }
  function _(M, w) {
    const D = new Int16Array(w.length * 3);
    let B = 0;
    for (; B < w.length; B++) {
      const R = w[B];
      if (R === -1) continue;
      D[B * 3 + 2] = M.hmtx.aWidth[R];
      const L = M.GPOS;
      if (L) {
        const A = L.lookupList;
        for (let k = 0; k < A.length; k++) {
          const Q = A[k];
          for (let U = 0; U < Q.tabs.length; U++) {
            const H = Q.tabs[U];
            if (Q.ltype === 1) {
              if (o._lctf.coverageIndex(H.coverage, R) !== -1 && H.pos) {
                P(H.pos, B);
                break;
              }
            } else if (Q.ltype === 2) {
              let I = null, V = z();
              if (V !== -1) {
                const W = o._lctf.coverageIndex(H.coverage, w[V]);
                if (W !== -1) {
                  if (H.fmt === 1) {
                    const X = H.pairsets[W];
                    for (let q = 0; q < X.length; q++)
                      X[q].gid2 === R && (I = X[q]);
                  } else if (H.fmt === 2) {
                    const X = o.U._getGlyphClass(w[V], H.classDef1), q = o.U._getGlyphClass(R, H.classDef2);
                    I = H.matrix[X][q];
                  }
                  if (I) {
                    I.val1 && P(I.val1, V), I.val2 && P(I.val2, B);
                    break;
                  }
                }
              }
            } else if (Q.ltype === 4) {
              const I = o._lctf.coverageIndex(H.markCoverage, R);
              if (I !== -1) {
                const V = z(F), W = V === -1 ? -1 : o._lctf.coverageIndex(H.baseCoverage, w[V]);
                if (W !== -1) {
                  const X = H.markArray[I], q = H.baseArray[W][X.markClass];
                  D[B * 3] = q.x - X.x + D[V * 3] - D[V * 3 + 2], D[B * 3 + 1] = q.y - X.y + D[V * 3 + 1];
                  break;
                }
              }
            } else if (Q.ltype === 6) {
              const I = o._lctf.coverageIndex(H.mark1Coverage, R);
              if (I !== -1) {
                const V = z();
                if (V !== -1) {
                  const W = w[V];
                  if (b(M, W) === 3) {
                    const X = o._lctf.coverageIndex(H.mark2Coverage, W);
                    if (X !== -1) {
                      const q = H.mark1Array[I], O = H.mark2Array[X][q.markClass];
                      D[B * 3] = O.x - q.x + D[V * 3] - D[V * 3 + 2], D[B * 3 + 1] = O.y - q.y + D[V * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (M.kern && !M.cff) {
        const A = z();
        if (A !== -1) {
          const k = M.kern.glyph1.indexOf(w[A]);
          if (k !== -1) {
            const Q = M.kern.rval[k].glyph2.indexOf(R);
            Q !== -1 && (D[A * 3 + 2] += M.kern.rval[k].vals[Q]);
          }
        }
      }
    }
    return D;
    function z(R) {
      for (let L = B - 1; L >= 0; L--)
        if (w[L] !== -1 && (!R || R(w[L])))
          return L;
      return -1;
    }
    function F(R) {
      return b(M, R) === 1;
    }
    function P(R, L) {
      for (let A = 0; A < 3; A++)
        D[L * 3 + A] += R[A] || 0;
    }
  }
  function b(M, w) {
    const D = M.GDEF && M.GDEF.glyphClassDef;
    return D ? o.U._getGlyphClass(w, D) : 0;
  }
  function S(...M) {
    for (let w = 0; w < M.length; w++)
      if (typeof M[w] == "number")
        return M[w];
  }
  function x(M) {
    const w = /* @__PURE__ */ Object.create(null), D = M["OS/2"], B = M.hhea, z = M.head.unitsPerEm, F = S(D && D.sTypoAscender, B && B.ascender, z), P = {
      unitsPerEm: z,
      ascender: F,
      descender: S(D && D.sTypoDescender, B && B.descender, 0),
      capHeight: S(D && D.sCapHeight, F),
      xHeight: S(D && D.sxHeight, F),
      lineGap: S(D && D.sTypoLineGap, B && B.lineGap),
      supportsCodePoint(R) {
        return o.U.codeToGlyph(M, R) > 0;
      },
      forEachGlyph(R, L, A, k) {
        let Q = 0;
        const U = 1 / P.unitsPerEm * L, H = g(M, R);
        let I = 0;
        const V = _(M, H);
        return H.forEach((W, X) => {
          if (W !== -1) {
            let q = w[W];
            if (!q) {
              const { cmds: O, crds: te } = o.U.glyphToPath(M, W);
              let ne = "", ce = 0;
              for (let se = 0, ae = O.length; se < ae; se++) {
                const oe = t[O[se]];
                ne += O[se];
                for (let E = 1; E <= oe; E++)
                  ne += (E > 1 ? "," : "") + te[ce++];
              }
              let he, le, G, re;
              if (te.length) {
                he = le = 1 / 0, G = re = -1 / 0;
                for (let se = 0, ae = te.length; se < ae; se += 2) {
                  let oe = te[se], E = te[se + 1];
                  oe < he && (he = oe), E < le && (le = E), oe > G && (G = oe), E > re && (re = E);
                }
              } else
                he = G = le = re = 0;
              q = w[W] = {
                index: W,
                advanceWidth: M.hmtx.aWidth[W],
                xMin: he,
                yMin: le,
                xMax: G,
                yMax: re,
                path: ne
              };
            }
            k.call(
              null,
              q,
              Q + V[X * 3] * U,
              V[X * 3 + 1] * U,
              I
            ), Q += V[X * 3 + 2] * U, A && (Q += A * L);
          }
          I += R.codePointAt(I) > 65535 ? 2 : 1;
        }), Q;
      }
    };
    return P;
  }
  return function(w) {
    const D = new Uint8Array(w, 0, 4), B = o._bin.readASCII(D, 0, 4);
    if (B === "wOFF")
      w = e(w);
    else if (B === "wOF2")
      throw new Error("woff2 fonts not supported");
    return x(o.parse(w)[0]);
  };
}
const workerModule = /* @__PURE__ */ defineWorkerModule({
  name: "Typr Font Parser",
  dependencies: [typrFactory, woff2otfFactory, parserFactory],
  init(o, e, t) {
    const i = o(), n = e();
    return t(i, n);
  }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function unicodeFontResolverClientFactory() {
  return function(o) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(_) {
      var b = _ >> 5;
      this.buckets.set(b, (this.buckets.get(b) || 0) | 1 << (31 & _));
    }, e.prototype.has = function(_) {
      var b = this.buckets.get(_ >> 5);
      return b !== void 0 && (b & 1 << (31 & _)) != 0;
    }, e.prototype.serialize = function() {
      var _ = [];
      return this.buckets.forEach(function(b, S) {
        _.push((+S).toString(36) + ":" + b.toString(36));
      }), _.join(",");
    }, e.prototype.deserialize = function(_) {
      var b = this;
      this.buckets.clear(), _.split(",").forEach(function(S) {
        var x = S.split(":");
        b.buckets.set(parseInt(x[0], 36), parseInt(x[1], 36));
      });
    };
    var t = Math.pow(2, 8), i = t - 1, n = ~i;
    function r(_) {
      var b = function(x) {
        return x & n;
      }(_).toString(16), S = function(x) {
        return (x & n) + t - 1;
      }(_).toString(16);
      return "codepoint-index/plane" + (_ >> 16) + "/" + b + "-" + S + ".json";
    }
    function s(_, b) {
      var S = _ & i, x = b.codePointAt(S / 6 | 0);
      return ((x = (x || 48) - 48) & 1 << S % 6) != 0;
    }
    function a(_, b) {
      var S;
      (S = _, S.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(x) {
        return x.split("-").map(function(M) {
          return parseInt(M.trim(), 16);
        });
      })).forEach(function(x) {
        var M = x[0], w = x[1];
        w === void 0 && (w = M), b(M, w);
      });
    }
    function l(_, b) {
      a(_, function(S, x) {
        for (var M = S; M <= x; M++) b(M);
      });
    }
    var c = {}, u = {}, h = /* @__PURE__ */ new WeakMap(), d = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function f(_) {
      var b = h.get(_);
      return b || (b = new e(), l(_.ranges, function(S) {
        return b.add(S);
      }), h.set(_, b)), b;
    }
    var p, m = /* @__PURE__ */ new Map();
    function v(_, b, S) {
      return _[b] ? b : _[S] ? S : function(x) {
        for (var M in x) return M;
      }(_);
    }
    function y(_, b) {
      var S = b;
      if (!_.includes(S)) {
        S = 1 / 0;
        for (var x = 0; x < _.length; x++) Math.abs(_[x] - b) < Math.abs(S - b) && (S = _[x]);
      }
      return S;
    }
    function g(_) {
      return p || (p = /* @__PURE__ */ new Set(), l("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(b) {
        p.add(b);
      })), p.has(_);
    }
    return o.CodePointSet = e, o.clearCache = function() {
      c = {}, u = {};
    }, o.getFontsForString = function(_, b) {
      b === void 0 && (b = {});
      var S, x = b.lang;
      x === void 0 && (x = new RegExp("\\p{Script=Hangul}", "u").test(S = _) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(S) ? "ja" : "en");
      var M = b.category;
      M === void 0 && (M = "sans-serif");
      var w = b.style;
      w === void 0 && (w = "normal");
      var D = b.weight;
      D === void 0 && (D = 400);
      var B = (b.dataUrl || d).replace(/\/$/g, ""), z = /* @__PURE__ */ new Map(), F = new Uint8Array(_.length), P = {}, R = {}, L = new Array(_.length), A = /* @__PURE__ */ new Map(), k = !1;
      function Q(I) {
        var V = m.get(I);
        return V || (V = fetch(B + "/" + I).then(function(W) {
          if (!W.ok) throw new Error(W.statusText);
          return W.json().then(function(X) {
            if (!Array.isArray(X) || X[0] !== 1) throw new Error("Incorrect schema version; need 1, got " + X[0]);
            return X[1];
          });
        }).catch(function(W) {
          if (B !== d) return k || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + B + '", trying default CDN. ' + W.message), k = !0), B = d, m.delete(I), Q(I);
          throw W;
        }), m.set(I, V)), V;
      }
      for (var U = function(I) {
        var V = _.codePointAt(I), W = r(V);
        L[I] = W, c[W] || A.has(W) || A.set(W, Q(W).then(function(X) {
          c[W] = X;
        })), V > 65535 && (I++, H = I);
      }, H = 0; H < _.length; H++) U(H);
      return Promise.all(A.values()).then(function() {
        A.clear();
        for (var I = function(W) {
          var X = _.codePointAt(W), q = null, O = c[L[W]], te = void 0;
          for (var ne in O) {
            var ce = R[ne];
            if (ce === void 0 && (ce = R[ne] = new RegExp(ne).test(x || "en")), ce) {
              for (var he in te = ne, O[ne]) if (s(X, O[ne][he])) {
                q = he;
                break;
              }
              break;
            }
          }
          if (!q) {
            e: for (var le in O) if (le !== te) {
              for (var G in O[le]) if (s(X, O[le][G])) {
                q = G;
                break e;
              }
            }
          }
          q || (console.debug("No font coverage for U+" + X.toString(16)), q = "latin"), L[W] = q, u[q] || A.has(q) || A.set(q, Q("font-meta/" + q + ".json").then(function(re) {
            u[q] = re;
          })), X > 65535 && (W++, V = W);
        }, V = 0; V < _.length; V++) I(V);
        return Promise.all(A.values());
      }).then(function() {
        for (var I, V = null, W = 0; W < _.length; W++) {
          var X = _.codePointAt(W);
          if (V && (g(X) || f(V).has(X))) F[W] = F[W - 1];
          else {
            V = u[L[W]];
            var q = P[V.id];
            if (!q) {
              var O = V.typeforms, te = v(O, M, "sans-serif"), ne = v(O[te], w, "normal"), ce = y((I = O[te]) === null || I === void 0 ? void 0 : I[ne], D);
              q = P[V.id] = B + "/font-files/" + V.id + "/" + te + "." + ne + "." + ce + ".woff";
            }
            var he = z.get(q);
            he == null && (he = z.size, z.set(q, he)), F[W] = he;
          }
          X > 65535 && (W++, F[W] = F[W - 1]);
        }
        return { fontUrls: Array.from(z.keys()), chars: F };
      });
    }, Object.defineProperty(o, "__esModule", { value: !0 }), o;
  }({});
}
function createFontResolver(o, e) {
  const t = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  function n(s, a) {
    const l = (c) => {
      console.error(`Failure loading font ${s}`, c);
    };
    try {
      const c = new XMLHttpRequest();
      c.open("get", s, !0), c.responseType = "arraybuffer", c.onload = function() {
        if (c.status >= 400)
          l(new Error(c.statusText));
        else if (c.status > 0)
          try {
            const u = o(c.response);
            u.src = s, a(u);
          } catch (u) {
            l(u);
          }
      }, c.onerror = l, c.send();
    } catch (c) {
      l(c);
    }
  }
  function r(s, a) {
    let l = t[s];
    l ? a(l) : i[s] ? i[s].push(a) : (i[s] = [a], n(s, (c) => {
      c.src = s, t[s] = c, i[s].forEach((u) => u(c)), delete i[s];
    }));
  }
  return function(s, a, {
    lang: l,
    fonts: c = [],
    style: u = "normal",
    weight: h = "normal",
    unicodeFontsURL: d
  } = {}) {
    const f = new Uint8Array(s.length), p = [];
    s.length || g();
    const m = /* @__PURE__ */ new Map(), v = [];
    if (u !== "italic" && (u = "normal"), typeof h != "number" && (h = h === "bold" ? 700 : 400), c && !Array.isArray(c) && (c = [c]), c = c.slice().filter((b) => !b.lang || b.lang.test(l)).reverse(), c.length) {
      let M = 0;
      (function w(D = 0) {
        for (let B = D, z = s.length; B < z; B++) {
          const F = s.codePointAt(B);
          if (M === 1 && p[f[B - 1]].supportsCodePoint(F) || /\s/.test(s[B]))
            f[B] = f[B - 1], M === 2 && (v[v.length - 1][1] = B);
          else
            for (let P = f[B], R = c.length; P <= R; P++)
              if (P === R) {
                const L = M === 2 ? v[v.length - 1] : v[v.length] = [B, B];
                L[1] = B, M = 2;
              } else {
                f[B] = P;
                const { src: L, unicodeRange: A } = c[P];
                if (!A || _(F, A)) {
                  const k = t[L];
                  if (!k) {
                    r(L, () => {
                      w(B);
                    });
                    return;
                  }
                  if (k.supportsCodePoint(F)) {
                    let Q = m.get(k);
                    typeof Q != "number" && (Q = p.length, p.push(k), m.set(k, Q)), f[B] = Q, M = 1;
                    break;
                  }
                }
              }
          F > 65535 && B + 1 < z && (f[B + 1] = f[B], B++, M === 2 && (v[v.length - 1][1] = B));
        }
        y();
      })();
    } else
      v.push([0, s.length - 1]), y();
    function y() {
      if (v.length) {
        const b = v.map((S) => s.substring(S[0], S[1] + 1)).join(`
`);
        e.getFontsForString(b, {
          lang: l || void 0,
          style: u,
          weight: h,
          dataUrl: d
        }).then(({ fontUrls: S, chars: x }) => {
          const M = p.length;
          let w = 0;
          v.forEach((B) => {
            for (let z = 0, F = B[1] - B[0]; z <= F; z++)
              f[B[0] + z] = x[w++] + M;
            w++;
          });
          let D = 0;
          S.forEach((B, z) => {
            r(B, (F) => {
              p[z + M] = F, ++D === S.length && g();
            });
          });
        });
      } else
        g();
    }
    function g() {
      a({
        chars: f,
        fonts: p
      });
    }
    function _(b, S) {
      for (let x = 0; x < S.length; x++) {
        const [M, w = M] = S[x];
        if (M <= b && b <= w)
          return !0;
      }
      return !1;
    }
  };
}
const fontResolverWorkerModule = /* @__PURE__ */ defineWorkerModule({
  name: "FontResolver",
  dependencies: [
    createFontResolver,
    workerModule,
    unicodeFontResolverClientFactory
  ],
  init(o, e, t) {
    return o(e, t());
  }
});
function createTypesetter(o, e) {
  const i = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, n = "[^\\S\\u00A0]", r = new RegExp(`${n}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function s({ text: p, lang: m, fonts: v, style: y, weight: g, preResolvedFonts: _, unicodeFontsURL: b }, S) {
    const x = ({ chars: M, fonts: w }) => {
      let D, B;
      const z = [];
      for (let F = 0; F < M.length; F++)
        M[F] !== B ? (B = M[F], z.push(D = { start: F, end: F, fontObj: w[M[F]] })) : D.end = F;
      S(z);
    };
    _ ? x(_) : o(
      p,
      x,
      { lang: m, fonts: v, style: y, weight: g, unicodeFontsURL: b }
    );
  }
  function a({
    text: p = "",
    font: m,
    lang: v,
    sdfGlyphSize: y = 64,
    fontSize: g = 400,
    fontWeight: _ = 1,
    fontStyle: b = "normal",
    letterSpacing: S = 0,
    lineHeight: x = "normal",
    maxWidth: M = 1 / 0,
    direction: w,
    textAlign: D = "left",
    textIndent: B = 0,
    whiteSpace: z = "normal",
    overflowWrap: F = "normal",
    anchorX: P = 0,
    anchorY: R = 0,
    metricsOnly: L = !1,
    unicodeFontsURL: A,
    preResolvedFonts: k = null,
    includeCaretPositions: Q = !1,
    chunkedBoundsSize: U = 8192,
    colorRanges: H = null
  }, I) {
    const V = h(), W = { fontLoad: 0, typesetting: 0 };
    p.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), p = p.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), g = +g, S = +S, M = +M, x = x || "normal", B = +B, s({
      text: p,
      lang: v,
      style: b,
      weight: _,
      fonts: typeof m == "string" ? [{ src: m }] : m,
      unicodeFontsURL: A,
      preResolvedFonts: k
    }, (X) => {
      W.fontLoad = h() - V;
      const q = isFinite(M);
      let O = null, te = null, ne = null, ce = null, he = null, le = null, G = null, re = null, se = 0, ae = 0, oe = z !== "nowrap";
      const E = /* @__PURE__ */ new Map(), T = h();
      let $ = B, Z = 0, j = new d();
      const de = [j];
      X.forEach((N) => {
        const { fontObj: ee } = N, { ascender: J, descender: ye, unitsPerEm: me, lineGap: Le, capHeight: Te, xHeight: we } = ee;
        let xe = E.get(ee);
        if (!xe) {
          const Ee = g / me, Ue = x === "normal" ? (J - ye + Le) * Ee : x * g, Je = (Ue - (J - ye) * Ee) / 2, Oe = Math.min(Ue, (J - ye) * Ee), Ie = (J + ye) / 2 * Ee + Oe / 2;
          xe = {
            index: E.size,
            src: ee.src,
            fontObj: ee,
            fontSizeMult: Ee,
            unitsPerEm: me,
            ascender: J * Ee,
            descender: ye * Ee,
            capHeight: Te * Ee,
            xHeight: we * Ee,
            lineHeight: Ue,
            baseline: -Je - J * Ee,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: Ie,
            caretBottom: Ie - Oe
          }, E.set(ee, xe);
        }
        const { fontSizeMult: Pe } = xe, Fe = p.slice(N.start, N.end + 1);
        let He, Ve;
        ee.forEachGlyph(Fe, g, S, (Ee, Ue, Je, Oe) => {
          Ue += Z, Oe += N.start, He = Ue, Ve = Ee;
          const Ie = p.charAt(Oe), We = Ee.advanceWidth * Pe, ze = j.count;
          let Re;
          if ("isEmpty" in Ee || (Ee.isWhitespace = !!Ie && new RegExp(n).test(Ie), Ee.canBreakAfter = !!Ie && r.test(Ie), Ee.isEmpty = Ee.xMin === Ee.xMax || Ee.yMin === Ee.yMax || i.test(Ie)), !Ee.isWhitespace && !Ee.isEmpty && ae++, oe && q && !Ee.isWhitespace && Ue + We + $ > M && ze) {
            if (j.glyphAt(ze - 1).glyphObj.canBreakAfter)
              Re = new d(), $ = -Ue;
            else
              for (let $e = ze; $e--; )
                if ($e === 0 && F === "break-word") {
                  Re = new d(), $ = -Ue;
                  break;
                } else if (j.glyphAt($e).glyphObj.canBreakAfter) {
                  Re = j.splitAt($e + 1);
                  const Xe = Re.glyphAt(0).x;
                  $ -= Xe;
                  for (let qe = Re.count; qe--; )
                    Re.glyphAt(qe).x -= Xe;
                  break;
                }
            Re && (j.isSoftWrapped = !0, j = Re, de.push(j), se = M);
          }
          let ke = j.glyphAt(j.count);
          ke.glyphObj = Ee, ke.x = Ue + $, ke.y = Je, ke.width = We, ke.charIndex = Oe, ke.fontData = xe, Ie === `
` && (j = new d(), de.push(j), $ = -(Ue + We + S * g) + B);
        }), Z = He + Ve.advanceWidth * Pe + S * g;
      });
      let ue = 0;
      de.forEach((N) => {
        let ee = !0;
        for (let J = N.count; J--; ) {
          const ye = N.glyphAt(J);
          ee && !ye.glyphObj.isWhitespace && (N.width = ye.x + ye.width, N.width > se && (se = N.width), ee = !1);
          let { lineHeight: me, capHeight: Le, xHeight: Te, baseline: we } = ye.fontData;
          me > N.lineHeight && (N.lineHeight = me);
          const xe = we - N.baseline;
          xe < 0 && (N.baseline += xe, N.cap += xe, N.ex += xe), N.cap = Math.max(N.cap, N.baseline + Le), N.ex = Math.max(N.ex, N.baseline + Te);
        }
        N.baseline -= ue, N.cap -= ue, N.ex -= ue, ue += N.lineHeight;
      });
      let pe = 0, fe = 0;
      if (P && (typeof P == "number" ? pe = -P : typeof P == "string" && (pe = -se * (P === "left" ? 0 : P === "center" ? 0.5 : P === "right" ? 1 : c(P)))), R && (typeof R == "number" ? fe = -R : typeof R == "string" && (fe = R === "top" ? 0 : R === "top-baseline" ? -de[0].baseline : R === "top-cap" ? -de[0].cap : R === "top-ex" ? -de[0].ex : R === "middle" ? ue / 2 : R === "bottom" ? ue : R === "bottom-baseline" ? -de[de.length - 1].baseline : c(R) * ue)), !L) {
        const N = e.getEmbeddingLevels(p, w);
        O = new Uint16Array(ae), te = new Uint8Array(ae), ne = new Float32Array(ae * 2), ce = {}, G = [1 / 0, 1 / 0, -1 / 0, -1 / 0], re = [], Q && (le = new Float32Array(p.length * 4)), H && (he = new Uint8Array(ae * 3));
        let ee = 0, J = -1, ye = -1, me, Le;
        if (de.forEach((Te, we) => {
          let { count: xe, width: Pe } = Te;
          if (xe > 0) {
            let Fe = 0;
            for (let Oe = xe; Oe-- && Te.glyphAt(Oe).glyphObj.isWhitespace; )
              Fe++;
            let He = 0, Ve = 0;
            if (D === "center")
              He = (se - Pe) / 2;
            else if (D === "right")
              He = se - Pe;
            else if (D === "justify" && Te.isSoftWrapped) {
              let Oe = 0;
              for (let Ie = xe - Fe; Ie--; )
                Te.glyphAt(Ie).glyphObj.isWhitespace && Oe++;
              Ve = (se - Pe) / Oe;
            }
            if (Ve || He) {
              let Oe = 0;
              for (let Ie = 0; Ie < xe; Ie++) {
                let We = Te.glyphAt(Ie);
                const ze = We.glyphObj;
                We.x += He + Oe, Ve !== 0 && ze.isWhitespace && Ie < xe - Fe && (Oe += Ve, We.width += Ve);
              }
            }
            const Ee = e.getReorderSegments(
              p,
              N,
              Te.glyphAt(0).charIndex,
              Te.glyphAt(Te.count - 1).charIndex
            );
            for (let Oe = 0; Oe < Ee.length; Oe++) {
              const [Ie, We] = Ee[Oe];
              let ze = 1 / 0, Re = -1 / 0;
              for (let ke = 0; ke < xe; ke++)
                if (Te.glyphAt(ke).charIndex >= Ie) {
                  let $e = ke, Xe = ke;
                  for (; Xe < xe; Xe++) {
                    let qe = Te.glyphAt(Xe);
                    if (qe.charIndex > We)
                      break;
                    Xe < xe - Fe && (ze = Math.min(ze, qe.x), Re = Math.max(Re, qe.x + qe.width));
                  }
                  for (let qe = $e; qe < Xe; qe++) {
                    const C = Te.glyphAt(qe);
                    C.x = Re - (C.x + C.width - ze);
                  }
                  break;
                }
            }
            let Ue;
            const Je = (Oe) => Ue = Oe;
            for (let Oe = 0; Oe < xe; Oe++) {
              const Ie = Te.glyphAt(Oe);
              Ue = Ie.glyphObj;
              const We = Ue.index, ze = N.levels[Ie.charIndex] & 1;
              if (ze) {
                const Re = e.getMirroredCharacter(p[Ie.charIndex]);
                Re && Ie.fontData.fontObj.forEachGlyph(Re, 0, 0, Je);
              }
              if (Q) {
                const { charIndex: Re, fontData: ke } = Ie, $e = Ie.x + pe, Xe = Ie.x + Ie.width + pe;
                le[Re * 4] = ze ? Xe : $e, le[Re * 4 + 1] = ze ? $e : Xe, le[Re * 4 + 2] = Te.baseline + ke.caretBottom + fe, le[Re * 4 + 3] = Te.baseline + ke.caretTop + fe;
                const qe = Re - J;
                qe > 1 && u(le, J, qe), J = Re;
              }
              if (H) {
                const { charIndex: Re } = Ie;
                for (; Re > ye; )
                  ye++, H.hasOwnProperty(ye) && (Le = H[ye]);
              }
              if (!Ue.isWhitespace && !Ue.isEmpty) {
                const Re = ee++, { fontSizeMult: ke, src: $e, index: Xe } = Ie.fontData, qe = ce[$e] || (ce[$e] = {});
                qe[We] || (qe[We] = {
                  path: Ue.path,
                  pathBounds: [Ue.xMin, Ue.yMin, Ue.xMax, Ue.yMax]
                });
                const C = Ie.x + pe, K = Ie.y + Te.baseline + fe;
                ne[Re * 2] = C, ne[Re * 2 + 1] = K;
                const Y = C + Ue.xMin * ke, ie = K + Ue.yMin * ke, ge = C + Ue.xMax * ke, Ae = K + Ue.yMax * ke;
                Y < G[0] && (G[0] = Y), ie < G[1] && (G[1] = ie), ge > G[2] && (G[2] = ge), Ae > G[3] && (G[3] = Ae), Re % U === 0 && (me = { start: Re, end: Re, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, re.push(me)), me.end++;
                const be = me.rect;
                if (Y < be[0] && (be[0] = Y), ie < be[1] && (be[1] = ie), ge > be[2] && (be[2] = ge), Ae > be[3] && (be[3] = Ae), O[Re] = We, te[Re] = Xe, H) {
                  const _e = Re * 3;
                  he[_e] = Le >> 16 & 255, he[_e + 1] = Le >> 8 & 255, he[_e + 2] = Le & 255;
                }
              }
            }
          }
        }), le) {
          const Te = p.length - J;
          Te > 1 && u(le, J, Te);
        }
      }
      const ve = [];
      E.forEach(({ index: N, src: ee, unitsPerEm: J, ascender: ye, descender: me, lineHeight: Le, capHeight: Te, xHeight: we }) => {
        ve[N] = { src: ee, unitsPerEm: J, ascender: ye, descender: me, lineHeight: Le, capHeight: Te, xHeight: we };
      }), W.typesetting = h() - T, I({
        glyphIds: O,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: te,
        //index into fontData for each glyph
        glyphPositions: ne,
        //x,y of each glyph's origin in layout
        glyphData: ce,
        //dict holding data about each glyph appearing in the text
        fontData: ve,
        //data about each font used in the text
        caretPositions: le,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: he,
        //color for each glyph, if color ranges supplied
        chunkedBounds: re,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: g,
        //calculated em height
        topBaseline: fe + de[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          pe,
          fe - ue,
          pe + se,
          fe
        ],
        visibleBounds: G,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: W
      });
    });
  }
  function l(p, m) {
    a({ ...p, metricsOnly: !0 }, (v) => {
      const [y, g, _, b] = v.blockBounds;
      m({
        width: _ - y,
        height: b - g
      });
    });
  }
  function c(p) {
    let m = p.match(/^([\d.]+)%$/), v = m ? parseFloat(m[1]) : NaN;
    return isNaN(v) ? 0 : v / 100;
  }
  function u(p, m, v) {
    const y = p[m * 4], g = p[m * 4 + 1], _ = p[m * 4 + 2], b = p[m * 4 + 3], S = (g - y) / v;
    for (let x = 0; x < v; x++) {
      const M = (m + x) * 4;
      p[M] = y + S * x, p[M + 1] = y + S * (x + 1), p[M + 2] = _, p[M + 3] = b;
    }
  }
  function h() {
    return (self.performance || Date).now();
  }
  function d() {
    this.data = [];
  }
  const f = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return d.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / f.length);
    },
    glyphAt(p) {
      let m = d.flyweight;
      return m.data = this.data, m.index = p, m;
    },
    splitAt(p) {
      let m = new d();
      return m.data = this.data.splice(p * f.length), m;
    }
  }, d.flyweight = f.reduce((p, m, v, y) => (Object.defineProperty(p, m, {
    get() {
      return this.data[this.index * f.length + v];
    },
    set(g) {
      this.data[this.index * f.length + v] = g;
    }
  }), p), { data: null, index: 0 }), {
    typeset: a,
    measure: l
  };
}
const now = () => (self.performance || Date).now(), mainThreadGenerator = /* @__PURE__ */ SDFGenerator();
let warned;
function generateSDF(o, e, t, i, n, r, s, a, l, c, u = !0) {
  return u ? generateSDF_GL(o, e, t, i, n, r, s, a, l, c).then(
    null,
    (h) => (warned || (console.warn("WebGL SDF generation failed, falling back to JS", h), warned = !0), generateSDF_JS_Worker(o, e, t, i, n, r, s, a, l, c))
  ) : generateSDF_JS_Worker(o, e, t, i, n, r, s, a, l, c);
}
const queue = [], chunkTimeBudget = 5;
let timer = 0;
function nextChunk() {
  const o = now();
  for (; queue.length && now() - o < chunkTimeBudget; )
    queue.shift()();
  timer = queue.length ? setTimeout(nextChunk, 0) : 0;
}
const generateSDF_GL = (...o) => new Promise((e, t) => {
  queue.push(() => {
    const i = now();
    try {
      mainThreadGenerator.webgl.generateIntoCanvas(...o), e({ timing: now() - i });
    } catch (n) {
      t(n);
    }
  }), timer || (timer = setTimeout(nextChunk, 0));
}), threadCount = 4, idleTimeout = 2e3, threads = {};
let callNum = 0;
function generateSDF_JS_Worker(o, e, t, i, n, r, s, a, l, c) {
  const u = "TroikaTextSDFGenerator_JS_" + callNum++ % threadCount;
  let h = threads[u];
  return h || (h = threads[u] = {
    workerModule: defineWorkerModule({
      name: u,
      workerId: u,
      dependencies: [
        SDFGenerator,
        now
      ],
      init(d, f) {
        const p = d().javascript.generate;
        return function(...m) {
          const v = f();
          return {
            textureData: p(...m),
            timing: f() - v
          };
        };
      },
      getTransferables(d) {
        return [d.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), h.requests++, clearTimeout(h.idleTimer), h.workerModule(o, e, t, i, n, r).then(({ textureData: d, timing: f }) => {
    const p = now(), m = new Uint8Array(d.length * 4);
    for (let v = 0; v < d.length; v++)
      m[v * 4 + c] = d[v];
    return mainThreadGenerator.webglUtils.renderImageData(s, m, a, l, o, e, 1 << 3 - c), f += now() - p, --h.requests === 0 && (h.idleTimer = setTimeout(() => {
      terminateWorker(u);
    }, idleTimeout)), { timing: f };
  });
}
function warmUpSDFCanvas(o) {
  o._warm || (mainThreadGenerator.webgl.isSupported(o), o._warm = !0);
}
const resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing, CONFIG = {
  defaultFontURL: null,
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, tempColor = /* @__PURE__ */ new Color();
function now$1() {
  return (self.performance || Date).now();
}
const atlases = /* @__PURE__ */ Object.create(null);
function getTextRenderInfo(o, e) {
  o = assign({}, o);
  const t = now$1(), { defaultFontURL: i } = CONFIG, n = [];
  if (i && n.push({ label: "default", src: toAbsoluteURL(i) }), o.font && n.push({ label: "user", src: toAbsoluteURL(o.font) }), o.font = n, o.text = "" + o.text, o.sdfGlyphSize = o.sdfGlyphSize || CONFIG.sdfGlyphSize, o.unicodeFontsURL = o.unicodeFontsURL || CONFIG.unicodeFontsURL, o.colorRanges != null) {
    let d = {};
    for (let f in o.colorRanges)
      if (o.colorRanges.hasOwnProperty(f)) {
        let p = o.colorRanges[f];
        typeof p != "number" && (p = tempColor.set(p).getHex()), d[f] = p;
      }
    o.colorRanges = d;
  }
  Object.freeze(o);
  const { textureWidth: r, sdfExponent: s } = CONFIG, { sdfGlyphSize: a } = o, l = r / a * 4;
  let c = atlases[a];
  if (!c) {
    const d = document.createElement("canvas");
    d.width = r, d.height = a * 256 / l, c = atlases[a] = {
      glyphCount: 0,
      sdfGlyphSize: a,
      sdfCanvas: d,
      sdfTexture: new Texture(
        d,
        void 0,
        void 0,
        void 0,
        LinearFilter,
        LinearFilter
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, c.sdfTexture.generateMipmaps = !1, initContextLossHandling(c);
  }
  const { sdfTexture: u, sdfCanvas: h } = c;
  typesetInWorker(o).then((d) => {
    const { glyphIds: f, glyphFontIndices: p, fontData: m, glyphPositions: v, fontSize: y, timings: g } = d, _ = [], b = new Float32Array(f.length * 4);
    let S = 0, x = 0;
    const M = now$1(), w = m.map((P) => {
      let R = c.glyphsByFont.get(P.src);
      return R || c.glyphsByFont.set(P.src, R = /* @__PURE__ */ new Map()), R;
    });
    f.forEach((P, R) => {
      const L = p[R], { src: A, unitsPerEm: k } = m[L];
      let Q = w[L].get(P);
      if (!Q) {
        const { path: W, pathBounds: X } = d.glyphData[A][P], q = Math.max(X[2] - X[0], X[3] - X[1]) / a * (CONFIG.sdfMargin * a + 0.5), O = c.glyphCount++, te = [
          X[0] - q,
          X[1] - q,
          X[2] + q,
          X[3] + q
        ];
        w[L].set(P, Q = { path: W, atlasIndex: O, sdfViewBox: te }), _.push(Q);
      }
      const { sdfViewBox: U } = Q, H = v[x++], I = v[x++], V = y / k;
      b[S++] = H + U[0] * V, b[S++] = I + U[1] * V, b[S++] = H + U[2] * V, b[S++] = I + U[3] * V, f[R] = Q.atlasIndex;
    }), g.quads = (g.quads || 0) + (now$1() - M);
    const D = now$1();
    g.sdf = {};
    const B = h.height, z = Math.ceil(c.glyphCount / l), F = Math.pow(2, Math.ceil(Math.log2(z * a)));
    F > B && (console.info(`Increasing SDF texture size ${B}->${F}`), resizeWebGLCanvasWithoutClearing(h, r, F), u.dispose()), Promise.all(_.map(
      (P) => generateGlyphSDF(P, c, o.gpuAccelerateSDF).then(({ timing: R }) => {
        g.sdf[P.atlasIndex] = R;
      })
    )).then(() => {
      _.length && !c.contextLost && (safariPre15Workaround(c), u.needsUpdate = !0), g.sdfTotal = now$1() - D, g.total = now$1() - t, e(Object.freeze({
        parameters: o,
        sdfTexture: u,
        sdfGlyphSize: a,
        sdfExponent: s,
        glyphBounds: b,
        glyphAtlasIndices: f,
        glyphColors: d.glyphColors,
        caretPositions: d.caretPositions,
        chunkedBounds: d.chunkedBounds,
        ascender: d.ascender,
        descender: d.descender,
        lineHeight: d.lineHeight,
        capHeight: d.capHeight,
        xHeight: d.xHeight,
        topBaseline: d.topBaseline,
        blockBounds: d.blockBounds,
        visibleBounds: d.visibleBounds,
        timings: d.timings
      }));
    });
  }), Promise.resolve().then(() => {
    c.contextLost || warmUpSDFCanvas(h);
  });
}
function generateGlyphSDF({ path: o, atlasIndex: e, sdfViewBox: t }, { sdfGlyphSize: i, sdfCanvas: n, contextLost: r }, s) {
  if (r)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: a, sdfExponent: l } = CONFIG, c = Math.max(t[2] - t[0], t[3] - t[1]), u = Math.floor(e / 4), h = u % (a / i) * i, d = Math.floor(u / (a / i)) * i, f = e % 4;
  return generateSDF(i, i, o, t, c, l, n, h, d, f, s);
}
function initContextLossHandling(o) {
  const e = o.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), o.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (t) => {
    console.log("Context Restored", t), o.contextLost = !1;
    const i = [];
    o.glyphsByFont.forEach((n) => {
      n.forEach((r) => {
        i.push(generateGlyphSDF(r, o, !0));
      });
    }), Promise.all(i).then(() => {
      safariPre15Workaround(o), o.sdfTexture.needsUpdate = !0;
    });
  });
}
function assign(o, e) {
  for (let t in e)
    e.hasOwnProperty(t) && (o[t] = e[t]);
  return o;
}
let linkEl;
function toAbsoluteURL(o) {
  return linkEl || (linkEl = typeof document > "u" ? {} : document.createElement("a")), linkEl.href = o, linkEl.href;
}
function safariPre15Workaround(o) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = o, { width: i, height: n } = e, r = o.sdfCanvas.getContext("webgl");
    let s = t.image.data;
    (!s || s.length !== i * n * 4) && (s = new Uint8Array(i * n * 4), t.image = { width: i, height: n, data: s }, t.flipY = !1, t.isDataTexture = !0), r.readPixels(0, 0, i, n, r.RGBA, r.UNSIGNED_BYTE, s);
  }
}
const typesetterWorkerModule = /* @__PURE__ */ defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    createTypesetter,
    fontResolverWorkerModule,
    bidiFactory
  ],
  init(o, e, t) {
    return o(e, t());
  }
}), typesetInWorker = /* @__PURE__ */ defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    typesetterWorkerModule
  ],
  init(o) {
    return function(e) {
      return new Promise((t) => {
        o.typeset(e, t);
      });
    };
  },
  getTransferables(o) {
    const e = [];
    for (let t in o)
      o[t] && o[t].buffer && e.push(o[t].buffer);
    return e;
  }
}), templateGeometries = {};
function getTemplateGeometry(o) {
  let e = templateGeometries[o];
  if (!e) {
    const t = new PlaneGeometry(1, 1, o, o), i = t.clone(), n = t.attributes, r = i.attributes, s = new BufferGeometry(), a = n.uv.count;
    for (let l = 0; l < a; l++)
      r.position.array[l * 3] *= -1, r.normal.array[l * 3 + 2] *= -1;
    ["position", "normal", "uv"].forEach((l) => {
      s.setAttribute(
        l,
        new Float32BufferAttribute(
          [...n[l].array, ...r[l].array],
          n[l].itemSize
        )
      );
    }), s.setIndex([...t.index.array, ...i.index.array.map((l) => l + a)]), s.translate(0.5, 0.5, 0), e = templateGeometries[o] = s;
  }
  return e;
}
const glyphBoundsAttrName = "aTroikaGlyphBounds", glyphIndexAttrName = "aTroikaGlyphIndex", glyphColorAttrName = "aTroikaGlyphColor";
class GlyphsGeometry extends InstancedBufferGeometry {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new Sphere(), this.boundingBox = new Box3();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  // Since our base geometry contains triangles for both front and back sides, we can emulate
  // the "side" by restricting the draw range.
  setSide(e) {
    const t = this.getIndex().count;
    this.setDrawRange(e === BackSide ? t / 2 : 0, e === DoubleSide ? t : t / 2);
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let t = getTemplateGeometry(e);
      ["position", "normal", "uv"].forEach((i) => {
        this.attributes[i] = t.attributes[i].clone();
      }), this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, t, i, n, r) {
    updateBufferAttr(this, glyphBoundsAttrName, e, 4), updateBufferAttr(this, glyphIndexAttrName, t, 1), updateBufferAttr(this, glyphColorAttrName, r, 3), this._blockBounds = i, this._chunkedBounds = n, this.instanceCount = t.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: i } = this;
      if (t) {
        const { PI: n, floor: r, min: s, max: a, sin: l, cos: c } = Math, u = n / 2, h = n * 2, d = Math.abs(t), f = e[0] / d, p = e[2] / d, m = r((f + u) / h) !== r((p + u) / h) ? -d : s(l(f) * d, l(p) * d), v = r((f - u) / h) !== r((p - u) / h) ? d : a(l(f) * d, l(p) * d), y = r((f + n) / h) !== r((p + n) / h) ? d * 2 : a(d - c(f) * d, d - c(p) * d);
        i.min.set(m, e[1], t < 0 ? -y : 0), i.max.set(v, e[3], t < 0 ? 0 : y);
      } else
        i.min.set(e[0], e[1], 0), i.max.set(e[2], e[3], 0);
      i.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let t = this.getAttribute(glyphIndexAttrName).count, i = this._chunkedBounds;
    if (i)
      for (let n = i.length; n--; ) {
        t = i[n].end;
        let r = i[n].rect;
        if (r[1] < e.w && r[3] > e.y && r[0] < e.z && r[2] > e.x)
          break;
      }
    this.instanceCount = t;
  }
}
function updateBufferAttr(o, e, t, i) {
  const n = o.getAttribute(e);
  t ? n && n.array.length === t.length ? (n.array.set(t), n.needsUpdate = !0) : (o.setAttribute(e, new InstancedBufferAttribute(t, i)), delete o._maxInstanceCount, o.dispose()) : n && o.deleteAttribute(e);
}
const VERTEX_DEFS = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, VERTEX_TRANSFORM = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, FRAGMENT_DEFS = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, FRAGMENT_TRANSFORM = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function createTextDerivedMaterial(o) {
  const e = createDerivedMaterial(o, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Vector2() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Vector4(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Vector4(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Vector2() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Color() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Matrix3() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: VERTEX_DEFS,
    vertexTransform: VERTEX_TRANSFORM,
    fragmentDefs: FRAGMENT_DEFS,
    fragmentColorTransform: FRAGMENT_TRANSFORM,
    customRewriter({ vertexShader: t, fragmentShader: i }) {
      let n = /\buniform\s+vec3\s+diffuse\b/;
      return n.test(i) && (i = i.replace(n, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), n.test(t) || (t = t.replace(
        voidMainRegExp,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: t, fragmentShader: i };
    }
  });
  return e.transparent = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const defaultMaterial = /* @__PURE__ */ new MeshBasicMaterial({
  color: 16777215,
  side: DoubleSide,
  transparent: !0
}), defaultStrokeColor = 8421504, tempMat4 = /* @__PURE__ */ new Matrix4(), tempVec3a = /* @__PURE__ */ new Vector3(), tempVec3b = /* @__PURE__ */ new Vector3(), tempArray = [], origin = /* @__PURE__ */ new Vector3(), defaultOrient = "+x+y";
function first(o) {
  return Array.isArray(o) ? o[0] : o;
}
let getFlatRaycastMesh = () => {
  const o = new Mesh(
    new PlaneGeometry(1, 1),
    defaultMaterial
  );
  return getFlatRaycastMesh = () => o, o;
}, getCurvedRaycastMesh = () => {
  const o = new Mesh(
    new PlaneGeometry(1, 1, 32, 1),
    defaultMaterial
  );
  return getCurvedRaycastMesh = () => o, o;
};
const syncStartEvent = { type: "syncstart" }, syncCompleteEvent = { type: "synccomplete" }, SYNCABLE_PROPS = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], COPYABLE_PROPS = SYNCABLE_PROPS.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
class Text extends Mesh {
  constructor() {
    const e = new GlyphsGeometry();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = defaultStrokeColor, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = defaultOrient, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(syncStartEvent), getTextRenderInfo({
      text: this.text,
      font: this.font,
      lang: this.lang,
      fontSize: this.fontSize || 0.1,
      fontWeight: this.fontWeight || "normal",
      fontStyle: this.fontStyle || "normal",
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF,
      unicodeFontsURL: this.unicodeFontsURL
    }, (t) => {
      this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(
        t.glyphBounds,
        t.glyphAtlasIndices,
        t.blockBounds,
        t.chunkedBounds,
        t.glyphColors
      );
      const i = this._queuedSyncs;
      i && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        i.forEach((n) => n && n());
      })), this.dispatchEvent(syncCompleteEvent), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, t, i, n, r, s) {
    this.sync(), r.isTroikaTextMaterial && this._prepareForRender(r), r._hadOwnSide = r.hasOwnProperty("side"), this.geometry.setSide(r._actualSide = r.side), r.side = FrontSide;
  }
  onAfterRender(e, t, i, n, r, s) {
    r._hadOwnSide ? r.side = r._actualSide : delete r.side;
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());
    if ((!e || e.baseMaterial !== t) && (e = this._derivedMaterial = createTextDerivedMaterial(t), t.addEventListener("dispose", function i() {
      t.removeEventListener("dispose", i), e.dispose();
    })), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let i = e._outlineMtl;
      return i || (i = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), i.isTextOutlineMaterial = !0, i.depthWrite = !1, i.map = null, e.addEventListener("dispose", function n() {
        e.removeEventListener("dispose", n), i.dispose();
      })), [
        i,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return first(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return first(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial, i = e.uniforms, n = this.textRenderInfo;
    if (n) {
      const { sdfTexture: a, blockBounds: l } = n;
      i.uTroikaSDFTexture.value = a, i.uTroikaSDFTextureSize.value.set(a.image.width, a.image.height), i.uTroikaSDFGlyphSize.value = n.sdfGlyphSize, i.uTroikaSDFExponent.value = n.sdfExponent, i.uTroikaTotalBounds.value.fromArray(l), i.uTroikaUseGlyphColors.value = !t && !!n.glyphColors;
      let c = 0, u = 0, h = 0, d, f, p, m = 0, v = 0;
      if (t) {
        let { outlineWidth: g, outlineOffsetX: _, outlineOffsetY: b, outlineBlur: S, outlineOpacity: x } = this;
        c = this._parsePercent(g) || 0, u = Math.max(0, this._parsePercent(S) || 0), d = x, m = this._parsePercent(_) || 0, v = this._parsePercent(b) || 0;
      } else
        h = Math.max(0, this._parsePercent(this.strokeWidth) || 0), h && (p = this.strokeColor, i.uTroikaStrokeColor.value.set(p ?? defaultStrokeColor), f = this.strokeOpacity, f == null && (f = 1)), d = this.fillOpacity;
      i.uTroikaDistanceOffset.value = c, i.uTroikaPositionOffset.value.set(m, v), i.uTroikaBlurRadius.value = u, i.uTroikaStrokeWidth.value = h, i.uTroikaStrokeOpacity.value = f, i.uTroikaFillOpacity.value = d ?? 1, i.uTroikaCurveRadius.value = this.curveRadius || 0;
      let y = this.clipRect;
      if (y && Array.isArray(y) && y.length === 4)
        i.uTroikaClipRect.value.fromArray(y);
      else {
        const g = (this.fontSize || 0.1) * 100;
        i.uTroikaClipRect.value.set(
          l[0] - g,
          l[1] - g,
          l[2] + g,
          l[3] + g
        );
      }
      this.geometry.applyClipRect(i.uTroikaClipRect.value);
    }
    i.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const r = t ? this.outlineColor || 0 : this.color;
    if (r == null)
      delete e.color;
    else {
      const a = e.hasOwnProperty("color") ? e.color : e.color = new Color();
      (r !== a._input || typeof r == "object") && a.set(a._input = r);
    }
    let s = this.orientation || defaultOrient;
    if (s !== e._orientation) {
      let a = i.uTroikaOrient.value;
      s = s.replace(/[^-+xyz]/g, "");
      let l = s !== defaultOrient && s.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (l) {
        let [, c, u, h, d] = l;
        tempVec3a.set(0, 0, 0)[u] = c === "-" ? 1 : -1, tempVec3b.set(0, 0, 0)[d] = h === "-" ? -1 : 1, tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b), a.setFromMatrix4(tempMat4);
      } else
        a.identity();
      e._orientation = s;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/), i = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(i) ? 0 : i / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, t = new Vector2()) {
    t.copy(e);
    const i = this.curveRadius;
    return i && (t.x = Math.atan2(e.x, Math.abs(i) - Math.abs(e.z)) * Math.abs(i)), t;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, t = new Vector2()) {
    return tempVec3a.copy(e), this.localPositionToTextCoords(this.worldToLocal(tempVec3a), t);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, t) {
    const { textRenderInfo: i, curveRadius: n } = this;
    if (i) {
      const r = i.blockBounds, s = n ? getCurvedRaycastMesh() : getFlatRaycastMesh(), a = s.geometry, { position: l, uv: c } = a.attributes;
      for (let u = 0; u < c.count; u++) {
        let h = r[0] + c.getX(u) * (r[2] - r[0]);
        const d = r[1] + c.getY(u) * (r[3] - r[1]);
        let f = 0;
        n && (f = n - Math.cos(h / n) * n, h = Math.sin(h / n) * n), l.setXYZ(u, h, d, f);
      }
      a.boundingSphere = this.geometry.boundingSphere, a.boundingBox = this.geometry.boundingBox, s.matrixWorld = this.matrixWorld, s.material.side = this.material.side, tempArray.length = 0, s.raycast(e, tempArray);
      for (let u = 0; u < tempArray.length; u++)
        tempArray[u].object = this, t.push(tempArray[u]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return super.copy(e), this.geometry = t, COPYABLE_PROPS.forEach((i) => {
      this[i] = e[i];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
SYNCABLE_PROPS.forEach((o) => {
  const e = "_private_" + o;
  Object.defineProperty(Text.prototype, o, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && (this[e] = t, this._needsSync = !0);
    }
  });
});
const baselineMapping = {
  top: "top",
  center: "middle",
  bottom: "bottom"
};
class SDFTextSystem extends System {
  updateText(e, t) {
    e.text = t.text, e.textAlign = t.textAlign, e.anchorX = t.anchor, e.anchorY = baselineMapping[t.baseline], e.color = t.color, e.font = t.font, e.fontSize = t.fontSize, e.letterSpacing = t.letterSpacing || 0, e.lineHeight = t.lineHeight || null, e.overflowWrap = t.overflowWrap, e.whiteSpace = t.whiteSpace, e.maxWidth = t.maxWidth, e.material.opacity = t.opacity, e.sync();
  }
  execute() {
    var e = this.queries.entities;
    e.added.forEach((t) => {
      var i = t.getComponent(Text$1);
      const n = new Text();
      n.name = "textMesh", n.anchorX = 0, n.anchorY = 0, n.renderOrder = 10, this.updateText(n, i), t.addComponent(Object3DComponent, { value: n });
    }), e.removed.forEach((t) => {
      var i = t.getObject3D(), n = i.getObjectByName("textMesh");
      n.dispose(), i.remove(n);
    }), e.changed.forEach((t) => {
      var i = t.getObject3D();
      if (i instanceof Text) {
        var n = t.getComponent(Text$1);
        this.updateText(i, n);
      }
    });
  }
}
SDFTextSystem.queries = {
  entities: {
    components: [Text$1],
    listen: {
      added: !0,
      removed: !0,
      changed: [Text$1]
    }
  }
};
const Constants = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
async function fetchJsonFile(o) {
  const e = await fetch(o);
  if (e.ok)
    return e.json();
  throw new Error(e.statusText);
}
async function fetchProfilesList(o) {
  if (!o)
    throw new Error("No basePath supplied");
  return await fetchJsonFile(`${o}/profilesList.json`);
}
async function fetchProfile(o, e, t = null, i = !0) {
  if (!o)
    throw new Error("No xrInputSource supplied");
  if (!e)
    throw new Error("No basePath supplied");
  const n = await fetchProfilesList(e);
  let r;
  if (o.profiles.some((l) => {
    const c = n[l];
    return c && (r = {
      profileId: l,
      profilePath: `${e}/${c.path}`,
      deprecated: !!c.deprecated
    }), !!r;
  }), !r) {
    if (!t)
      throw new Error("No matching profile name found");
    const l = n[t];
    if (!l)
      throw new Error(`No matching profile name found and default profile "${t}" missing.`);
    r = {
      profileId: t,
      profilePath: `${e}/${l.path}`,
      deprecated: !!l.deprecated
    };
  }
  const s = await fetchJsonFile(r.profilePath);
  let a;
  if (i) {
    let l;
    if (o.handedness === "any" ? l = s.layouts[Object.keys(s.layouts)[0]] : l = s.layouts[o.handedness], !l)
      throw new Error(
        `No matching handedness, ${o.handedness}, in profile ${r.profileId}`
      );
    l.assetPath && (a = r.profilePath.replace("profile.json", l.assetPath));
  }
  return { profile: s, assetPath: a };
}
const defaultComponentValues = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: Constants.ComponentState.DEFAULT
};
function normalizeAxes(o = 0, e = 0) {
  let t = o, i = e;
  if (Math.sqrt(o * o + e * e) > 1) {
    const s = Math.atan2(e, o);
    t = Math.cos(s), i = Math.sin(s);
  }
  return {
    normalizedXAxis: t * 0.5 + 0.5,
    normalizedYAxis: i * 0.5 + 0.5
  };
}
class VisualResponse {
  constructor(e) {
    this.componentProperty = e.componentProperty, this.states = e.states, this.valueNodeName = e.valueNodeName, this.valueNodeProperty = e.valueNodeProperty, this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM && (this.minNodeName = e.minNodeName, this.maxNodeName = e.maxNodeName), this.value = 0, this.updateFromComponent(defaultComponentValues);
  }
  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent({
    xAxis: e,
    yAxis: t,
    button: i,
    state: n
  }) {
    const { normalizedXAxis: r, normalizedYAxis: s } = normalizeAxes(e, t);
    switch (this.componentProperty) {
      case Constants.ComponentProperty.X_AXIS:
        this.value = this.states.includes(n) ? r : 0.5;
        break;
      case Constants.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(n) ? s : 0.5;
        break;
      case Constants.ComponentProperty.BUTTON:
        this.value = this.states.includes(n) ? i : 0;
        break;
      case Constants.ComponentProperty.STATE:
        this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY ? this.value = this.states.includes(n) : this.value = this.states.includes(n) ? 1 : 0;
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
}
class Component {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(e, t) {
    if (!e || !t || !t.visualResponses || !t.gamepadIndices || Object.keys(t.gamepadIndices).length === 0)
      throw new Error("Invalid arguments supplied");
    this.id = e, this.type = t.type, this.rootNodeName = t.rootNodeName, this.touchPointNodeName = t.touchPointNodeName, this.visualResponses = {}, Object.keys(t.visualResponses).forEach((i) => {
      const n = new VisualResponse(t.visualResponses[i]);
      this.visualResponses[i] = n;
    }), this.gamepadIndices = Object.assign({}, t.gamepadIndices), this.values = {
      state: Constants.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
    };
  }
  get data() {
    return { id: this.id, ...this.values };
  }
  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(e) {
    if (this.values.state = Constants.ComponentState.DEFAULT, this.gamepadIndices.button !== void 0 && e.buttons.length > this.gamepadIndices.button) {
      const t = e.buttons[this.gamepadIndices.button];
      this.values.button = t.value, this.values.button = this.values.button < 0 ? 0 : this.values.button, this.values.button = this.values.button > 1 ? 1 : this.values.button, t.pressed || this.values.button === 1 ? this.values.state = Constants.ComponentState.PRESSED : (t.touched || this.values.button > Constants.ButtonTouchThreshold) && (this.values.state = Constants.ComponentState.TOUCHED);
    }
    this.gamepadIndices.xAxis !== void 0 && e.axes.length > this.gamepadIndices.xAxis && (this.values.xAxis = e.axes[this.gamepadIndices.xAxis], this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis, this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis, this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold && (this.values.state = Constants.ComponentState.TOUCHED)), this.gamepadIndices.yAxis !== void 0 && e.axes.length > this.gamepadIndices.yAxis && (this.values.yAxis = e.axes[this.gamepadIndices.yAxis], this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis, this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis, this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold && (this.values.state = Constants.ComponentState.TOUCHED)), Object.values(this.visualResponses).forEach((t) => {
      t.updateFromComponent(this.values);
    });
  }
}
class MotionController {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(e, t, i) {
    if (!e)
      throw new Error("No xrInputSource supplied");
    if (!t)
      throw new Error("No profile supplied");
    this.xrInputSource = e, this.assetUrl = i, this.id = t.profileId, this.layoutDescription = t.layouts[e.handedness], this.components = {}, Object.keys(this.layoutDescription.components).forEach((n) => {
      const r = this.layoutDescription.components[n];
      this.components[n] = new Component(n, r);
    }), this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const e = [];
    return Object.values(this.components).forEach((t) => {
      e.push(t.data);
    }), e;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach((e) => {
      e.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
}
const DEFAULT_PROFILES_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles", DEFAULT_PROFILE = "generic-trigger";
class XRControllerModel extends Object3D {
  constructor() {
    super(), this.motionController = null, this.envMap = null;
  }
  setEnvironmentMap(e) {
    return this.envMap == e ? this : (this.envMap = e, this.traverse((t) => {
      t.isMesh && (t.material.envMap = this.envMap, t.material.needsUpdate = !0);
    }), this);
  }
  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.motionController && (this.motionController.updateFromGamepad(), Object.values(this.motionController.components).forEach((t) => {
      Object.values(t.visualResponses).forEach((i) => {
        const { valueNode: n, minNode: r, maxNode: s, value: a, valueNodeProperty: l } = i;
        n && (l === Constants.VisualResponseProperty.VISIBILITY ? n.visible = a : l === Constants.VisualResponseProperty.TRANSFORM && (n.quaternion.slerpQuaternions(
          r.quaternion,
          s.quaternion,
          a
        ), n.position.lerpVectors(
          r.position,
          s.position,
          a
        )));
      });
    }));
  }
}
function findNodes(o, e) {
  Object.values(o.components).forEach((t) => {
    const { type: i, touchPointNodeName: n, visualResponses: r } = t;
    if (i === Constants.ComponentType.TOUCHPAD)
      if (t.touchPointNode = e.getObjectByName(n), t.touchPointNode) {
        const s = new SphereGeometry(1e-3), a = new MeshBasicMaterial({ color: 255 }), l = new Mesh(s, a);
        t.touchPointNode.add(l);
      } else
        console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`);
    Object.values(r).forEach((s) => {
      const { valueNodeName: a, minNodeName: l, maxNodeName: c, valueNodeProperty: u } = s;
      if (u === Constants.VisualResponseProperty.TRANSFORM) {
        if (s.minNode = e.getObjectByName(l), s.maxNode = e.getObjectByName(c), !s.minNode) {
          console.warn(`Could not find ${l} in the model`);
          return;
        }
        if (!s.maxNode) {
          console.warn(`Could not find ${c} in the model`);
          return;
        }
      }
      s.valueNode = e.getObjectByName(a), s.valueNode || console.warn(`Could not find ${a} in the model`);
    });
  });
}
function addAssetSceneToControllerModel(o, e) {
  findNodes(o.motionController, e), o.envMap && e.traverse((t) => {
    t.isMesh && (t.material.envMap = o.envMap, t.material.needsUpdate = !0);
  }), o.add(e);
}
class XRControllerModelFactory {
  constructor(e = null) {
    this.gltfLoader = e, this.path = DEFAULT_PROFILES_PATH, this._assetCache = {}, this.gltfLoader || (this.gltfLoader = new GLTFLoader());
  }
  createControllerModel(e) {
    const t = new XRControllerModel();
    let i = null;
    return e.addEventListener("connected", (n) => {
      const r = n.data;
      r.targetRayMode !== "tracked-pointer" || !r.gamepad || fetchProfile(r, this.path, DEFAULT_PROFILE).then(({ profile: s, assetPath: a }) => {
        t.motionController = new MotionController(
          r,
          s,
          a
        );
        const l = this._assetCache[t.motionController.assetUrl];
        if (l)
          i = l.scene.clone(), addAssetSceneToControllerModel(t, i);
        else {
          if (!this.gltfLoader)
            throw new Error("GLTFLoader not set.");
          this.gltfLoader.setPath(""), this.gltfLoader.load(
            t.motionController.assetUrl,
            (c) => {
              this._assetCache[t.motionController.assetUrl] = c, i = c.scene.clone(), addAssetSceneToControllerModel(t, i);
            },
            null,
            () => {
              throw new Error(`Asset ${t.motionController.assetUrl} missing or malformed.`);
            }
          );
        }
      }).catch((s) => {
        console.warn(s);
      });
    }), e.addEventListener("disconnected", () => {
      t.motionController = null, t.remove(i), i = null;
    }), t;
  }
}
var controllerModelFactory = new XRControllerModelFactory();
class VRControllerSystem extends System {
  init() {
    this.world.registerComponent(VRController).registerComponent(VRControllerBasicBehaviour).registerComponent(ControllerConnected);
  }
  execute() {
    let e = this.queries.rendererContext.results[0].getComponent(
      WebGLRendererContext
    ).value;
    this.queries.controllers.added.forEach((t) => {
      let i = t.getComponent(VRController).id;
      var n = e.xr.getController(i);
      n.name = "controller";
      var r = new Group();
      if (r.add(n), t.addComponent(Object3DComponent, { value: r }), n.addEventListener("connected", () => {
        t.addComponent(ControllerConnected);
      }), n.addEventListener("disconnected", () => {
        t.removeComponent(ControllerConnected);
      }), t.hasComponent(VRControllerBasicBehaviour)) {
        var s = t.getComponent(VRControllerBasicBehaviour);
        Object.keys(s).forEach((l) => {
          s[l] && n.addEventListener(l, s[l]);
        });
      }
      let a = e.xr.getControllerGrip(i);
      a.add(
        controllerModelFactory.createControllerModel(a)
      ), a.name = "model", r.add(a);
    });
  }
}
VRControllerSystem.queries = {
  controllers: {
    components: [VRController],
    listen: {
      added: !0
      //changed: [Visible]
    }
  },
  rendererContext: {
    components: [WebGLRendererContext],
    mandatory: !0
  }
};
class AnimationMixerComponent extends Component$1 {
}
AnimationMixerComponent.schema = {
  value: { default: 0, type: Types.Number }
};
class AnimationActionsComponent extends Component$1 {
}
AnimationActionsComponent.schema = {
  animations: { default: [], type: Types.Array },
  duration: { default: 0, type: Types.Number }
};
class AnimationSystem extends System {
  init() {
    this.world.registerComponent(AnimationMixerComponent).registerComponent(AnimationActionsComponent);
  }
  execute(e) {
    this.queries.entities.added.forEach((t) => {
      let i = t.getComponent(GLTFModel).value, n = new AnimationMixer(i.scene);
      t.addComponent(AnimationMixerComponent, {
        value: n
      });
      let r = [];
      i.animations.forEach((s) => {
        const a = n.clipAction(s, i.scene);
        a.loop = LoopOnce, r.push(a);
      }), t.addComponent(AnimationActionsComponent, {
        animations: r,
        duration: t.getComponent(Animation).duration
      });
    }), this.queries.mixers.results.forEach((t) => {
      t.getComponent(AnimationMixerComponent).value.update(e);
    }), this.queries.playClips.results.forEach((t) => {
      let i = t.getComponent(AnimationActionsComponent);
      i.animations.forEach((n) => {
        i.duration !== -1 && n.setDuration(i.duration), n.clampWhenFinished = !0, n.reset(), n.play();
      }), t.removeComponent(Play);
    }), this.queries.stopClips.results.forEach((t) => {
      t.getComponent(AnimationActionsComponent).animations.forEach((n) => {
        n.reset(), n.stop();
      }), t.removeComponent(Stop);
    });
  }
}
AnimationSystem.queries = {
  entities: {
    components: [Animation, GLTFModel],
    listen: {
      added: !0
    }
  },
  mixers: {
    components: [AnimationMixerComponent]
  },
  playClips: {
    components: [AnimationActionsComponent, Play]
  },
  stopClips: {
    components: [AnimationActionsComponent, Stop]
  }
};
class InputSystem extends System {
  init() {
    //!!!!!!!!!!!!!
    this.world.registerComponent(InputState);
    let e = this.world.createEntity().addComponent(InputState);
    this.inputStateComponent = e.getMutableComponent(InputState);
  }
  execute() {
    this.processVRControllers();
  }
  processVRControllers() {
    this.queries.vrcontrollers.added.forEach((e) => {
      e.addComponent(VRControllerBasicBehaviour, {
        selectstart: (t) => {
          let i = this.inputStateComponent.vrcontrollers.get(t.target);
          i.selected = !0, i.prevSelected = !1;
        },
        selectend: (t) => {
          let i = this.inputStateComponent.vrcontrollers.get(t.target);
          i.selected = !1, i.prevSelected = !0;
        },
        connected: (t) => {
          this.inputStateComponent.vrcontrollers.set(t.target, {});
        },
        disconnected: (t) => {
          this.inputStateComponent.vrcontrollers.delete(t.target);
        }
      });
    }), this.inputStateComponent.vrcontrollers.forEach((e) => {
      e.selectStart = e.selected && !e.prevSelected, e.selectEnd = !e.selected && e.prevSelected, e.prevSelected = e.selected;
    });
  }
}
InputSystem.queries = {
  vrcontrollers: {
    components: [VRController],
    listen: {
      added: !0
    }
  }
};
class PositionalAudioPolyphonic extends Object3D {
  constructor(e, t) {
    super(), this.listener = e, this.context = e.context, this.poolSize = t || 5;
    for (var i = 0; i < this.poolSize; i++)
      this.children.push(new PositionalAudio(e));
  }
  setBuffer(e) {
    this.children.forEach((t) => {
      t.setBuffer(e);
    });
  }
  play() {
    var e = !1;
    for (let t = 0; t < this.children.length; t++) {
      let i = this.children[t];
      if (!i.isPlaying && i.buffer && !e) {
        i.play(), i.isPaused = !1, e = !0;
        continue;
      }
    }
    if (!e) {
      console.warn(
        "All the sounds are playing. If you need to play more sounds simultaneously consider increasing the pool size"
      );
      return;
    }
  }
}
class SoundSystem extends System {
  init() {
    this.listener = new AudioListener();
  }
  execute() {
    this.queries.sounds.added.forEach((e) => {
      const t = e.getMutableComponent(Sound), i = new PositionalAudioPolyphonic(this.listener, 10);
      new AudioLoader().load(t.url, (r) => {
        i.setBuffer(r);
      }), t.sound = i;
    });
  }
}
SoundSystem.queries = {
  sounds: {
    components: [Sound],
    listen: {
      added: !0,
      removed: !0,
      changed: !0
      // [Sound]
    }
  }
};
class LevelItem extends Component$1 {
}
class Level extends Component$1 {
}
Level.schema = {
  value: { default: 0, type: Types.Number }
};
class FloorCollided extends TagComponent {
}
class Cleared extends TagComponent {
}
class Element extends Component$1 {
}
Element.schema = {
  value: { default: 0, type: Types.Number },
  type: { default: 0, type: Types.Number }
};
class Rotating extends Component$1 {
}
Rotating.schema = {
  speed: {
    default: new Vector3(0, 0, 0),
    type: ThreeTypes.Vector3Type
  }
};
class Dissolve extends Component$1 {
}
Dissolve.schema = {
  speed: { default: 1, type: Types.Number },
  value: { default: 1, type: Types.Number }
};
class GameState extends Component$1 {
}
GameState.schema = {
  playing: { default: !1, type: Types.Boolean },
  prevPlaying: { default: !1, type: Types.Boolean },
  levelFinished: { default: !1, type: Types.Boolean },
  numBallsFailed: { default: 0, type: Types.Number },
  numBallsTotal: { default: 0, type: Types.Number },
  levelStartTime: { default: 0, type: Types.Number },
  gameStartTime: { default: 0, type: Types.Number },
  inAR: { default: !1, type: Types.Boolean }
};
class BallGenerator extends Component$1 {
}
BallGenerator.schema = {
  position: { default: new Vector3(), type: ThreeTypes.Vector3Type },
  linearVelocity: { default: new Vector3(), type: ThreeTypes.Vector3Type }
};
class Ball extends Component$1 {
}
Ball.schema = {
  radius: { default: 0.4, type: Types.Number },
  position: { default: new Vector3(), type: ThreeTypes.Vector3Type },
  linearVelocity: { default: new Vector3(), type: ThreeTypes.Vector3Type }
};
class Target extends Component$1 {
}
Target.schema = {
  position: { default: new Vector3(), type: ThreeTypes.Vector3Type }
};
class UI extends TagComponent {
}
class Button extends Component$1 {
}
Button.schema = {
  text: { default: "", type: Types.String },
  onClick: { default: null, type: Types.Ref }
};
class RaycastReceiver extends Component$1 {
}
RaycastReceiver.schema = {
  hovering: { default: !1, type: Types.Boolean },
  selecting: { default: !1, type: Types.Boolean },
  onHover: { default: null, type: Types.Ref },
  onEnter: { default: null, type: Types.Ref },
  onLeave: { default: null, type: Types.Ref },
  onSelectStart: { default: null, type: Types.Ref },
  onSelect: { default: null, type: Types.Ref },
  onSelectEnd: { default: null, type: Types.Ref },
  layerMask: { default: 0, type: Types.Number }
};
class Raycaster extends Component$1 {
}
Raycaster.schema = {
  enabled: { default: !0, type: Types.Boolean },
  currentEntity: { default: null, type: Types.Ref },
  layerMask: { default: 0, type: Types.Number },
  value: { default: null, type: Types.Ref }
};
class Floor extends TagComponent {
}
class Ad extends TagComponent {
}
const Components = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Active,
  Ad,
  Animation,
  AnimationSystem,
  Ball,
  BallGenerator,
  Button,
  Camera,
  CameraRig,
  CameraTagComponent,
  Cleared,
  Colliding,
  CollisionStart,
  CollisionStop,
  ControllerConnected,
  Dissolve,
  Draggable,
  Dragging,
  ECSYThreeSystem: System,
  ECSYThreeWorld,
  Element,
  Floor,
  FloorCollided,
  GLTFLoader: GLTFLoader$1,
  GLTFLoaderSystem,
  GLTFModel,
  GameState,
  Geometry,
  GeometrySystem,
  InputState,
  InputSystem,
  Level,
  LevelItem,
  MeshTagComponent,
  Object3DComponent,
  OnObject3DAdded,
  OnObject3DAddedSystem,
  Parent,
  ParentObject3D,
  Play,
  Position,
  RaycastReceiver,
  Raycaster,
  RenderPass,
  RigidBody,
  Rotating,
  Rotation,
  SDFTextSystem,
  Scale,
  Scene,
  SceneTagComponent,
  Shape,
  SkyBox,
  SkyBoxSystem,
  Sound,
  SoundSystem,
  Stop,
  Target,
  Text: Text$1,
  ThreeTypes,
  Transform,
  TransformSystem,
  Types,
  UI,
  UpdateAspectOnResizeSystem,
  UpdateAspectOnResizeTag,
  VRController,
  VRControllerBasicBehaviour,
  VRControllerSystem,
  Vector3Type,
  VisibilitySystem,
  Visible,
  WebGLRenderer,
  WebGLRendererContext,
  WebGLRendererSystem,
  defaultObject3DInflator,
  initialize
}, Symbol.toStringTag, { value: "Module" })), environmentMap = new TextureLoader().load(
  "assets/textures/env.jpg"
);
environmentMap.mapping = EquirectangularReflectionMapping;
environmentMap.encoding = sRGBEncoding;
environmentMap.flipY = !1;
const UIMaterial = new MeshBasicMaterial({
  map: new TextureLoader().load("assets/textures/ui.png"),
  transparent: !0
});
UIMaterial.map.encoding = sRGBEncoding;
UIMaterial.map.flipY = !1;
var textures = {};
const textureURLs = [
  "metal.jpg",
  "rubber.png",
  "wood.png",
  "floor.png",
  "target.png",
  "cannon.jpg",
  "ball.png",
  "wood_spec.jpg",
  "cannon_spec.jpg",
  "metal_spec.jpg"
];
for (let o = 0; o < textureURLs.length; o++) {
  let e = new TextureLoader().load(`assets/textures/${textureURLs[o]}`);
  e.encoding = sRGBEncoding, e.flipY = !1, textures[textureURLs[o]] = e;
}
var worldPos = new Vector3();
class TargetSystem extends System {
  init() {
    this.world.registerComponent(Rotating).registerComponent(Cleared);
  }
  execute() {
    var e = this.queries.balls.results, t = this.queries.targets.results;
    for (let a = 0; a < t.length; a++) {
      var i = t[a], n = i.getObject3D();
      let l = n.children[0];
      l.getWorldPosition(worldPos), l.geometry.boundingSphere || l.geometry.computeBoundingSphere();
      let c = l.geometry.boundingSphere.radius;
      for (let u = 0; u < e.length; u++) {
        var r = e[u], s = r.getObject3D();
        s.geometry.boundingSphere || s.geometry.computeBoundingSphere();
        let d = s.geometry.boundingSphere.radius + c;
        s.position.distanceToSquared(worldPos) <= d * d && (r.removeComponent(Active), i.addComponent(Rotating, { speed: new Vector3(0, 30, 0) }), i.addComponent(Cleared));
      }
    }
  }
}
TargetSystem.queries = {
  targets: { components: [Target, Object3DComponent] },
  balls: { components: [Ball, Active, Object3DComponent] }
};
const METAL = 0, RUBBER = 1, WOOD = 2, STATIC = 3, levels = [
  // 1
  {
    targets: [{
      position: { x: 0.7, y: 1, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: -0.7, y: 1, z: 0 },
      linearVelocity: { x: 2, y: 2, z: 0 }
    }],
    elements: [
      {
        type: RUBBER,
        position: { x: 0, y: 1.1, z: 0 },
        rotation: { x: 0, y: 0, z: Math.PI / 2 }
      }
    ]
  },
  // 2
  {
    targets: [{
      position: { x: 0.7, y: 0.7, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: -0.6, y: 1.2, z: 0 },
      linearVelocity: { x: 0.6, y: 2.8, z: 0 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: -0.3, y: 0.5, z: 0 },
        rotation: { x: -0.1, y: 0, z: -0.2 }
      },
      {
        type: WOOD,
        position: { x: 0.1, y: 0.75, z: -0.2 },
        rotation: { x: -0.3, y: 0.1, z: 1.1 }
      }
    ]
  },
  // 3
  {
    targets: [{
      position: { x: 0.5, y: 1.4, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: -0.5, y: 1, z: 0 },
      linearVelocity: { x: 1, y: -2, z: 0 }
    }],
    elements: [
      {
        type: METAL,
        position: { x: -0.1, y: 1, z: 0 },
        rotation: { x: 0.2, y: 0.3, z: 0 }
      },
      {
        type: RUBBER,
        position: { x: 0.4, y: 0.95, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.2, y: 1.5, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.4, y: 0.8, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 4
  {
    targets: [{
      position: { x: 0.6, y: 1.2, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: -0.7, y: 1, z: 0 },
      linearVelocity: { x: 2, y: -1, z: 0 }
    }],
    elements: [
      {
        type: METAL,
        position: { x: -0.5, y: 0.8, z: 0 },
        rotation: { x: 1.4, y: 1.4, z: -1.5 }
      },
      {
        type: RUBBER,
        position: { x: 0.5, y: 0.5, z: 0 },
        rotation: { x: -1.4, y: 1.4, z: 1.1 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.3, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.5, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.2, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 5
  {
    targets: [{
      position: { x: 0.5, y: 0.65, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: 0.1, y: 1.4, z: 0 },
      linearVelocity: { x: -3, y: 0.5, z: 0 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: 0.1, y: 0.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: RUBBER,
        position: { x: 1, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.22, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.22, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.44, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 6
  {
    targets: [{
      position: { x: 0.6, y: 1.6, z: 0 },
      rotation: { x: Math.PI / 2, y: 0.3, z: 0 }
    }],
    generators: [{
      position: { x: -1.4, y: 1, z: 0 },
      linearVelocity: { x: 2, y: 3, z: 0 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: 0.4, y: 0.5, z: 0 },
        rotation: { x: 0.08, y: 0, z: 0.2 }
      },
      {
        type: RUBBER,
        position: { x: 0.6, y: 0.7, z: 0 },
        rotation: { x: 0.3, y: 0, z: -0.1 }
      },
      {
        type: RUBBER,
        position: { x: -0.5, y: 0.96, z: 0 },
        rotation: { x: 0.5, y: 0, z: 0.7 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.8, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.2, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 7
  {
    targets: [{
      position: { x: 0, y: 1, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: 0.8, y: 1.7, z: 0 },
      linearVelocity: { x: -0.4, y: 3, z: 0 }
    }],
    elements: [
      {
        type: METAL,
        position: { x: -0.7, y: 1.5, z: 0 },
        rotation: { x: 0.2, y: 0, z: -0.3 }
      },
      {
        type: WOOD,
        position: { x: 0.6, y: 0.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0.6 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: 0 },
        rotation: { x: 0.1, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.4, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.4, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.2, y: 1.2, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.2, y: 0.8, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.2, y: 1.2, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.2, y: 0.8, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 8
  {
    targets: [{
      position: { x: -0.7, y: 0.8, z: 0 },
      rotation: { x: -0.1, y: -1.5, z: 2.2 }
    }],
    generators: [{
      position: { x: -0.1, y: 1.58, z: 0 },
      linearVelocity: { x: 3, y: 1, z: 0 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: 0.7, y: 1.3, z: 0 },
        rotation: { x: 0.1, y: 0, z: -0.2 }
      },
      {
        type: RUBBER,
        position: { x: 0.5, y: 0.7, z: 0 },
        rotation: { x: 0.1, y: -0.4, z: 0.7 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.8, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.2, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.8, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.6, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.2, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.8, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.4, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.8, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.6, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.2, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.8, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.4, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 9
  {
    targets: [{
      position: { x: 0.8, y: 0.7, z: -0.7 },
      rotation: { x: 2.6, y: 0.9, z: 3 }
    }],
    generators: [{
      position: { x: -1, y: 1.4, z: -0.2 },
      linearVelocity: { x: 2, y: 2, z: 1.5 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: -0.3, y: 0.8, z: 0.1 },
        rotation: { x: -0.1, y: 0.3, z: -0.2 }
      },
      {
        type: METAL,
        position: { x: 0.4, y: 1.3, z: 0 },
        rotation: { x: 0, y: 0.6, z: 0.1 }
      },
      {
        type: WOOD,
        position: { x: 0, y: 0.9, z: 0 },
        rotation: { x: -0.1, y: -0.1, z: -0.2 }
      },
      {
        type: STATIC,
        position: { x: 0.3, y: 0.5, z: -0.4 },
        rotation: { x: -0.1, y: -0.4, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.6, y: 1, z: 0.1 },
        rotation: { x: 0, y: 0.5, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.3, y: 1, z: -0.4 },
        rotation: { x: -0.1, y: 0.1, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.1, y: 0.9, z: -0.6 },
        rotation: { x: -0.1, y: -0.3, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.3, y: 1.3, z: -0.3 },
        rotation: { x: 0.1, y: -0.5, z: 0.1 }
      },
      {
        type: STATIC,
        position: { x: 0.5, y: 0.9, z: 0 },
        rotation: { x: 0, y: -0.7, z: -0.1 }
      },
      {
        type: STATIC,
        position: { x: 0.5, y: 0.8, z: -0.5 },
        rotation: { x: 0, y: 0.3, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.3, y: 1.5, z: -0.2 },
        rotation: { x: 0.1, y: 0.1, z: -0.1 }
      }
    ]
  },
  // 10
  {
    targets: [{
      position: { x: 1.2, y: 0.8, z: 0 },
      rotation: { x: 0, y: 1.5, z: 0 }
    }],
    generators: [{
      position: { x: -1.2, y: 1.7, z: 0 },
      linearVelocity: { x: 0.4, y: 1, z: -1.5 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: -0.4, y: 1.5, z: -0.4 },
        rotation: { x: 0.3, y: 0.1, z: -0.5 }
      },
      {
        type: WOOD,
        position: { x: 0.1, y: 0.7, z: -0.4 },
        rotation: { x: -0.2, y: -0.2, z: 0.2 }
      },
      {
        type: RUBBER,
        position: { x: -0.3, y: 0.8, z: 0 },
        rotation: { x: -0.1, y: 0.4, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.3, y: 1.2, z: -0.4 },
        rotation: { x: 0.1, y: -0.1, z: -0.1 }
      },
      {
        type: STATIC,
        position: { x: 0.8, y: 1, z: -0.4 },
        rotation: { x: 0, y: -0.8, z: 0.1 }
      },
      {
        type: STATIC,
        position: { x: -0.5, y: 0.9, z: -0.2 },
        rotation: { x: -0.1, y: 0.4, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.6, y: 0.8, z: -0.1 },
        rotation: { x: 0, y: -0.8, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.1, y: 1, z: -0.8 },
        rotation: { x: 0, y: -0.4, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.3, y: 1, z: -0.4 },
        rotation: { x: 0, y: -0.5, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: -0.6 },
        rotation: { x: 0.2, y: -0.3, z: 0.1 }
      },
      {
        type: STATIC,
        position: { x: -0.6, y: 1.2, z: -0.2 },
        rotation: { x: 0.1, y: 0.4, z: -0.2 }
      },
      {
        type: STATIC,
        position: { x: 0.4, y: 1.2, z: 0.1 },
        rotation: { x: 0, y: -0.3, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.9, y: 1.5, z: -0.7 },
        rotation: { x: 0, y: 0.2, z: -0.1 }
      },
      {
        type: STATIC,
        position: { x: -0.5, y: 1.1, z: 0.2 },
        rotation: { x: 0.1, y: 0.8, z: -0.2 }
      },
      {
        type: STATIC,
        position: { x: -0.5, y: 1.2, z: -0.8 },
        rotation: { x: 0.1, y: -0.1, z: -0.1 }
      },
      {
        type: STATIC,
        position: { x: 0.7, y: 0.7, z: 0.3 },
        rotation: { x: 0.1, y: -1.1, z: 0.2 }
      }
    ]
  }
];
class GameStateSystem extends System {
  setVisibilityByName(e, t) {
    let i = this.world.entityManager.getEntityByName(e);
    i && (i.getMutableComponent(Visible).value = t);
  }
  finish() {
    this.stopGame(), this.setVisibilityByName("startbutton", !0), this.setVisibilityByName("finished", !0), this.setVisibilityByName("playingGroup", !1), this.world.getSystem(LevelManager).clearCurrentLevel(), this.world.entityManager.getEntityByName("singleton").getMutableComponent(Level).value = 1, this.queries.raycasters.results.forEach((i) => {
      i.getMutableComponent(Raycaster).layerMask = 4;
    });
    let e = this.world.entityManager.getEntityByName("panelInfo");
    e.addComponent(Play);
    let t = e.getObject3D().children[0];
    t.userData.oldPosition || (t.userData.oldPosition = new Vector3()), t.userData.oldPosition.copy(t.position), t.position.set(0, 1.6, -2), t.scale.set(3, 3, 3);
  }
  playGame() {
    let e = this.queries.gameState.results[0].getMutableComponent(
      GameState
    );
    if (e.playing)
      return;
    this.setVisibilityByName("help", !1), this.setVisibilityByName("startbutton", !1), this.setVisibilityByName("finished", !1), this.setVisibilityByName("zestyBanner", !1), this.setVisibilityByName("newsPanel", !1), this.setVisibilityByName("adText", !1), this.setVisibilityByName("newsText", !1), this.setVisibilityByName("futureUpdateText", !1), this.setVisibilityByName("playingGroup", !0), this.setVisibilityByName("panelInfo", !0), this.queries.raycasters.results.forEach((n) => {
      n.getMutableComponent(Raycaster).layerMask = 2;
    }), e.playing = !0, e.numBallsFailed = 0, e.numBallsTotal = 0, e.levelStartTime = performance.now(), e.gameStartTime = performance.now(), this.updateTexts(e), this.queries.ballGenerators.results.forEach((n) => {
      n.addComponent(Active);
    });
    let t = this.world.entityManager.getEntityByName("panelInfo");
    t.addComponent(Stop);
    let i = t.getComponent(Object3DComponent);
    i && (i = i.value.children[0], i.userData.oldPosition && i.position.copy(i.userData.oldPosition), i.scale.set(1, 1, 1)), this.world.getSystem(PhysicsSystem).play();
  }
  updateTexts(e) {
    let t = this.world.entityManager.getEntityByName("numberBalls");
    t && (t.getMutableComponent(
      Text$1
    ).text = `${e.numBallsFailed}/${e.numBallsTotal}`);
  }
  stopGame() {
    this.queries.gameState.results[0].getMutableComponent(
      GameState
    ).playing = !1;
  }
  isPlaying() {
    return this.queries.gameState.results[0].getMutableComponent(
      GameState
    ).playing;
  }
  setEnvEnabled(e) {
    this.setVisibilityByName("environment", e);
    var t = this.queries.gameState.results[0].getComponent(GameState);
    t.inAR = !e, e || this.world.getSystem(CameraRigSystem).queries.entities.results[0].getComponent(Object3DComponent).value.position.set(0, 1.6, 0.5);
  }
  execute() {
    var e = this.queries.gameState.results[0].getComponent(GameState);
    if (!e.playing)
      return;
    let t = performance.now() - e.levelStartTime, i = performance.now() - e.gameStartTime, n = this.world.entityManager.getEntityByName("singleton"), r = this.world.entityManager.getEntityByName("timer");
    r && (r.getMutableComponent(Text$1).text = new Date(t).toISOString().substr(14, 5));
    let s = this.world.entityManager.getEntityByName("timerTotal");
    s && (s.getMutableComponent(Text$1).text = new Date(i).toISOString().substr(14, 5)), this.queries.ballFloorCollided.added.forEach((a) => {
      e.numBallsFailed++, this.world.entityManager.getEntityByName("numberBalls").getMutableComponent(
        Text$1
      ).text = `${e.numBallsFailed}`;
      let l = n.getComponent(Level).value;
      this.queries.ballGenerators.results.forEach((c) => {
        c.addComponent(Play);
      }), setTimeout(() => {
        n.getComponent(Level).value === l && this.queries.ballGenerators.results.forEach((c) => {
          c.addComponent(Active);
        });
      }, 1900), setTimeout(() => {
        !a || !a.alive || n.getComponent(Level).value;
      }, 2e3), a.addComponent(Dissolve);
    }), this.queries.targetCleared.added.forEach((a) => {
      a.getComponent(Sound).sound.play(), setTimeout(() => {
        var l = n.getMutableComponent(Level);
        l.value === levels.length - 1 ? (l.value = 1, this.finish()) : (l.value++, e.levelStartTime = performance.now(), e.levelFinished = !1);
      }, 2e3), e.levelFinished = !0;
    });
  }
}
GameStateSystem.queries = {
  ballGenerators: { components: [BallGenerator] },
  gameState: {
    components: [GameState],
    listen: {
      changed: !0
    }
  },
  ballFloorCollided: {
    components: [Ball, FloorCollided],
    listen: {
      added: !0
    }
  },
  targetCleared: {
    components: [Target, Cleared],
    listen: {
      added: !0
    }
  },
  raycasters: {
    components: [Raycaster]
  }
};
const RADIUS = 0.03;
class BallGeneratorSystem extends System {
  execute() {
    this.queries.entities.added.forEach((e) => {
      let t = e.getComponent(Sound);
      t.sound && t.sound.play();
      var i = e.getComponent(BallGenerator), n = this.world.createEntity();
      n.addComponent(GLTFLoader$1, {
        url: "assets/models/ball.glb",
        onLoaded: (r) => {
          n.getMutableComponent(Object3DComponent).value = r.children[0], r.children[0].material = new THREE.MeshPhongMaterial({
            map: textures["ball.png"],
            envMap: environmentMap,
            reflectivity: 0.2
          });
        }
      }).addComponent(Transform, {
        position: i.position,
        rotation: { x: 0, y: 0, z: 0 }
      }).addComponent(Shape, {
        primitive: "sphere",
        radius: RADIUS
      }).addComponent(RigidBody, {
        weight: 10,
        restitution: 0.5,
        friction: 0.5,
        linearDamping: 0,
        angularDamping: 0,
        linearVelocity: i.linearVelocity
      }).addComponent(LevelItem).addComponent(Ball, {
        position: i.position,
        radius: RADIUS,
        linearVelocity: i.linearVelocity
      }).addComponent(Active).addComponent(Parent, {
        value: this.world.entityManager.getEntityByName("playingGroup")
      }), e.removeComponent(Active);
    });
  }
}
BallGeneratorSystem.queries = {
  entities: {
    components: [BallGenerator, Active],
    listen: {
      added: !0
    }
  }
};
class DissolveSystem extends System {
  execute(e) {
    var t = this.queries.entities.results;
    for (let s = 0; s < t.length; s++) {
      var i = t[s], n = i.getMutableComponent(Dissolve), r = i.getObject3D();
      r.material && (r.material.opacity = n.value, r.material.transparent = !0, n.value -= e * n.speed, n.value <= 0 && i.remove());
    }
  }
}
DissolveSystem.queries = {
  entities: {
    components: [Ball, Dissolve, Object3DComponent],
    listen: {
      added: !0
    }
  }
};
class RotatingSystem extends System {
  execute(e) {
    this.queries.entities.results.forEach((t) => {
      var i = t.getComponent(Rotating), n = t.getObject3D();
      n.rotation.x += i.speed.x * e, n.rotation.y += i.speed.y * e, n.rotation.z += i.speed.z * e;
    });
  }
}
RotatingSystem.queries = {
  entities: {
    components: [Object3DComponent, Rotating]
  }
};
const urlParams$2 = new URLSearchParams(window.location.search);
var editMode$1 = urlParams$2.has("edit");
const elementTypes = [
  {
    model: "metal",
    restitution: 1.7,
    draggable: !0,
    scale: 1,
    sound: "metal.ogg",
    material: new MeshPhongMaterial({
      map: textures["metal.jpg"],
      envMap: environmentMap,
      specularMap: textures["metal_spec.jpg"],
      shininess: 70,
      specular: new Color(8947848),
      reflectivity: 0.7
    })
  },
  {
    model: "rubber",
    restitution: 2.5,
    draggable: !0,
    scale: 1,
    sound: "rubber.ogg",
    material: new MeshPhongMaterial({
      map: textures["rubber.png"],
      envMap: environmentMap,
      shininess: 10,
      specular: new Color(400159),
      reflectivity: 0.1
    })
  },
  {
    model: "wood",
    restitution: 1,
    draggable: !0,
    scale: 1,
    sound: "wood.ogg",
    material: new MeshPhongMaterial({
      map: textures["wood.png"],
      envMap: environmentMap,
      specularMap: textures["wood_spec.jpg"],
      shininess: 20,
      specular: new Color(6710886),
      reflectivity: 0.5
    })
  },
  {
    model: "static",
    restitution: 0.05,
    draggable: editMode$1,
    scale: 0.2,
    sound: "",
    material: new MeshLambertMaterial({
      map: textures["floor.png"]
    })
  }
];
class ElementSystem extends System {
  execute() {
    var e = this.queries.entities.added;
    for (let i = 0; i < e.length; i++) {
      let n = e[i];
      var t = n.getComponent(Element);
      const r = elementTypes[t.type];
      n.addComponent(GLTFLoader$1, {
        url: "assets/models/" + r.model + ".glb",
        onLoaded: (s) => {
          let a = s.children[0], l = a.geometry;
          r.scale && (l.scale(r.scale, r.scale, r.scale), l.computeBoundingBox());
          let c = l.boundingBox.min, u = l.boundingBox.max, h = Math.abs(u.x - c.x), d = Math.abs(u.y - c.y), f = Math.abs(u.z - c.z);
          a.material = r.material.clone(), n.addComponent(Shape, {
            primitive: "box",
            width: h,
            height: d,
            depth: f
          }), n.addComponent(Sound, {
            url: "assets/sounds/" + r.sound
          });
        }
      }).addComponent(RigidBody, {
        weight: 0,
        restitution: r.restitution,
        friction: 0.5,
        linearDamping: 0,
        angularDamping: 0
      }), r.draggable && n.addComponent(Draggable);
    }
    this.queries.colliding.results.forEach((i) => {
      let n = i.getComponent(Colliding), r = i.hasComponent(Ball), s = r ? i : n.collidingWith[0], a = r ? n.collidingWith[0] : i;
      a.hasComponent(Floor) ? s.hasComponent(Active) && (a.getComponent(Sound).sound.play(), s.removeComponent(Active), s.addComponent(FloorCollided)) : a.hasComponent(Sound) && a.getComponent(Sound).sound.play();
    });
  }
}
ElementSystem.queries = {
  entities: {
    components: [Element],
    listen: {
      added: !0
    }
  },
  colliding: {
    components: [CollisionStart]
  }
};
class OutputSystem extends System {
  trimDecimals(e) {
    e.x = Math.floor(e.x * 10) / 10, e.y = Math.floor(e.y * 10) / 10, e.z = Math.floor(e.z * 10) / 10;
  }
  outputJSON() {
    var e = {
      targets: [],
      generators: [],
      elements: []
    };
    this.queries.elements.results.forEach((t) => {
      var i = {}, n = t.getComponent(Element);
      i.type = n.type;
      var r = t.getObject3D();
      i.position = JSON.parse(JSON.stringify(r.position)), i.rotation = {
        x: r.rotation._x,
        y: r.rotation._y,
        z: r.rotation._z
      }, this.trimDecimals(i.position), this.trimDecimals(i.rotation), e.elements.push(i);
    }), this.queries.targets.results.forEach((t) => {
      var i = {}, n = t.getObject3D();
      i.position = JSON.parse(JSON.stringify(n.position)), i.rotation = {
        x: n.rotation._x,
        y: n.rotation._y,
        z: n.rotation._z
      }, this.trimDecimals(i.position), this.trimDecimals(i.rotation), e.targets.push(i);
    }), this.queries.generators.results.forEach((t) => {
      var i = {}, n = t.getComponent(BallGenerator), r = t.getObject3D();
      i.position = JSON.parse(JSON.stringify(r.position)), i.linearVelocity = n.linearVelocity, this.trimDecimals(i.position), this.trimDecimals(i.linearVelocity), e.generators.push(i);
    }), console.log(JSON.stringify(e, null, 2));
  }
  execute() {
  }
}
OutputSystem.queries = {
  elements: { components: [Element] },
  targets: { components: [Target] },
  generators: { components: [BallGenerator] }
};
const urlParams$1 = new URLSearchParams(window.location.search);
var editMode = urlParams$1.has("edit");
class LevelManager extends System {
  execute() {
    this.queries.levels.added.forEach((e) => {
      this.initializeLevel(e.getComponent(Level).value);
    }), this.queries.levels.changed.forEach((e) => {
      this.initializeLevel(e.getComponent(Level).value);
    });
  }
  clearCurrentLevel() {
    for (var e = this.queries.levelItems.results, t = e.length - 1; t >= 0; t--)
      e[t].remove();
  }
  initializeLevel(e) {
    e > levels.length && (e = 0);
    let t = this.world.entityManager.getEntityByName("level");
    t && (t.getMutableComponent(Text$1).text = e);
    let i = this.world.entityManager.getEntityByName("levelGroup");
    this.clearCurrentLevel();
    var n = levels[e];
    let r = this.world.entityManager.getEntityByName("singleton");
    n.generators.forEach((s) => {
      let a = new Vector3().copy(s.linearVelocity).normalize(), l = this.world.createEntity().addComponent(BallGenerator, {
        position: s.position,
        linearVelocity: s.linearVelocity
      }).addComponent(GLTFLoader$1, {
        url: "assets/models/cannon.glb",
        onLoaded: (c, u) => {
          c.lookAt(a), c.getObjectByName(
            "cannon"
          ).material = new MeshPhongMaterial({
            map: textures["cannon.jpg"],
            envMap: environmentMap,
            reflectivity: 0.2,
            specularMap: textures["cannon_spec.jpg"],
            shininess: 50,
            specular: new Color(3355443)
          });
          var h = new MeshBasicMaterial({ color: 15188515 });
          c.getObjectByName("explosion").material = h, c.getObjectByName("sparks").material = h;
          let d = c.userData.mixer = new AnimationMixer(
            c
          );
          const f = AnimationClip.findByName(
            u.animations,
            "cannonAction"
          ), p = d.clipAction(f, c);
          c.userData.animationClip = p;
        }
      }).addComponent(Animation, { duration: 2.35 }).addComponent(Sound, { url: "assets/sounds/cannon.ogg" }).addComponent(Position, {
        value: new Vector3().copy(s.position)
      }).addComponent(LevelItem).addComponent(Parent, { value: i });
      editMode && l.addComponent(Draggable), r.getComponent(GameState).playing && setTimeout(() => {
        l.addComponent(Play), setTimeout(() => {
          l.addComponent(Active);
        }, 1900);
      }, 2e3);
    }), n.targets.forEach((s) => {
      let a = this.world.createEntity().addComponent(Target).addComponent(GLTFLoader$1, {
        url: "assets/models/target.glb",
        onLoaded: (l) => {
          l.children[0].material = new MeshPhongMaterial({
            map: textures["target.png"],
            envMap: environmentMap,
            reflectivity: 0.2
          });
        }
      }).addComponent(Transform, {
        position: s.position,
        rotation: s.rotation
      }).addComponent(LevelItem).addComponent(Parent, { value: i }).addComponent(Sound, { url: "assets/sounds/target.ogg" });
      editMode && a.addComponent(Draggable);
    }), n.elements.forEach((s) => {
      this.world.createEntity().addComponent(Element, { type: s.type }).addComponent(Transform, {
        position: s.position,
        rotation: s.rotation
      }).addComponent(LevelItem).addComponent(Parent, { value: i });
    });
  }
}
LevelManager.queries = {
  /* @todo singleton */
  levels: {
    components: [Level],
    listen: {
      added: !0,
      changed: !0
    }
  },
  levelItems: {
    components: [LevelItem]
  }
};
class CameraRigSystem extends System {
  init() {
    window.addEventListener("resize", this.onWindowResize.bind(this), !1);
  }
  execute() {
    this.queries.entities.added.forEach((e) => {
      const t = this.world.getSystem(GameStateSystem).inAR;
      var i = new Group();
      e.addComponent(Object3DComponent, { value: i }).addComponent(Position, { value: new Vector3(0, t ? 1.6 : 0, 0.5) }), this.world.entityManager.queryComponents([
        Camera,
        Active
      ]).entities.forEach((r) => {
        r.removeComponent(Active);
      }), this.world.createEntity().addComponent(Position, {
        value: new Vector3(0, 1.6, -0.6)
      }).addObject3DComponent(
        new PerspectiveCamera(
          90,
          window.innerWidth / window.innerHeight,
          0.1,
          500
        ),
        e
      ).addComponent(UpdateAspectOnResizeTag).addComponent(Active), this.world.createEntity().addComponent(VRController, { id: 0 }).addComponent(Parent, { value: e }), this.world.createEntity().addComponent(VRController, { id: 1 }).addComponent(Parent, { value: e });
    });
  }
  onWindowResize() {
    this.queries.entities.results.forEach((e) => {
    });
  }
}
CameraRigSystem.queries = {
  entities: {
    components: [CameraRig],
    listen: {
      added: !0
    }
  }
};
var raycaster = new Raycaster$1(), tempMatrix = new Matrix4(), intersected = [];
function setEmisive(o, e, t) {
  o.traverse((i) => {
    i.material && i.material.emissive && (t ? i.material.emissive[t] = e : i.material.emissive.set(e));
  });
}
class VRControllerInteraction extends System {
  execute() {
    this.queries.dragging.results.forEach((e) => {
      this.reposition(e.getObject3D(), !0);
    }), this.queries.objects.added.forEach((e) => {
      let t = e.getObject3D().children[0];
      e.addComponent(RaycastReceiver, {
        layerMask: 2,
        onHover: (i, n) => {
          let s = n.getObject3D().getObjectByName("line");
          s.scale.z = i.distance;
        },
        onEnter: () => {
          setEmisive(t, 2245717);
        },
        onLeave: (i) => {
          let r = i.getObject3D().getObjectByName("line");
          r.scale.z = 10, setEmisive(t, 0);
        },
        onSelectStart: this.onSelectStart.bind(this)
      });
    }), this.world.getSystem(InputSystem).inputStateComponent.vrcontrollers.forEach((e, t) => {
      e.selectEnd && this.onSelectEnd(t);
    }), this.queries.controllers.added.forEach((e) => {
      e.addComponent(Raycaster, {
        value: raycaster,
        layerMask: 4
      });
      var t = new BufferGeometry().setFromPoints([
        new Vector3(0, 0, 0),
        new Vector3(0, 0, -1)
      ]), i = new Line(t);
      i.name = "line", i.scale.z = 5;
      let n = e.getObject3D().getObjectByName("controller");
      this.world.createEntity().addComponent(Object3DComponent, { value: i }).addComponent(ParentObject3D, { value: n });
    }), this.cleanIntersected();
  }
  onSelectStart(e, t) {
    var i = t;
    tempMatrix.getInverse(i.matrixWorld);
    var n = e.object.parent;
    n.matrix.premultiply(tempMatrix), n.matrix.decompose(n.position, n.quaternion, n.scale), setEmisive(n, 1, "b"), n.userData.previousParent = n.parent, i.add(n), n.children[0].material.transparent = !0, n.children[0].renderOrder = 20, n.children[0].material.opacity = 0.5, i.userData.selected = n, this.disablePhysics(n);
  }
  onSelectEnd(e) {
    if (e.userData.selected !== void 0) {
      var t = e.userData.selected;
      t.children[0].material.transparent = !1, t.userData.entity.removeComponent(Dragging), t.matrix.premultiply(e.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale), setEmisive(t, 0, "b"), t.userData.previousParent.add(t), e.userData.selected = void 0, this.reposition(t);
    }
  }
  disablePhysics(e) {
    const t = new Ammo.btTransform();
    t.setIdentity(), t.setOrigin(new Ammo.btVector3(0, -10, 0)), e.userData.body.setWorldTransform(t);
  }
  reposition(e, t) {
    if (e.userData.body)
      if (t) {
        var i = new Vector3(), n = new Vector3(), r = new Quaternion();
        e.updateWorldMatrix(!0), e.matrixWorld.decompose(i, r, n);
        var s = e.userData.body.getWorldTransform();
        s.setIdentity();
        const a = new Ammo.btTransform();
        a.setIdentity(), a.setOrigin(
          new Ammo.btVector3(i.x, i.y, i.z)
        ), a.setRotation(
          new Ammo.btQuaternion(
            r.x,
            r.y,
            r.z,
            r.w
          )
        ), e.userData.body.setWorldTransform(a);
      } else {
        const a = new Ammo.btTransform();
        a.setIdentity(), a.setOrigin(
          new Ammo.btVector3(
            e.position.x,
            e.position.y,
            e.position.z
          )
        ), a.setRotation(
          new Ammo.btQuaternion(
            e.quaternion.x,
            e.quaternion.y,
            e.quaternion.z,
            e.quaternion.w
          )
        ), e.userData.body.setWorldTransform(a);
      }
  }
  cleanIntersected() {
    for (; intersected.length; ) {
      var e = intersected.pop();
      e.material.emissive.r = 0;
    }
  }
}
VRControllerInteraction.queries = {
  controllers: {
    components: [VRController],
    listen: {
      added: !0
    }
  },
  objects: {
    components: [Draggable, Object3DComponent],
    listen: {
      added: !0
    }
  },
  dragging: { components: [Dragging] },
  rendererContext: {
    components: [WebGLRendererContext],
    mandatory: !0
  }
};
var quaternion = new Quaternion(), euler = new Euler();
class PhysicsSystem extends System {
  init() {
    this.epsilon = 1e-5, this.collisions = /* @__PURE__ */ new Map(), this.collisionKeys = [], this.frame = 0, this._physicsWorld = this._createWorld(), this._transform = new Ammo.btTransform(), this._quaternion = new Ammo.btQuaternion(0, 0, 0, 1), this.bodyToEntity = /* @__PURE__ */ new Map();
  }
  execute(e) {
    this.frame++, this.queries.entities.added.forEach((n) => {
      var r = n.getObject3D();
      const s = this._setupRigidBody(this._createRigidBody(n), n);
      s.setCcdMotionThreshold(0.01), s.setCcdSweptSphereRadius(0.01), s.Object3DComponent = r, r.userData.body = s, this._physicsWorld.addRigidBody(s);
    }), this._physicsWorld.stepSimulation(e, 4, 1 / 60), this.queries.collisionsStart.results.forEach((n) => {
      n.removeComponent(CollisionStart);
    });
    const t = this.dispatcher.getNumManifolds();
    for (let n = 0; n < t; n++) {
      const r = this.dispatcher.getManifoldByIndexInternal(n), s = r.getNumContacts(), a = Ammo.getPointer(r.getBody0()), l = Ammo.getPointer(r.getBody1());
      for (let c = 0; c < s; c++)
        if (r.getContactPoint(c).getDistance() <= this.epsilon) {
          let d = this.bodyToEntity.get(a), f = this.bodyToEntity.get(l);
          d.hasComponent(Colliding) || (d.addComponent(Colliding, { collidingFrame: this.frame }), d.addComponent(CollisionStart));
          let p = d.getMutableComponent(Colliding);
          p.collidingWith.indexOf(f) === -1 && p.collidingWith.push(f);
          break;
        }
    }
    const i = this.queries.entities.results;
    for (let n = 0, r = i.length; n < r; n++) {
      const s = i[n];
      if (s.getComponent(RigidBody).weight === 0) continue;
      const l = s.getObject3D(), c = l.userData.body;
      if (c.isActive() && c.getMotionState()) {
        const u = this._transform, h = this._quaternion;
        c.getMotionState().getWorldTransform(u);
        const d = u.getOrigin();
        u.getBasis().getRotation(h), l.position.set(d.x(), d.y(), d.z()), l.quaternion.set(h.x(), h.y(), h.z(), h.w());
        let f = s.getMutableComponent(Transform);
        f.position.copy(l.position), f.rotation.copy(l.rotation);
      }
    }
    this.queries.entities.removed.forEach((n) => {
      this._removeRigidBody(n);
    }), this.queries.collisionsStop.results.forEach((n) => {
      n.removeComponent(CollisionStop);
    }), this.queries.collisions.results.forEach((n) => {
      n.getComponent(Colliding).collidingFrame !== this.frame && (n.removeComponent(Colliding), n.addComponent(CollisionStop));
    });
  }
  _removeRigidBody(e) {
    var t = e.getRemovedComponent(Object3DComponent);
    if (t) {
      let n = t.value;
      var i = n.userData.body;
      this._physicsWorld.removeRigidBody(i), this.bodyToEntity.delete(Ammo.getPointer(i)), Ammo.destroy(i), delete n.userData.body;
    } else
      console.warn(">>>>>>>>>>>>>>> Not found");
  }
  _createWorld() {
    const e = new Ammo.btDefaultCollisionConfiguration();
    this.dispatcher = new Ammo.btCollisionDispatcher(e);
    const t = new Ammo.btDbvtBroadphase(), i = new Ammo.btSequentialImpulseConstraintSolver(), n = new Ammo.btDiscreteDynamicsWorld(
      this.dispatcher,
      t,
      i,
      e
    );
    return n.setGravity(new Ammo.btVector3(0, -9.8, 0)), n;
  }
  _createShape(e) {
    var t = e.getComponent(Shape);
    return t.primitive === "box" ? new Ammo.btBoxShape(
      new Ammo.btVector3(t.width / 2, t.height / 2, t.depth / 2)
    ) : t.primitive === "sphere" ? new Ammo.btSphereShape(t.radius) : new Ammo.btBoxShape(new Ammo.btVector3(1, 1, 1));
  }
  _createRigidBody(e) {
    const t = e.getComponent(RigidBody), i = e.getComponent(Transform), n = this._createShape(e), r = new Ammo.btVector3(0, 0, 0);
    n.calculateLocalInertia(t.weight, r);
    const s = new Ammo.btTransform();
    s.setIdentity(), s.setOrigin(
      new Ammo.btVector3(
        i.position.x,
        i.position.y,
        i.position.z
      )
    ), euler.set(i.rotation.x, i.rotation.y, i.rotation.z), quaternion.setFromEuler(euler), s.setRotation(
      new Ammo.btQuaternion(
        quaternion.x,
        quaternion.y,
        quaternion.z,
        quaternion.w
      )
    );
    const a = new Ammo.btDefaultMotionState(s), l = new Ammo.btRigidBodyConstructionInfo(
      t.weight,
      a,
      n,
      r
    );
    var c = new Ammo.btRigidBody(l);
    return this.bodyToEntity.set(Ammo.getPointer(c), e), c;
  }
  _setupRigidBody(e, t) {
    const i = t.getComponent(RigidBody), n = i.linearVelocity;
    return e.setRestitution(i.restitution), e.setFriction(i.friction), e.setDamping(i.linearDamping, i.angularDamping), e.setSleepingThresholds(0, 0), e.setLinearVelocity(
      new Ammo.btVector3(n.x, n.y, n.z)
    ), e;
  }
}
PhysicsSystem.queries = {
  entities: {
    components: [RigidBody, Shape, Object3DComponent],
    listen: {
      added: !0,
      removed: !0
    }
  },
  collisions: {
    components: [Colliding],
    listen: {
      added: !0
    }
  },
  collisionsStart: {
    components: [CollisionStart],
    listen: {
      added: !0
    }
  },
  collisionsStop: {
    components: [CollisionStop],
    listen: {
      added: !0
    }
  }
};
var version = "18.4.2", _Group = function() {
  this._tweens = {}, this._tweensAddedDuringUpdate = {};
};
_Group.prototype = {
  getAll: function() {
    return Object.keys(this._tweens).map((function(o) {
      return this._tweens[o];
    }).bind(this));
  },
  removeAll: function() {
    this._tweens = {};
  },
  add: function(o) {
    this._tweens[o.getId()] = o, this._tweensAddedDuringUpdate[o.getId()] = o;
  },
  remove: function(o) {
    delete this._tweens[o.getId()], delete this._tweensAddedDuringUpdate[o.getId()];
  },
  update: function(o, e) {
    var t = Object.keys(this._tweens);
    if (t.length === 0)
      return !1;
    for (o = o !== void 0 ? o : TWEEN.now(); t.length > 0; ) {
      this._tweensAddedDuringUpdate = {};
      for (var i = 0; i < t.length; i++) {
        var n = this._tweens[t[i]];
        n && n.update(o) === !1 && (n._isPlaying = !1, e || delete this._tweens[t[i]]);
      }
      t = Object.keys(this._tweensAddedDuringUpdate);
    }
    return !0;
  }
};
var TWEEN = new _Group();
TWEEN.Group = _Group;
TWEEN._nextId = 0;
TWEEN.nextId = function() {
  return TWEEN._nextId++;
};
typeof self > "u" && typeof process < "u" && process.hrtime ? TWEEN.now = function() {
  var o = process.hrtime();
  return o[0] * 1e3 + o[1] / 1e6;
} : typeof self < "u" && self.performance !== void 0 && self.performance.now !== void 0 ? TWEEN.now = self.performance.now.bind(self.performance) : Date.now !== void 0 ? TWEEN.now = Date.now : TWEEN.now = function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
TWEEN.Tween = function(o, e) {
  this._isPaused = !1, this._pauseStart = null, this._object = o, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._repeat = 0, this._repeatDelayTime = void 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = null, this._easingFunction = TWEEN.Easing.Linear.None, this._interpolationFunction = TWEEN.Interpolation.Linear, this._chainedTweens = [], this._onStartCallback = null, this._onStartCallbackFired = !1, this._onUpdateCallback = null, this._onRepeatCallback = null, this._onCompleteCallback = null, this._onStopCallback = null, this._group = e || TWEEN, this._id = TWEEN.nextId();
};
TWEEN.Tween.prototype = {
  getId: function() {
    return this._id;
  },
  isPlaying: function() {
    return this._isPlaying;
  },
  isPaused: function() {
    return this._isPaused;
  },
  to: function(o, e) {
    return this._valuesEnd = Object.create(o), e !== void 0 && (this._duration = e), this;
  },
  duration: function o(e) {
    return this._duration = e, this;
  },
  start: function(o) {
    this._group.add(this), this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._startTime = o !== void 0 ? typeof o == "string" ? TWEEN.now() + parseFloat(o) : o : TWEEN.now(), this._startTime += this._delayTime;
    for (var e in this._valuesEnd) {
      if (this._valuesEnd[e] instanceof Array) {
        if (this._valuesEnd[e].length === 0)
          continue;
        this._valuesEnd[e] = [this._object[e]].concat(this._valuesEnd[e]);
      }
      this._object[e] !== void 0 && (typeof this._valuesStart[e] > "u" && (this._valuesStart[e] = this._object[e]), this._valuesStart[e] instanceof Array || (this._valuesStart[e] *= 1), this._valuesStartRepeat[e] = this._valuesStart[e] || 0);
    }
    return this;
  },
  stop: function() {
    return this._isPlaying ? (this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback !== null && this._onStopCallback(this._object), this.stopChainedTweens(), this) : this;
  },
  end: function() {
    return this.update(1 / 0), this;
  },
  pause: function(o) {
    return this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = o === void 0 ? TWEEN.now() : o, this._group.remove(this), this);
  },
  resume: function(o) {
    return !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += (o === void 0 ? TWEEN.now() : o) - this._pauseStart, this._pauseStart = 0, this._group.add(this), this);
  },
  stopChainedTweens: function() {
    for (var o = 0, e = this._chainedTweens.length; o < e; o++)
      this._chainedTweens[o].stop();
  },
  group: function(o) {
    return this._group = o, this;
  },
  delay: function(o) {
    return this._delayTime = o, this;
  },
  repeat: function(o) {
    return this._repeat = o, this;
  },
  repeatDelay: function(o) {
    return this._repeatDelayTime = o, this;
  },
  yoyo: function(o) {
    return this._yoyo = o, this;
  },
  easing: function(o) {
    return this._easingFunction = o, this;
  },
  interpolation: function(o) {
    return this._interpolationFunction = o, this;
  },
  chain: function() {
    return this._chainedTweens = arguments, this;
  },
  onStart: function(o) {
    return this._onStartCallback = o, this;
  },
  onUpdate: function(o) {
    return this._onUpdateCallback = o, this;
  },
  onRepeat: function o(e) {
    return this._onRepeatCallback = e, this;
  },
  onComplete: function(o) {
    return this._onCompleteCallback = o, this;
  },
  onStop: function(o) {
    return this._onStopCallback = o, this;
  },
  update: function(o) {
    var e, t, i;
    if (o < this._startTime)
      return !0;
    this._onStartCallbackFired === !1 && (this._onStartCallback !== null && this._onStartCallback(this._object), this._onStartCallbackFired = !0), t = (o - this._startTime) / this._duration, t = this._duration === 0 || t > 1 ? 1 : t, i = this._easingFunction(t);
    for (e in this._valuesEnd)
      if (this._valuesStart[e] !== void 0) {
        var n = this._valuesStart[e] || 0, r = this._valuesEnd[e];
        r instanceof Array ? this._object[e] = this._interpolationFunction(r, i) : (typeof r == "string" && (r.charAt(0) === "+" || r.charAt(0) === "-" ? r = n + parseFloat(r) : r = parseFloat(r)), typeof r == "number" && (this._object[e] = n + (r - n) * i));
      }
    if (this._onUpdateCallback !== null && this._onUpdateCallback(this._object, t), t === 1)
      if (this._repeat > 0) {
        isFinite(this._repeat) && this._repeat--;
        for (e in this._valuesStartRepeat) {
          if (typeof this._valuesEnd[e] == "string" && (this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(this._valuesEnd[e])), this._yoyo) {
            var s = this._valuesStartRepeat[e];
            this._valuesStartRepeat[e] = this._valuesEnd[e], this._valuesEnd[e] = s;
          }
          this._valuesStart[e] = this._valuesStartRepeat[e];
        }
        return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = o + this._repeatDelayTime : this._startTime = o + this._delayTime, this._onRepeatCallback !== null && this._onRepeatCallback(this._object), !0;
      } else {
        this._onCompleteCallback !== null && this._onCompleteCallback(this._object);
        for (var a = 0, l = this._chainedTweens.length; a < l; a++)
          this._chainedTweens[a].start(this._startTime + this._duration);
        return !1;
      }
    return !0;
  }
};
TWEEN.Easing = {
  Linear: {
    None: function(o) {
      return o;
    }
  },
  Quadratic: {
    In: function(o) {
      return o * o;
    },
    Out: function(o) {
      return o * (2 - o);
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o : -0.5 * (--o * (o - 2) - 1);
    }
  },
  Cubic: {
    In: function(o) {
      return o * o * o;
    },
    Out: function(o) {
      return --o * o * o + 1;
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o * o : 0.5 * ((o -= 2) * o * o + 2);
    }
  },
  Quartic: {
    In: function(o) {
      return o * o * o * o;
    },
    Out: function(o) {
      return 1 - --o * o * o * o;
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o * o * o : -0.5 * ((o -= 2) * o * o * o - 2);
    }
  },
  Quintic: {
    In: function(o) {
      return o * o * o * o * o;
    },
    Out: function(o) {
      return --o * o * o * o * o + 1;
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? 0.5 * o * o * o * o * o : 0.5 * ((o -= 2) * o * o * o * o + 2);
    }
  },
  Sinusoidal: {
    In: function(o) {
      return 1 - Math.cos(o * Math.PI / 2);
    },
    Out: function(o) {
      return Math.sin(o * Math.PI / 2);
    },
    InOut: function(o) {
      return 0.5 * (1 - Math.cos(Math.PI * o));
    }
  },
  Exponential: {
    In: function(o) {
      return o === 0 ? 0 : Math.pow(1024, o - 1);
    },
    Out: function(o) {
      return o === 1 ? 1 : 1 - Math.pow(2, -10 * o);
    },
    InOut: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : (o *= 2) < 1 ? 0.5 * Math.pow(1024, o - 1) : 0.5 * (-Math.pow(2, -10 * (o - 1)) + 2);
    }
  },
  Circular: {
    In: function(o) {
      return 1 - Math.sqrt(1 - o * o);
    },
    Out: function(o) {
      return Math.sqrt(1 - --o * o);
    },
    InOut: function(o) {
      return (o *= 2) < 1 ? -0.5 * (Math.sqrt(1 - o * o) - 1) : 0.5 * (Math.sqrt(1 - (o -= 2) * o) + 1);
    }
  },
  Elastic: {
    In: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : -Math.pow(2, 10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI);
    },
    Out: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : Math.pow(2, -10 * o) * Math.sin((o - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(o) {
      return o === 0 ? 0 : o === 1 ? 1 : (o *= 2, o < 1 ? -0.5 * Math.pow(2, 10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI) + 1);
    }
  },
  Back: {
    In: function(o) {
      var e = 1.70158;
      return o * o * ((e + 1) * o - e);
    },
    Out: function(o) {
      var e = 1.70158;
      return --o * o * ((e + 1) * o + e) + 1;
    },
    InOut: function(o) {
      var e = 2.5949095;
      return (o *= 2) < 1 ? 0.5 * (o * o * ((e + 1) * o - e)) : 0.5 * ((o -= 2) * o * ((e + 1) * o + e) + 2);
    }
  },
  Bounce: {
    In: function(o) {
      return 1 - TWEEN.Easing.Bounce.Out(1 - o);
    },
    Out: function(o) {
      return o < 1 / 2.75 ? 7.5625 * o * o : o < 2 / 2.75 ? 7.5625 * (o -= 1.5 / 2.75) * o + 0.75 : o < 2.5 / 2.75 ? 7.5625 * (o -= 2.25 / 2.75) * o + 0.9375 : 7.5625 * (o -= 2.625 / 2.75) * o + 0.984375;
    },
    InOut: function(o) {
      return o < 0.5 ? TWEEN.Easing.Bounce.In(o * 2) * 0.5 : TWEEN.Easing.Bounce.Out(o * 2 - 1) * 0.5 + 0.5;
    }
  }
};
TWEEN.Interpolation = {
  Linear: function(o, e) {
    var t = o.length - 1, i = t * e, n = Math.floor(i), r = TWEEN.Interpolation.Utils.Linear;
    return e < 0 ? r(o[0], o[1], i) : e > 1 ? r(o[t], o[t - 1], t - i) : r(o[n], o[n + 1 > t ? t : n + 1], i - n);
  },
  Bezier: function(o, e) {
    for (var t = 0, i = o.length - 1, n = Math.pow, r = TWEEN.Interpolation.Utils.Bernstein, s = 0; s <= i; s++)
      t += n(1 - e, i - s) * n(e, s) * o[s] * r(i, s);
    return t;
  },
  CatmullRom: function(o, e) {
    var t = o.length - 1, i = t * e, n = Math.floor(i), r = TWEEN.Interpolation.Utils.CatmullRom;
    return o[0] === o[t] ? (e < 0 && (n = Math.floor(i = t * (1 + e))), r(o[(n - 1 + t) % t], o[n], o[(n + 1) % t], o[(n + 2) % t], i - n)) : e < 0 ? o[0] - (r(o[0], o[0], o[1], o[1], -i) - o[0]) : e > 1 ? o[t] - (r(o[t], o[t], o[t - 1], o[t - 1], i - t) - o[t]) : r(o[n ? n - 1 : 0], o[n], o[t < n + 1 ? t : n + 1], o[t < n + 2 ? t : n + 2], i - n);
  },
  Utils: {
    Linear: function(o, e, t) {
      return (e - o) * t + o;
    },
    Bernstein: function(o, e) {
      var t = TWEEN.Interpolation.Utils.Factorial;
      return t(o) / t(e) / t(o - e);
    },
    Factorial: /* @__PURE__ */ function() {
      var o = [1];
      return function(e) {
        var t = 1;
        if (o[e])
          return o[e];
        for (var i = e; i > 1; i--)
          t *= i;
        return o[e] = t, t;
      };
    }(),
    CatmullRom: function(o, e, t, i, n) {
      var r = (t - o) * 0.5, s = (i - e) * 0.5, a = n * n, l = n * a;
      return (2 * e - 2 * t + r + s) * l + (-3 * e + 3 * t - 2 * r - s) * a + r * n + e;
    }
  }
};
TWEEN.version = version;
function setColor(o, e) {
  o.traverse((t) => {
    t.material && t.material.color.setRGB(e, e, e);
  });
}
class UISystem extends System {
  execute(e, t) {
    TWEEN.update();
    const i = this.queries.entities;
    for (let n = 0; n < i.results.length; n++)
      i.results[n].getComponent(UI);
    for (let n = 0; n < i.added.length; n++) {
      const r = i.added[n];
      r.getComponent(UI);
      const s = r.getComponent(Button);
      let a = this.world.createEntity(), l = new Group();
      r.addComponent(Object3DComponent, { value: l }), r.addComponent(RaycastReceiver, {
        layerMask: 4,
        onHover: () => {
        },
        onEnter: () => {
          let c = r.getObject3D();
          setColor(c, 1), new TWEEN.Tween(c.scale).to(
            {
              x: 1.1,
              y: 1.1,
              z: 1.1
            },
            500
          ).onUpdate(() => {
          }).easing(TWEEN.Easing.Quadratic.Out).start();
        },
        onLeave: () => {
          let c = r.getObject3D();
          setColor(c, 0.7), new TWEEN.Tween(c.scale).to(
            {
              x: 1,
              y: 1,
              z: 1
            },
            300
          ).onUpdate(() => {
          }).easing(TWEEN.Easing.Quadratic.Out).start();
        },
        onSelectStart: () => {
          let c = r.getObject3D();
          setColor(c, 1), setTimeout(() => {
            setColor(c, 0.7);
          }, 300), new TWEEN.Tween(c.scale).to(
            {
              x: 1.2,
              y: 1.2,
              z: 1.2
            },
            100
          ).repeat(1).yoyo(!0).easing(TWEEN.Easing.Quadratic.Out).start().onComplete(() => {
            s.onClick && s.onClick();
          }), r.hasComponent(Sound) && r.getComponent(Sound).sound.play();
        }
      }), a.addComponent(Text$1, {
        color: "#999",
        font: "assets/fonts/WetinCaroWant.ttf",
        fontSize: 0.09,
        anchor: "center",
        textAlign: "center",
        baseline: "center",
        maxWidth: 10,
        lineHeight: 0,
        text: s.text
      }).addComponent(Position, { value: new Vector3(0, 0, 0.01) }).addComponent(Parent, { value: r });
    }
  }
}
UISystem.queries = {
  entities: {
    components: [UI, Button],
    listen: {
      added: !0,
      removed: !0,
      changed: !0
      // [UI]
    }
  }
};
class RaycasterSystem extends System {
  init() {
    this.world.registerComponent(Raycaster);
  }
  execute() {
    let e = this.queries.inputState.results[0].getComponent(
      InputState
    );
    this.queries.raycasters.added.forEach((t) => {
      new Raycaster$1();
    }), this.queries.raycasters.results.forEach((t) => {
      let i = t.getComponent(Raycaster);
      if (!i.enabled)
        return;
      var n = this.queries.receivers.results.filter((d) => {
        var f = d.getComponent(RaycastReceiver).layerMask;
        return (f & i.layerMask) !== 0;
      }).map((d) => {
        var f = d.getObject3D();
        return f.traverse((p) => {
          p.userData.entity = d;
        }), f;
      });
      if (n.length === 0)
        return;
      let r = i.value;
      var s = new Matrix4(), a = t.getObject3D().getObjectByName("controller");
      s.identity().extractRotation(a.matrixWorld), r.ray.origin.setFromMatrixPosition(a.matrixWorld), r.ray.direction.set(0, 0, -1).applyMatrix4(s);
      let l = r.intersectObjects(n, !0), c = t.getObject3D(), u = c ? c.children[0] : null, h = e.vrcontrollers.get(
        u
      );
      if (l.length > 0) {
        let d = l[0].object.parent ? l[0] : l[1], f = d.object, p = f.userData.entity;
        for (; !p && f.parent; )
          f = f.parent, p = f.userData.entity;
        if (p) {
          const m = p.getComponent(RaycastReceiver);
          m && !m.hovering && (m.hovering = !0, m.onEnter(d, t)), m.onHover && m.onHover(d, t), h && h.selectStart && m.onSelectStart && m.onSelectStart(d, u), i.currentEntity = p;
        }
      } else if (i.currentEntity) {
        const d = i.currentEntity.getComponent(
          RaycastReceiver
        );
        d && d.hovering && (d.hovering = !1, d.onLeave && d.onLeave(t)), i.currentEntity = null;
      }
    });
  }
}
RaycasterSystem.queries = {
  raycasters: {
    components: [Raycaster],
    listen: {
      added: !0,
      removed: !0,
      changed: !0
      // [RaycasterReceiver]
    }
  },
  receivers: {
    components: [RaycastReceiver],
    listen: {
      added: !0,
      removed: !0,
      changed: !0
      // [RaycasterReceiver]
    }
  },
  inputState: {
    components: [InputState]
  }
};
const Systems = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BallGeneratorSystem,
  CameraRigSystem,
  DissolveSystem,
  ElementSystem,
  GameStateSystem,
  LevelManager,
  OutputSystem,
  PhysicsSystem,
  RaycasterSystem,
  RotatingSystem,
  TargetSystem,
  UISystem,
  VRControllerInteraction
}, Symbol.toStringTag, { value: "Module" }));
window.Components = Components;
window.Systems = Systems;
window.THREE = THREE$1;
var world;
const urlParams = new URLSearchParams(window.location.search);
function detectWebXR() {
  "xr" in navigator ? navigator.xr.isSessionSupported("immersive-vr").then((o) => {
    o || document.getElementById("no-webxr").classList.remove("hidden");
  }) : document.getElementById("no-webxr").classList.remove("hidden");
}
function initGame() {
  detectWebXR(), world = new ECSYThreeWorld(), world.registerComponent(BallGenerator).registerComponent(GameState).registerComponent(Geometry).registerComponent(FloorCollided).registerComponent(Dissolve).registerComponent(Sound).registerComponent(Level).registerComponent(LevelItem).registerComponent(Colliding).registerComponent(CollisionStart).registerComponent(CollisionStop).registerComponent(Ball).registerComponent(Stop).registerComponent(Play).registerComponent(Text$1).registerComponent(RaycastReceiver).registerComponent(Target).registerComponent(Element).registerComponent(ParentObject3D).registerComponent(RigidBody).registerComponent(Animation).registerComponent(Floor).registerComponent(Position).registerComponent(Shape).registerComponent(Draggable).registerComponent(GLTFLoader$1).registerComponent(Transform).registerComponent(Visible).registerComponent(UI).registerComponent(Button).registerComponent(Ad), world.registerSystem(InputSystem).registerSystem(GameStateSystem).registerSystem(LevelManager).registerSystem(AnimationSystem).registerSystem(RaycasterSystem).registerSystem(UISystem).registerSystem(DissolveSystem).registerSystem(BallGeneratorSystem).registerSystem(VRControllerSystem).registerSystem(VRControllerInteraction).registerSystem(CameraRigSystem).registerSystem(ElementSystem).registerSystem(PhysicsSystem).registerSystem(SoundSystem).registerSystem(VisibilitySystem).registerSystem(TargetSystem).registerSystem(SDFTextSystem).registerSystem(RotatingSystem).registerSystem(OutputSystem).registerSystem(GLTFLoaderSystem).registerSystem(GeometrySystem);
  let o = initialize(world, { vr: !0 });
  var e = o.entities.scene.getObject3D();
  window.entityScene = o.entities.scene;
  let t = urlParams.has("level") ? parseInt(urlParams.get("level")) : 0;
  world.createEntity("singleton").addComponent(Scene, { value: o.entities.scene }).addComponent(GameState, {
    levelStartTime: performance.now(),
    gameStartTime: performance.now()
  }).addComponent(Level, { value: t }), world.getSystem(PhysicsSystem).stop(), i(o);
  function i(a) {
    e.fog = new FogExp2(new Color(5948892), 0.05), e.add(new HemisphereLight(13421772, 7368816));
    var l = new DirectionalLight(11184810);
    l.position.set(0.2, 1.7, -0.7), l.castShadow = !0, l.shadow.camera.top = 1, l.shadow.camera.bottom = -1, l.shadow.camera.right = 10, l.shadow.camera.left = -10, l.shadow.mapSize.set(4096, 4096), e.add(l), window.world = world, n(a);
    var c = new AudioListener(), u = new Audio$1(c), h = new Audio("assets/sounds/JosSs - Wehehey (Looped).ogg");
    h.loop = !0, u.setVolume(0.6), u.setMediaElementSource(h), world.execute(0.016, 0);
    const d = a.entities.renderer.getComponent(WebGLRendererContext).value;
    world.createEntity("zestyBanner").addComponent(OnObject3DAdded, {
      callback: (m) => {
      }
    }).addComponent(Position, { value: new Vector3(-1.5, 1.6, -2) }).addComponent(Parent, { value: a.entities.scene }).addComponent(Ad).addComponent(UI).addComponent(Visible, { value: !0 }).addComponent(GLTFLoader$1, {
      url: "assets/models/panelinfo.glb",
      onLoaded: (m) => {
        m.children[0].material = UIMaterial.clone(), m.children[0].renderOrder = 1, m.rotateZ(-Math.PI / 2), m.translateZ(-0.01), m.scale.set(1, 1.2, 1.2);
      }
    }), world.createEntity("newsPanel").addComponent(Position, { value: new Vector3(1.5, 1.6, -2) }).addComponent(Parent, { value: a.entities.scene }).addComponent(Visible, { value: !0 }).addComponent(GLTFLoader$1, {
      url: "assets/models/panelinfo.glb",
      onLoaded: (m) => {
        m.children[0].material = UIMaterial.clone(), m.children[0].renderOrder = 1, m.rotateZ(-Math.PI / 2), m.translateZ(-0.01), m.scale.set(1, 1.2, 1.2);
      }
    }), world.createEntity("adText").addComponent(Position, { value: new Vector3(-1.5, 2.75, -2) }).addComponent(Parent, { value: a.entities.scene }).addComponent(UI).addComponent(Visible, { value: !0 }).addComponent(Text$1, {
      color: "#FFF",
      font: "assets/fonts/WetinCaroWant.ttf",
      fontSize: 0.15,
      anchor: "center",
      textAlign: "center",
      baseline: "center",
      maxWidth: 10,
      lineHeight: 0,
      text: "Ad"
    }), world.createEntity("newsText").addComponent(Position, { value: new Vector3(1.5, 2.75, -2) }).addComponent(Parent, { value: a.entities.scene }).addComponent(UI).addComponent(Visible, { value: !0 }).addComponent(Text$1, {
      color: "#FFF",
      font: "assets/fonts/WetinCaroWant.ttf",
      fontSize: 0.15,
      anchor: "center",
      textAlign: "center",
      baseline: "center",
      maxWidth: 10,
      lineHeight: 0,
      text: "News"
    }), world.createEntity("futureUpdateText").addComponent(Position, { value: new Vector3(1.5, 1.75, -2) }).addComponent(Parent, { value: a.entities.scene }).addComponent(UI).addComponent(Visible, { value: !0 }).addComponent(Text$1, {
      color: "#FFF",
      font: "assets/fonts/WetinCaroWant.ttf",
      fontSize: 0.08,
      anchor: "center",
      textAlign: "center",
      baseline: "center",
      maxWidth: 1,
      lineHeight: 1,
      text: "7/18/2024 - Passthrough mode added!"
    });
    let f = world.createEntity("startbutton").addComponent(UI).addComponent(GLTFLoader$1, {
      url: "assets/models/startbutton.glb",
      append: !0,
      onLoaded: (m) => {
        m.children[0].material = UIMaterial, m.children[0].material.color.setRGB(0.7, 0.7, 0.7);
      }
    }).addComponent(Button, {
      text: "START",
      onClick: () => {
        h.play(), world.getSystem(GameStateSystem).playGame(), setTimeout(() => {
          f.addComponent(Visible, { value: !1 });
        }, 300);
      }
    }).addComponent(Parent, { value: a.entities.scene }).addComponent(Position, { value: new Vector3(0, 0.6, -1.5) }).addComponent(Sound, { url: "assets/sounds/click.ogg" }).addComponent(Visible, { value: !urlParams.has("autostart") });
    urlParams.has("autostart") && world.getSystem(GameStateSystem).playGame(), a.entities.renderer.getComponent(
      WebGLRendererContext
    ).value.outputEncoding = sRGBEncoding;
    const p = ARButton.createButton(d, { optionalFeatures: ["hand-tracking"] });
    p.addEventListener("click", () => {
      p.innerText == "Exit AR" ? world.getSystem(GameStateSystem).setEnvEnabled(!0) : world.getSystem(GameStateSystem).setEnvEnabled(!1);
    }), document.body.appendChild(p);
  }
  function n(a) {
    r(a);
    let l = world.createEntity("playingGroup").addComponent(Object3DComponent, { value: new Group() }).addComponent(Parent, { value: a.entities.scene }).addComponent(Visible, { value: urlParams.has("autostart") });
    world.createEntity("levelGroup").addComponent(Object3DComponent, { value: new Group() }).addComponent(Parent, { value: l }).addComponent(Visible, { value: !0 }), world.createEntity("environment").addComponent(GLTFLoader$1, {
      url: "assets/models/set.glb",
      onLoaded: (c) => {
        const u = c.getObjectByName("clouds").material;
        u.transparent = !0, u.fog = !1;
        const h = c.getObjectByName("sky").material;
        h.fog = !1;
      }
    }).addComponent(Parent, { value: a.entities.scene }).addComponent(Visible, { value: !0 }), world.createEntity("help").addComponent(GLTFLoader$1, {
      url: "assets/models/help.glb",
      onLoaded: (c) => {
        c.children[0].material.transparent = !0, c.children[0].material.map.magFilter = LinearFilter, c.children[0].material.map.minFilter = LinearMipmapLinearFilter;
      }
    }).addComponent(Position, { value: new Vector3(0, 1.6, -2) }).addComponent(Parent, { value: a.entities.scene }).addComponent(Visible, { value: !0 }), world.createEntity("panelLevel").addComponent(GLTFLoader$1, {
      url: "assets/models/panellevel.glb",
      onLoaded: (c) => {
        c.children[0].material = UIMaterial, c.children[0].renderOrder = 1, world.createEntity("levelLabel").addComponent(
          Text$1,
          s("Level", "#20b4d6", 0.12, "center")
        ).addComponent(ParentObject3D, { value: c.children[0] }).addComponent(Position, { value: new Vector3(0, 0.2, 0.01) }), world.createEntity("level").addComponent(
          Text$1,
          s("1", "#90cdeb", 0.3, "center")
        ).addComponent(OnObject3DAdded, {
          callback: (u) => {
            c.children[0].add(u);
          }
        }).addComponent(ParentObject3D, { value: c.children[0] }).addComponent(Position, { value: new Vector3(0, 0, 0.01) });
      }
    }).addComponent(Parent, { value: l }).addComponent(Position, { value: new Vector3(0, 3.2, -6) }), world.createEntity("panelInfo").addComponent(GLTFLoader$1, {
      url: "assets/models/panelinfo.glb",
      onLoaded: (c) => {
        c.children[0].material = UIMaterial, c.children[0].children[0].material = UIMaterial, c.children[0].children[0].renderOrder = 1, c.children[0].renderOrder = 2;
        let u = c.children[0].children[0];
        world.createEntity("finished").addComponent(
          Text$1,
          s("Finished!", "#ffffff", 0.2, "center")
        ).addComponent(ParentObject3D, { value: u }).addComponent(Position, { value: new Vector3(0, 0.1, -0.1) }).addComponent(Visible, { value: !0 }), world.createEntity("numberBallsLabel").addComponent(
          Text$1,
          s("Balls", "#c0095d", 0.2, "center")
        ).addComponent(ParentObject3D, { value: c.children[0] }).addComponent(Position, { value: new Vector3(-0.4, 0.26, 0.01) }), world.createEntity("numberBalls").addComponent(
          Text$1,
          s("0", "#f9258b", 0.2, "center")
        ).addComponent(ParentObject3D, { value: c.children[0] }).addComponent(Position, { value: new Vector3(-0.4, 0, 0.01) }), world.createEntity("timeLabel").addComponent(
          Text$1,
          s("Time", "#836000", 0.2, "center")
        ).addComponent(ParentObject3D, { value: c.children[0] }).addComponent(Position, { value: new Vector3(0.4, 0.28, 0.01) }), world.createEntity("totalTimeLabel").addComponent(
          Text$1,
          s("Total", "#836000", 0.095, "center")
        ).addComponent(ParentObject3D, { value: c.children[0] }).addComponent(Position, { value: new Vector3(0.16, -0.21, 0.01) }), world.createEntity("timer").addComponent(
          Text$1,
          s("00:00", "#ebb808", 0.22, "center")
        ).addComponent(ParentObject3D, { value: c.children[0] }).addComponent(Position, { value: new Vector3(0.4, 0.04, 0.01) }), world.createEntity("timerTotal").addComponent(
          Text$1,
          s("00:00", "#ebb808", 0.12, "left")
        ).addComponent(ParentObject3D, { value: c.children[0] }).addComponent(Position, { value: new Vector3(0.36, -0.13, 0.01) });
      }
    }).addComponent(Parent, {
      value: a.entities.scene
      /*playingGroup*/
    }).addComponent(Animation, { duration: 2.35 }).addComponent(Position, { value: new Vector3(0, 2, -6) }).addComponent(Visible, { value: !1 });
  }
  function r(a) {
    world.createEntity().addComponent(Geometry, {
      primitive: "box",
      width: 100,
      height: 0.1,
      depth: 100
    }).addComponent(Shape, {
      primitive: "box",
      width: 100,
      height: 0.1,
      depth: 100
    }).addComponent(Visible, { value: !1 }).addComponent(Transform, {
      position: { x: 0, y: -0.05, z: 0 },
      rotation: { x: 0, y: 0, z: 0 }
    }).addComponent(Floor).addComponent(Sound, { url: "assets/sounds/miss.ogg" }).addComponent(RigidBody, {
      weight: 0,
      restitution: 0.5,
      friction: 3,
      linearDamping: 0,
      angularDamping: 0
    }).addComponent(Parent, { value: a.entities.scene });
  }
  function s(a, l, c, u) {
    return {
      color: l || "0xFFFFFF",
      fontSize: c || 0.5,
      anchor: u || "center",
      textAlign: u || "center",
      baseline: u || "center",
      font: "assets/fonts/WetinCaroWant.ttf",
      maxWidth: 10,
      lineHeight: 1.3,
      text: a || "LOREM IPSUM"
    };
  }
}
Ammo().then(initGame);
