/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "130", MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, CullFaceNone = 0, CullFaceBack = 1, CullFaceFront = 2, CullFaceFrontBack = 3, BasicShadowMap = 0, PCFShadowMap = 1, PCFSoftShadowMap = 2, VSMShadowMap = 3, FrontSide = 0, BackSide = 1, DoubleSide = 2, FlatShading = 1, SmoothShading = 2, NoBlending = 0, NormalBlending = 1, AdditiveBlending = 2, SubtractiveBlending = 3, MultiplyBlending = 4, CustomBlending = 5, AddEquation = 100, SubtractEquation = 101, ReverseSubtractEquation = 102, MinEquation = 103, MaxEquation = 104, ZeroFactor = 200, OneFactor = 201, SrcColorFactor = 202, OneMinusSrcColorFactor = 203, SrcAlphaFactor = 204, OneMinusSrcAlphaFactor = 205, DstAlphaFactor = 206, OneMinusDstAlphaFactor = 207, DstColorFactor = 208, OneMinusDstColorFactor = 209, SrcAlphaSaturateFactor = 210, NeverDepth = 0, AlwaysDepth = 1, LessDepth = 2, LessEqualDepth = 3, EqualDepth = 4, GreaterEqualDepth = 5, GreaterDepth = 6, NotEqualDepth = 7, MultiplyOperation = 0, MixOperation = 1, AddOperation = 2, NoToneMapping = 0, LinearToneMapping = 1, ReinhardToneMapping = 2, CineonToneMapping = 3, ACESFilmicToneMapping = 4, CustomToneMapping = 5, UVMapping = 300, CubeReflectionMapping = 301, CubeRefractionMapping = 302, EquirectangularReflectionMapping = 303, EquirectangularRefractionMapping = 304, CubeUVReflectionMapping = 306, CubeUVRefractionMapping = 307, RepeatWrapping = 1e3, ClampToEdgeWrapping = 1001, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipmapNearestFilter = 1004, NearestMipMapNearestFilter = 1004, NearestMipmapLinearFilter = 1005, NearestMipMapLinearFilter = 1005, LinearFilter = 1006, LinearMipmapNearestFilter = 1007, LinearMipMapNearestFilter = 1007, LinearMipmapLinearFilter = 1008, LinearMipMapLinearFilter = 1008, UnsignedByteType = 1009, ByteType = 1010, ShortType = 1011, UnsignedShortType = 1012, IntType = 1013, UnsignedIntType = 1014, FloatType = 1015, HalfFloatType = 1016, UnsignedShort4444Type = 1017, UnsignedShort5551Type = 1018, UnsignedShort565Type = 1019, UnsignedInt248Type = 1020, AlphaFormat = 1021, RGBFormat = 1022, RGBAFormat = 1023, LuminanceFormat = 1024, LuminanceAlphaFormat = 1025, RGBEFormat = RGBAFormat, DepthFormat = 1026, DepthStencilFormat = 1027, RedFormat = 1028, RedIntegerFormat = 1029, RGFormat = 1030, RGIntegerFormat = 1031, RGBIntegerFormat = 1032, RGBAIntegerFormat = 1033, RGB_S3TC_DXT1_Format = 33776, RGBA_S3TC_DXT1_Format = 33777, RGBA_S3TC_DXT3_Format = 33778, RGBA_S3TC_DXT5_Format = 33779, RGB_PVRTC_4BPPV1_Format = 35840, RGB_PVRTC_2BPPV1_Format = 35841, RGBA_PVRTC_4BPPV1_Format = 35842, RGBA_PVRTC_2BPPV1_Format = 35843, RGB_ETC1_Format = 36196, RGB_ETC2_Format = 37492, RGBA_ETC2_EAC_Format = 37496, RGBA_ASTC_4x4_Format = 37808, RGBA_ASTC_5x4_Format = 37809, RGBA_ASTC_5x5_Format = 37810, RGBA_ASTC_6x5_Format = 37811, RGBA_ASTC_6x6_Format = 37812, RGBA_ASTC_8x5_Format = 37813, RGBA_ASTC_8x6_Format = 37814, RGBA_ASTC_8x8_Format = 37815, RGBA_ASTC_10x5_Format = 37816, RGBA_ASTC_10x6_Format = 37817, RGBA_ASTC_10x8_Format = 37818, RGBA_ASTC_10x10_Format = 37819, RGBA_ASTC_12x10_Format = 37820, RGBA_ASTC_12x12_Format = 37821, RGBA_BPTC_Format = 36492, SRGB8_ALPHA8_ASTC_4x4_Format = 37840, SRGB8_ALPHA8_ASTC_5x4_Format = 37841, SRGB8_ALPHA8_ASTC_5x5_Format = 37842, SRGB8_ALPHA8_ASTC_6x5_Format = 37843, SRGB8_ALPHA8_ASTC_6x6_Format = 37844, SRGB8_ALPHA8_ASTC_8x5_Format = 37845, SRGB8_ALPHA8_ASTC_8x6_Format = 37846, SRGB8_ALPHA8_ASTC_8x8_Format = 37847, SRGB8_ALPHA8_ASTC_10x5_Format = 37848, SRGB8_ALPHA8_ASTC_10x6_Format = 37849, SRGB8_ALPHA8_ASTC_10x8_Format = 37850, SRGB8_ALPHA8_ASTC_10x10_Format = 37851, SRGB8_ALPHA8_ASTC_12x10_Format = 37852, SRGB8_ALPHA8_ASTC_12x12_Format = 37853, LoopOnce = 2200, LoopRepeat = 2201, LoopPingPong = 2202, InterpolateDiscrete = 2300, InterpolateLinear = 2301, InterpolateSmooth = 2302, ZeroCurvatureEnding = 2400, ZeroSlopeEnding = 2401, WrapAroundEnding = 2402, NormalAnimationBlendMode = 2500, AdditiveAnimationBlendMode = 2501, TrianglesDrawMode = 0, TriangleStripDrawMode = 1, TriangleFanDrawMode = 2, LinearEncoding = 3e3, sRGBEncoding = 3001, GammaEncoding = 3007, RGBEEncoding = 3002, LogLuvEncoding = 3003, RGBM7Encoding = 3004, RGBM16Encoding = 3005, RGBDEncoding = 3006, BasicDepthPacking = 3200, RGBADepthPacking = 3201, TangentSpaceNormalMap = 0, ObjectSpaceNormalMap = 1, ZeroStencilOp = 0, KeepStencilOp = 7680, ReplaceStencilOp = 7681, IncrementStencilOp = 7682, DecrementStencilOp = 7683, IncrementWrapStencilOp = 34055, DecrementWrapStencilOp = 34056, InvertStencilOp = 5386, NeverStencilFunc = 512, LessStencilFunc = 513, EqualStencilFunc = 514, LessEqualStencilFunc = 515, GreaterStencilFunc = 516, NotEqualStencilFunc = 517, GreaterEqualStencilFunc = 518, AlwaysStencilFunc = 519, StaticDrawUsage = 35044, DynamicDrawUsage = 35048, StreamDrawUsage = 35040, StaticReadUsage = 35045, DynamicReadUsage = 35049, StreamReadUsage = 35041, StaticCopyUsage = 35046, DynamicCopyUsage = 35050, StreamCopyUsage = 35042, GLSL1 = "100", GLSL3 = "300 es";
let EventDispatcher$1 = class {
  addEventListener(e, b) {
    this._listeners === void 0 && (this._listeners = {});
    const L = this._listeners;
    L[e] === void 0 && (L[e] = []), L[e].indexOf(b) === -1 && L[e].push(b);
  }
  hasEventListener(e, b) {
    if (this._listeners === void 0) return !1;
    const L = this._listeners;
    return L[e] !== void 0 && L[e].indexOf(b) !== -1;
  }
  removeEventListener(e, b) {
    if (this._listeners === void 0) return;
    const M = this._listeners[e];
    if (M !== void 0) {
      const D = M.indexOf(b);
      D !== -1 && M.splice(D, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const L = this._listeners[e.type];
    if (L !== void 0) {
      e.target = this;
      const M = L.slice(0);
      for (let D = 0, I = M.length; D < I; D++)
        M[D].call(this, e);
      e.target = null;
    }
  }
};
const _lut$1 = [];
for (let B = 0; B < 256; B++)
  _lut$1[B] = (B < 16 ? "0" : "") + B.toString(16);
let _seed = 1234567;
const DEG2RAD = Math.PI / 180, RAD2DEG = 180 / Math.PI;
function generateUUID$1() {
  const B = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, b = Math.random() * 4294967295 | 0, L = Math.random() * 4294967295 | 0;
  return (_lut$1[B & 255] + _lut$1[B >> 8 & 255] + _lut$1[B >> 16 & 255] + _lut$1[B >> 24 & 255] + "-" + _lut$1[e & 255] + _lut$1[e >> 8 & 255] + "-" + _lut$1[e >> 16 & 15 | 64] + _lut$1[e >> 24 & 255] + "-" + _lut$1[b & 63 | 128] + _lut$1[b >> 8 & 255] + "-" + _lut$1[b >> 16 & 255] + _lut$1[b >> 24 & 255] + _lut$1[L & 255] + _lut$1[L >> 8 & 255] + _lut$1[L >> 16 & 255] + _lut$1[L >> 24 & 255]).toUpperCase();
}
function clamp(B, e, b) {
  return Math.max(e, Math.min(b, B));
}
function euclideanModulo(B, e) {
  return (B % e + e) % e;
}
function mapLinear(B, e, b, L, M) {
  return L + (B - e) * (M - L) / (b - e);
}
function inverseLerp(B, e, b) {
  return B !== e ? (b - B) / (e - B) : 0;
}
function lerp(B, e, b) {
  return (1 - b) * B + b * e;
}
function damp(B, e, b, L) {
  return lerp(B, e, 1 - Math.exp(-b * L));
}
function pingpong(B, e = 1) {
  return e - Math.abs(euclideanModulo(B, e * 2) - e);
}
function smoothstep(B, e, b) {
  return B <= e ? 0 : B >= b ? 1 : (B = (B - e) / (b - e), B * B * (3 - 2 * B));
}
function smootherstep(B, e, b) {
  return B <= e ? 0 : B >= b ? 1 : (B = (B - e) / (b - e), B * B * B * (B * (B * 6 - 15) + 10));
}
function randInt(B, e) {
  return B + Math.floor(Math.random() * (e - B + 1));
}
function randFloat(B, e) {
  return B + Math.random() * (e - B);
}
function randFloatSpread(B) {
  return B * (0.5 - Math.random());
}
function seededRandom(B) {
  return B !== void 0 && (_seed = B % 2147483647), _seed = _seed * 16807 % 2147483647, (_seed - 1) / 2147483646;
}
function degToRad(B) {
  return B * DEG2RAD;
}
function radToDeg(B) {
  return B * RAD2DEG;
}
function isPowerOfTwo(B) {
  return (B & B - 1) === 0 && B !== 0;
}
function ceilPowerOfTwo(B) {
  return Math.pow(2, Math.ceil(Math.log(B) / Math.LN2));
}
function floorPowerOfTwo(B) {
  return Math.pow(2, Math.floor(Math.log(B) / Math.LN2));
}
function setQuaternionFromProperEuler(B, e, b, L, M) {
  const D = Math.cos, I = Math.sin, F = D(b / 2), N = I(b / 2), U = D((e + L) / 2), G = I((e + L) / 2), V = D((e - L) / 2), z = I((e - L) / 2), k = D((L - e) / 2), H = I((L - e) / 2);
  switch (M) {
    case "XYX":
      B.set(F * G, N * V, N * z, F * U);
      break;
    case "YZY":
      B.set(N * z, F * G, N * V, F * U);
      break;
    case "ZXZ":
      B.set(N * V, N * z, F * G, F * U);
      break;
    case "XZX":
      B.set(F * G, N * H, N * k, F * U);
      break;
    case "YXY":
      B.set(N * k, F * G, N * H, F * U);
      break;
    case "ZYZ":
      B.set(N * H, N * k, F * G, F * U);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + M);
  }
}
var MathUtils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DEG2RAD,
  RAD2DEG,
  generateUUID: generateUUID$1,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler
});
class Vector2 {
  constructor(e = 0, b = 0) {
    this.x = e, this.y = b;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, b) {
    return this.x = e, this.y = b, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, b) {
    switch (e) {
      case 0:
        this.x = b;
        break;
      case 1:
        this.y = b;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e, b) {
    return b !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, b)) : (this.x += e.x, this.y += e.y, this);
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, b) {
    return this.x = e.x + b.x, this.y = e.y + b.y, this;
  }
  addScaledVector(e, b) {
    return this.x += e.x * b, this.y += e.y * b, this;
  }
  sub(e, b) {
    return b !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, b)) : (this.x -= e.x, this.y -= e.y, this);
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, b) {
    return this.x = e.x - b.x, this.y = e.y - b.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const b = this.x, L = this.y, M = e.elements;
    return this.x = M[0] * b + M[3] * L + M[6], this.y = M[1] * b + M[4] * L + M[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, b) {
    return this.x = Math.max(e.x, Math.min(b.x, this.x)), this.y = Math.max(e.y, Math.min(b.y, this.y)), this;
  }
  clampScalar(e, b) {
    return this.x = Math.max(e, Math.min(b, this.x)), this.y = Math.max(e, Math.min(b, this.y)), this;
  }
  clampLength(e, b) {
    const L = this.length();
    return this.divideScalar(L || 1).multiplyScalar(Math.max(e, Math.min(b, L)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const b = this.x - e.x, L = this.y - e.y;
    return b * b + L * L;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, b) {
    return this.x += (e.x - this.x) * b, this.y += (e.y - this.y) * b, this;
  }
  lerpVectors(e, b, L) {
    return this.x = e.x + (b.x - e.x) * L, this.y = e.y + (b.y - e.y) * L, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, b = 0) {
    return this.x = e[b], this.y = e[b + 1], this;
  }
  toArray(e = [], b = 0) {
    return e[b] = this.x, e[b + 1] = this.y, e;
  }
  fromBufferAttribute(e, b, L) {
    return L !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(b), this.y = e.getY(b), this;
  }
  rotateAround(e, b) {
    const L = Math.cos(b), M = Math.sin(b), D = this.x - e.x, I = this.y - e.y;
    return this.x = D * L - I * M + e.x, this.y = D * M + I * L + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
}
Vector2.prototype.isVector2 = !0;
class Matrix3 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
  }
  set(e, b, L, M, D, I, F, N, U) {
    const G = this.elements;
    return G[0] = e, G[1] = M, G[2] = F, G[3] = b, G[4] = D, G[5] = N, G[6] = L, G[7] = I, G[8] = U, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const b = this.elements, L = e.elements;
    return b[0] = L[0], b[1] = L[1], b[2] = L[2], b[3] = L[3], b[4] = L[4], b[5] = L[5], b[6] = L[6], b[7] = L[7], b[8] = L[8], this;
  }
  extractBasis(e, b, L) {
    return e.setFromMatrix3Column(this, 0), b.setFromMatrix3Column(this, 1), L.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const b = e.elements;
    return this.set(
      b[0],
      b[4],
      b[8],
      b[1],
      b[5],
      b[9],
      b[2],
      b[6],
      b[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, b) {
    const L = e.elements, M = b.elements, D = this.elements, I = L[0], F = L[3], N = L[6], U = L[1], G = L[4], V = L[7], z = L[2], k = L[5], H = L[8], W = M[0], $ = M[3], j = M[6], q = M[1], Y = M[4], J = M[7], K = M[2], X = M[5], Z = M[8];
    return D[0] = I * W + F * q + N * K, D[3] = I * $ + F * Y + N * X, D[6] = I * j + F * J + N * Z, D[1] = U * W + G * q + V * K, D[4] = U * $ + G * Y + V * X, D[7] = U * j + G * J + V * Z, D[2] = z * W + k * q + H * K, D[5] = z * $ + k * Y + H * X, D[8] = z * j + k * J + H * Z, this;
  }
  multiplyScalar(e) {
    const b = this.elements;
    return b[0] *= e, b[3] *= e, b[6] *= e, b[1] *= e, b[4] *= e, b[7] *= e, b[2] *= e, b[5] *= e, b[8] *= e, this;
  }
  determinant() {
    const e = this.elements, b = e[0], L = e[1], M = e[2], D = e[3], I = e[4], F = e[5], N = e[6], U = e[7], G = e[8];
    return b * I * G - b * F * U - L * D * G + L * F * N + M * D * U - M * I * N;
  }
  invert() {
    const e = this.elements, b = e[0], L = e[1], M = e[2], D = e[3], I = e[4], F = e[5], N = e[6], U = e[7], G = e[8], V = G * I - F * U, z = F * N - G * D, k = U * D - I * N, H = b * V + L * z + M * k;
    if (H === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const W = 1 / H;
    return e[0] = V * W, e[1] = (M * U - G * L) * W, e[2] = (F * L - M * I) * W, e[3] = z * W, e[4] = (G * b - M * N) * W, e[5] = (M * D - F * b) * W, e[6] = k * W, e[7] = (L * N - U * b) * W, e[8] = (I * b - L * D) * W, this;
  }
  transpose() {
    let e;
    const b = this.elements;
    return e = b[1], b[1] = b[3], b[3] = e, e = b[2], b[2] = b[6], b[6] = e, e = b[5], b[5] = b[7], b[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const b = this.elements;
    return e[0] = b[0], e[1] = b[3], e[2] = b[6], e[3] = b[1], e[4] = b[4], e[5] = b[7], e[6] = b[2], e[7] = b[5], e[8] = b[8], this;
  }
  setUvTransform(e, b, L, M, D, I, F) {
    const N = Math.cos(D), U = Math.sin(D);
    return this.set(
      L * N,
      L * U,
      -L * (N * I + U * F) + I + e,
      -M * U,
      M * N,
      -M * (-U * I + N * F) + F + b,
      0,
      0,
      1
    ), this;
  }
  scale(e, b) {
    const L = this.elements;
    return L[0] *= e, L[3] *= e, L[6] *= e, L[1] *= b, L[4] *= b, L[7] *= b, this;
  }
  rotate(e) {
    const b = Math.cos(e), L = Math.sin(e), M = this.elements, D = M[0], I = M[3], F = M[6], N = M[1], U = M[4], G = M[7];
    return M[0] = b * D + L * N, M[3] = b * I + L * U, M[6] = b * F + L * G, M[1] = -L * D + b * N, M[4] = -L * I + b * U, M[7] = -L * F + b * G, this;
  }
  translate(e, b) {
    const L = this.elements;
    return L[0] += e * L[2], L[3] += e * L[5], L[6] += e * L[8], L[1] += b * L[2], L[4] += b * L[5], L[7] += b * L[8], this;
  }
  equals(e) {
    const b = this.elements, L = e.elements;
    for (let M = 0; M < 9; M++)
      if (b[M] !== L[M]) return !1;
    return !0;
  }
  fromArray(e, b = 0) {
    for (let L = 0; L < 9; L++)
      this.elements[L] = e[L + b];
    return this;
  }
  toArray(e = [], b = 0) {
    const L = this.elements;
    return e[b] = L[0], e[b + 1] = L[1], e[b + 2] = L[2], e[b + 3] = L[3], e[b + 4] = L[4], e[b + 5] = L[5], e[b + 6] = L[6], e[b + 7] = L[7], e[b + 8] = L[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
Matrix3.prototype.isMatrix3 = !0;
let _canvas;
class ImageUtils {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let b;
    if (e instanceof HTMLCanvasElement)
      b = e;
    else {
      _canvas === void 0 && (_canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), _canvas.width = e.width, _canvas.height = e.height;
      const L = _canvas.getContext("2d");
      e instanceof ImageData ? L.putImageData(e, 0, 0) : L.drawImage(e, 0, 0, e.width, e.height), b = _canvas;
    }
    return b.width > 2048 || b.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), b.toDataURL("image/jpeg", 0.6)) : b.toDataURL("image/png");
  }
}
let textureId = 0;
class Texture extends EventDispatcher$1 {
  constructor(e = Texture.DEFAULT_IMAGE, b = Texture.DEFAULT_MAPPING, L = ClampToEdgeWrapping, M = ClampToEdgeWrapping, D = LinearFilter, I = LinearMipmapLinearFilter, F = RGBAFormat, N = UnsignedByteType, U = 1, G = LinearEncoding) {
    super(), Object.defineProperty(this, "id", { value: textureId++ }), this.uuid = generateUUID$1(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = b, this.wrapS = L, this.wrapT = M, this.magFilter = D, this.minFilter = I, this.anisotropy = U, this.format = F, this.internalFormat = null, this.type = N, this.offset = new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Matrix3(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = G, this.version = 0, this.onUpdate = null;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this;
  }
  toJSON(e) {
    const b = e === void 0 || typeof e == "string";
    if (!b && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const L = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const M = this.image;
      if (M.uuid === void 0 && (M.uuid = generateUUID$1()), !b && e.images[M.uuid] === void 0) {
        let D;
        if (Array.isArray(M)) {
          D = [];
          for (let I = 0, F = M.length; I < F; I++)
            M[I].isDataTexture ? D.push(serializeImage(M[I].image)) : D.push(serializeImage(M[I]));
        } else
          D = serializeImage(M);
        e.images[M.uuid] = {
          uuid: M.uuid,
          url: D
        };
      }
      L.image = M.uuid;
    }
    return b || (e.textures[this.uuid] = L), L;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== UVMapping) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case RepeatWrapping:
          e.x = e.x - Math.floor(e.x);
          break;
        case ClampToEdgeWrapping:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case RepeatWrapping:
          e.y = e.y - Math.floor(e.y);
          break;
        case ClampToEdgeWrapping:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = !0;
function serializeImage(B) {
  return typeof HTMLImageElement < "u" && B instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && B instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && B instanceof ImageBitmap ? ImageUtils.getDataURL(B) : B.data ? {
    data: Array.prototype.slice.call(B.data),
    width: B.width,
    height: B.height,
    type: B.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
class Vector4 {
  constructor(e = 0, b = 0, L = 0, M = 1) {
    this.x = e, this.y = b, this.z = L, this.w = M;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, b, L, M) {
    return this.x = e, this.y = b, this.z = L, this.w = M, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, b) {
    switch (e) {
      case 0:
        this.x = b;
        break;
      case 1:
        this.y = b;
        break;
      case 2:
        this.z = b;
        break;
      case 3:
        this.w = b;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e, b) {
    return b !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, b)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this);
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, b) {
    return this.x = e.x + b.x, this.y = e.y + b.y, this.z = e.z + b.z, this.w = e.w + b.w, this;
  }
  addScaledVector(e, b) {
    return this.x += e.x * b, this.y += e.y * b, this.z += e.z * b, this.w += e.w * b, this;
  }
  sub(e, b) {
    return b !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, b)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this);
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, b) {
    return this.x = e.x - b.x, this.y = e.y - b.y, this.z = e.z - b.z, this.w = e.w - b.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const b = this.x, L = this.y, M = this.z, D = this.w, I = e.elements;
    return this.x = I[0] * b + I[4] * L + I[8] * M + I[12] * D, this.y = I[1] * b + I[5] * L + I[9] * M + I[13] * D, this.z = I[2] * b + I[6] * L + I[10] * M + I[14] * D, this.w = I[3] * b + I[7] * L + I[11] * M + I[15] * D, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const b = Math.sqrt(1 - e.w * e.w);
    return b < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / b, this.y = e.y / b, this.z = e.z / b), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let b, L, M, D;
    const N = e.elements, U = N[0], G = N[4], V = N[8], z = N[1], k = N[5], H = N[9], W = N[2], $ = N[6], j = N[10];
    if (Math.abs(G - z) < 0.01 && Math.abs(V - W) < 0.01 && Math.abs(H - $) < 0.01) {
      if (Math.abs(G + z) < 0.1 && Math.abs(V + W) < 0.1 && Math.abs(H + $) < 0.1 && Math.abs(U + k + j - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      b = Math.PI;
      const Y = (U + 1) / 2, J = (k + 1) / 2, K = (j + 1) / 2, X = (G + z) / 4, Z = (V + W) / 4, Q = (H + $) / 4;
      return Y > J && Y > K ? Y < 0.01 ? (L = 0, M = 0.707106781, D = 0.707106781) : (L = Math.sqrt(Y), M = X / L, D = Z / L) : J > K ? J < 0.01 ? (L = 0.707106781, M = 0, D = 0.707106781) : (M = Math.sqrt(J), L = X / M, D = Q / M) : K < 0.01 ? (L = 0.707106781, M = 0.707106781, D = 0) : (D = Math.sqrt(K), L = Z / D, M = Q / D), this.set(L, M, D, b), this;
    }
    let q = Math.sqrt(($ - H) * ($ - H) + (V - W) * (V - W) + (z - G) * (z - G));
    return Math.abs(q) < 1e-3 && (q = 1), this.x = ($ - H) / q, this.y = (V - W) / q, this.z = (z - G) / q, this.w = Math.acos((U + k + j - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, b) {
    return this.x = Math.max(e.x, Math.min(b.x, this.x)), this.y = Math.max(e.y, Math.min(b.y, this.y)), this.z = Math.max(e.z, Math.min(b.z, this.z)), this.w = Math.max(e.w, Math.min(b.w, this.w)), this;
  }
  clampScalar(e, b) {
    return this.x = Math.max(e, Math.min(b, this.x)), this.y = Math.max(e, Math.min(b, this.y)), this.z = Math.max(e, Math.min(b, this.z)), this.w = Math.max(e, Math.min(b, this.w)), this;
  }
  clampLength(e, b) {
    const L = this.length();
    return this.divideScalar(L || 1).multiplyScalar(Math.max(e, Math.min(b, L)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, b) {
    return this.x += (e.x - this.x) * b, this.y += (e.y - this.y) * b, this.z += (e.z - this.z) * b, this.w += (e.w - this.w) * b, this;
  }
  lerpVectors(e, b, L) {
    return this.x = e.x + (b.x - e.x) * L, this.y = e.y + (b.y - e.y) * L, this.z = e.z + (b.z - e.z) * L, this.w = e.w + (b.w - e.w) * L, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, b = 0) {
    return this.x = e[b], this.y = e[b + 1], this.z = e[b + 2], this.w = e[b + 3], this;
  }
  toArray(e = [], b = 0) {
    return e[b] = this.x, e[b + 1] = this.y, e[b + 2] = this.z, e[b + 3] = this.w, e;
  }
  fromBufferAttribute(e, b, L) {
    return L !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(b), this.y = e.getY(b), this.z = e.getZ(b), this.w = e.getW(b), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
}
Vector4.prototype.isVector4 = !0;
class WebGLRenderTarget extends EventDispatcher$1 {
  constructor(e, b, L = {}) {
    super(), this.width = e, this.height = b, this.depth = 1, this.scissor = new Vector4(0, 0, e, b), this.scissorTest = !1, this.viewport = new Vector4(0, 0, e, b), this.texture = new Texture(void 0, L.mapping, L.wrapS, L.wrapT, L.magFilter, L.minFilter, L.format, L.type, L.anisotropy, L.encoding), this.texture.image = { width: e, height: b, depth: 1 }, this.texture.generateMipmaps = L.generateMipmaps !== void 0 ? L.generateMipmaps : !1, this.texture.minFilter = L.minFilter !== void 0 ? L.minFilter : LinearFilter, this.depthBuffer = L.depthBuffer !== void 0 ? L.depthBuffer : !0, this.stencilBuffer = L.stencilBuffer !== void 0 ? L.stencilBuffer : !1, this.depthTexture = L.depthTexture !== void 0 ? L.depthTexture : null;
  }
  setTexture(e) {
    e.image = {
      width: this.width,
      height: this.height,
      depth: this.depth
    }, this.texture = e;
  }
  setSize(e, b, L = 1) {
    (this.width !== e || this.height !== b || this.depth !== L) && (this.width = e, this.height = b, this.depth = L, this.texture.image.width = e, this.texture.image.height = b, this.texture.image.depth = L, this.dispose()), this.viewport.set(0, 0, e, b), this.scissor.set(0, 0, e, b);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.image = { ...this.texture.image }, this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
WebGLRenderTarget.prototype.isWebGLRenderTarget = !0;
class WebGLMultipleRenderTargets extends WebGLRenderTarget {
  constructor(e, b, L) {
    super(e, b);
    const M = this.texture;
    this.texture = [];
    for (let D = 0; D < L; D++)
      this.texture[D] = M.clone();
  }
  setSize(e, b, L = 1) {
    if (this.width !== e || this.height !== b || this.depth !== L) {
      this.width = e, this.height = b, this.depth = L;
      for (let M = 0, D = this.texture.length; M < D; M++)
        this.texture[M].image.width = e, this.texture[M].image.height = b, this.texture[M].image.depth = L;
      this.dispose();
    }
    return this.viewport.set(0, 0, e, b), this.scissor.set(0, 0, e, b), this;
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this.texture.length = 0;
    for (let b = 0, L = e.texture.length; b < L; b++)
      this.texture[b] = e.texture[b].clone();
    return this;
  }
}
WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = !0;
class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
  constructor(e, b, L) {
    super(e, b, L), this.samples = 4;
  }
  copy(e) {
    return super.copy.call(this, e), this.samples = e.samples, this;
  }
}
WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = !0;
class Quaternion {
  constructor(e = 0, b = 0, L = 0, M = 1) {
    this._x = e, this._y = b, this._z = L, this._w = M;
  }
  static slerp(e, b, L, M) {
    return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), L.slerpQuaternions(e, b, M);
  }
  static slerpFlat(e, b, L, M, D, I, F) {
    let N = L[M + 0], U = L[M + 1], G = L[M + 2], V = L[M + 3];
    const z = D[I + 0], k = D[I + 1], H = D[I + 2], W = D[I + 3];
    if (F === 0) {
      e[b + 0] = N, e[b + 1] = U, e[b + 2] = G, e[b + 3] = V;
      return;
    }
    if (F === 1) {
      e[b + 0] = z, e[b + 1] = k, e[b + 2] = H, e[b + 3] = W;
      return;
    }
    if (V !== W || N !== z || U !== k || G !== H) {
      let $ = 1 - F;
      const j = N * z + U * k + G * H + V * W, q = j >= 0 ? 1 : -1, Y = 1 - j * j;
      if (Y > Number.EPSILON) {
        const K = Math.sqrt(Y), X = Math.atan2(K, j * q);
        $ = Math.sin($ * X) / K, F = Math.sin(F * X) / K;
      }
      const J = F * q;
      if (N = N * $ + z * J, U = U * $ + k * J, G = G * $ + H * J, V = V * $ + W * J, $ === 1 - F) {
        const K = 1 / Math.sqrt(N * N + U * U + G * G + V * V);
        N *= K, U *= K, G *= K, V *= K;
      }
    }
    e[b] = N, e[b + 1] = U, e[b + 2] = G, e[b + 3] = V;
  }
  static multiplyQuaternionsFlat(e, b, L, M, D, I) {
    const F = L[M], N = L[M + 1], U = L[M + 2], G = L[M + 3], V = D[I], z = D[I + 1], k = D[I + 2], H = D[I + 3];
    return e[b] = F * H + G * V + N * k - U * z, e[b + 1] = N * H + G * z + U * V - F * k, e[b + 2] = U * H + G * k + F * z - N * V, e[b + 3] = G * H - F * V - N * z - U * k, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, b, L, M) {
    return this._x = e, this._y = b, this._z = L, this._w = M, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, b) {
    if (!(e && e.isEuler))
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    const L = e._x, M = e._y, D = e._z, I = e._order, F = Math.cos, N = Math.sin, U = F(L / 2), G = F(M / 2), V = F(D / 2), z = N(L / 2), k = N(M / 2), H = N(D / 2);
    switch (I) {
      case "XYZ":
        this._x = z * G * V + U * k * H, this._y = U * k * V - z * G * H, this._z = U * G * H + z * k * V, this._w = U * G * V - z * k * H;
        break;
      case "YXZ":
        this._x = z * G * V + U * k * H, this._y = U * k * V - z * G * H, this._z = U * G * H - z * k * V, this._w = U * G * V + z * k * H;
        break;
      case "ZXY":
        this._x = z * G * V - U * k * H, this._y = U * k * V + z * G * H, this._z = U * G * H + z * k * V, this._w = U * G * V - z * k * H;
        break;
      case "ZYX":
        this._x = z * G * V - U * k * H, this._y = U * k * V + z * G * H, this._z = U * G * H - z * k * V, this._w = U * G * V + z * k * H;
        break;
      case "YZX":
        this._x = z * G * V + U * k * H, this._y = U * k * V + z * G * H, this._z = U * G * H - z * k * V, this._w = U * G * V - z * k * H;
        break;
      case "XZY":
        this._x = z * G * V - U * k * H, this._y = U * k * V - z * G * H, this._z = U * G * H + z * k * V, this._w = U * G * V + z * k * H;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + I);
    }
    return b !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, b) {
    const L = b / 2, M = Math.sin(L);
    return this._x = e.x * M, this._y = e.y * M, this._z = e.z * M, this._w = Math.cos(L), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const b = e.elements, L = b[0], M = b[4], D = b[8], I = b[1], F = b[5], N = b[9], U = b[2], G = b[6], V = b[10], z = L + F + V;
    if (z > 0) {
      const k = 0.5 / Math.sqrt(z + 1);
      this._w = 0.25 / k, this._x = (G - N) * k, this._y = (D - U) * k, this._z = (I - M) * k;
    } else if (L > F && L > V) {
      const k = 2 * Math.sqrt(1 + L - F - V);
      this._w = (G - N) / k, this._x = 0.25 * k, this._y = (M + I) / k, this._z = (D + U) / k;
    } else if (F > V) {
      const k = 2 * Math.sqrt(1 + F - L - V);
      this._w = (D - U) / k, this._x = (M + I) / k, this._y = 0.25 * k, this._z = (N + G) / k;
    } else {
      const k = 2 * Math.sqrt(1 + V - L - F);
      this._w = (I - M) / k, this._x = (D + U) / k, this._y = (N + G) / k, this._z = 0.25 * k;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, b) {
    let L = e.dot(b) + 1;
    return L < Number.EPSILON ? (L = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = L) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = L)) : (this._x = e.y * b.z - e.z * b.y, this._y = e.z * b.x - e.x * b.z, this._z = e.x * b.y - e.y * b.x, this._w = L), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(e), -1, 1)));
  }
  rotateTowards(e, b) {
    const L = this.angleTo(e);
    if (L === 0) return this;
    const M = Math.min(1, b / L);
    return this.slerp(e, M), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e, b) {
    return b !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, b)) : this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, b) {
    const L = e._x, M = e._y, D = e._z, I = e._w, F = b._x, N = b._y, U = b._z, G = b._w;
    return this._x = L * G + I * F + M * U - D * N, this._y = M * G + I * N + D * F - L * U, this._z = D * G + I * U + L * N - M * F, this._w = I * G - L * F - M * N - D * U, this._onChangeCallback(), this;
  }
  slerp(e, b) {
    if (b === 0) return this;
    if (b === 1) return this.copy(e);
    const L = this._x, M = this._y, D = this._z, I = this._w;
    let F = I * e._w + L * e._x + M * e._y + D * e._z;
    if (F < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, F = -F) : this.copy(e), F >= 1)
      return this._w = I, this._x = L, this._y = M, this._z = D, this;
    const N = 1 - F * F;
    if (N <= Number.EPSILON) {
      const k = 1 - b;
      return this._w = k * I + b * this._w, this._x = k * L + b * this._x, this._y = k * M + b * this._y, this._z = k * D + b * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const U = Math.sqrt(N), G = Math.atan2(U, F), V = Math.sin((1 - b) * G) / U, z = Math.sin(b * G) / U;
    return this._w = I * V + this._w * z, this._x = L * V + this._x * z, this._y = M * V + this._y * z, this._z = D * V + this._z * z, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, b, L) {
    this.copy(e).slerp(b, L);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, b = 0) {
    return this._x = e[b], this._y = e[b + 1], this._z = e[b + 2], this._w = e[b + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], b = 0) {
    return e[b] = this._x, e[b + 1] = this._y, e[b + 2] = this._z, e[b + 3] = this._w, e;
  }
  fromBufferAttribute(e, b) {
    return this._x = e.getX(b), this._y = e.getY(b), this._z = e.getZ(b), this._w = e.getW(b), this;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
}
Quaternion.prototype.isQuaternion = !0;
class Vector3 {
  constructor(e = 0, b = 0, L = 0) {
    this.x = e, this.y = b, this.z = L;
  }
  set(e, b, L) {
    return L === void 0 && (L = this.z), this.x = e, this.y = b, this.z = L, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, b) {
    switch (e) {
      case 0:
        this.x = b;
        break;
      case 1:
        this.y = b;
        break;
      case 2:
        this.z = b;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e, b) {
    return b !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, b)) : (this.x += e.x, this.y += e.y, this.z += e.z, this);
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, b) {
    return this.x = e.x + b.x, this.y = e.y + b.y, this.z = e.z + b.z, this;
  }
  addScaledVector(e, b) {
    return this.x += e.x * b, this.y += e.y * b, this.z += e.z * b, this;
  }
  sub(e, b) {
    return b !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, b)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this);
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, b) {
    return this.x = e.x - b.x, this.y = e.y - b.y, this.z = e.z - b.z, this;
  }
  multiply(e, b) {
    return b !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, b)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this);
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, b) {
    return this.x = e.x * b.x, this.y = e.y * b.y, this.z = e.z * b.z, this;
  }
  applyEuler(e) {
    return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(_quaternion$4.setFromEuler(e));
  }
  applyAxisAngle(e, b) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(e, b));
  }
  applyMatrix3(e) {
    const b = this.x, L = this.y, M = this.z, D = e.elements;
    return this.x = D[0] * b + D[3] * L + D[6] * M, this.y = D[1] * b + D[4] * L + D[7] * M, this.z = D[2] * b + D[5] * L + D[8] * M, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const b = this.x, L = this.y, M = this.z, D = e.elements, I = 1 / (D[3] * b + D[7] * L + D[11] * M + D[15]);
    return this.x = (D[0] * b + D[4] * L + D[8] * M + D[12]) * I, this.y = (D[1] * b + D[5] * L + D[9] * M + D[13]) * I, this.z = (D[2] * b + D[6] * L + D[10] * M + D[14]) * I, this;
  }
  applyQuaternion(e) {
    const b = this.x, L = this.y, M = this.z, D = e.x, I = e.y, F = e.z, N = e.w, U = N * b + I * M - F * L, G = N * L + F * b - D * M, V = N * M + D * L - I * b, z = -D * b - I * L - F * M;
    return this.x = U * N + z * -D + G * -F - V * -I, this.y = G * N + z * -I + V * -D - U * -F, this.z = V * N + z * -F + U * -I - G * -D, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const b = this.x, L = this.y, M = this.z, D = e.elements;
    return this.x = D[0] * b + D[4] * L + D[8] * M, this.y = D[1] * b + D[5] * L + D[9] * M, this.z = D[2] * b + D[6] * L + D[10] * M, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, b) {
    return this.x = Math.max(e.x, Math.min(b.x, this.x)), this.y = Math.max(e.y, Math.min(b.y, this.y)), this.z = Math.max(e.z, Math.min(b.z, this.z)), this;
  }
  clampScalar(e, b) {
    return this.x = Math.max(e, Math.min(b, this.x)), this.y = Math.max(e, Math.min(b, this.y)), this.z = Math.max(e, Math.min(b, this.z)), this;
  }
  clampLength(e, b) {
    const L = this.length();
    return this.divideScalar(L || 1).multiplyScalar(Math.max(e, Math.min(b, L)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, b) {
    return this.x += (e.x - this.x) * b, this.y += (e.y - this.y) * b, this.z += (e.z - this.z) * b, this;
  }
  lerpVectors(e, b, L) {
    return this.x = e.x + (b.x - e.x) * L, this.y = e.y + (b.y - e.y) * L, this.z = e.z + (b.z - e.z) * L, this;
  }
  cross(e, b) {
    return b !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, b)) : this.crossVectors(this, e);
  }
  crossVectors(e, b) {
    const L = e.x, M = e.y, D = e.z, I = b.x, F = b.y, N = b.z;
    return this.x = M * N - D * F, this.y = D * I - L * N, this.z = L * F - M * I, this;
  }
  projectOnVector(e) {
    const b = e.lengthSq();
    if (b === 0) return this.set(0, 0, 0);
    const L = e.dot(this) / b;
    return this.copy(e).multiplyScalar(L);
  }
  projectOnPlane(e) {
    return _vector$c.copy(this).projectOnVector(e), this.sub(_vector$c);
  }
  reflect(e) {
    return this.sub(_vector$c.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const b = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (b === 0) return Math.PI / 2;
    const L = this.dot(e) / b;
    return Math.acos(clamp(L, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const b = this.x - e.x, L = this.y - e.y, M = this.z - e.z;
    return b * b + L * L + M * M;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, b, L) {
    const M = Math.sin(b) * e;
    return this.x = M * Math.sin(L), this.y = Math.cos(b) * e, this.z = M * Math.cos(L), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, b, L) {
    return this.x = e * Math.sin(b), this.y = L, this.z = e * Math.cos(b), this;
  }
  setFromMatrixPosition(e) {
    const b = e.elements;
    return this.x = b[12], this.y = b[13], this.z = b[14], this;
  }
  setFromMatrixScale(e) {
    const b = this.setFromMatrixColumn(e, 0).length(), L = this.setFromMatrixColumn(e, 1).length(), M = this.setFromMatrixColumn(e, 2).length();
    return this.x = b, this.y = L, this.z = M, this;
  }
  setFromMatrixColumn(e, b) {
    return this.fromArray(e.elements, b * 4);
  }
  setFromMatrix3Column(e, b) {
    return this.fromArray(e.elements, b * 3);
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, b = 0) {
    return this.x = e[b], this.y = e[b + 1], this.z = e[b + 2], this;
  }
  toArray(e = [], b = 0) {
    return e[b] = this.x, e[b + 1] = this.y, e[b + 2] = this.z, e;
  }
  fromBufferAttribute(e, b, L) {
    return L !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(b), this.y = e.getY(b), this.z = e.getZ(b), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
}
Vector3.prototype.isVector3 = !0;
const _vector$c = /* @__PURE__ */ new Vector3(), _quaternion$4 = /* @__PURE__ */ new Quaternion();
class Box3 {
  constructor(e = new Vector3(1 / 0, 1 / 0, 1 / 0), b = new Vector3(-1 / 0, -1 / 0, -1 / 0)) {
    this.min = e, this.max = b;
  }
  set(e, b) {
    return this.min.copy(e), this.max.copy(b), this;
  }
  setFromArray(e) {
    let b = 1 / 0, L = 1 / 0, M = 1 / 0, D = -1 / 0, I = -1 / 0, F = -1 / 0;
    for (let N = 0, U = e.length; N < U; N += 3) {
      const G = e[N], V = e[N + 1], z = e[N + 2];
      G < b && (b = G), V < L && (L = V), z < M && (M = z), G > D && (D = G), V > I && (I = V), z > F && (F = z);
    }
    return this.min.set(b, L, M), this.max.set(D, I, F), this;
  }
  setFromBufferAttribute(e) {
    let b = 1 / 0, L = 1 / 0, M = 1 / 0, D = -1 / 0, I = -1 / 0, F = -1 / 0;
    for (let N = 0, U = e.count; N < U; N++) {
      const G = e.getX(N), V = e.getY(N), z = e.getZ(N);
      G < b && (b = G), V < L && (L = V), z < M && (M = z), G > D && (D = G), V > I && (I = V), z > F && (F = z);
    }
    return this.min.set(b, L, M), this.max.set(D, I, F), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let b = 0, L = e.length; b < L; b++)
      this.expandByPoint(e[b]);
    return this;
  }
  setFromCenterAndSize(e, b) {
    const L = _vector$b.copy(b).multiplyScalar(0.5);
    return this.min.copy(e).sub(L), this.max.copy(e).add(L), this;
  }
  setFromObject(e) {
    return this.makeEmpty(), this.expandByObject(e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e) {
    e.updateWorldMatrix(!1, !1);
    const b = e.geometry;
    b !== void 0 && (b.boundingBox === null && b.computeBoundingBox(), _box$3.copy(b.boundingBox), _box$3.applyMatrix4(e.matrixWorld), this.union(_box$3));
    const L = e.children;
    for (let M = 0, D = L.length; M < D; M++)
      this.expandByObject(L[M]);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, b) {
    return b.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, _vector$b), _vector$b.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let b, L;
    return e.normal.x > 0 ? (b = e.normal.x * this.min.x, L = e.normal.x * this.max.x) : (b = e.normal.x * this.max.x, L = e.normal.x * this.min.x), e.normal.y > 0 ? (b += e.normal.y * this.min.y, L += e.normal.y * this.max.y) : (b += e.normal.y * this.max.y, L += e.normal.y * this.min.y), e.normal.z > 0 ? (b += e.normal.z * this.min.z, L += e.normal.z * this.max.z) : (b += e.normal.z * this.max.z, L += e.normal.z * this.min.z), b <= -e.constant && L >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(_center), _extents.subVectors(this.max, _center), _v0$2.subVectors(e.a, _center), _v1$7.subVectors(e.b, _center), _v2$3.subVectors(e.c, _center), _f0.subVectors(_v1$7, _v0$2), _f1.subVectors(_v2$3, _v1$7), _f2.subVectors(_v0$2, _v2$3);
    let b = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    return !satForAxes(b, _v0$2, _v1$7, _v2$3, _extents) || (b = [1, 0, 0, 0, 1, 0, 0, 0, 1], !satForAxes(b, _v0$2, _v1$7, _v2$3, _extents)) ? !1 : (_triangleNormal.crossVectors(_f0, _f1), b = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z], satForAxes(b, _v0$2, _v1$7, _v2$3, _extents));
  }
  clampPoint(e, b) {
    return b.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return _vector$b.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return this.getCenter(e.center), e.radius = this.getSize(_vector$b).length() * 0.5, e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(_points), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
Box3.prototype.isBox3 = !0;
const _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
], _vector$b = /* @__PURE__ */ new Vector3(), _box$3 = /* @__PURE__ */ new Box3(), _v0$2 = /* @__PURE__ */ new Vector3(), _v1$7 = /* @__PURE__ */ new Vector3(), _v2$3 = /* @__PURE__ */ new Vector3(), _f0 = /* @__PURE__ */ new Vector3(), _f1 = /* @__PURE__ */ new Vector3(), _f2 = /* @__PURE__ */ new Vector3(), _center = /* @__PURE__ */ new Vector3(), _extents = /* @__PURE__ */ new Vector3(), _triangleNormal = /* @__PURE__ */ new Vector3(), _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(B, e, b, L, M) {
  for (let D = 0, I = B.length - 3; D <= I; D += 3) {
    _testAxis.fromArray(B, D);
    const F = M.x * Math.abs(_testAxis.x) + M.y * Math.abs(_testAxis.y) + M.z * Math.abs(_testAxis.z), N = e.dot(_testAxis), U = b.dot(_testAxis), G = L.dot(_testAxis);
    if (Math.max(-Math.max(N, U, G), Math.min(N, U, G)) > F)
      return !1;
  }
  return !0;
}
const _box$2 = /* @__PURE__ */ new Box3(), _v1$6 = /* @__PURE__ */ new Vector3(), _toFarthestPoint = /* @__PURE__ */ new Vector3(), _toPoint = /* @__PURE__ */ new Vector3();
class Sphere {
  constructor(e = new Vector3(), b = -1) {
    this.center = e, this.radius = b;
  }
  set(e, b) {
    return this.center.copy(e), this.radius = b, this;
  }
  setFromPoints(e, b) {
    const L = this.center;
    b !== void 0 ? L.copy(b) : _box$2.setFromPoints(e).getCenter(L);
    let M = 0;
    for (let D = 0, I = e.length; D < I; D++)
      M = Math.max(M, L.distanceToSquared(e[D]));
    return this.radius = Math.sqrt(M), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const b = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= b * b;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, b) {
    const L = this.center.distanceToSquared(e);
    return b.copy(e), L > this.radius * this.radius && (b.sub(this.center).normalize(), b.multiplyScalar(this.radius).add(this.center)), b;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    _toPoint.subVectors(e, this.center);
    const b = _toPoint.lengthSq();
    if (b > this.radius * this.radius) {
      const L = Math.sqrt(b), M = (L - this.radius) * 0.5;
      this.center.add(_toPoint.multiplyScalar(M / L)), this.radius += M;
    }
    return this;
  }
  union(e) {
    return _toFarthestPoint.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(_v1$6.copy(e.center).add(_toFarthestPoint)), this.expandByPoint(_v1$6.copy(e.center).sub(_toFarthestPoint)), this;
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$a = /* @__PURE__ */ new Vector3(), _segCenter = /* @__PURE__ */ new Vector3(), _segDir = /* @__PURE__ */ new Vector3(), _diff = /* @__PURE__ */ new Vector3(), _edge1 = /* @__PURE__ */ new Vector3(), _edge2 = /* @__PURE__ */ new Vector3(), _normal$1 = /* @__PURE__ */ new Vector3();
class Ray {
  constructor(e = new Vector3(), b = new Vector3(0, 0, -1)) {
    this.origin = e, this.direction = b;
  }
  set(e, b) {
    return this.origin.copy(e), this.direction.copy(b), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, b) {
    return b.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, _vector$a)), this;
  }
  closestPointToPoint(e, b) {
    b.subVectors(e, this.origin);
    const L = b.dot(this.direction);
    return L < 0 ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(L).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const b = _vector$a.subVectors(e, this.origin).dot(this.direction);
    return b < 0 ? this.origin.distanceToSquared(e) : (_vector$a.copy(this.direction).multiplyScalar(b).add(this.origin), _vector$a.distanceToSquared(e));
  }
  distanceSqToSegment(e, b, L, M) {
    _segCenter.copy(e).add(b).multiplyScalar(0.5), _segDir.copy(b).sub(e).normalize(), _diff.copy(this.origin).sub(_segCenter);
    const D = e.distanceTo(b) * 0.5, I = -this.direction.dot(_segDir), F = _diff.dot(this.direction), N = -_diff.dot(_segDir), U = _diff.lengthSq(), G = Math.abs(1 - I * I);
    let V, z, k, H;
    if (G > 0)
      if (V = I * N - F, z = I * F - N, H = D * G, V >= 0)
        if (z >= -H)
          if (z <= H) {
            const W = 1 / G;
            V *= W, z *= W, k = V * (V + I * z + 2 * F) + z * (I * V + z + 2 * N) + U;
          } else
            z = D, V = Math.max(0, -(I * z + F)), k = -V * V + z * (z + 2 * N) + U;
        else
          z = -D, V = Math.max(0, -(I * z + F)), k = -V * V + z * (z + 2 * N) + U;
      else
        z <= -H ? (V = Math.max(0, -(-I * D + F)), z = V > 0 ? -D : Math.min(Math.max(-D, -N), D), k = -V * V + z * (z + 2 * N) + U) : z <= H ? (V = 0, z = Math.min(Math.max(-D, -N), D), k = z * (z + 2 * N) + U) : (V = Math.max(0, -(I * D + F)), z = V > 0 ? D : Math.min(Math.max(-D, -N), D), k = -V * V + z * (z + 2 * N) + U);
    else
      z = I > 0 ? -D : D, V = Math.max(0, -(I * z + F)), k = -V * V + z * (z + 2 * N) + U;
    return L && L.copy(this.direction).multiplyScalar(V).add(this.origin), M && M.copy(_segDir).multiplyScalar(z).add(_segCenter), k;
  }
  intersectSphere(e, b) {
    _vector$a.subVectors(e.center, this.origin);
    const L = _vector$a.dot(this.direction), M = _vector$a.dot(_vector$a) - L * L, D = e.radius * e.radius;
    if (M > D) return null;
    const I = Math.sqrt(D - M), F = L - I, N = L + I;
    return F < 0 && N < 0 ? null : F < 0 ? this.at(N, b) : this.at(F, b);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const b = e.normal.dot(this.direction);
    if (b === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const L = -(this.origin.dot(e.normal) + e.constant) / b;
    return L >= 0 ? L : null;
  }
  intersectPlane(e, b) {
    const L = this.distanceToPlane(e);
    return L === null ? null : this.at(L, b);
  }
  intersectsPlane(e) {
    const b = e.distanceToPoint(this.origin);
    return b === 0 || e.normal.dot(this.direction) * b < 0;
  }
  intersectBox(e, b) {
    let L, M, D, I, F, N;
    const U = 1 / this.direction.x, G = 1 / this.direction.y, V = 1 / this.direction.z, z = this.origin;
    return U >= 0 ? (L = (e.min.x - z.x) * U, M = (e.max.x - z.x) * U) : (L = (e.max.x - z.x) * U, M = (e.min.x - z.x) * U), G >= 0 ? (D = (e.min.y - z.y) * G, I = (e.max.y - z.y) * G) : (D = (e.max.y - z.y) * G, I = (e.min.y - z.y) * G), L > I || D > M || ((D > L || L !== L) && (L = D), (I < M || M !== M) && (M = I), V >= 0 ? (F = (e.min.z - z.z) * V, N = (e.max.z - z.z) * V) : (F = (e.max.z - z.z) * V, N = (e.min.z - z.z) * V), L > N || F > M) || ((F > L || L !== L) && (L = F), (N < M || M !== M) && (M = N), M < 0) ? null : this.at(L >= 0 ? L : M, b);
  }
  intersectsBox(e) {
    return this.intersectBox(e, _vector$a) !== null;
  }
  intersectTriangle(e, b, L, M, D) {
    _edge1.subVectors(b, e), _edge2.subVectors(L, e), _normal$1.crossVectors(_edge1, _edge2);
    let I = this.direction.dot(_normal$1), F;
    if (I > 0) {
      if (M) return null;
      F = 1;
    } else if (I < 0)
      F = -1, I = -I;
    else
      return null;
    _diff.subVectors(this.origin, e);
    const N = F * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (N < 0)
      return null;
    const U = F * this.direction.dot(_edge1.cross(_diff));
    if (U < 0 || N + U > I)
      return null;
    const G = -F * _diff.dot(_normal$1);
    return G < 0 ? null : this.at(G / I, D);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
  }
  set(e, b, L, M, D, I, F, N, U, G, V, z, k, H, W, $) {
    const j = this.elements;
    return j[0] = e, j[4] = b, j[8] = L, j[12] = M, j[1] = D, j[5] = I, j[9] = F, j[13] = N, j[2] = U, j[6] = G, j[10] = V, j[14] = z, j[3] = k, j[7] = H, j[11] = W, j[15] = $, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(e) {
    const b = this.elements, L = e.elements;
    return b[0] = L[0], b[1] = L[1], b[2] = L[2], b[3] = L[3], b[4] = L[4], b[5] = L[5], b[6] = L[6], b[7] = L[7], b[8] = L[8], b[9] = L[9], b[10] = L[10], b[11] = L[11], b[12] = L[12], b[13] = L[13], b[14] = L[14], b[15] = L[15], this;
  }
  copyPosition(e) {
    const b = this.elements, L = e.elements;
    return b[12] = L[12], b[13] = L[13], b[14] = L[14], this;
  }
  setFromMatrix3(e) {
    const b = e.elements;
    return this.set(
      b[0],
      b[3],
      b[6],
      0,
      b[1],
      b[4],
      b[7],
      0,
      b[2],
      b[5],
      b[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, b, L) {
    return e.setFromMatrixColumn(this, 0), b.setFromMatrixColumn(this, 1), L.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, b, L) {
    return this.set(
      e.x,
      b.x,
      L.x,
      0,
      e.y,
      b.y,
      L.y,
      0,
      e.z,
      b.z,
      L.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const b = this.elements, L = e.elements, M = 1 / _v1$5.setFromMatrixColumn(e, 0).length(), D = 1 / _v1$5.setFromMatrixColumn(e, 1).length(), I = 1 / _v1$5.setFromMatrixColumn(e, 2).length();
    return b[0] = L[0] * M, b[1] = L[1] * M, b[2] = L[2] * M, b[3] = 0, b[4] = L[4] * D, b[5] = L[5] * D, b[6] = L[6] * D, b[7] = 0, b[8] = L[8] * I, b[9] = L[9] * I, b[10] = L[10] * I, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    const b = this.elements, L = e.x, M = e.y, D = e.z, I = Math.cos(L), F = Math.sin(L), N = Math.cos(M), U = Math.sin(M), G = Math.cos(D), V = Math.sin(D);
    if (e.order === "XYZ") {
      const z = I * G, k = I * V, H = F * G, W = F * V;
      b[0] = N * G, b[4] = -N * V, b[8] = U, b[1] = k + H * U, b[5] = z - W * U, b[9] = -F * N, b[2] = W - z * U, b[6] = H + k * U, b[10] = I * N;
    } else if (e.order === "YXZ") {
      const z = N * G, k = N * V, H = U * G, W = U * V;
      b[0] = z + W * F, b[4] = H * F - k, b[8] = I * U, b[1] = I * V, b[5] = I * G, b[9] = -F, b[2] = k * F - H, b[6] = W + z * F, b[10] = I * N;
    } else if (e.order === "ZXY") {
      const z = N * G, k = N * V, H = U * G, W = U * V;
      b[0] = z - W * F, b[4] = -I * V, b[8] = H + k * F, b[1] = k + H * F, b[5] = I * G, b[9] = W - z * F, b[2] = -I * U, b[6] = F, b[10] = I * N;
    } else if (e.order === "ZYX") {
      const z = I * G, k = I * V, H = F * G, W = F * V;
      b[0] = N * G, b[4] = H * U - k, b[8] = z * U + W, b[1] = N * V, b[5] = W * U + z, b[9] = k * U - H, b[2] = -U, b[6] = F * N, b[10] = I * N;
    } else if (e.order === "YZX") {
      const z = I * N, k = I * U, H = F * N, W = F * U;
      b[0] = N * G, b[4] = W - z * V, b[8] = H * V + k, b[1] = V, b[5] = I * G, b[9] = -F * G, b[2] = -U * G, b[6] = k * V + H, b[10] = z - W * V;
    } else if (e.order === "XZY") {
      const z = I * N, k = I * U, H = F * N, W = F * U;
      b[0] = N * G, b[4] = -V, b[8] = U * G, b[1] = z * V + W, b[5] = I * G, b[9] = k * V - H, b[2] = H * V - k, b[6] = F * G, b[10] = W * V + z;
    }
    return b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(_zero, e, _one);
  }
  lookAt(e, b, L) {
    const M = this.elements;
    return _z.subVectors(e, b), _z.lengthSq() === 0 && (_z.z = 1), _z.normalize(), _x.crossVectors(L, _z), _x.lengthSq() === 0 && (Math.abs(L.z) === 1 ? _z.x += 1e-4 : _z.z += 1e-4, _z.normalize(), _x.crossVectors(L, _z)), _x.normalize(), _y.crossVectors(_z, _x), M[0] = _x.x, M[4] = _y.x, M[8] = _z.x, M[1] = _x.y, M[5] = _y.y, M[9] = _z.y, M[2] = _x.z, M[6] = _y.z, M[10] = _z.z, this;
  }
  multiply(e, b) {
    return b !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, b)) : this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, b) {
    const L = e.elements, M = b.elements, D = this.elements, I = L[0], F = L[4], N = L[8], U = L[12], G = L[1], V = L[5], z = L[9], k = L[13], H = L[2], W = L[6], $ = L[10], j = L[14], q = L[3], Y = L[7], J = L[11], K = L[15], X = M[0], Z = M[4], Q = M[8], ne = M[12], le = M[1], pe = M[5], ue = M[9], oe = M[13], ae = M[2], se = M[6], ie = M[10], ye = M[14], Ce = M[3], de = M[7], ve = M[11], ce = M[15];
    return D[0] = I * X + F * le + N * ae + U * Ce, D[4] = I * Z + F * pe + N * se + U * de, D[8] = I * Q + F * ue + N * ie + U * ve, D[12] = I * ne + F * oe + N * ye + U * ce, D[1] = G * X + V * le + z * ae + k * Ce, D[5] = G * Z + V * pe + z * se + k * de, D[9] = G * Q + V * ue + z * ie + k * ve, D[13] = G * ne + V * oe + z * ye + k * ce, D[2] = H * X + W * le + $ * ae + j * Ce, D[6] = H * Z + W * pe + $ * se + j * de, D[10] = H * Q + W * ue + $ * ie + j * ve, D[14] = H * ne + W * oe + $ * ye + j * ce, D[3] = q * X + Y * le + J * ae + K * Ce, D[7] = q * Z + Y * pe + J * se + K * de, D[11] = q * Q + Y * ue + J * ie + K * ve, D[15] = q * ne + Y * oe + J * ye + K * ce, this;
  }
  multiplyScalar(e) {
    const b = this.elements;
    return b[0] *= e, b[4] *= e, b[8] *= e, b[12] *= e, b[1] *= e, b[5] *= e, b[9] *= e, b[13] *= e, b[2] *= e, b[6] *= e, b[10] *= e, b[14] *= e, b[3] *= e, b[7] *= e, b[11] *= e, b[15] *= e, this;
  }
  determinant() {
    const e = this.elements, b = e[0], L = e[4], M = e[8], D = e[12], I = e[1], F = e[5], N = e[9], U = e[13], G = e[2], V = e[6], z = e[10], k = e[14], H = e[3], W = e[7], $ = e[11], j = e[15];
    return H * (+D * N * V - M * U * V - D * F * z + L * U * z + M * F * k - L * N * k) + W * (+b * N * k - b * U * z + D * I * z - M * I * k + M * U * G - D * N * G) + $ * (+b * U * V - b * F * k - D * I * V + L * I * k + D * F * G - L * U * G) + j * (-M * F * G - b * N * V + b * F * z + M * I * V - L * I * z + L * N * G);
  }
  transpose() {
    const e = this.elements;
    let b;
    return b = e[1], e[1] = e[4], e[4] = b, b = e[2], e[2] = e[8], e[8] = b, b = e[6], e[6] = e[9], e[9] = b, b = e[3], e[3] = e[12], e[12] = b, b = e[7], e[7] = e[13], e[13] = b, b = e[11], e[11] = e[14], e[14] = b, this;
  }
  setPosition(e, b, L) {
    const M = this.elements;
    return e.isVector3 ? (M[12] = e.x, M[13] = e.y, M[14] = e.z) : (M[12] = e, M[13] = b, M[14] = L), this;
  }
  invert() {
    const e = this.elements, b = e[0], L = e[1], M = e[2], D = e[3], I = e[4], F = e[5], N = e[6], U = e[7], G = e[8], V = e[9], z = e[10], k = e[11], H = e[12], W = e[13], $ = e[14], j = e[15], q = V * $ * U - W * z * U + W * N * k - F * $ * k - V * N * j + F * z * j, Y = H * z * U - G * $ * U - H * N * k + I * $ * k + G * N * j - I * z * j, J = G * W * U - H * V * U + H * F * k - I * W * k - G * F * j + I * V * j, K = H * V * N - G * W * N - H * F * z + I * W * z + G * F * $ - I * V * $, X = b * q + L * Y + M * J + D * K;
    if (X === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const Z = 1 / X;
    return e[0] = q * Z, e[1] = (W * z * D - V * $ * D - W * M * k + L * $ * k + V * M * j - L * z * j) * Z, e[2] = (F * $ * D - W * N * D + W * M * U - L * $ * U - F * M * j + L * N * j) * Z, e[3] = (V * N * D - F * z * D - V * M * U + L * z * U + F * M * k - L * N * k) * Z, e[4] = Y * Z, e[5] = (G * $ * D - H * z * D + H * M * k - b * $ * k - G * M * j + b * z * j) * Z, e[6] = (H * N * D - I * $ * D - H * M * U + b * $ * U + I * M * j - b * N * j) * Z, e[7] = (I * z * D - G * N * D + G * M * U - b * z * U - I * M * k + b * N * k) * Z, e[8] = J * Z, e[9] = (H * V * D - G * W * D - H * L * k + b * W * k + G * L * j - b * V * j) * Z, e[10] = (I * W * D - H * F * D + H * L * U - b * W * U - I * L * j + b * F * j) * Z, e[11] = (G * F * D - I * V * D - G * L * U + b * V * U + I * L * k - b * F * k) * Z, e[12] = K * Z, e[13] = (G * W * M - H * V * M + H * L * z - b * W * z - G * L * $ + b * V * $) * Z, e[14] = (H * F * M - I * W * M - H * L * N + b * W * N + I * L * $ - b * F * $) * Z, e[15] = (I * V * M - G * F * M + G * L * N - b * V * N - I * L * z + b * F * z) * Z, this;
  }
  scale(e) {
    const b = this.elements, L = e.x, M = e.y, D = e.z;
    return b[0] *= L, b[4] *= M, b[8] *= D, b[1] *= L, b[5] *= M, b[9] *= D, b[2] *= L, b[6] *= M, b[10] *= D, b[3] *= L, b[7] *= M, b[11] *= D, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, b = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], L = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], M = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(b, L, M));
  }
  makeTranslation(e, b, L) {
    return this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      b,
      0,
      0,
      1,
      L,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const b = Math.cos(e), L = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      b,
      -L,
      0,
      0,
      L,
      b,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const b = Math.cos(e), L = Math.sin(e);
    return this.set(
      b,
      0,
      L,
      0,
      0,
      1,
      0,
      0,
      -L,
      0,
      b,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const b = Math.cos(e), L = Math.sin(e);
    return this.set(
      b,
      -L,
      0,
      0,
      L,
      b,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, b) {
    const L = Math.cos(b), M = Math.sin(b), D = 1 - L, I = e.x, F = e.y, N = e.z, U = D * I, G = D * F;
    return this.set(
      U * I + L,
      U * F - M * N,
      U * N + M * F,
      0,
      U * F + M * N,
      G * F + L,
      G * N - M * I,
      0,
      U * N - M * F,
      G * N + M * I,
      D * N * N + L,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, b, L) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      L,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, b, L, M, D, I) {
    return this.set(
      1,
      L,
      D,
      0,
      e,
      1,
      I,
      0,
      b,
      M,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, b, L) {
    const M = this.elements, D = b._x, I = b._y, F = b._z, N = b._w, U = D + D, G = I + I, V = F + F, z = D * U, k = D * G, H = D * V, W = I * G, $ = I * V, j = F * V, q = N * U, Y = N * G, J = N * V, K = L.x, X = L.y, Z = L.z;
    return M[0] = (1 - (W + j)) * K, M[1] = (k + J) * K, M[2] = (H - Y) * K, M[3] = 0, M[4] = (k - J) * X, M[5] = (1 - (z + j)) * X, M[6] = ($ + q) * X, M[7] = 0, M[8] = (H + Y) * Z, M[9] = ($ - q) * Z, M[10] = (1 - (z + W)) * Z, M[11] = 0, M[12] = e.x, M[13] = e.y, M[14] = e.z, M[15] = 1, this;
  }
  decompose(e, b, L) {
    const M = this.elements;
    let D = _v1$5.set(M[0], M[1], M[2]).length();
    const I = _v1$5.set(M[4], M[5], M[6]).length(), F = _v1$5.set(M[8], M[9], M[10]).length();
    this.determinant() < 0 && (D = -D), e.x = M[12], e.y = M[13], e.z = M[14], _m1$2.copy(this);
    const U = 1 / D, G = 1 / I, V = 1 / F;
    return _m1$2.elements[0] *= U, _m1$2.elements[1] *= U, _m1$2.elements[2] *= U, _m1$2.elements[4] *= G, _m1$2.elements[5] *= G, _m1$2.elements[6] *= G, _m1$2.elements[8] *= V, _m1$2.elements[9] *= V, _m1$2.elements[10] *= V, b.setFromRotationMatrix(_m1$2), L.x = D, L.y = I, L.z = F, this;
  }
  makePerspective(e, b, L, M, D, I) {
    I === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    const F = this.elements, N = 2 * D / (b - e), U = 2 * D / (L - M), G = (b + e) / (b - e), V = (L + M) / (L - M), z = -(I + D) / (I - D), k = -2 * I * D / (I - D);
    return F[0] = N, F[4] = 0, F[8] = G, F[12] = 0, F[1] = 0, F[5] = U, F[9] = V, F[13] = 0, F[2] = 0, F[6] = 0, F[10] = z, F[14] = k, F[3] = 0, F[7] = 0, F[11] = -1, F[15] = 0, this;
  }
  makeOrthographic(e, b, L, M, D, I) {
    const F = this.elements, N = 1 / (b - e), U = 1 / (L - M), G = 1 / (I - D), V = (b + e) * N, z = (L + M) * U, k = (I + D) * G;
    return F[0] = 2 * N, F[4] = 0, F[8] = 0, F[12] = -V, F[1] = 0, F[5] = 2 * U, F[9] = 0, F[13] = -z, F[2] = 0, F[6] = 0, F[10] = -2 * G, F[14] = -k, F[3] = 0, F[7] = 0, F[11] = 0, F[15] = 1, this;
  }
  equals(e) {
    const b = this.elements, L = e.elements;
    for (let M = 0; M < 16; M++)
      if (b[M] !== L[M]) return !1;
    return !0;
  }
  fromArray(e, b = 0) {
    for (let L = 0; L < 16; L++)
      this.elements[L] = e[L + b];
    return this;
  }
  toArray(e = [], b = 0) {
    const L = this.elements;
    return e[b] = L[0], e[b + 1] = L[1], e[b + 2] = L[2], e[b + 3] = L[3], e[b + 4] = L[4], e[b + 5] = L[5], e[b + 6] = L[6], e[b + 7] = L[7], e[b + 8] = L[8], e[b + 9] = L[9], e[b + 10] = L[10], e[b + 11] = L[11], e[b + 12] = L[12], e[b + 13] = L[13], e[b + 14] = L[14], e[b + 15] = L[15], e;
  }
}
Matrix4.prototype.isMatrix4 = !0;
const _v1$5 = /* @__PURE__ */ new Vector3(), _m1$2 = /* @__PURE__ */ new Matrix4(), _zero = /* @__PURE__ */ new Vector3(0, 0, 0), _one = /* @__PURE__ */ new Vector3(1, 1, 1), _x = /* @__PURE__ */ new Vector3(), _y = /* @__PURE__ */ new Vector3(), _z = /* @__PURE__ */ new Vector3(), _matrix$1 = /* @__PURE__ */ new Matrix4(), _quaternion$3 = /* @__PURE__ */ new Quaternion();
class Euler {
  constructor(e = 0, b = 0, L = 0, M = Euler.DefaultOrder) {
    this._x = e, this._y = b, this._z = L, this._order = M;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, b, L, M = this._order) {
    return this._x = e, this._y = b, this._z = L, this._order = M, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, b = this._order, L = !0) {
    const M = e.elements, D = M[0], I = M[4], F = M[8], N = M[1], U = M[5], G = M[9], V = M[2], z = M[6], k = M[10];
    switch (b) {
      case "XYZ":
        this._y = Math.asin(clamp(F, -1, 1)), Math.abs(F) < 0.9999999 ? (this._x = Math.atan2(-G, k), this._z = Math.atan2(-I, D)) : (this._x = Math.atan2(z, U), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(G, -1, 1)), Math.abs(G) < 0.9999999 ? (this._y = Math.atan2(F, k), this._z = Math.atan2(N, U)) : (this._y = Math.atan2(-V, D), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(clamp(z, -1, 1)), Math.abs(z) < 0.9999999 ? (this._y = Math.atan2(-V, k), this._z = Math.atan2(-I, U)) : (this._y = 0, this._z = Math.atan2(N, D));
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(V, -1, 1)), Math.abs(V) < 0.9999999 ? (this._x = Math.atan2(z, k), this._z = Math.atan2(N, D)) : (this._x = 0, this._z = Math.atan2(-I, U));
        break;
      case "YZX":
        this._z = Math.asin(clamp(N, -1, 1)), Math.abs(N) < 0.9999999 ? (this._x = Math.atan2(-G, U), this._y = Math.atan2(-V, D)) : (this._x = 0, this._y = Math.atan2(F, k));
        break;
      case "XZY":
        this._z = Math.asin(-clamp(I, -1, 1)), Math.abs(I) < 0.9999999 ? (this._x = Math.atan2(z, U), this._y = Math.atan2(F, D)) : (this._x = Math.atan2(-G, k), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + b);
    }
    return this._order = b, L === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, b, L) {
    return _matrix$1.makeRotationFromQuaternion(e), this.setFromRotationMatrix(_matrix$1, b, L);
  }
  setFromVector3(e, b = this._order) {
    return this.set(e.x, e.y, e.z, b);
  }
  reorder(e) {
    return _quaternion$3.setFromEuler(this), this.setFromQuaternion(_quaternion$3, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], b = 0) {
    return e[b] = this._x, e[b + 1] = this._y, e[b + 2] = this._z, e[b + 3] = this._order, e;
  }
  toVector3(e) {
    return e ? e.set(this._x, this._y, this._z) : new Vector3(this._x, this._y, this._z);
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
}
Euler.prototype.isEuler = !0;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class Layers {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = 1 << e | 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = /* @__PURE__ */ new Vector3(), _q1 = /* @__PURE__ */ new Quaternion(), _m1$1 = /* @__PURE__ */ new Matrix4(), _target = /* @__PURE__ */ new Vector3(), _position$3 = /* @__PURE__ */ new Vector3(), _scale$2 = /* @__PURE__ */ new Vector3(), _quaternion$2 = /* @__PURE__ */ new Quaternion(), _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0), _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0), _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1), _addedEvent = { type: "added" }, _removedEvent = { type: "removed" };
class Object3D extends EventDispatcher$1 {
  constructor() {
    super(), Object.defineProperty(this, "id", { value: _object3DId++ }), this.uuid = generateUUID$1(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Object3D.DefaultUp.clone();
    const e = new Vector3(), b = new Euler(), L = new Quaternion(), M = new Vector3(1, 1, 1);
    function D() {
      L.setFromEuler(b, !1);
    }
    function I() {
      b.setFromQuaternion(L, void 0, !1);
    }
    b._onChange(D), L._onChange(I), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: b
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: L
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: M
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    }), this.matrix = new Matrix4(), this.matrixWorld = new Matrix4(), this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Layers(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, b) {
    this.quaternion.setFromAxisAngle(e, b);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, b) {
    return _q1.setFromAxisAngle(e, b), this.quaternion.multiply(_q1), this;
  }
  rotateOnWorldAxis(e, b) {
    return _q1.setFromAxisAngle(e, b), this.quaternion.premultiply(_q1), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(_xAxis, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(_yAxis, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(_zAxis, e);
  }
  translateOnAxis(e, b) {
    return _v1$4.copy(e).applyQuaternion(this.quaternion), this.position.add(_v1$4.multiplyScalar(b)), this;
  }
  translateX(e) {
    return this.translateOnAxis(_xAxis, e);
  }
  translateY(e) {
    return this.translateOnAxis(_yAxis, e);
  }
  translateZ(e) {
    return this.translateOnAxis(_zAxis, e);
  }
  localToWorld(e) {
    return e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return e.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  lookAt(e, b, L) {
    e.isVector3 ? _target.copy(e) : _target.set(e, b, L);
    const M = this.parent;
    this.updateWorldMatrix(!0, !1), _position$3.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? _m1$1.lookAt(_position$3, _target, this.up) : _m1$1.lookAt(_target, _position$3, this.up), this.quaternion.setFromRotationMatrix(_m1$1), M && (_m1$1.extractRotation(M.matrixWorld), _q1.setFromRotationMatrix(_m1$1), this.quaternion.premultiply(_q1.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let b = 0; b < arguments.length; b++)
        this.add(arguments[b]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(_addedEvent)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let L = 0; L < arguments.length; L++)
        this.remove(arguments[L]);
      return this;
    }
    const b = this.children.indexOf(e);
    return b !== -1 && (e.parent = null, this.children.splice(b, 1), e.dispatchEvent(_removedEvent)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const b = this.children[e];
      b.parent = null, b.dispatchEvent(_removedEvent);
    }
    return this.children.length = 0, this;
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), _m1$1.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), _m1$1.multiply(e.parent.matrixWorld)), e.applyMatrix4(_m1$1), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, b) {
    if (this[e] === b) return this;
    for (let L = 0, M = this.children.length; L < M; L++) {
      const I = this.children[L].getObjectByProperty(e, b);
      if (I !== void 0)
        return I;
    }
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, e, _scale$2), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, _quaternion$2, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const b = this.matrixWorld.elements;
    return e.set(b[8], b[9], b[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const b = this.children;
    for (let L = 0, M = b.length; L < M; L++)
      b[L].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const b = this.children;
    for (let L = 0, M = b.length; L < M; L++)
      b[L].traverseVisible(e);
  }
  traverseAncestors(e) {
    const b = this.parent;
    b !== null && (e(b), b.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const b = this.children;
    for (let L = 0, M = b.length; L < M; L++)
      b[L].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, b) {
    const L = this.parent;
    if (e === !0 && L !== null && L.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), b === !0) {
      const M = this.children;
      for (let D = 0, I = M.length; D < I; D++)
        M[D].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const b = e === void 0 || typeof e == "string", L = {};
    b && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {}
    }, L.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const M = {};
    M.uuid = this.uuid, M.type = this.type, this.name !== "" && (M.name = this.name), this.castShadow === !0 && (M.castShadow = !0), this.receiveShadow === !0 && (M.receiveShadow = !0), this.visible === !1 && (M.visible = !1), this.frustumCulled === !1 && (M.frustumCulled = !1), this.renderOrder !== 0 && (M.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (M.userData = this.userData), M.layers = this.layers.mask, M.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (M.matrixAutoUpdate = !1), this.isInstancedMesh && (M.type = "InstancedMesh", M.count = this.count, M.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (M.instanceColor = this.instanceColor.toJSON()));
    function D(F, N) {
      return F[N.uuid] === void 0 && (F[N.uuid] = N.toJSON(e)), N.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? M.background = this.background.toJSON() : this.background.isTexture && (M.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (M.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      M.geometry = D(e.geometries, this.geometry);
      const F = this.geometry.parameters;
      if (F !== void 0 && F.shapes !== void 0) {
        const N = F.shapes;
        if (Array.isArray(N))
          for (let U = 0, G = N.length; U < G; U++) {
            const V = N[U];
            D(e.shapes, V);
          }
        else
          D(e.shapes, N);
      }
    }
    if (this.isSkinnedMesh && (M.bindMode = this.bindMode, M.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (D(e.skeletons, this.skeleton), M.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const F = [];
        for (let N = 0, U = this.material.length; N < U; N++)
          F.push(D(e.materials, this.material[N]));
        M.material = F;
      } else
        M.material = D(e.materials, this.material);
    if (this.children.length > 0) {
      M.children = [];
      for (let F = 0; F < this.children.length; F++)
        M.children.push(this.children[F].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      M.animations = [];
      for (let F = 0; F < this.animations.length; F++) {
        const N = this.animations[F];
        M.animations.push(D(e.animations, N));
      }
    }
    if (b) {
      const F = I(e.geometries), N = I(e.materials), U = I(e.textures), G = I(e.images), V = I(e.shapes), z = I(e.skeletons), k = I(e.animations);
      F.length > 0 && (L.geometries = F), N.length > 0 && (L.materials = N), U.length > 0 && (L.textures = U), G.length > 0 && (L.images = G), V.length > 0 && (L.shapes = V), z.length > 0 && (L.skeletons = z), k.length > 0 && (L.animations = k);
    }
    return L.object = M, L;
    function I(F) {
      const N = [];
      for (const U in F) {
        const G = F[U];
        delete G.metadata, N.push(G);
      }
      return N;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, b = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), b === !0)
      for (let L = 0; L < e.children.length; L++) {
        const M = e.children[L];
        this.add(M.clone());
      }
    return this;
  }
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = !0;
Object3D.prototype.isObject3D = !0;
const _v0$1 = /* @__PURE__ */ new Vector3(), _v1$3 = /* @__PURE__ */ new Vector3(), _v2$2 = /* @__PURE__ */ new Vector3(), _v3$1 = /* @__PURE__ */ new Vector3(), _vab = /* @__PURE__ */ new Vector3(), _vac = /* @__PURE__ */ new Vector3(), _vbc = /* @__PURE__ */ new Vector3(), _vap = /* @__PURE__ */ new Vector3(), _vbp = /* @__PURE__ */ new Vector3(), _vcp = /* @__PURE__ */ new Vector3();
class Triangle {
  constructor(e = new Vector3(), b = new Vector3(), L = new Vector3()) {
    this.a = e, this.b = b, this.c = L;
  }
  static getNormal(e, b, L, M) {
    M.subVectors(L, b), _v0$1.subVectors(e, b), M.cross(_v0$1);
    const D = M.lengthSq();
    return D > 0 ? M.multiplyScalar(1 / Math.sqrt(D)) : M.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, b, L, M, D) {
    _v0$1.subVectors(M, b), _v1$3.subVectors(L, b), _v2$2.subVectors(e, b);
    const I = _v0$1.dot(_v0$1), F = _v0$1.dot(_v1$3), N = _v0$1.dot(_v2$2), U = _v1$3.dot(_v1$3), G = _v1$3.dot(_v2$2), V = I * U - F * F;
    if (V === 0)
      return D.set(-2, -1, -1);
    const z = 1 / V, k = (U * N - F * G) * z, H = (I * G - F * N) * z;
    return D.set(1 - k - H, H, k);
  }
  static containsPoint(e, b, L, M) {
    return this.getBarycoord(e, b, L, M, _v3$1), _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(e, b, L, M, D, I, F, N) {
    return this.getBarycoord(e, b, L, M, _v3$1), N.set(0, 0), N.addScaledVector(D, _v3$1.x), N.addScaledVector(I, _v3$1.y), N.addScaledVector(F, _v3$1.z), N;
  }
  static isFrontFacing(e, b, L, M) {
    return _v0$1.subVectors(L, b), _v1$3.subVectors(e, b), _v0$1.cross(_v1$3).dot(M) < 0;
  }
  set(e, b, L) {
    return this.a.copy(e), this.b.copy(b), this.c.copy(L), this;
  }
  setFromPointsAndIndices(e, b, L, M) {
    return this.a.copy(e[b]), this.b.copy(e[L]), this.c.copy(e[M]), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return _v0$1.subVectors(this.c, this.b), _v1$3.subVectors(this.a, this.b), _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Triangle.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, b) {
    return Triangle.getBarycoord(e, this.a, this.b, this.c, b);
  }
  getUV(e, b, L, M, D) {
    return Triangle.getUV(e, this.a, this.b, this.c, b, L, M, D);
  }
  containsPoint(e) {
    return Triangle.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, b) {
    const L = this.a, M = this.b, D = this.c;
    let I, F;
    _vab.subVectors(M, L), _vac.subVectors(D, L), _vap.subVectors(e, L);
    const N = _vab.dot(_vap), U = _vac.dot(_vap);
    if (N <= 0 && U <= 0)
      return b.copy(L);
    _vbp.subVectors(e, M);
    const G = _vab.dot(_vbp), V = _vac.dot(_vbp);
    if (G >= 0 && V <= G)
      return b.copy(M);
    const z = N * V - G * U;
    if (z <= 0 && N >= 0 && G <= 0)
      return I = N / (N - G), b.copy(L).addScaledVector(_vab, I);
    _vcp.subVectors(e, D);
    const k = _vab.dot(_vcp), H = _vac.dot(_vcp);
    if (H >= 0 && k <= H)
      return b.copy(D);
    const W = k * U - N * H;
    if (W <= 0 && U >= 0 && H <= 0)
      return F = U / (U - H), b.copy(L).addScaledVector(_vac, F);
    const $ = G * H - k * V;
    if ($ <= 0 && V - G >= 0 && k - H >= 0)
      return _vbc.subVectors(D, M), F = (V - G) / (V - G + (k - H)), b.copy(M).addScaledVector(_vbc, F);
    const j = 1 / ($ + W + z);
    return I = W * j, F = z * j, b.copy(L).addScaledVector(_vab, I).addScaledVector(_vac, F);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let materialId = 0;
class Material extends EventDispatcher$1 {
  constructor() {
    super(), Object.defineProperty(this, "id", { value: materialId++ }), this.uuid = generateUUID$1(), this.name = "", this.type = "Material", this.fog = !0, this.blending = NormalBlending, this.side = FrontSide, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = SrcAlphaFactor, this.blendDst = OneMinusSrcAlphaFactor, this.blendEquation = AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = LessEqualDepth, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = AlwaysStencilFunc, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = KeepStencilOp, this.stencilZFail = KeepStencilOp, this.stencilZPass = KeepStencilOp, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0;
  }
  onBuild() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const b in e) {
        const L = e[b];
        if (L === void 0) {
          console.warn("THREE.Material: '" + b + "' parameter is undefined.");
          continue;
        }
        if (b === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = L === FlatShading;
          continue;
        }
        const M = this[b];
        if (M === void 0) {
          console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.");
          continue;
        }
        M && M.isColor ? M.set(L) : M && M.isVector3 && L && L.isVector3 ? M.copy(L) : this[b] = L;
      }
  }
  toJSON(e) {
    const b = e === void 0 || typeof e == "string";
    b && (e = {
      textures: {},
      images: {}
    });
    const L = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    L.uuid = this.uuid, L.type = this.type, this.name !== "" && (L.name = this.name), this.color && this.color.isColor && (L.color = this.color.getHex()), this.roughness !== void 0 && (L.roughness = this.roughness), this.metalness !== void 0 && (L.metalness = this.metalness), this.sheen && this.sheen.isColor && (L.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (L.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (L.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (L.specular = this.specular.getHex()), this.shininess !== void 0 && (L.shininess = this.shininess), this.clearcoat !== void 0 && (L.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (L.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (L.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (L.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (L.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, L.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (L.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (L.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (L.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (L.lightMap = this.lightMap.toJSON(e).uuid, L.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (L.aoMap = this.aoMap.toJSON(e).uuid, L.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (L.bumpMap = this.bumpMap.toJSON(e).uuid, L.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (L.normalMap = this.normalMap.toJSON(e).uuid, L.normalMapType = this.normalMapType, L.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (L.displacementMap = this.displacementMap.toJSON(e).uuid, L.displacementScale = this.displacementScale, L.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (L.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (L.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (L.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (L.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (L.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (L.combine = this.combine)), this.envMapIntensity !== void 0 && (L.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (L.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (L.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (L.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (L.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (L.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (L.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (L.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && (L.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (L.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (L.size = this.size), this.shadowSide !== null && (L.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (L.sizeAttenuation = this.sizeAttenuation), this.blending !== NormalBlending && (L.blending = this.blending), this.side !== FrontSide && (L.side = this.side), this.vertexColors && (L.vertexColors = !0), this.opacity < 1 && (L.opacity = this.opacity), this.transparent === !0 && (L.transparent = this.transparent), L.depthFunc = this.depthFunc, L.depthTest = this.depthTest, L.depthWrite = this.depthWrite, L.colorWrite = this.colorWrite, L.stencilWrite = this.stencilWrite, L.stencilWriteMask = this.stencilWriteMask, L.stencilFunc = this.stencilFunc, L.stencilRef = this.stencilRef, L.stencilFuncMask = this.stencilFuncMask, L.stencilFail = this.stencilFail, L.stencilZFail = this.stencilZFail, L.stencilZPass = this.stencilZPass, this.rotation && this.rotation !== 0 && (L.rotation = this.rotation), this.polygonOffset === !0 && (L.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (L.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (L.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && this.linewidth !== 1 && (L.linewidth = this.linewidth), this.dashSize !== void 0 && (L.dashSize = this.dashSize), this.gapSize !== void 0 && (L.gapSize = this.gapSize), this.scale !== void 0 && (L.scale = this.scale), this.dithering === !0 && (L.dithering = !0), this.alphaTest > 0 && (L.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (L.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (L.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (L.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (L.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (L.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (L.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === !0 && (L.morphTargets = !0), this.morphNormals === !0 && (L.morphNormals = !0), this.flatShading === !0 && (L.flatShading = this.flatShading), this.visible === !1 && (L.visible = !1), this.toneMapped === !1 && (L.toneMapped = !1), JSON.stringify(this.userData) !== "{}" && (L.userData = this.userData);
    function M(D) {
      const I = [];
      for (const F in D) {
        const N = D[F];
        delete N.metadata, I.push(N);
      }
      return I;
    }
    if (b) {
      const D = M(e.textures), I = M(e.images);
      D.length > 0 && (L.textures = D), I.length > 0 && (L.images = I);
    }
    return L;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const b = e.clippingPlanes;
    let L = null;
    if (b !== null) {
      const M = b.length;
      L = new Array(M);
      for (let D = 0; D !== M; ++D)
        L[D] = b[D].clone();
    }
    return this.clippingPlanes = L, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
Material.prototype.isMaterial = !0;
const _colorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, _hslA = { h: 0, s: 0, l: 0 }, _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(B, e, b) {
  return b < 0 && (b += 1), b > 1 && (b -= 1), b < 1 / 6 ? B + (e - B) * 6 * b : b < 1 / 2 ? e : b < 2 / 3 ? B + (e - B) * 6 * (2 / 3 - b) : B;
}
function SRGBToLinear(B) {
  return B < 0.04045 ? B * 0.0773993808 : Math.pow(B * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(B) {
  return B < 31308e-7 ? B * 12.92 : 1.055 * Math.pow(B, 0.41666) - 0.055;
}
class Color {
  constructor(e, b, L) {
    return b === void 0 && L === void 0 ? this.set(e) : this.setRGB(e, b, L);
  }
  set(e) {
    return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, this;
  }
  setRGB(e, b, L) {
    return this.r = e, this.g = b, this.b = L, this;
  }
  setHSL(e, b, L) {
    if (e = euclideanModulo(e, 1), b = clamp(b, 0, 1), L = clamp(L, 0, 1), b === 0)
      this.r = this.g = this.b = L;
    else {
      const M = L <= 0.5 ? L * (1 + b) : L + b - L * b, D = 2 * L - M;
      this.r = hue2rgb(D, M, e + 1 / 3), this.g = hue2rgb(D, M, e), this.b = hue2rgb(D, M, e - 1 / 3);
    }
    return this;
  }
  setStyle(e) {
    function b(M) {
      M !== void 0 && parseFloat(M) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let L;
    if (L = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
      let M;
      const D = L[1], I = L[2];
      switch (D) {
        case "rgb":
        case "rgba":
          if (M = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(I))
            return this.r = Math.min(255, parseInt(M[1], 10)) / 255, this.g = Math.min(255, parseInt(M[2], 10)) / 255, this.b = Math.min(255, parseInt(M[3], 10)) / 255, b(M[4]), this;
          if (M = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(I))
            return this.r = Math.min(100, parseInt(M[1], 10)) / 100, this.g = Math.min(100, parseInt(M[2], 10)) / 100, this.b = Math.min(100, parseInt(M[3], 10)) / 100, b(M[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (M = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(I)) {
            const F = parseFloat(M[1]) / 360, N = parseInt(M[2], 10) / 100, U = parseInt(M[3], 10) / 100;
            return b(M[4]), this.setHSL(F, N, U);
          }
          break;
      }
    } else if (L = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const M = L[1], D = M.length;
      if (D === 3)
        return this.r = parseInt(M.charAt(0) + M.charAt(0), 16) / 255, this.g = parseInt(M.charAt(1) + M.charAt(1), 16) / 255, this.b = parseInt(M.charAt(2) + M.charAt(2), 16) / 255, this;
      if (D === 6)
        return this.r = parseInt(M.charAt(0) + M.charAt(1), 16) / 255, this.g = parseInt(M.charAt(2) + M.charAt(3), 16) / 255, this.b = parseInt(M.charAt(4) + M.charAt(5), 16) / 255, this;
    }
    return e && e.length > 0 ? this.setColorName(e) : this;
  }
  setColorName(e) {
    const b = _colorKeywords[e.toLowerCase()];
    return b !== void 0 ? this.setHex(b) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copyGammaToLinear(e, b = 2) {
    return this.r = Math.pow(e.r, b), this.g = Math.pow(e.g, b), this.b = Math.pow(e.b, b), this;
  }
  copyLinearToGamma(e, b = 2) {
    const L = b > 0 ? 1 / b : 1;
    return this.r = Math.pow(e.r, L), this.g = Math.pow(e.g, L), this.b = Math.pow(e.b, L), this;
  }
  convertGammaToLinear(e) {
    return this.copyGammaToLinear(this, e), this;
  }
  convertLinearToGamma(e) {
    return this.copyLinearToGamma(this, e), this;
  }
  copySRGBToLinear(e) {
    return this.r = SRGBToLinear(e.r), this.g = SRGBToLinear(e.g), this.b = SRGBToLinear(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = LinearToSRGB(e.r), this.g = LinearToSRGB(e.g), this.b = LinearToSRGB(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(e) {
    const b = this.r, L = this.g, M = this.b, D = Math.max(b, L, M), I = Math.min(b, L, M);
    let F, N;
    const U = (I + D) / 2;
    if (I === D)
      F = 0, N = 0;
    else {
      const G = D - I;
      switch (N = U <= 0.5 ? G / (D + I) : G / (2 - D - I), D) {
        case b:
          F = (L - M) / G + (L < M ? 6 : 0);
          break;
        case L:
          F = (M - b) / G + 2;
          break;
        case M:
          F = (b - L) / G + 4;
          break;
      }
      F /= 6;
    }
    return e.h = F, e.s = N, e.l = U, e;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(e, b, L) {
    return this.getHSL(_hslA), _hslA.h += e, _hslA.s += b, _hslA.l += L, this.setHSL(_hslA.h, _hslA.s, _hslA.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, b) {
    return this.r = e.r + b.r, this.g = e.g + b.g, this.b = e.b + b.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, b) {
    return this.r += (e.r - this.r) * b, this.g += (e.g - this.g) * b, this.b += (e.b - this.b) * b, this;
  }
  lerpColors(e, b, L) {
    return this.r = e.r + (b.r - e.r) * L, this.g = e.g + (b.g - e.g) * L, this.b = e.b + (b.b - e.b) * L, this;
  }
  lerpHSL(e, b) {
    this.getHSL(_hslA), e.getHSL(_hslB);
    const L = lerp(_hslA.h, _hslB.h, b), M = lerp(_hslA.s, _hslB.s, b), D = lerp(_hslA.l, _hslB.l, b);
    return this.setHSL(L, M, D), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, b = 0) {
    return this.r = e[b], this.g = e[b + 1], this.b = e[b + 2], this;
  }
  toArray(e = [], b = 0) {
    return e[b] = this.r, e[b + 1] = this.g, e[b + 2] = this.b, e;
  }
  fromBufferAttribute(e, b) {
    return this.r = e.getX(b), this.g = e.getY(b), this.b = e.getZ(b), e.normalized === !0 && (this.r /= 255, this.g /= 255, this.b /= 255), this;
  }
  toJSON() {
    return this.getHex();
  }
}
Color.NAMES = _colorKeywords;
Color.prototype.isColor = !0;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
class MeshBasicMaterial extends Material {
  constructor(e) {
    super(), this.type = "MeshBasicMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.morphTargets = e.morphTargets, this;
  }
}
MeshBasicMaterial.prototype.isMeshBasicMaterial = !0;
const _vector$9 = /* @__PURE__ */ new Vector3(), _vector2$1 = /* @__PURE__ */ new Vector2();
class BufferAttribute {
  constructor(e, b, L) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.name = "", this.array = e, this.itemSize = b, this.count = e !== void 0 ? e.length / b : 0, this.normalized = L === !0, this.usage = StaticDrawUsage, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
  }
  copyAt(e, b, L) {
    e *= this.itemSize, L *= b.itemSize;
    for (let M = 0, D = this.itemSize; M < D; M++)
      this.array[e + M] = b.array[L + M];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  copyColorsArray(e) {
    const b = this.array;
    let L = 0;
    for (let M = 0, D = e.length; M < D; M++) {
      let I = e[M];
      I === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", M), I = new Color()), b[L++] = I.r, b[L++] = I.g, b[L++] = I.b;
    }
    return this;
  }
  copyVector2sArray(e) {
    const b = this.array;
    let L = 0;
    for (let M = 0, D = e.length; M < D; M++) {
      let I = e[M];
      I === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", M), I = new Vector2()), b[L++] = I.x, b[L++] = I.y;
    }
    return this;
  }
  copyVector3sArray(e) {
    const b = this.array;
    let L = 0;
    for (let M = 0, D = e.length; M < D; M++) {
      let I = e[M];
      I === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", M), I = new Vector3()), b[L++] = I.x, b[L++] = I.y, b[L++] = I.z;
    }
    return this;
  }
  copyVector4sArray(e) {
    const b = this.array;
    let L = 0;
    for (let M = 0, D = e.length; M < D; M++) {
      let I = e[M];
      I === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", M), I = new Vector4()), b[L++] = I.x, b[L++] = I.y, b[L++] = I.z, b[L++] = I.w;
    }
    return this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let b = 0, L = this.count; b < L; b++)
        _vector2$1.fromBufferAttribute(this, b), _vector2$1.applyMatrix3(e), this.setXY(b, _vector2$1.x, _vector2$1.y);
    else if (this.itemSize === 3)
      for (let b = 0, L = this.count; b < L; b++)
        _vector$9.fromBufferAttribute(this, b), _vector$9.applyMatrix3(e), this.setXYZ(b, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  applyMatrix4(e) {
    for (let b = 0, L = this.count; b < L; b++)
      _vector$9.x = this.getX(b), _vector$9.y = this.getY(b), _vector$9.z = this.getZ(b), _vector$9.applyMatrix4(e), this.setXYZ(b, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let b = 0, L = this.count; b < L; b++)
      _vector$9.x = this.getX(b), _vector$9.y = this.getY(b), _vector$9.z = this.getZ(b), _vector$9.applyNormalMatrix(e), this.setXYZ(b, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  transformDirection(e) {
    for (let b = 0, L = this.count; b < L; b++)
      _vector$9.x = this.getX(b), _vector$9.y = this.getY(b), _vector$9.z = this.getZ(b), _vector$9.transformDirection(e), this.setXYZ(b, _vector$9.x, _vector$9.y, _vector$9.z);
    return this;
  }
  set(e, b = 0) {
    return this.array.set(e, b), this;
  }
  getX(e) {
    return this.array[e * this.itemSize];
  }
  setX(e, b) {
    return this.array[e * this.itemSize] = b, this;
  }
  getY(e) {
    return this.array[e * this.itemSize + 1];
  }
  setY(e, b) {
    return this.array[e * this.itemSize + 1] = b, this;
  }
  getZ(e) {
    return this.array[e * this.itemSize + 2];
  }
  setZ(e, b) {
    return this.array[e * this.itemSize + 2] = b, this;
  }
  getW(e) {
    return this.array[e * this.itemSize + 3];
  }
  setW(e, b) {
    return this.array[e * this.itemSize + 3] = b, this;
  }
  setXY(e, b, L) {
    return e *= this.itemSize, this.array[e + 0] = b, this.array[e + 1] = L, this;
  }
  setXYZ(e, b, L, M) {
    return e *= this.itemSize, this.array[e + 0] = b, this.array[e + 1] = L, this.array[e + 2] = M, this;
  }
  setXYZW(e, b, L, M, D) {
    return e *= this.itemSize, this.array[e + 0] = b, this.array[e + 1] = L, this.array[e + 2] = M, this.array[e + 3] = D, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== StaticDrawUsage && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
}
BufferAttribute.prototype.isBufferAttribute = !0;
class Int8BufferAttribute extends BufferAttribute {
  constructor(e, b, L) {
    super(new Int8Array(e), b, L);
  }
}
class Uint8BufferAttribute extends BufferAttribute {
  constructor(e, b, L) {
    super(new Uint8Array(e), b, L);
  }
}
class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(e, b, L) {
    super(new Uint8ClampedArray(e), b, L);
  }
}
class Int16BufferAttribute extends BufferAttribute {
  constructor(e, b, L) {
    super(new Int16Array(e), b, L);
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  constructor(e, b, L) {
    super(new Uint16Array(e), b, L);
  }
}
class Int32BufferAttribute extends BufferAttribute {
  constructor(e, b, L) {
    super(new Int32Array(e), b, L);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(e, b, L) {
    super(new Uint32Array(e), b, L);
  }
}
class Float16BufferAttribute extends BufferAttribute {
  constructor(e, b, L) {
    super(new Uint16Array(e), b, L);
  }
}
Float16BufferAttribute.prototype.isFloat16BufferAttribute = !0;
class Float32BufferAttribute extends BufferAttribute {
  constructor(e, b, L) {
    super(new Float32Array(e), b, L);
  }
}
class Float64BufferAttribute extends BufferAttribute {
  constructor(e, b, L) {
    super(new Float64Array(e), b, L);
  }
}
function arrayMax(B) {
  if (B.length === 0) return -1 / 0;
  let e = B[0];
  for (let b = 1, L = B.length; b < L; ++b)
    B[b] > e && (e = B[b]);
  return e;
}
const TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function getTypedArray(B, e) {
  return new TYPED_ARRAYS[B](e);
}
let _id = 0;
const _m1 = /* @__PURE__ */ new Matrix4(), _obj = /* @__PURE__ */ new Object3D(), _offset = /* @__PURE__ */ new Vector3(), _box$1 = /* @__PURE__ */ new Box3(), _boxMorphTargets = /* @__PURE__ */ new Box3(), _vector$8 = /* @__PURE__ */ new Vector3();
class BufferGeometry extends EventDispatcher$1 {
  constructor() {
    super(), Object.defineProperty(this, "id", { value: _id++ }), this.uuid = generateUUID$1(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (arrayMax(e) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, b) {
    return this.attributes[e] = b, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, b, L = 0) {
    this.groups.push({
      start: e,
      count: b,
      materialIndex: L
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, b) {
    this.drawRange.start = e, this.drawRange.count = b;
  }
  applyMatrix4(e) {
    const b = this.attributes.position;
    b !== void 0 && (b.applyMatrix4(e), b.needsUpdate = !0);
    const L = this.attributes.normal;
    if (L !== void 0) {
      const D = new Matrix3().getNormalMatrix(e);
      L.applyNormalMatrix(D), L.needsUpdate = !0;
    }
    const M = this.attributes.tangent;
    return M !== void 0 && (M.transformDirection(e), M.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return _m1.makeRotationFromQuaternion(e), this.applyMatrix4(_m1), this;
  }
  rotateX(e) {
    return _m1.makeRotationX(e), this.applyMatrix4(_m1), this;
  }
  rotateY(e) {
    return _m1.makeRotationY(e), this.applyMatrix4(_m1), this;
  }
  rotateZ(e) {
    return _m1.makeRotationZ(e), this.applyMatrix4(_m1), this;
  }
  translate(e, b, L) {
    return _m1.makeTranslation(e, b, L), this.applyMatrix4(_m1), this;
  }
  scale(e, b, L) {
    return _m1.makeScale(e, b, L), this.applyMatrix4(_m1), this;
  }
  lookAt(e) {
    return _obj.lookAt(e), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(_offset).negate(), this.translate(_offset.x, _offset.y, _offset.z), this;
  }
  setFromPoints(e) {
    const b = [];
    for (let L = 0, M = e.length; L < M; L++) {
      const D = e[L];
      b.push(D.x, D.y, D.z || 0);
    }
    return this.setAttribute("position", new Float32BufferAttribute(b, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    const e = this.attributes.position, b = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new Vector3(-1 / 0, -1 / 0, -1 / 0),
        new Vector3(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), b)
        for (let L = 0, M = b.length; L < M; L++) {
          const D = b[L];
          _box$1.setFromBufferAttribute(D), this.morphTargetsRelative ? (_vector$8.addVectors(this.boundingBox.min, _box$1.min), this.boundingBox.expandByPoint(_vector$8), _vector$8.addVectors(this.boundingBox.max, _box$1.max), this.boundingBox.expandByPoint(_vector$8)) : (this.boundingBox.expandByPoint(_box$1.min), this.boundingBox.expandByPoint(_box$1.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere());
    const e = this.attributes.position, b = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new Vector3(), 1 / 0);
      return;
    }
    if (e) {
      const L = this.boundingSphere.center;
      if (_box$1.setFromBufferAttribute(e), b)
        for (let D = 0, I = b.length; D < I; D++) {
          const F = b[D];
          _boxMorphTargets.setFromBufferAttribute(F), this.morphTargetsRelative ? (_vector$8.addVectors(_box$1.min, _boxMorphTargets.min), _box$1.expandByPoint(_vector$8), _vector$8.addVectors(_box$1.max, _boxMorphTargets.max), _box$1.expandByPoint(_vector$8)) : (_box$1.expandByPoint(_boxMorphTargets.min), _box$1.expandByPoint(_boxMorphTargets.max));
        }
      _box$1.getCenter(L);
      let M = 0;
      for (let D = 0, I = e.count; D < I; D++)
        _vector$8.fromBufferAttribute(e, D), M = Math.max(M, L.distanceToSquared(_vector$8));
      if (b)
        for (let D = 0, I = b.length; D < I; D++) {
          const F = b[D], N = this.morphTargetsRelative;
          for (let U = 0, G = F.count; U < G; U++)
            _vector$8.fromBufferAttribute(F, U), N && (_offset.fromBufferAttribute(e, U), _vector$8.add(_offset)), M = Math.max(M, L.distanceToSquared(_vector$8));
        }
      this.boundingSphere.radius = Math.sqrt(M), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeFaceNormals() {
  }
  computeTangents() {
    const e = this.index, b = this.attributes;
    if (e === null || b.position === void 0 || b.normal === void 0 || b.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const L = e.array, M = b.position.array, D = b.normal.array, I = b.uv.array, F = M.length / 3;
    b.tangent === void 0 && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * F), 4));
    const N = b.tangent.array, U = [], G = [];
    for (let le = 0; le < F; le++)
      U[le] = new Vector3(), G[le] = new Vector3();
    const V = new Vector3(), z = new Vector3(), k = new Vector3(), H = new Vector2(), W = new Vector2(), $ = new Vector2(), j = new Vector3(), q = new Vector3();
    function Y(le, pe, ue) {
      V.fromArray(M, le * 3), z.fromArray(M, pe * 3), k.fromArray(M, ue * 3), H.fromArray(I, le * 2), W.fromArray(I, pe * 2), $.fromArray(I, ue * 2), z.sub(V), k.sub(V), W.sub(H), $.sub(H);
      const oe = 1 / (W.x * $.y - $.x * W.y);
      isFinite(oe) && (j.copy(z).multiplyScalar($.y).addScaledVector(k, -W.y).multiplyScalar(oe), q.copy(k).multiplyScalar(W.x).addScaledVector(z, -$.x).multiplyScalar(oe), U[le].add(j), U[pe].add(j), U[ue].add(j), G[le].add(q), G[pe].add(q), G[ue].add(q));
    }
    let J = this.groups;
    J.length === 0 && (J = [{
      start: 0,
      count: L.length
    }]);
    for (let le = 0, pe = J.length; le < pe; ++le) {
      const ue = J[le], oe = ue.start, ae = ue.count;
      for (let se = oe, ie = oe + ae; se < ie; se += 3)
        Y(
          L[se + 0],
          L[se + 1],
          L[se + 2]
        );
    }
    const K = new Vector3(), X = new Vector3(), Z = new Vector3(), Q = new Vector3();
    function ne(le) {
      Z.fromArray(D, le * 3), Q.copy(Z);
      const pe = U[le];
      K.copy(pe), K.sub(Z.multiplyScalar(Z.dot(pe))).normalize(), X.crossVectors(Q, pe);
      const oe = X.dot(G[le]) < 0 ? -1 : 1;
      N[le * 4] = K.x, N[le * 4 + 1] = K.y, N[le * 4 + 2] = K.z, N[le * 4 + 3] = oe;
    }
    for (let le = 0, pe = J.length; le < pe; ++le) {
      const ue = J[le], oe = ue.start, ae = ue.count;
      for (let se = oe, ie = oe + ae; se < ie; se += 3)
        ne(L[se + 0]), ne(L[se + 1]), ne(L[se + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, b = this.getAttribute("position");
    if (b !== void 0) {
      let L = this.getAttribute("normal");
      if (L === void 0)
        L = new BufferAttribute(new Float32Array(b.count * 3), 3), this.setAttribute("normal", L);
      else
        for (let z = 0, k = L.count; z < k; z++)
          L.setXYZ(z, 0, 0, 0);
      const M = new Vector3(), D = new Vector3(), I = new Vector3(), F = new Vector3(), N = new Vector3(), U = new Vector3(), G = new Vector3(), V = new Vector3();
      if (e)
        for (let z = 0, k = e.count; z < k; z += 3) {
          const H = e.getX(z + 0), W = e.getX(z + 1), $ = e.getX(z + 2);
          M.fromBufferAttribute(b, H), D.fromBufferAttribute(b, W), I.fromBufferAttribute(b, $), G.subVectors(I, D), V.subVectors(M, D), G.cross(V), F.fromBufferAttribute(L, H), N.fromBufferAttribute(L, W), U.fromBufferAttribute(L, $), F.add(G), N.add(G), U.add(G), L.setXYZ(H, F.x, F.y, F.z), L.setXYZ(W, N.x, N.y, N.z), L.setXYZ($, U.x, U.y, U.z);
        }
      else
        for (let z = 0, k = b.count; z < k; z += 3)
          M.fromBufferAttribute(b, z + 0), D.fromBufferAttribute(b, z + 1), I.fromBufferAttribute(b, z + 2), G.subVectors(I, D), V.subVectors(M, D), G.cross(V), L.setXYZ(z + 0, G.x, G.y, G.z), L.setXYZ(z + 1, G.x, G.y, G.z), L.setXYZ(z + 2, G.x, G.y, G.z);
      this.normalizeNormals(), L.needsUpdate = !0;
    }
  }
  merge(e, b) {
    if (!(e && e.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
      return;
    }
    b === void 0 && (b = 0, console.warn(
      "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
    ));
    const L = this.attributes;
    for (const M in L) {
      if (e.attributes[M] === void 0) continue;
      const I = L[M].array, F = e.attributes[M], N = F.array, U = F.itemSize * b, G = Math.min(N.length, I.length - U);
      for (let V = 0, z = U; V < G; V++, z++)
        I[z] = N[V];
    }
    return this;
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let b = 0, L = e.count; b < L; b++)
      _vector$8.fromBufferAttribute(e, b), _vector$8.normalize(), e.setXYZ(b, _vector$8.x, _vector$8.y, _vector$8.z);
  }
  toNonIndexed() {
    function e(F, N) {
      const U = F.array, G = F.itemSize, V = F.normalized, z = new U.constructor(N.length * G);
      let k = 0, H = 0;
      for (let W = 0, $ = N.length; W < $; W++) {
        F.isInterleavedBufferAttribute ? k = N[W] * F.data.stride + F.offset : k = N[W] * G;
        for (let j = 0; j < G; j++)
          z[H++] = U[k++];
      }
      return new BufferAttribute(z, G, V);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const b = new BufferGeometry(), L = this.index.array, M = this.attributes;
    for (const F in M) {
      const N = M[F], U = e(N, L);
      b.setAttribute(F, U);
    }
    const D = this.morphAttributes;
    for (const F in D) {
      const N = [], U = D[F];
      for (let G = 0, V = U.length; G < V; G++) {
        const z = U[G], k = e(z, L);
        N.push(k);
      }
      b.morphAttributes[F] = N;
    }
    b.morphTargetsRelative = this.morphTargetsRelative;
    const I = this.groups;
    for (let F = 0, N = I.length; F < N; F++) {
      const U = I[F];
      b.addGroup(U.start, U.count, U.materialIndex);
    }
    return b;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const N = this.parameters;
      for (const U in N)
        N[U] !== void 0 && (e[U] = N[U]);
      return e;
    }
    e.data = { attributes: {} };
    const b = this.index;
    b !== null && (e.data.index = {
      type: b.array.constructor.name,
      array: Array.prototype.slice.call(b.array)
    });
    const L = this.attributes;
    for (const N in L) {
      const U = L[N];
      e.data.attributes[N] = U.toJSON(e.data);
    }
    const M = {};
    let D = !1;
    for (const N in this.morphAttributes) {
      const U = this.morphAttributes[N], G = [];
      for (let V = 0, z = U.length; V < z; V++) {
        const k = U[V];
        G.push(k.toJSON(e.data));
      }
      G.length > 0 && (M[N] = G, D = !0);
    }
    D && (e.data.morphAttributes = M, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const I = this.groups;
    I.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(I)));
    const F = this.boundingSphere;
    return F !== null && (e.data.boundingSphere = {
      center: F.center.toArray(),
      radius: F.radius
    }), e;
  }
  clone() {
    return new BufferGeometry().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const b = {};
    this.name = e.name;
    const L = e.index;
    L !== null && this.setIndex(L.clone(b));
    const M = e.attributes;
    for (const U in M) {
      const G = M[U];
      this.setAttribute(U, G.clone(b));
    }
    const D = e.morphAttributes;
    for (const U in D) {
      const G = [], V = D[U];
      for (let z = 0, k = V.length; z < k; z++)
        G.push(V[z].clone(b));
      this.morphAttributes[U] = G;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const I = e.groups;
    for (let U = 0, G = I.length; U < G; U++) {
      const V = I[U];
      this.addGroup(V.start, V.count, V.materialIndex);
    }
    const F = e.boundingBox;
    F !== null && (this.boundingBox = F.clone());
    const N = e.boundingSphere;
    return N !== null && (this.boundingSphere = N.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
BufferGeometry.prototype.isBufferGeometry = !0;
const _inverseMatrix$2 = /* @__PURE__ */ new Matrix4(), _ray$2 = /* @__PURE__ */ new Ray(), _sphere$3 = /* @__PURE__ */ new Sphere(), _vA$1 = /* @__PURE__ */ new Vector3(), _vB$1 = /* @__PURE__ */ new Vector3(), _vC$1 = /* @__PURE__ */ new Vector3(), _tempA = /* @__PURE__ */ new Vector3(), _tempB = /* @__PURE__ */ new Vector3(), _tempC = /* @__PURE__ */ new Vector3(), _morphA = /* @__PURE__ */ new Vector3(), _morphB = /* @__PURE__ */ new Vector3(), _morphC = /* @__PURE__ */ new Vector3(), _uvA$1 = /* @__PURE__ */ new Vector2(), _uvB$1 = /* @__PURE__ */ new Vector2(), _uvC$1 = /* @__PURE__ */ new Vector2(), _intersectionPoint = /* @__PURE__ */ new Vector3(), _intersectionPointWorld = /* @__PURE__ */ new Vector3();
class Mesh extends Object3D {
  constructor(e = new BufferGeometry(), b = new MeshBasicMaterial()) {
    super(), this.type = "Mesh", this.geometry = e, this.material = b, this.updateMorphTargets();
  }
  copy(e) {
    return super.copy(e), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const e = this.geometry;
    if (e.isBufferGeometry) {
      const b = e.morphAttributes, L = Object.keys(b);
      if (L.length > 0) {
        const M = b[L[0]];
        if (M !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let D = 0, I = M.length; D < I; D++) {
            const F = M[D].name || String(D);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[F] = D;
          }
        }
      }
    } else {
      const b = e.morphTargets;
      b !== void 0 && b.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  raycast(e, b) {
    const L = this.geometry, M = this.material, D = this.matrixWorld;
    if (M === void 0 || (L.boundingSphere === null && L.computeBoundingSphere(), _sphere$3.copy(L.boundingSphere), _sphere$3.applyMatrix4(D), e.ray.intersectsSphere(_sphere$3) === !1) || (_inverseMatrix$2.copy(D).invert(), _ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$2), L.boundingBox !== null && _ray$2.intersectsBox(L.boundingBox) === !1))
      return;
    let I;
    if (L.isBufferGeometry) {
      const F = L.index, N = L.attributes.position, U = L.morphAttributes.position, G = L.morphTargetsRelative, V = L.attributes.uv, z = L.attributes.uv2, k = L.groups, H = L.drawRange;
      if (F !== null)
        if (Array.isArray(M))
          for (let W = 0, $ = k.length; W < $; W++) {
            const j = k[W], q = M[j.materialIndex], Y = Math.max(j.start, H.start), J = Math.min(j.start + j.count, H.start + H.count);
            for (let K = Y, X = J; K < X; K += 3) {
              const Z = F.getX(K), Q = F.getX(K + 1), ne = F.getX(K + 2);
              I = checkBufferGeometryIntersection(this, q, e, _ray$2, N, U, G, V, z, Z, Q, ne), I && (I.faceIndex = Math.floor(K / 3), I.face.materialIndex = j.materialIndex, b.push(I));
            }
          }
        else {
          const W = Math.max(0, H.start), $ = Math.min(F.count, H.start + H.count);
          for (let j = W, q = $; j < q; j += 3) {
            const Y = F.getX(j), J = F.getX(j + 1), K = F.getX(j + 2);
            I = checkBufferGeometryIntersection(this, M, e, _ray$2, N, U, G, V, z, Y, J, K), I && (I.faceIndex = Math.floor(j / 3), b.push(I));
          }
        }
      else if (N !== void 0)
        if (Array.isArray(M))
          for (let W = 0, $ = k.length; W < $; W++) {
            const j = k[W], q = M[j.materialIndex], Y = Math.max(j.start, H.start), J = Math.min(j.start + j.count, H.start + H.count);
            for (let K = Y, X = J; K < X; K += 3) {
              const Z = K, Q = K + 1, ne = K + 2;
              I = checkBufferGeometryIntersection(this, q, e, _ray$2, N, U, G, V, z, Z, Q, ne), I && (I.faceIndex = Math.floor(K / 3), I.face.materialIndex = j.materialIndex, b.push(I));
            }
          }
        else {
          const W = Math.max(0, H.start), $ = Math.min(N.count, H.start + H.count);
          for (let j = W, q = $; j < q; j += 3) {
            const Y = j, J = j + 1, K = j + 2;
            I = checkBufferGeometryIntersection(this, M, e, _ray$2, N, U, G, V, z, Y, J, K), I && (I.faceIndex = Math.floor(j / 3), b.push(I));
          }
        }
    } else L.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  }
}
Mesh.prototype.isMesh = !0;
function checkIntersection(B, e, b, L, M, D, I, F) {
  let N;
  if (e.side === BackSide ? N = L.intersectTriangle(I, D, M, !0, F) : N = L.intersectTriangle(M, D, I, e.side !== DoubleSide, F), N === null) return null;
  _intersectionPointWorld.copy(F), _intersectionPointWorld.applyMatrix4(B.matrixWorld);
  const U = b.ray.origin.distanceTo(_intersectionPointWorld);
  return U < b.near || U > b.far ? null : {
    distance: U,
    point: _intersectionPointWorld.clone(),
    object: B
  };
}
function checkBufferGeometryIntersection(B, e, b, L, M, D, I, F, N, U, G, V) {
  _vA$1.fromBufferAttribute(M, U), _vB$1.fromBufferAttribute(M, G), _vC$1.fromBufferAttribute(M, V);
  const z = B.morphTargetInfluences;
  if (e.morphTargets && D && z) {
    _morphA.set(0, 0, 0), _morphB.set(0, 0, 0), _morphC.set(0, 0, 0);
    for (let H = 0, W = D.length; H < W; H++) {
      const $ = z[H], j = D[H];
      $ !== 0 && (_tempA.fromBufferAttribute(j, U), _tempB.fromBufferAttribute(j, G), _tempC.fromBufferAttribute(j, V), I ? (_morphA.addScaledVector(_tempA, $), _morphB.addScaledVector(_tempB, $), _morphC.addScaledVector(_tempC, $)) : (_morphA.addScaledVector(_tempA.sub(_vA$1), $), _morphB.addScaledVector(_tempB.sub(_vB$1), $), _morphC.addScaledVector(_tempC.sub(_vC$1), $)));
    }
    _vA$1.add(_morphA), _vB$1.add(_morphB), _vC$1.add(_morphC);
  }
  B.isSkinnedMesh && (B.boneTransform(U, _vA$1), B.boneTransform(G, _vB$1), B.boneTransform(V, _vC$1));
  const k = checkIntersection(B, e, b, L, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (k) {
    F && (_uvA$1.fromBufferAttribute(F, U), _uvB$1.fromBufferAttribute(F, G), _uvC$1.fromBufferAttribute(F, V), k.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2())), N && (_uvA$1.fromBufferAttribute(N, U), _uvB$1.fromBufferAttribute(N, G), _uvC$1.fromBufferAttribute(N, V), k.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()));
    const H = {
      a: U,
      b: G,
      c: V,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, H.normal), k.face = H;
  }
  return k;
}
class BoxGeometry extends BufferGeometry {
  constructor(e = 1, b = 1, L = 1, M = 1, D = 1, I = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: b,
      depth: L,
      widthSegments: M,
      heightSegments: D,
      depthSegments: I
    };
    const F = this;
    M = Math.floor(M), D = Math.floor(D), I = Math.floor(I);
    const N = [], U = [], G = [], V = [];
    let z = 0, k = 0;
    H("z", "y", "x", -1, -1, L, b, e, I, D, 0), H("z", "y", "x", 1, -1, L, b, -e, I, D, 1), H("x", "z", "y", 1, 1, e, L, b, M, I, 2), H("x", "z", "y", 1, -1, e, L, -b, M, I, 3), H("x", "y", "z", 1, -1, e, b, L, M, D, 4), H("x", "y", "z", -1, -1, e, b, -L, M, D, 5), this.setIndex(N), this.setAttribute("position", new Float32BufferAttribute(U, 3)), this.setAttribute("normal", new Float32BufferAttribute(G, 3)), this.setAttribute("uv", new Float32BufferAttribute(V, 2));
    function H(W, $, j, q, Y, J, K, X, Z, Q, ne) {
      const le = J / Z, pe = K / Q, ue = J / 2, oe = K / 2, ae = X / 2, se = Z + 1, ie = Q + 1;
      let ye = 0, Ce = 0;
      const de = new Vector3();
      for (let ve = 0; ve < ie; ve++) {
        const ce = ve * pe - oe;
        for (let ge = 0; ge < se; ge++) {
          const _e = ge * le - ue;
          de[W] = _e * q, de[$] = ce * Y, de[j] = ae, U.push(de.x, de.y, de.z), de[W] = 0, de[$] = 0, de[j] = X > 0 ? 1 : -1, G.push(de.x, de.y, de.z), V.push(ge / Z), V.push(1 - ve / Q), ye += 1;
        }
      }
      for (let ve = 0; ve < Q; ve++)
        for (let ce = 0; ce < Z; ce++) {
          const ge = z + ce + se * ve, _e = z + ce + se * (ve + 1), Me = z + (ce + 1) + se * (ve + 1), xe = z + (ce + 1) + se * ve;
          N.push(ge, _e, xe), N.push(_e, Me, xe), Ce += 6;
        }
      F.addGroup(k, Ce, ne), k += Ce, z += ye;
    }
  }
  static fromJSON(e) {
    return new BoxGeometry(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function cloneUniforms(B) {
  const e = {};
  for (const b in B) {
    e[b] = {};
    for (const L in B[b]) {
      const M = B[b][L];
      M && (M.isColor || M.isMatrix3 || M.isMatrix4 || M.isVector2 || M.isVector3 || M.isVector4 || M.isTexture || M.isQuaternion) ? e[b][L] = M.clone() : Array.isArray(M) ? e[b][L] = M.slice() : e[b][L] = M;
    }
  }
  return e;
}
function mergeUniforms(B) {
  const e = {};
  for (let b = 0; b < B.length; b++) {
    const L = cloneUniforms(B[b]);
    for (const M in L)
      e[M] = L[M];
  }
  return e;
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ShaderMaterial extends Material {
  constructor(e) {
    super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = default_vertex, this.fragmentShader = default_fragment, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1
      // set to use shader texture LOD
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv2: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && (e.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e));
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = cloneUniforms(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const b = super.toJSON(e);
    b.glslVersion = this.glslVersion, b.uniforms = {};
    for (const M in this.uniforms) {
      const I = this.uniforms[M].value;
      I && I.isTexture ? b.uniforms[M] = {
        type: "t",
        value: I.toJSON(e).uuid
      } : I && I.isColor ? b.uniforms[M] = {
        type: "c",
        value: I.getHex()
      } : I && I.isVector2 ? b.uniforms[M] = {
        type: "v2",
        value: I.toArray()
      } : I && I.isVector3 ? b.uniforms[M] = {
        type: "v3",
        value: I.toArray()
      } : I && I.isVector4 ? b.uniforms[M] = {
        type: "v4",
        value: I.toArray()
      } : I && I.isMatrix3 ? b.uniforms[M] = {
        type: "m3",
        value: I.toArray()
      } : I && I.isMatrix4 ? b.uniforms[M] = {
        type: "m4",
        value: I.toArray()
      } : b.uniforms[M] = {
        value: I
      };
    }
    Object.keys(this.defines).length > 0 && (b.defines = this.defines), b.vertexShader = this.vertexShader, b.fragmentShader = this.fragmentShader;
    const L = {};
    for (const M in this.extensions)
      this.extensions[M] === !0 && (L[M] = !0);
    return Object.keys(L).length > 0 && (b.extensions = L), b;
  }
}
ShaderMaterial.prototype.isShaderMaterial = !0;
let Camera$1 = class extends Object3D {
  constructor() {
    super(), this.type = "Camera", this.matrixWorldInverse = new Matrix4(), this.projectionMatrix = new Matrix4(), this.projectionMatrixInverse = new Matrix4();
  }
  copy(e, b) {
    return super.copy(e, b), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const b = this.matrixWorld.elements;
    return e.set(-b[8], -b[9], -b[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, b) {
    super.updateWorldMatrix(e, b), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
Camera$1.prototype.isCamera = !0;
class PerspectiveCamera extends Camera$1 {
  constructor(e = 50, b = 1, L = 0.1, M = 2e3) {
    super(), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = L, this.far = M, this.focus = 10, this.aspect = b, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, b) {
    return super.copy(e, b), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const b = 0.5 * this.getFilmHeight() / e;
    this.fov = RAD2DEG * 2 * Math.atan(b), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(
      Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, b, L, M, D, I) {
    this.aspect = e / b, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = b, this.view.offsetX = L, this.view.offsetY = M, this.view.width = D, this.view.height = I, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let b = e * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom, L = 2 * b, M = this.aspect * L, D = -0.5 * M;
    const I = this.view;
    if (this.view !== null && this.view.enabled) {
      const N = I.fullWidth, U = I.fullHeight;
      D += I.offsetX * M / N, b -= I.offsetY * L / U, M *= I.width / N, L *= I.height / U;
    }
    const F = this.filmOffset;
    F !== 0 && (D += e * F / this.getFilmWidth()), this.projectionMatrix.makePerspective(D, D + M, b, b - L, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const b = super.toJSON(e);
    return b.object.fov = this.fov, b.object.zoom = this.zoom, b.object.near = this.near, b.object.far = this.far, b.object.focus = this.focus, b.object.aspect = this.aspect, this.view !== null && (b.object.view = Object.assign({}, this.view)), b.object.filmGauge = this.filmGauge, b.object.filmOffset = this.filmOffset, b;
  }
}
PerspectiveCamera.prototype.isPerspectiveCamera = !0;
const fov = 90, aspect = 1;
class CubeCamera extends Object3D {
  constructor(e, b, L) {
    if (super(), this.type = "CubeCamera", L.isWebGLCubeRenderTarget !== !0) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = L;
    const M = new PerspectiveCamera(fov, aspect, e, b);
    M.layers = this.layers, M.up.set(0, -1, 0), M.lookAt(new Vector3(1, 0, 0)), this.add(M);
    const D = new PerspectiveCamera(fov, aspect, e, b);
    D.layers = this.layers, D.up.set(0, -1, 0), D.lookAt(new Vector3(-1, 0, 0)), this.add(D);
    const I = new PerspectiveCamera(fov, aspect, e, b);
    I.layers = this.layers, I.up.set(0, 0, 1), I.lookAt(new Vector3(0, 1, 0)), this.add(I);
    const F = new PerspectiveCamera(fov, aspect, e, b);
    F.layers = this.layers, F.up.set(0, 0, -1), F.lookAt(new Vector3(0, -1, 0)), this.add(F);
    const N = new PerspectiveCamera(fov, aspect, e, b);
    N.layers = this.layers, N.up.set(0, -1, 0), N.lookAt(new Vector3(0, 0, 1)), this.add(N);
    const U = new PerspectiveCamera(fov, aspect, e, b);
    U.layers = this.layers, U.up.set(0, -1, 0), U.lookAt(new Vector3(0, 0, -1)), this.add(U);
  }
  update(e, b) {
    this.parent === null && this.updateMatrixWorld();
    const L = this.renderTarget, [M, D, I, F, N, U] = this.children, G = e.xr.enabled, V = e.getRenderTarget();
    e.xr.enabled = !1;
    const z = L.texture.generateMipmaps;
    L.texture.generateMipmaps = !1, e.setRenderTarget(L, 0), e.render(b, M), e.setRenderTarget(L, 1), e.render(b, D), e.setRenderTarget(L, 2), e.render(b, I), e.setRenderTarget(L, 3), e.render(b, F), e.setRenderTarget(L, 4), e.render(b, N), L.texture.generateMipmaps = z, e.setRenderTarget(L, 5), e.render(b, U), e.setRenderTarget(V), e.xr.enabled = G;
  }
}
class CubeTexture extends Texture {
  constructor(e, b, L, M, D, I, F, N, U, G) {
    e = e !== void 0 ? e : [], b = b !== void 0 ? b : CubeReflectionMapping, F = F !== void 0 ? F : RGBFormat, super(e, b, L, M, D, I, F, N, U, G), this._needsFlipEnvMap = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
CubeTexture.prototype.isCubeTexture = !0;
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(e, b, L) {
    Number.isInteger(b) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), b = L), super(e, e, b), b = b || {}, this.texture = new CubeTexture(void 0, b.mapping, b.wrapS, b.wrapT, b.magFilter, b.minFilter, b.format, b.type, b.anisotropy, b.encoding), this.texture.generateMipmaps = b.generateMipmaps !== void 0 ? b.generateMipmaps : !1, this.texture.minFilter = b.minFilter !== void 0 ? b.minFilter : LinearFilter, this.texture._needsFlipEnvMap = !1;
  }
  fromEquirectangularTexture(e, b) {
    this.texture.type = b.type, this.texture.format = RGBAFormat, this.texture.encoding = b.encoding, this.texture.generateMipmaps = b.generateMipmaps, this.texture.minFilter = b.minFilter, this.texture.magFilter = b.magFilter;
    const L = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, M = new BoxGeometry(5, 5, 5), D = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(L.uniforms),
      vertexShader: L.vertexShader,
      fragmentShader: L.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    D.uniforms.tEquirect.value = b;
    const I = new Mesh(M, D), F = b.minFilter;
    return b.minFilter === LinearMipmapLinearFilter && (b.minFilter = LinearFilter), new CubeCamera(1, 10, this).update(e, I), b.minFilter = F, I.geometry.dispose(), I.material.dispose(), this;
  }
  clear(e, b, L, M) {
    const D = e.getRenderTarget();
    for (let I = 0; I < 6; I++)
      e.setRenderTarget(this, I), e.clear(b, L, M);
    e.setRenderTarget(D);
  }
}
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = !0;
const _vector1 = /* @__PURE__ */ new Vector3(), _vector2 = /* @__PURE__ */ new Vector3(), _normalMatrix = /* @__PURE__ */ new Matrix3();
class Plane {
  constructor(e = new Vector3(1, 0, 0), b = 0) {
    this.normal = e, this.constant = b;
  }
  set(e, b) {
    return this.normal.copy(e), this.constant = b, this;
  }
  setComponents(e, b, L, M) {
    return this.normal.set(e, b, L), this.constant = M, this;
  }
  setFromNormalAndCoplanarPoint(e, b) {
    return this.normal.copy(e), this.constant = -b.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, b, L) {
    const M = _vector1.subVectors(L, b).cross(_vector2.subVectors(e, b)).normalize();
    return this.setFromNormalAndCoplanarPoint(M, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, b) {
    return b.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, b) {
    const L = e.delta(_vector1), M = this.normal.dot(L);
    if (M === 0)
      return this.distanceToPoint(e.start) === 0 ? b.copy(e.start) : null;
    const D = -(e.start.dot(this.normal) + this.constant) / M;
    return D < 0 || D > 1 ? null : b.copy(L).multiplyScalar(D).add(e.start);
  }
  intersectsLine(e) {
    const b = this.distanceToPoint(e.start), L = this.distanceToPoint(e.end);
    return b < 0 && L > 0 || L < 0 && b > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, b) {
    const L = b || _normalMatrix.getNormalMatrix(e), M = this.coplanarPoint(_vector1).applyMatrix4(e), D = this.normal.applyMatrix3(L).normalize();
    return this.constant = -M.dot(D), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Plane.prototype.isPlane = !0;
const _sphere$2 = /* @__PURE__ */ new Sphere(), _vector$7 = /* @__PURE__ */ new Vector3();
class Frustum {
  constructor(e = new Plane(), b = new Plane(), L = new Plane(), M = new Plane(), D = new Plane(), I = new Plane()) {
    this.planes = [e, b, L, M, D, I];
  }
  set(e, b, L, M, D, I) {
    const F = this.planes;
    return F[0].copy(e), F[1].copy(b), F[2].copy(L), F[3].copy(M), F[4].copy(D), F[5].copy(I), this;
  }
  copy(e) {
    const b = this.planes;
    for (let L = 0; L < 6; L++)
      b[L].copy(e.planes[L]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const b = this.planes, L = e.elements, M = L[0], D = L[1], I = L[2], F = L[3], N = L[4], U = L[5], G = L[6], V = L[7], z = L[8], k = L[9], H = L[10], W = L[11], $ = L[12], j = L[13], q = L[14], Y = L[15];
    return b[0].setComponents(F - M, V - N, W - z, Y - $).normalize(), b[1].setComponents(F + M, V + N, W + z, Y + $).normalize(), b[2].setComponents(F + D, V + U, W + k, Y + j).normalize(), b[3].setComponents(F - D, V - U, W - k, Y - j).normalize(), b[4].setComponents(F - I, V - G, W - H, Y - q).normalize(), b[5].setComponents(F + I, V + G, W + H, Y + q).normalize(), this;
  }
  intersectsObject(e) {
    const b = e.geometry;
    return b.boundingSphere === null && b.computeBoundingSphere(), _sphere$2.copy(b.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(_sphere$2);
  }
  intersectsSprite(e) {
    return _sphere$2.center.set(0, 0, 0), _sphere$2.radius = 0.7071067811865476, _sphere$2.applyMatrix4(e.matrixWorld), this.intersectsSphere(_sphere$2);
  }
  intersectsSphere(e) {
    const b = this.planes, L = e.center, M = -e.radius;
    for (let D = 0; D < 6; D++)
      if (b[D].distanceToPoint(L) < M)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const b = this.planes;
    for (let L = 0; L < 6; L++) {
      const M = b[L];
      if (_vector$7.x = M.normal.x > 0 ? e.max.x : e.min.x, _vector$7.y = M.normal.y > 0 ? e.max.y : e.min.y, _vector$7.z = M.normal.z > 0 ? e.max.z : e.min.z, M.distanceToPoint(_vector$7) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const b = this.planes;
    for (let L = 0; L < 6; L++)
      if (b[L].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let B = null, e = !1, b = null, L = null;
  function M(D, I) {
    b(D, I), L = B.requestAnimationFrame(M);
  }
  return {
    start: function() {
      e !== !0 && b !== null && (L = B.requestAnimationFrame(M), e = !0);
    },
    stop: function() {
      B.cancelAnimationFrame(L), e = !1;
    },
    setAnimationLoop: function(D) {
      b = D;
    },
    setContext: function(D) {
      B = D;
    }
  };
}
function WebGLAttributes(B, e) {
  const b = e.isWebGL2, L = /* @__PURE__ */ new WeakMap();
  function M(U, G) {
    const V = U.array, z = U.usage, k = B.createBuffer();
    B.bindBuffer(G, k), B.bufferData(G, V, z), U.onUploadCallback();
    let H = 5126;
    return V instanceof Float32Array ? H = 5126 : V instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : V instanceof Uint16Array ? U.isFloat16BufferAttribute ? b ? H = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : H = 5123 : V instanceof Int16Array ? H = 5122 : V instanceof Uint32Array ? H = 5125 : V instanceof Int32Array ? H = 5124 : V instanceof Int8Array ? H = 5120 : (V instanceof Uint8Array || V instanceof Uint8ClampedArray) && (H = 5121), {
      buffer: k,
      type: H,
      bytesPerElement: V.BYTES_PER_ELEMENT,
      version: U.version
    };
  }
  function D(U, G, V) {
    const z = G.array, k = G.updateRange;
    B.bindBuffer(V, U), k.count === -1 ? B.bufferSubData(V, 0, z) : (b ? B.bufferSubData(
      V,
      k.offset * z.BYTES_PER_ELEMENT,
      z,
      k.offset,
      k.count
    ) : B.bufferSubData(
      V,
      k.offset * z.BYTES_PER_ELEMENT,
      z.subarray(k.offset, k.offset + k.count)
    ), k.count = -1);
  }
  function I(U) {
    return U.isInterleavedBufferAttribute && (U = U.data), L.get(U);
  }
  function F(U) {
    U.isInterleavedBufferAttribute && (U = U.data);
    const G = L.get(U);
    G && (B.deleteBuffer(G.buffer), L.delete(U));
  }
  function N(U, G) {
    if (U.isGLBufferAttribute) {
      const z = L.get(U);
      (!z || z.version < U.version) && L.set(U, {
        buffer: U.buffer,
        type: U.type,
        bytesPerElement: U.elementSize,
        version: U.version
      });
      return;
    }
    U.isInterleavedBufferAttribute && (U = U.data);
    const V = L.get(U);
    V === void 0 ? L.set(U, M(U, G)) : V.version < U.version && (D(V.buffer, U, G), V.version = U.version);
  }
  return {
    get: I,
    remove: F,
    update: N
  };
}
class PlaneGeometry extends BufferGeometry {
  constructor(e = 1, b = 1, L = 1, M = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: b,
      widthSegments: L,
      heightSegments: M
    };
    const D = e / 2, I = b / 2, F = Math.floor(L), N = Math.floor(M), U = F + 1, G = N + 1, V = e / F, z = b / N, k = [], H = [], W = [], $ = [];
    for (let j = 0; j < G; j++) {
      const q = j * z - I;
      for (let Y = 0; Y < U; Y++) {
        const J = Y * V - D;
        H.push(J, -q, 0), W.push(0, 0, 1), $.push(Y / F), $.push(1 - j / N);
      }
    }
    for (let j = 0; j < N; j++)
      for (let q = 0; q < F; q++) {
        const Y = q + U * j, J = q + U * (j + 1), K = q + 1 + U * (j + 1), X = q + 1 + U * j;
        k.push(Y, J, X), k.push(J, K, X);
      }
    this.setIndex(k), this.setAttribute("position", new Float32BufferAttribute(H, 3)), this.setAttribute("normal", new Float32BufferAttribute(W, 3)), this.setAttribute("uv", new Float32BufferAttribute($, 2));
  }
  static fromJSON(e) {
    return new PlaneGeometry(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, alphatest_fragment = `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`, aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`, aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, begin_vertex = "vec3 transformed = vec3( position );", beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, bsdfs = `vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotVH ) {
	float fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`, bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, color_fragment = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, color_pars_fragment = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, color_pars_vertex = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, color_vertex = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, common = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment = `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`, envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, fog_vertex = `#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`, fog_pars_vertex = `#ifdef USE_FOG
	varying float fogDepth;
#endif`, fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`, lightmap_fragment = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`, lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, lights_lambert_vertex = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`, lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`, envmap_physical_pars_fragment = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`, lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, lights_toon_pars_fragment = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`, lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, lights_phong_pars_fragment = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`, lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`, lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, lights_fragment_begin = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`, lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, logdepthbuf_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, logdepthbuf_pars_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, logdepthbuf_pars_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, logdepthbuf_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, map_fragment = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`, map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, map_particle_pars_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`, morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`, morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`, normal_fragment_begin = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, normal_fragment_maps = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, clearcoat_normal_fragment_begin = `#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, shadowmap_pars_fragment = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, shadowmap_pars_vertex = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, shadowmap_vertex = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`, shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`, skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, tonemapping_pars_fragment = `#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, transmission_fragment = `#ifdef USE_TRANSMISSION
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSNMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition.xyz / vWorldPosition.w;
	vec3 v = normalize( cameraPosition - pos );
	float ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );
	vec3 transmission = transmissionFactor * getIBLVolumeRefraction(
		normal, v, roughnessFactor, material.diffuseColor, totalSpecular,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );
#endif`, transmission_pars_fragment = `#ifdef USE_TRANSMISSION
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec4 vWorldPosition;
	vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {
		vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);
		vec3 modelScale;
		modelScale.x = length(vec3(modelMatrix[0].xyz));
		modelScale.y = length(vec3(modelMatrix[1].xyz));
		modelScale.z = length(vec3(modelMatrix[2].xyz));
		return normalize(refractionVector) * thickness * modelScale;
	}
	float applyIorToRoughness(float roughness, float ior) {
		return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);
	}
	vec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {
		float framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);
		return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;
	}
	vec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {
		if (attenuationDistance == 0.0) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;
			vec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);			return transmittance * radiance;
		}
	}
	vec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance) {
		vec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);
		vec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);
		return (1.0 - specularColor) * attenuatedColor * baseColor;
	}
#endif`, uv_pars_fragment = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, uv_pars_vertex = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, uv_vertex = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, uv2_pars_fragment = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, uv2_pars_vertex = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, uv2_vertex = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`, background_frag = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, background_vert = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, cube_frag = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, cube_vert = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, depth_frag = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, depth_vert = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, distanceRGBA_frag = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, distanceRGBA_vert = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, equirect_frag = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, equirect_vert = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, linedashed_frag = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, linedashed_vert = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, meshbasic_frag = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshbasic_vert = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, meshlambert_frag = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshlambert_vert = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshmatcap_frag = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshmatcap_vert = `#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, meshtoon_frag = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshtoon_vert = `#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshphong_frag = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshphong_vert = `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshphysical_frag = `#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform vec3 attenuationColor;
	uniform float attenuationDistance;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <transmission_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshphysical_vert = `#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#ifdef USE_TRANSMISSION
	varying vec4 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition;
#endif
}`, normal_frag = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`, normal_vert = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, points_frag = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, points_vert = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, shadow_frag = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, shadow_vert = `#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, sprite_frag = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, sprite_vert = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;
const ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_frag,
  background_vert,
  cube_frag,
  cube_vert,
  depth_frag,
  depth_vert,
  distanceRGBA_frag,
  distanceRGBA_vert,
  equirect_frag,
  equirect_vert,
  linedashed_frag,
  linedashed_vert,
  meshbasic_frag,
  meshbasic_vert,
  meshlambert_frag,
  meshlambert_vert,
  meshmatcap_frag,
  meshmatcap_vert,
  meshtoon_frag,
  meshtoon_vert,
  meshphong_frag,
  meshphong_vert,
  meshphysical_frag,
  meshphysical_vert,
  normal_frag,
  normal_vert,
  points_frag,
  points_vert,
  shadow_frag,
  shadow_vert,
  sprite_frag,
  sprite_vert
}, UniformsLib = {
  common: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Matrix3() },
    uv2Transform: { value: new Matrix3() },
    alphaMap: { value: null }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    refractionRatio: { value: 0.98 },
    maxMipLevel: { value: 0 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new Matrix3() }
  },
  sprite: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    center: { value: new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new Matrix3() }
  }
}, ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        specular: { value: new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix3() },
      t2D: { value: null }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: new Color(0) },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color(0) }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(B, e, b, L, M) {
  const D = new Color(0);
  let I = 0, F, N, U = null, G = 0, V = null;
  function z(H, W) {
    let $ = !1, j = W.isScene === !0 ? W.background : null;
    j && j.isTexture && (j = e.get(j));
    const q = B.xr, Y = q.getSession && q.getSession();
    Y && Y.environmentBlendMode === "additive" && (j = null), j === null ? k(D, I) : j && j.isColor && (k(j, 1), $ = !0), (B.autoClear || $) && B.clear(B.autoClearColor, B.autoClearDepth, B.autoClearStencil), j && (j.isCubeTexture || j.mapping === CubeUVReflectionMapping) ? (N === void 0 && (N = new Mesh(
      new BoxGeometry(1, 1, 1),
      new ShaderMaterial({
        name: "BackgroundCubeMaterial",
        uniforms: cloneUniforms(ShaderLib.cube.uniforms),
        vertexShader: ShaderLib.cube.vertexShader,
        fragmentShader: ShaderLib.cube.fragmentShader,
        side: BackSide,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), N.geometry.deleteAttribute("normal"), N.geometry.deleteAttribute("uv"), N.onBeforeRender = function(J, K, X) {
      this.matrixWorld.copyPosition(X.matrixWorld);
    }, Object.defineProperty(N.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), L.update(N)), N.material.uniforms.envMap.value = j, N.material.uniforms.flipEnvMap.value = j.isCubeTexture && j._needsFlipEnvMap ? -1 : 1, (U !== j || G !== j.version || V !== B.toneMapping) && (N.material.needsUpdate = !0, U = j, G = j.version, V = B.toneMapping), H.unshift(N, N.geometry, N.material, 0, 0, null)) : j && j.isTexture && (F === void 0 && (F = new Mesh(
      new PlaneGeometry(2, 2),
      new ShaderMaterial({
        name: "BackgroundMaterial",
        uniforms: cloneUniforms(ShaderLib.background.uniforms),
        vertexShader: ShaderLib.background.vertexShader,
        fragmentShader: ShaderLib.background.fragmentShader,
        side: FrontSide,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), F.geometry.deleteAttribute("normal"), Object.defineProperty(F.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), L.update(F)), F.material.uniforms.t2D.value = j, j.matrixAutoUpdate === !0 && j.updateMatrix(), F.material.uniforms.uvTransform.value.copy(j.matrix), (U !== j || G !== j.version || V !== B.toneMapping) && (F.material.needsUpdate = !0, U = j, G = j.version, V = B.toneMapping), H.unshift(F, F.geometry, F.material, 0, 0, null));
  }
  function k(H, W) {
    b.buffers.color.setClear(H.r, H.g, H.b, W, M);
  }
  return {
    getClearColor: function() {
      return D;
    },
    setClearColor: function(H, W = 1) {
      D.set(H), I = W, k(D, I);
    },
    getClearAlpha: function() {
      return I;
    },
    setClearAlpha: function(H) {
      I = H, k(D, I);
    },
    render: z
  };
}
function WebGLBindingStates(B, e, b, L) {
  const M = B.getParameter(34921), D = L.isWebGL2 ? null : e.get("OES_vertex_array_object"), I = L.isWebGL2 || D !== null, F = {}, N = W(null);
  let U = N;
  function G(oe, ae, se, ie, ye) {
    let Ce = !1;
    if (I) {
      const de = H(ie, se, ae);
      U !== de && (U = de, z(U.object)), Ce = $(ie, ye), Ce && j(ie, ye);
    } else {
      const de = ae.wireframe === !0;
      (U.geometry !== ie.id || U.program !== se.id || U.wireframe !== de) && (U.geometry = ie.id, U.program = se.id, U.wireframe = de, Ce = !0);
    }
    oe.isInstancedMesh === !0 && (Ce = !0), ye !== null && b.update(ye, 34963), Ce && (Z(oe, ae, se, ie), ye !== null && B.bindBuffer(34963, b.get(ye).buffer));
  }
  function V() {
    return L.isWebGL2 ? B.createVertexArray() : D.createVertexArrayOES();
  }
  function z(oe) {
    return L.isWebGL2 ? B.bindVertexArray(oe) : D.bindVertexArrayOES(oe);
  }
  function k(oe) {
    return L.isWebGL2 ? B.deleteVertexArray(oe) : D.deleteVertexArrayOES(oe);
  }
  function H(oe, ae, se) {
    const ie = se.wireframe === !0;
    let ye = F[oe.id];
    ye === void 0 && (ye = {}, F[oe.id] = ye);
    let Ce = ye[ae.id];
    Ce === void 0 && (Ce = {}, ye[ae.id] = Ce);
    let de = Ce[ie];
    return de === void 0 && (de = W(V()), Ce[ie] = de), de;
  }
  function W(oe) {
    const ae = [], se = [], ie = [];
    for (let ye = 0; ye < M; ye++)
      ae[ye] = 0, se[ye] = 0, ie[ye] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: ae,
      enabledAttributes: se,
      attributeDivisors: ie,
      object: oe,
      attributes: {},
      index: null
    };
  }
  function $(oe, ae) {
    const se = U.attributes, ie = oe.attributes;
    let ye = 0;
    for (const Ce in ie) {
      const de = se[Ce], ve = ie[Ce];
      if (de === void 0 || de.attribute !== ve || de.data !== ve.data) return !0;
      ye++;
    }
    return U.attributesNum !== ye || U.index !== ae;
  }
  function j(oe, ae) {
    const se = {}, ie = oe.attributes;
    let ye = 0;
    for (const Ce in ie) {
      const de = ie[Ce], ve = {};
      ve.attribute = de, de.data && (ve.data = de.data), se[Ce] = ve, ye++;
    }
    U.attributes = se, U.attributesNum = ye, U.index = ae;
  }
  function q() {
    const oe = U.newAttributes;
    for (let ae = 0, se = oe.length; ae < se; ae++)
      oe[ae] = 0;
  }
  function Y(oe) {
    J(oe, 0);
  }
  function J(oe, ae) {
    const se = U.newAttributes, ie = U.enabledAttributes, ye = U.attributeDivisors;
    se[oe] = 1, ie[oe] === 0 && (B.enableVertexAttribArray(oe), ie[oe] = 1), ye[oe] !== ae && ((L.isWebGL2 ? B : e.get("ANGLE_instanced_arrays"))[L.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](oe, ae), ye[oe] = ae);
  }
  function K() {
    const oe = U.newAttributes, ae = U.enabledAttributes;
    for (let se = 0, ie = ae.length; se < ie; se++)
      ae[se] !== oe[se] && (B.disableVertexAttribArray(se), ae[se] = 0);
  }
  function X(oe, ae, se, ie, ye, Ce) {
    L.isWebGL2 === !0 && (se === 5124 || se === 5125) ? B.vertexAttribIPointer(oe, ae, se, ye, Ce) : B.vertexAttribPointer(oe, ae, se, ie, ye, Ce);
  }
  function Z(oe, ae, se, ie) {
    if (L.isWebGL2 === !1 && (oe.isInstancedMesh || ie.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    q();
    const ye = ie.attributes, Ce = se.getAttributes(), de = ae.defaultAttributeValues;
    for (const ve in Ce) {
      const ce = Ce[ve];
      if (ce >= 0) {
        const ge = ye[ve];
        if (ge !== void 0) {
          const _e = ge.normalized, Me = ge.itemSize, xe = b.get(ge);
          if (xe === void 0) continue;
          const fe = xe.buffer, Re = xe.type, Pe = xe.bytesPerElement;
          if (ge.isInterleavedBufferAttribute) {
            const Ue = ge.data, Ve = Ue.stride, Oe = ge.offset;
            Ue && Ue.isInstancedInterleavedBuffer ? (J(ce, Ue.meshPerAttribute), ie._maxInstanceCount === void 0 && (ie._maxInstanceCount = Ue.meshPerAttribute * Ue.count)) : Y(ce), B.bindBuffer(34962, fe), X(ce, Me, Re, _e, Ve * Pe, Oe * Pe);
          } else
            ge.isInstancedBufferAttribute ? (J(ce, ge.meshPerAttribute), ie._maxInstanceCount === void 0 && (ie._maxInstanceCount = ge.meshPerAttribute * ge.count)) : Y(ce), B.bindBuffer(34962, fe), X(ce, Me, Re, _e, 0, 0);
        } else if (ve === "instanceMatrix") {
          const _e = b.get(oe.instanceMatrix);
          if (_e === void 0) continue;
          const Me = _e.buffer, xe = _e.type;
          J(ce + 0, 1), J(ce + 1, 1), J(ce + 2, 1), J(ce + 3, 1), B.bindBuffer(34962, Me), B.vertexAttribPointer(ce + 0, 4, xe, !1, 64, 0), B.vertexAttribPointer(ce + 1, 4, xe, !1, 64, 16), B.vertexAttribPointer(ce + 2, 4, xe, !1, 64, 32), B.vertexAttribPointer(ce + 3, 4, xe, !1, 64, 48);
        } else if (ve === "instanceColor") {
          const _e = b.get(oe.instanceColor);
          if (_e === void 0) continue;
          const Me = _e.buffer, xe = _e.type;
          J(ce, 1), B.bindBuffer(34962, Me), B.vertexAttribPointer(ce, 3, xe, !1, 12, 0);
        } else if (de !== void 0) {
          const _e = de[ve];
          if (_e !== void 0)
            switch (_e.length) {
              case 2:
                B.vertexAttrib2fv(ce, _e);
                break;
              case 3:
                B.vertexAttrib3fv(ce, _e);
                break;
              case 4:
                B.vertexAttrib4fv(ce, _e);
                break;
              default:
                B.vertexAttrib1fv(ce, _e);
            }
        }
      }
    }
    K();
  }
  function Q() {
    pe();
    for (const oe in F) {
      const ae = F[oe];
      for (const se in ae) {
        const ie = ae[se];
        for (const ye in ie)
          k(ie[ye].object), delete ie[ye];
        delete ae[se];
      }
      delete F[oe];
    }
  }
  function ne(oe) {
    if (F[oe.id] === void 0) return;
    const ae = F[oe.id];
    for (const se in ae) {
      const ie = ae[se];
      for (const ye in ie)
        k(ie[ye].object), delete ie[ye];
      delete ae[se];
    }
    delete F[oe.id];
  }
  function le(oe) {
    for (const ae in F) {
      const se = F[ae];
      if (se[oe.id] === void 0) continue;
      const ie = se[oe.id];
      for (const ye in ie)
        k(ie[ye].object), delete ie[ye];
      delete se[oe.id];
    }
  }
  function pe() {
    ue(), U !== N && (U = N, z(U.object));
  }
  function ue() {
    N.geometry = null, N.program = null, N.wireframe = !1;
  }
  return {
    setup: G,
    reset: pe,
    resetDefaultState: ue,
    dispose: Q,
    releaseStatesOfGeometry: ne,
    releaseStatesOfProgram: le,
    initAttributes: q,
    enableAttribute: Y,
    disableUnusedAttributes: K
  };
}
function WebGLBufferRenderer(B, e, b, L) {
  const M = L.isWebGL2;
  let D;
  function I(U) {
    D = U;
  }
  function F(U, G) {
    B.drawArrays(D, U, G), b.update(G, D, 1);
  }
  function N(U, G, V) {
    if (V === 0) return;
    let z, k;
    if (M)
      z = B, k = "drawArraysInstanced";
    else if (z = e.get("ANGLE_instanced_arrays"), k = "drawArraysInstancedANGLE", z === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    z[k](D, U, G, V), b.update(G, D, V);
  }
  this.setMode = I, this.render = F, this.renderInstances = N;
}
function WebGLCapabilities(B, e, b) {
  let L;
  function M() {
    if (L !== void 0) return L;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const Z = e.get("EXT_texture_filter_anisotropic");
      L = B.getParameter(Z.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      L = 0;
    return L;
  }
  function D(Z) {
    if (Z === "highp") {
      if (B.getShaderPrecisionFormat(35633, 36338).precision > 0 && B.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      Z = "mediump";
    }
    return Z === "mediump" && B.getShaderPrecisionFormat(35633, 36337).precision > 0 && B.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const I = typeof WebGL2RenderingContext < "u" && B instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && B instanceof WebGL2ComputeRenderingContext;
  let F = b.precision !== void 0 ? b.precision : "highp";
  const N = D(F);
  N !== F && (console.warn("THREE.WebGLRenderer:", F, "not supported, using", N, "instead."), F = N);
  const U = I || e.has("WEBGL_draw_buffers"), G = b.logarithmicDepthBuffer === !0, V = B.getParameter(34930), z = B.getParameter(35660), k = B.getParameter(3379), H = B.getParameter(34076), W = B.getParameter(34921), $ = B.getParameter(36347), j = B.getParameter(36348), q = B.getParameter(36349), Y = z > 0, J = I || e.has("OES_texture_float"), K = Y && J, X = I ? B.getParameter(36183) : 0;
  return {
    isWebGL2: I,
    drawBuffers: U,
    getMaxAnisotropy: M,
    getMaxPrecision: D,
    precision: F,
    logarithmicDepthBuffer: G,
    maxTextures: V,
    maxVertexTextures: z,
    maxTextureSize: k,
    maxCubemapSize: H,
    maxAttributes: W,
    maxVertexUniforms: $,
    maxVaryings: j,
    maxFragmentUniforms: q,
    vertexTextures: Y,
    floatFragmentTextures: J,
    floatVertexTextures: K,
    maxSamples: X
  };
}
function WebGLClipping(B) {
  const e = this;
  let b = null, L = 0, M = !1, D = !1;
  const I = new Plane(), F = new Matrix3(), N = { value: null, needsUpdate: !1 };
  this.uniform = N, this.numPlanes = 0, this.numIntersection = 0, this.init = function(V, z, k) {
    const H = V.length !== 0 || z || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    L !== 0 || M;
    return M = z, b = G(V, k, 0), L = V.length, H;
  }, this.beginShadows = function() {
    D = !0, G(null);
  }, this.endShadows = function() {
    D = !1, U();
  }, this.setState = function(V, z, k) {
    const H = V.clippingPlanes, W = V.clipIntersection, $ = V.clipShadows, j = B.get(V);
    if (!M || H === null || H.length === 0 || D && !$)
      D ? G(null) : U();
    else {
      const q = D ? 0 : L, Y = q * 4;
      let J = j.clippingState || null;
      N.value = J, J = G(H, z, Y, k);
      for (let K = 0; K !== Y; ++K)
        J[K] = b[K];
      j.clippingState = J, this.numIntersection = W ? this.numPlanes : 0, this.numPlanes += q;
    }
  };
  function U() {
    N.value !== b && (N.value = b, N.needsUpdate = L > 0), e.numPlanes = L, e.numIntersection = 0;
  }
  function G(V, z, k, H) {
    const W = V !== null ? V.length : 0;
    let $ = null;
    if (W !== 0) {
      if ($ = N.value, H !== !0 || $ === null) {
        const j = k + W * 4, q = z.matrixWorldInverse;
        F.getNormalMatrix(q), ($ === null || $.length < j) && ($ = new Float32Array(j));
        for (let Y = 0, J = k; Y !== W; ++Y, J += 4)
          I.copy(V[Y]).applyMatrix4(q, F), I.normal.toArray($, J), $[J + 3] = I.constant;
      }
      N.value = $, N.needsUpdate = !0;
    }
    return e.numPlanes = W, e.numIntersection = 0, $;
  }
}
function WebGLCubeMaps(B) {
  let e = /* @__PURE__ */ new WeakMap();
  function b(I, F) {
    return F === EquirectangularReflectionMapping ? I.mapping = CubeReflectionMapping : F === EquirectangularRefractionMapping && (I.mapping = CubeRefractionMapping), I;
  }
  function L(I) {
    if (I && I.isTexture) {
      const F = I.mapping;
      if (F === EquirectangularReflectionMapping || F === EquirectangularRefractionMapping)
        if (e.has(I)) {
          const N = e.get(I).texture;
          return b(N, I.mapping);
        } else {
          const N = I.image;
          if (N && N.height > 0) {
            const U = B.getRenderTarget(), G = new WebGLCubeRenderTarget(N.height / 2);
            return G.fromEquirectangularTexture(B, I), e.set(I, G), B.setRenderTarget(U), I.addEventListener("dispose", M), b(G.texture, I.mapping);
          } else
            return null;
        }
    }
    return I;
  }
  function M(I) {
    const F = I.target;
    F.removeEventListener("dispose", M);
    const N = e.get(F);
    N !== void 0 && (e.delete(F), N.dispose());
  }
  function D() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: L,
    dispose: D
  };
}
function WebGLExtensions(B) {
  const e = {};
  function b(L) {
    if (e[L] !== void 0)
      return e[L];
    let M;
    switch (L) {
      case "WEBGL_depth_texture":
        M = B.getExtension("WEBGL_depth_texture") || B.getExtension("MOZ_WEBGL_depth_texture") || B.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        M = B.getExtension("EXT_texture_filter_anisotropic") || B.getExtension("MOZ_EXT_texture_filter_anisotropic") || B.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        M = B.getExtension("WEBGL_compressed_texture_s3tc") || B.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || B.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        M = B.getExtension("WEBGL_compressed_texture_pvrtc") || B.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        M = B.getExtension(L);
    }
    return e[L] = M, M;
  }
  return {
    has: function(L) {
      return b(L) !== null;
    },
    init: function(L) {
      L.isWebGL2 ? b("EXT_color_buffer_float") : (b("WEBGL_depth_texture"), b("OES_texture_float"), b("OES_texture_half_float"), b("OES_texture_half_float_linear"), b("OES_standard_derivatives"), b("OES_element_index_uint"), b("OES_vertex_array_object"), b("ANGLE_instanced_arrays")), b("OES_texture_float_linear"), b("EXT_color_buffer_half_float");
    },
    get: function(L) {
      const M = b(L);
      return M === null && console.warn("THREE.WebGLRenderer: " + L + " extension not supported."), M;
    }
  };
}
function WebGLGeometries(B, e, b, L) {
  const M = {}, D = /* @__PURE__ */ new WeakMap();
  function I(V) {
    const z = V.target;
    z.index !== null && e.remove(z.index);
    for (const H in z.attributes)
      e.remove(z.attributes[H]);
    z.removeEventListener("dispose", I), delete M[z.id];
    const k = D.get(z);
    k && (e.remove(k), D.delete(z)), L.releaseStatesOfGeometry(z), z.isInstancedBufferGeometry === !0 && delete z._maxInstanceCount, b.memory.geometries--;
  }
  function F(V, z) {
    return M[z.id] === !0 || (z.addEventListener("dispose", I), M[z.id] = !0, b.memory.geometries++), z;
  }
  function N(V) {
    const z = V.attributes;
    for (const H in z)
      e.update(z[H], 34962);
    const k = V.morphAttributes;
    for (const H in k) {
      const W = k[H];
      for (let $ = 0, j = W.length; $ < j; $++)
        e.update(W[$], 34962);
    }
  }
  function U(V) {
    const z = [], k = V.index, H = V.attributes.position;
    let W = 0;
    if (k !== null) {
      const q = k.array;
      W = k.version;
      for (let Y = 0, J = q.length; Y < J; Y += 3) {
        const K = q[Y + 0], X = q[Y + 1], Z = q[Y + 2];
        z.push(K, X, X, Z, Z, K);
      }
    } else {
      const q = H.array;
      W = H.version;
      for (let Y = 0, J = q.length / 3 - 1; Y < J; Y += 3) {
        const K = Y + 0, X = Y + 1, Z = Y + 2;
        z.push(K, X, X, Z, Z, K);
      }
    }
    const $ = new (arrayMax(z) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(z, 1);
    $.version = W;
    const j = D.get(V);
    j && e.remove(j), D.set(V, $);
  }
  function G(V) {
    const z = D.get(V);
    if (z) {
      const k = V.index;
      k !== null && z.version < k.version && U(V);
    } else
      U(V);
    return D.get(V);
  }
  return {
    get: F,
    update: N,
    getWireframeAttribute: G
  };
}
function WebGLIndexedBufferRenderer(B, e, b, L) {
  const M = L.isWebGL2;
  let D;
  function I(z) {
    D = z;
  }
  let F, N;
  function U(z) {
    F = z.type, N = z.bytesPerElement;
  }
  function G(z, k) {
    B.drawElements(D, k, F, z * N), b.update(k, D, 1);
  }
  function V(z, k, H) {
    if (H === 0) return;
    let W, $;
    if (M)
      W = B, $ = "drawElementsInstanced";
    else if (W = e.get("ANGLE_instanced_arrays"), $ = "drawElementsInstancedANGLE", W === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    W[$](D, k, F, z * N, H), b.update(k, D, H);
  }
  this.setMode = I, this.setIndex = U, this.render = G, this.renderInstances = V;
}
function WebGLInfo(B) {
  const e = {
    geometries: 0,
    textures: 0
  }, b = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function L(D, I, F) {
    switch (b.calls++, I) {
      case 4:
        b.triangles += F * (D / 3);
        break;
      case 1:
        b.lines += F * (D / 2);
        break;
      case 3:
        b.lines += F * (D - 1);
        break;
      case 2:
        b.lines += F * D;
        break;
      case 0:
        b.points += F * D;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", I);
        break;
    }
  }
  function M() {
    b.frame++, b.calls = 0, b.triangles = 0, b.points = 0, b.lines = 0;
  }
  return {
    memory: e,
    render: b,
    programs: null,
    autoReset: !0,
    reset: M,
    update: L
  };
}
function numericalSort(B, e) {
  return B[0] - e[0];
}
function absNumericalSort(B, e) {
  return Math.abs(e[1]) - Math.abs(B[1]);
}
function WebGLMorphtargets(B) {
  const e = {}, b = new Float32Array(8), L = [];
  for (let D = 0; D < 8; D++)
    L[D] = [D, 0];
  function M(D, I, F, N) {
    const U = D.morphTargetInfluences, G = U === void 0 ? 0 : U.length;
    let V = e[I.id];
    if (V === void 0 || V.length !== G) {
      V = [];
      for (let $ = 0; $ < G; $++)
        V[$] = [$, 0];
      e[I.id] = V;
    }
    for (let $ = 0; $ < G; $++) {
      const j = V[$];
      j[0] = $, j[1] = U[$];
    }
    V.sort(absNumericalSort);
    for (let $ = 0; $ < 8; $++)
      $ < G && V[$][1] ? (L[$][0] = V[$][0], L[$][1] = V[$][1]) : (L[$][0] = Number.MAX_SAFE_INTEGER, L[$][1] = 0);
    L.sort(numericalSort);
    const z = F.morphTargets && I.morphAttributes.position, k = F.morphNormals && I.morphAttributes.normal;
    let H = 0;
    for (let $ = 0; $ < 8; $++) {
      const j = L[$], q = j[0], Y = j[1];
      q !== Number.MAX_SAFE_INTEGER && Y ? (z && I.getAttribute("morphTarget" + $) !== z[q] && I.setAttribute("morphTarget" + $, z[q]), k && I.getAttribute("morphNormal" + $) !== k[q] && I.setAttribute("morphNormal" + $, k[q]), b[$] = Y, H += Y) : (z && I.hasAttribute("morphTarget" + $) === !0 && I.deleteAttribute("morphTarget" + $), k && I.hasAttribute("morphNormal" + $) === !0 && I.deleteAttribute("morphNormal" + $), b[$] = 0);
    }
    const W = I.morphTargetsRelative ? 1 : 1 - H;
    N.getUniforms().setValue(B, "morphTargetBaseInfluence", W), N.getUniforms().setValue(B, "morphTargetInfluences", b);
  }
  return {
    update: M
  };
}
function WebGLObjects(B, e, b, L) {
  let M = /* @__PURE__ */ new WeakMap();
  function D(N) {
    const U = L.render.frame, G = N.geometry, V = e.get(N, G);
    return M.get(V) !== U && (e.update(V), M.set(V, U)), N.isInstancedMesh && (N.hasEventListener("dispose", F) === !1 && N.addEventListener("dispose", F), b.update(N.instanceMatrix, 34962), N.instanceColor !== null && b.update(N.instanceColor, 34962)), V;
  }
  function I() {
    M = /* @__PURE__ */ new WeakMap();
  }
  function F(N) {
    const U = N.target;
    U.removeEventListener("dispose", F), b.remove(U.instanceMatrix), U.instanceColor !== null && b.remove(U.instanceColor);
  }
  return {
    update: D,
    dispose: I
  };
}
class DataTexture2DArray extends Texture {
  constructor(e = null, b = 1, L = 1, M = 1) {
    super(null), this.image = { data: e, width: b, height: L, depth: M }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0;
  }
}
DataTexture2DArray.prototype.isDataTexture2DArray = !0;
class DataTexture3D extends Texture {
  constructor(e = null, b = 1, L = 1, M = 1) {
    super(null), this.image = { data: e, width: b, height: L, depth: M }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0;
  }
}
DataTexture3D.prototype.isDataTexture3D = !0;
const emptyTexture = new Texture(), emptyTexture2dArray = new DataTexture2DArray(), emptyTexture3d = new DataTexture3D(), emptyCubeTexture = new CubeTexture(), arrayCacheF32 = [], arrayCacheI32 = [], mat4array = new Float32Array(16), mat3array = new Float32Array(9), mat2array = new Float32Array(4);
function flatten(B, e, b) {
  const L = B[0];
  if (L <= 0 || L > 0) return B;
  const M = e * b;
  let D = arrayCacheF32[M];
  if (D === void 0 && (D = new Float32Array(M), arrayCacheF32[M] = D), e !== 0) {
    L.toArray(D, 0);
    for (let I = 1, F = 0; I !== e; ++I)
      F += b, B[I].toArray(D, F);
  }
  return D;
}
function arraysEqual(B, e) {
  if (B.length !== e.length) return !1;
  for (let b = 0, L = B.length; b < L; b++)
    if (B[b] !== e[b]) return !1;
  return !0;
}
function copyArray$1(B, e) {
  for (let b = 0, L = e.length; b < L; b++)
    B[b] = e[b];
}
function allocTexUnits(B, e) {
  let b = arrayCacheI32[e];
  b === void 0 && (b = new Int32Array(e), arrayCacheI32[e] = b);
  for (let L = 0; L !== e; ++L)
    b[L] = B.allocateTextureUnit();
  return b;
}
function setValueV1f(B, e) {
  const b = this.cache;
  b[0] !== e && (B.uniform1f(this.addr, e), b[0] = e);
}
function setValueV2f(B, e) {
  const b = this.cache;
  if (e.x !== void 0)
    (b[0] !== e.x || b[1] !== e.y) && (B.uniform2f(this.addr, e.x, e.y), b[0] = e.x, b[1] = e.y);
  else {
    if (arraysEqual(b, e)) return;
    B.uniform2fv(this.addr, e), copyArray$1(b, e);
  }
}
function setValueV3f(B, e) {
  const b = this.cache;
  if (e.x !== void 0)
    (b[0] !== e.x || b[1] !== e.y || b[2] !== e.z) && (B.uniform3f(this.addr, e.x, e.y, e.z), b[0] = e.x, b[1] = e.y, b[2] = e.z);
  else if (e.r !== void 0)
    (b[0] !== e.r || b[1] !== e.g || b[2] !== e.b) && (B.uniform3f(this.addr, e.r, e.g, e.b), b[0] = e.r, b[1] = e.g, b[2] = e.b);
  else {
    if (arraysEqual(b, e)) return;
    B.uniform3fv(this.addr, e), copyArray$1(b, e);
  }
}
function setValueV4f(B, e) {
  const b = this.cache;
  if (e.x !== void 0)
    (b[0] !== e.x || b[1] !== e.y || b[2] !== e.z || b[3] !== e.w) && (B.uniform4f(this.addr, e.x, e.y, e.z, e.w), b[0] = e.x, b[1] = e.y, b[2] = e.z, b[3] = e.w);
  else {
    if (arraysEqual(b, e)) return;
    B.uniform4fv(this.addr, e), copyArray$1(b, e);
  }
}
function setValueM2(B, e) {
  const b = this.cache, L = e.elements;
  if (L === void 0) {
    if (arraysEqual(b, e)) return;
    B.uniformMatrix2fv(this.addr, !1, e), copyArray$1(b, e);
  } else {
    if (arraysEqual(b, L)) return;
    mat2array.set(L), B.uniformMatrix2fv(this.addr, !1, mat2array), copyArray$1(b, L);
  }
}
function setValueM3(B, e) {
  const b = this.cache, L = e.elements;
  if (L === void 0) {
    if (arraysEqual(b, e)) return;
    B.uniformMatrix3fv(this.addr, !1, e), copyArray$1(b, e);
  } else {
    if (arraysEqual(b, L)) return;
    mat3array.set(L), B.uniformMatrix3fv(this.addr, !1, mat3array), copyArray$1(b, L);
  }
}
function setValueM4(B, e) {
  const b = this.cache, L = e.elements;
  if (L === void 0) {
    if (arraysEqual(b, e)) return;
    B.uniformMatrix4fv(this.addr, !1, e), copyArray$1(b, e);
  } else {
    if (arraysEqual(b, L)) return;
    mat4array.set(L), B.uniformMatrix4fv(this.addr, !1, mat4array), copyArray$1(b, L);
  }
}
function setValueV1i(B, e) {
  const b = this.cache;
  b[0] !== e && (B.uniform1i(this.addr, e), b[0] = e);
}
function setValueV2i(B, e) {
  const b = this.cache;
  arraysEqual(b, e) || (B.uniform2iv(this.addr, e), copyArray$1(b, e));
}
function setValueV3i(B, e) {
  const b = this.cache;
  arraysEqual(b, e) || (B.uniform3iv(this.addr, e), copyArray$1(b, e));
}
function setValueV4i(B, e) {
  const b = this.cache;
  arraysEqual(b, e) || (B.uniform4iv(this.addr, e), copyArray$1(b, e));
}
function setValueV1ui(B, e) {
  const b = this.cache;
  b[0] !== e && (B.uniform1ui(this.addr, e), b[0] = e);
}
function setValueV2ui(B, e) {
  const b = this.cache;
  arraysEqual(b, e) || (B.uniform2uiv(this.addr, e), copyArray$1(b, e));
}
function setValueV3ui(B, e) {
  const b = this.cache;
  arraysEqual(b, e) || (B.uniform3uiv(this.addr, e), copyArray$1(b, e));
}
function setValueV4ui(B, e) {
  const b = this.cache;
  arraysEqual(b, e) || (B.uniform4uiv(this.addr, e), copyArray$1(b, e));
}
function setValueT1(B, e, b) {
  const L = this.cache, M = b.allocateTextureUnit();
  L[0] !== M && (B.uniform1i(this.addr, M), L[0] = M), b.safeSetTexture2D(e || emptyTexture, M);
}
function setValueT3D1(B, e, b) {
  const L = this.cache, M = b.allocateTextureUnit();
  L[0] !== M && (B.uniform1i(this.addr, M), L[0] = M), b.setTexture3D(e || emptyTexture3d, M);
}
function setValueT6(B, e, b) {
  const L = this.cache, M = b.allocateTextureUnit();
  L[0] !== M && (B.uniform1i(this.addr, M), L[0] = M), b.safeSetTextureCube(e || emptyCubeTexture, M);
}
function setValueT2DArray1(B, e, b) {
  const L = this.cache, M = b.allocateTextureUnit();
  L[0] !== M && (B.uniform1i(this.addr, M), L[0] = M), b.setTexture2DArray(e || emptyTexture2dArray, M);
}
function getSingularSetter(B) {
  switch (B) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(B, e) {
  B.uniform1fv(this.addr, e);
}
function setValueV2fArray(B, e) {
  const b = flatten(e, this.size, 2);
  B.uniform2fv(this.addr, b);
}
function setValueV3fArray(B, e) {
  const b = flatten(e, this.size, 3);
  B.uniform3fv(this.addr, b);
}
function setValueV4fArray(B, e) {
  const b = flatten(e, this.size, 4);
  B.uniform4fv(this.addr, b);
}
function setValueM2Array(B, e) {
  const b = flatten(e, this.size, 4);
  B.uniformMatrix2fv(this.addr, !1, b);
}
function setValueM3Array(B, e) {
  const b = flatten(e, this.size, 9);
  B.uniformMatrix3fv(this.addr, !1, b);
}
function setValueM4Array(B, e) {
  const b = flatten(e, this.size, 16);
  B.uniformMatrix4fv(this.addr, !1, b);
}
function setValueV1iArray(B, e) {
  B.uniform1iv(this.addr, e);
}
function setValueV2iArray(B, e) {
  B.uniform2iv(this.addr, e);
}
function setValueV3iArray(B, e) {
  B.uniform3iv(this.addr, e);
}
function setValueV4iArray(B, e) {
  B.uniform4iv(this.addr, e);
}
function setValueV1uiArray(B, e) {
  B.uniform1uiv(this.addr, e);
}
function setValueV2uiArray(B, e) {
  B.uniform2uiv(this.addr, e);
}
function setValueV3uiArray(B, e) {
  B.uniform3uiv(this.addr, e);
}
function setValueV4uiArray(B, e) {
  B.uniform4uiv(this.addr, e);
}
function setValueT1Array(B, e, b) {
  const L = e.length, M = allocTexUnits(b, L);
  B.uniform1iv(this.addr, M);
  for (let D = 0; D !== L; ++D)
    b.safeSetTexture2D(e[D] || emptyTexture, M[D]);
}
function setValueT6Array(B, e, b) {
  const L = e.length, M = allocTexUnits(b, L);
  B.uniform1iv(this.addr, M);
  for (let D = 0; D !== L; ++D)
    b.safeSetTextureCube(e[D] || emptyCubeTexture, M[D]);
}
function getPureArraySetter(B) {
  switch (B) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
  }
}
function SingleUniform(B, e, b) {
  this.id = B, this.addr = b, this.cache = [], this.setValue = getSingularSetter(e.type);
}
function PureArrayUniform(B, e, b) {
  this.id = B, this.addr = b, this.cache = [], this.size = e.size, this.setValue = getPureArraySetter(e.type);
}
PureArrayUniform.prototype.updateCache = function(B) {
  const e = this.cache;
  B instanceof Float32Array && e.length !== B.length && (this.cache = new Float32Array(B.length)), copyArray$1(e, B);
};
function StructuredUniform(B) {
  this.id = B, this.seq = [], this.map = {};
}
StructuredUniform.prototype.setValue = function(B, e, b) {
  const L = this.seq;
  for (let M = 0, D = L.length; M !== D; ++M) {
    const I = L[M];
    I.setValue(B, e[I.id], b);
  }
};
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(B, e) {
  B.seq.push(e), B.map[e.id] = e;
}
function parseUniform(B, e, b) {
  const L = B.name, M = L.length;
  for (RePathPart.lastIndex = 0; ; ) {
    const D = RePathPart.exec(L), I = RePathPart.lastIndex;
    let F = D[1];
    const N = D[2] === "]", U = D[3];
    if (N && (F = F | 0), U === void 0 || U === "[" && I + 2 === M) {
      addUniform(b, U === void 0 ? new SingleUniform(F, B, e) : new PureArrayUniform(F, B, e));
      break;
    } else {
      let V = b.map[F];
      V === void 0 && (V = new StructuredUniform(F), addUniform(b, V)), b = V;
    }
  }
}
function WebGLUniforms(B, e) {
  this.seq = [], this.map = {};
  const b = B.getProgramParameter(e, 35718);
  for (let L = 0; L < b; ++L) {
    const M = B.getActiveUniform(e, L), D = B.getUniformLocation(e, M.name);
    parseUniform(M, D, this);
  }
}
WebGLUniforms.prototype.setValue = function(B, e, b, L) {
  const M = this.map[e];
  M !== void 0 && M.setValue(B, b, L);
};
WebGLUniforms.prototype.setOptional = function(B, e, b) {
  const L = e[b];
  L !== void 0 && this.setValue(B, b, L);
};
WebGLUniforms.upload = function(B, e, b, L) {
  for (let M = 0, D = e.length; M !== D; ++M) {
    const I = e[M], F = b[I.id];
    F.needsUpdate !== !1 && I.setValue(B, F.value, L);
  }
};
WebGLUniforms.seqWithValue = function(B, e) {
  const b = [];
  for (let L = 0, M = B.length; L !== M; ++L) {
    const D = B[L];
    D.id in e && b.push(D);
  }
  return b;
};
function WebGLShader(B, e, b) {
  const L = B.createShader(e);
  return B.shaderSource(L, b), B.compileShader(L), L;
}
let programIdCount = 0;
function addLineNumbers(B) {
  const e = B.split(`
`);
  for (let b = 0; b < e.length; b++)
    e[b] = b + 1 + ": " + e[b];
  return e.join(`
`);
}
function getEncodingComponents(B) {
  switch (B) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case LogLuvEncoding:
      return ["LogLuv", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", B), ["Linear", "( value )"];
  }
}
function getShaderErrors(B, e, b) {
  const L = B.getShaderParameter(e, 35713), M = B.getShaderInfoLog(e).trim();
  if (L && M === "") return "";
  const D = B.getShaderSource(e);
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + b + `
` + M + addLineNumbers(D);
}
function getTexelDecodingFunction(B, e) {
  const b = getEncodingComponents(e);
  return "vec4 " + B + "( vec4 value ) { return " + b[0] + "ToLinear" + b[1] + "; }";
}
function getTexelEncodingFunction(B, e) {
  const b = getEncodingComponents(e);
  return "vec4 " + B + "( vec4 value ) { return LinearTo" + b[0] + b[1] + "; }";
}
function getToneMappingFunction(B, e) {
  let b;
  switch (e) {
    case LinearToneMapping:
      b = "Linear";
      break;
    case ReinhardToneMapping:
      b = "Reinhard";
      break;
    case CineonToneMapping:
      b = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      b = "ACESFilmic";
      break;
    case CustomToneMapping:
      b = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), b = "Linear";
  }
  return "vec3 " + B + "( vec3 color ) { return " + b + "ToneMapping( color ); }";
}
function generateExtensions(B) {
  return [
    B.extensionDerivatives || B.envMapCubeUV || B.bumpMap || B.tangentSpaceNormalMap || B.clearcoatNormalMap || B.flatShading || B.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (B.extensionFragDepth || B.logarithmicDepthBuffer) && B.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    B.extensionDrawBuffers && B.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (B.extensionShaderTextureLOD || B.envMap || B.transmission > 0) && B.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(filterEmptyLine).join(`
`);
}
function generateDefines(B) {
  const e = [];
  for (const b in B) {
    const L = B[b];
    L !== !1 && e.push("#define " + b + " " + L);
  }
  return e.join(`
`);
}
function fetchAttributeLocations(B, e) {
  const b = {}, L = B.getProgramParameter(e, 35721);
  for (let M = 0; M < L; M++) {
    const I = B.getActiveAttrib(e, M).name;
    b[I] = B.getAttribLocation(e, I);
  }
  return b;
}
function filterEmptyLine(B) {
  return B !== "";
}
function replaceLightNums(B, e) {
  return B.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function replaceClippingPlaneNums(B, e) {
  return B.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(B) {
  return B.replace(includePattern, includeReplacer);
}
function includeReplacer(B, e) {
  const b = ShaderChunk[e];
  if (b === void 0)
    throw new Error("Can not resolve #include <" + e + ">");
  return resolveIncludes(b);
}
const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(B) {
  return B.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(B, e, b, L) {
  return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), loopReplacer(B, e, b, L);
}
function loopReplacer(B, e, b, L) {
  let M = "";
  for (let D = parseInt(e); D < parseInt(b); D++)
    M += L.replace(/\[\s*i\s*\]/g, "[ " + D + " ]").replace(/UNROLLED_LOOP_INDEX/g, D);
  return M;
}
function generatePrecision(B) {
  let e = "precision " + B.precision + ` float;
precision ` + B.precision + " int;";
  return B.precision === "highp" ? e += `
#define HIGH_PRECISION` : B.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : B.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function generateShadowMapTypeDefine(B) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return B.shadowMapType === PCFShadowMap ? e = "SHADOWMAP_TYPE_PCF" : B.shadowMapType === PCFSoftShadowMap ? e = "SHADOWMAP_TYPE_PCF_SOFT" : B.shadowMapType === VSMShadowMap && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function generateEnvMapTypeDefine(B) {
  let e = "ENVMAP_TYPE_CUBE";
  if (B.envMap)
    switch (B.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function generateEnvMapModeDefine(B) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (B.envMap)
    switch (B.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function generateEnvMapBlendingDefine(B) {
  let e = "ENVMAP_BLENDING_NONE";
  if (B.envMap)
    switch (B.combine) {
      case MultiplyOperation:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function WebGLProgram(B, e, b, L) {
  const M = B.getContext(), D = b.defines;
  let I = b.vertexShader, F = b.fragmentShader;
  const N = generateShadowMapTypeDefine(b), U = generateEnvMapTypeDefine(b), G = generateEnvMapModeDefine(b), V = generateEnvMapBlendingDefine(b), z = B.gammaFactor > 0 ? B.gammaFactor : 1, k = b.isWebGL2 ? "" : generateExtensions(b), H = generateDefines(D), W = M.createProgram();
  let $, j, q = b.glslVersion ? "#version " + b.glslVersion + `
` : "";
  b.isRawShaderMaterial ? ($ = [
    H
  ].filter(filterEmptyLine).join(`
`), $.length > 0 && ($ += `
`), j = [
    k,
    H
  ].filter(filterEmptyLine).join(`
`), j.length > 0 && (j += `
`)) : ($ = [
    generatePrecision(b),
    "#define SHADER_NAME " + b.shaderName,
    H,
    b.instancing ? "#define USE_INSTANCING" : "",
    b.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    b.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
    "#define GAMMA_FACTOR " + z,
    "#define MAX_BONES " + b.maxBones,
    b.useFog && b.fog ? "#define USE_FOG" : "",
    b.useFog && b.fogExp2 ? "#define FOG_EXP2" : "",
    b.map ? "#define USE_MAP" : "",
    b.envMap ? "#define USE_ENVMAP" : "",
    b.envMap ? "#define " + G : "",
    b.lightMap ? "#define USE_LIGHTMAP" : "",
    b.aoMap ? "#define USE_AOMAP" : "",
    b.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    b.bumpMap ? "#define USE_BUMPMAP" : "",
    b.normalMap ? "#define USE_NORMALMAP" : "",
    b.normalMap && b.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    b.normalMap && b.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    b.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    b.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    b.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    b.displacementMap && b.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
    b.specularMap ? "#define USE_SPECULARMAP" : "",
    b.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    b.metalnessMap ? "#define USE_METALNESSMAP" : "",
    b.alphaMap ? "#define USE_ALPHAMAP" : "",
    b.transmission ? "#define USE_TRANSMISSION" : "",
    b.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    b.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    b.vertexTangents ? "#define USE_TANGENT" : "",
    b.vertexColors ? "#define USE_COLOR" : "",
    b.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    b.vertexUvs ? "#define USE_UV" : "",
    b.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    b.flatShading ? "#define FLAT_SHADED" : "",
    b.skinning ? "#define USE_SKINNING" : "",
    b.useVertexTexture ? "#define BONE_TEXTURE" : "",
    b.morphTargets ? "#define USE_MORPHTARGETS" : "",
    b.morphNormals && b.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    b.doubleSided ? "#define DOUBLE_SIDED" : "",
    b.flipSided ? "#define FLIP_SIDED" : "",
    b.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    b.shadowMapEnabled ? "#define " + N : "",
    b.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    b.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    b.logarithmicDepthBuffer && b.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_MORPHTARGETS",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(filterEmptyLine).join(`
`), j = [
    k,
    generatePrecision(b),
    "#define SHADER_NAME " + b.shaderName,
    H,
    b.alphaTest ? "#define ALPHATEST " + b.alphaTest + (b.alphaTest % 1 ? "" : ".0") : "",
    // add '.0' if integer
    "#define GAMMA_FACTOR " + z,
    b.useFog && b.fog ? "#define USE_FOG" : "",
    b.useFog && b.fogExp2 ? "#define FOG_EXP2" : "",
    b.map ? "#define USE_MAP" : "",
    b.matcap ? "#define USE_MATCAP" : "",
    b.envMap ? "#define USE_ENVMAP" : "",
    b.envMap ? "#define " + U : "",
    b.envMap ? "#define " + G : "",
    b.envMap ? "#define " + V : "",
    b.lightMap ? "#define USE_LIGHTMAP" : "",
    b.aoMap ? "#define USE_AOMAP" : "",
    b.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    b.bumpMap ? "#define USE_BUMPMAP" : "",
    b.normalMap ? "#define USE_NORMALMAP" : "",
    b.normalMap && b.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    b.normalMap && b.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    b.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    b.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    b.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    b.specularMap ? "#define USE_SPECULARMAP" : "",
    b.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    b.metalnessMap ? "#define USE_METALNESSMAP" : "",
    b.alphaMap ? "#define USE_ALPHAMAP" : "",
    b.sheen ? "#define USE_SHEEN" : "",
    b.transmission ? "#define USE_TRANSMISSION" : "",
    b.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    b.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    b.vertexTangents ? "#define USE_TANGENT" : "",
    b.vertexColors || b.instancingColor ? "#define USE_COLOR" : "",
    b.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    b.vertexUvs ? "#define USE_UV" : "",
    b.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    b.gradientMap ? "#define USE_GRADIENTMAP" : "",
    b.flatShading ? "#define FLAT_SHADED" : "",
    b.doubleSided ? "#define DOUBLE_SIDED" : "",
    b.flipSided ? "#define FLIP_SIDED" : "",
    b.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    b.shadowMapEnabled ? "#define " + N : "",
    b.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    b.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
    b.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    b.logarithmicDepthBuffer && b.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    (b.extensionShaderTextureLOD || b.envMap) && b.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    b.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
    b.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    b.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", b.toneMapping) : "",
    b.dithering ? "#define DITHERING" : "",
    ShaderChunk.encodings_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    b.map ? getTexelDecodingFunction("mapTexelToLinear", b.mapEncoding) : "",
    b.matcap ? getTexelDecodingFunction("matcapTexelToLinear", b.matcapEncoding) : "",
    b.envMap ? getTexelDecodingFunction("envMapTexelToLinear", b.envMapEncoding) : "",
    b.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", b.emissiveMapEncoding) : "",
    b.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", b.lightMapEncoding) : "",
    getTexelEncodingFunction("linearToOutputTexel", b.outputEncoding),
    b.depthPacking ? "#define DEPTH_PACKING " + b.depthPacking : "",
    `
`
  ].filter(filterEmptyLine).join(`
`)), I = resolveIncludes(I), I = replaceLightNums(I, b), I = replaceClippingPlaneNums(I, b), F = resolveIncludes(F), F = replaceLightNums(F, b), F = replaceClippingPlaneNums(F, b), I = unrollLoops(I), F = unrollLoops(F), b.isWebGL2 && b.isRawShaderMaterial !== !0 && (q = `#version 300 es
`, $ = [
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + $, j = [
    "#define varying in",
    b.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
    b.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + j);
  const Y = q + $ + I, J = q + j + F, K = WebGLShader(M, 35633, Y), X = WebGLShader(M, 35632, J);
  if (M.attachShader(W, K), M.attachShader(W, X), b.index0AttributeName !== void 0 ? M.bindAttribLocation(W, 0, b.index0AttributeName) : b.morphTargets === !0 && M.bindAttribLocation(W, 0, "position"), M.linkProgram(W), B.debug.checkShaderErrors) {
    const ne = M.getProgramInfoLog(W).trim(), le = M.getShaderInfoLog(K).trim(), pe = M.getShaderInfoLog(X).trim();
    let ue = !0, oe = !0;
    if (M.getProgramParameter(W, 35714) === !1) {
      ue = !1;
      const ae = getShaderErrors(M, K, "vertex"), se = getShaderErrors(M, X, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", M.getError(), "35715", M.getProgramParameter(W, 35715), "gl.getProgramInfoLog", ne, ae, se);
    } else ne !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", ne) : (le === "" || pe === "") && (oe = !1);
    oe && (this.diagnostics = {
      runnable: ue,
      programLog: ne,
      vertexShader: {
        log: le,
        prefix: $
      },
      fragmentShader: {
        log: pe,
        prefix: j
      }
    });
  }
  M.deleteShader(K), M.deleteShader(X);
  let Z;
  this.getUniforms = function() {
    return Z === void 0 && (Z = new WebGLUniforms(M, W)), Z;
  };
  let Q;
  return this.getAttributes = function() {
    return Q === void 0 && (Q = fetchAttributeLocations(M, W)), Q;
  }, this.destroy = function() {
    L.releaseStatesOfProgram(this), M.deleteProgram(W), this.program = void 0;
  }, this.name = b.shaderName, this.id = programIdCount++, this.cacheKey = e, this.usedTimes = 1, this.program = W, this.vertexShader = K, this.fragmentShader = X, this;
}
function WebGLPrograms(B, e, b, L, M, D) {
  const I = [], F = L.isWebGL2, N = L.logarithmicDepthBuffer, U = L.floatVertexTextures, G = L.maxVertexUniforms, V = L.vertexTextures;
  let z = L.precision;
  const k = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  }, H = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "instancingColor",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "vertexAlphas",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "sheen",
    "transmission",
    "transmissionMap",
    "thicknessMap"
  ];
  function W(X) {
    const Q = X.skeleton.bones;
    if (U)
      return 1024;
    {
      const le = Math.floor((G - 20) / 4), pe = Math.min(le, Q.length);
      return pe < Q.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + Q.length + " bones. This GPU supports " + pe + "."), 0) : pe;
    }
  }
  function $(X) {
    let Z;
    return X && X.isTexture ? Z = X.encoding : X && X.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), Z = X.texture.encoding) : Z = LinearEncoding, Z;
  }
  function j(X, Z, Q, ne, le) {
    const pe = ne.fog, ue = X.isMeshStandardMaterial ? ne.environment : null, oe = e.get(X.envMap || ue), ae = k[X.type], se = le.isSkinnedMesh ? W(le) : 0;
    X.precision !== null && (z = L.getMaxPrecision(X.precision), z !== X.precision && console.warn("THREE.WebGLProgram.getParameters:", X.precision, "not supported, using", z, "instead."));
    let ie, ye;
    if (ae) {
      const ve = ShaderLib[ae];
      ie = ve.vertexShader, ye = ve.fragmentShader;
    } else
      ie = X.vertexShader, ye = X.fragmentShader;
    const Ce = B.getRenderTarget();
    return {
      isWebGL2: F,
      shaderID: ae,
      shaderName: X.type,
      vertexShader: ie,
      fragmentShader: ye,
      defines: X.defines,
      isRawShaderMaterial: X.isRawShaderMaterial === !0,
      glslVersion: X.glslVersion,
      precision: z,
      instancing: le.isInstancedMesh === !0,
      instancingColor: le.isInstancedMesh === !0 && le.instanceColor !== null,
      supportsVertexTextures: V,
      outputEncoding: Ce !== null ? $(Ce.texture) : B.outputEncoding,
      map: !!X.map,
      mapEncoding: $(X.map),
      matcap: !!X.matcap,
      matcapEncoding: $(X.matcap),
      envMap: !!oe,
      envMapMode: oe && oe.mapping,
      envMapEncoding: $(oe),
      envMapCubeUV: !!oe && (oe.mapping === CubeUVReflectionMapping || oe.mapping === CubeUVRefractionMapping),
      lightMap: !!X.lightMap,
      lightMapEncoding: $(X.lightMap),
      aoMap: !!X.aoMap,
      emissiveMap: !!X.emissiveMap,
      emissiveMapEncoding: $(X.emissiveMap),
      bumpMap: !!X.bumpMap,
      normalMap: !!X.normalMap,
      objectSpaceNormalMap: X.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: X.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!X.clearcoatMap,
      clearcoatRoughnessMap: !!X.clearcoatRoughnessMap,
      clearcoatNormalMap: !!X.clearcoatNormalMap,
      displacementMap: !!X.displacementMap,
      roughnessMap: !!X.roughnessMap,
      metalnessMap: !!X.metalnessMap,
      specularMap: !!X.specularMap,
      alphaMap: !!X.alphaMap,
      gradientMap: !!X.gradientMap,
      sheen: !!X.sheen,
      transmission: !!X.transmission,
      transmissionMap: !!X.transmissionMap,
      thicknessMap: !!X.thicknessMap,
      combine: X.combine,
      vertexTangents: X.normalMap && X.vertexTangents,
      vertexColors: X.vertexColors,
      vertexAlphas: X.vertexColors === !0 && le.geometry && le.geometry.attributes.color && le.geometry.attributes.color.itemSize === 4,
      vertexUvs: !!X.map || !!X.bumpMap || !!X.normalMap || !!X.specularMap || !!X.alphaMap || !!X.emissiveMap || !!X.roughnessMap || !!X.metalnessMap || !!X.clearcoatMap || !!X.clearcoatRoughnessMap || !!X.clearcoatNormalMap || !!X.displacementMap || !!X.transmissionMap || !!X.thicknessMap,
      uvsVertexOnly: !(X.map || X.bumpMap || X.normalMap || X.specularMap || X.alphaMap || X.emissiveMap || X.roughnessMap || X.metalnessMap || X.clearcoatNormalMap || X.transmission || X.transmissionMap || X.thicknessMap) && !!X.displacementMap,
      fog: !!pe,
      useFog: X.fog,
      fogExp2: pe && pe.isFogExp2,
      flatShading: !!X.flatShading,
      sizeAttenuation: X.sizeAttenuation,
      logarithmicDepthBuffer: N,
      skinning: le.isSkinnedMesh === !0 && se > 0,
      maxBones: se,
      useVertexTexture: U,
      morphTargets: X.morphTargets,
      morphNormals: X.morphNormals,
      numDirLights: Z.directional.length,
      numPointLights: Z.point.length,
      numSpotLights: Z.spot.length,
      numRectAreaLights: Z.rectArea.length,
      numHemiLights: Z.hemi.length,
      numDirLightShadows: Z.directionalShadowMap.length,
      numPointLightShadows: Z.pointShadowMap.length,
      numSpotLightShadows: Z.spotShadowMap.length,
      numClippingPlanes: D.numPlanes,
      numClipIntersection: D.numIntersection,
      dithering: X.dithering,
      shadowMapEnabled: B.shadowMap.enabled && Q.length > 0,
      shadowMapType: B.shadowMap.type,
      toneMapping: X.toneMapped ? B.toneMapping : NoToneMapping,
      physicallyCorrectLights: B.physicallyCorrectLights,
      premultipliedAlpha: X.premultipliedAlpha,
      alphaTest: X.alphaTest,
      doubleSided: X.side === DoubleSide,
      flipSided: X.side === BackSide,
      depthPacking: X.depthPacking !== void 0 ? X.depthPacking : !1,
      index0AttributeName: X.index0AttributeName,
      extensionDerivatives: X.extensions && X.extensions.derivatives,
      extensionFragDepth: X.extensions && X.extensions.fragDepth,
      extensionDrawBuffers: X.extensions && X.extensions.drawBuffers,
      extensionShaderTextureLOD: X.extensions && X.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: F || b.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: F || b.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: F || b.has("EXT_shader_texture_lod"),
      customProgramCacheKey: X.customProgramCacheKey()
    };
  }
  function q(X) {
    const Z = [];
    if (X.shaderID ? Z.push(X.shaderID) : (Z.push(X.fragmentShader), Z.push(X.vertexShader)), X.defines !== void 0)
      for (const Q in X.defines)
        Z.push(Q), Z.push(X.defines[Q]);
    if (X.isRawShaderMaterial === !1) {
      for (let Q = 0; Q < H.length; Q++)
        Z.push(X[H[Q]]);
      Z.push(B.outputEncoding), Z.push(B.gammaFactor);
    }
    return Z.push(X.customProgramCacheKey), Z.join();
  }
  function Y(X) {
    const Z = k[X.type];
    let Q;
    if (Z) {
      const ne = ShaderLib[Z];
      Q = UniformsUtils.clone(ne.uniforms);
    } else
      Q = X.uniforms;
    return Q;
  }
  function J(X, Z) {
    let Q;
    for (let ne = 0, le = I.length; ne < le; ne++) {
      const pe = I[ne];
      if (pe.cacheKey === Z) {
        Q = pe, ++Q.usedTimes;
        break;
      }
    }
    return Q === void 0 && (Q = new WebGLProgram(B, Z, X, M), I.push(Q)), Q;
  }
  function K(X) {
    if (--X.usedTimes === 0) {
      const Z = I.indexOf(X);
      I[Z] = I[I.length - 1], I.pop(), X.destroy();
    }
  }
  return {
    getParameters: j,
    getProgramCacheKey: q,
    getUniforms: Y,
    acquireProgram: J,
    releaseProgram: K,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: I
  };
}
function WebGLProperties() {
  let B = /* @__PURE__ */ new WeakMap();
  function e(D) {
    let I = B.get(D);
    return I === void 0 && (I = {}, B.set(D, I)), I;
  }
  function b(D) {
    B.delete(D);
  }
  function L(D, I, F) {
    B.get(D)[I] = F;
  }
  function M() {
    B = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: b,
    update: L,
    dispose: M
  };
}
function painterSortStable(B, e) {
  return B.groupOrder !== e.groupOrder ? B.groupOrder - e.groupOrder : B.renderOrder !== e.renderOrder ? B.renderOrder - e.renderOrder : B.program !== e.program ? B.program.id - e.program.id : B.material.id !== e.material.id ? B.material.id - e.material.id : B.z !== e.z ? B.z - e.z : B.id - e.id;
}
function reversePainterSortStable(B, e) {
  return B.groupOrder !== e.groupOrder ? B.groupOrder - e.groupOrder : B.renderOrder !== e.renderOrder ? B.renderOrder - e.renderOrder : B.z !== e.z ? e.z - B.z : B.id - e.id;
}
function WebGLRenderList(B) {
  const e = [];
  let b = 0;
  const L = [], M = [], D = [], I = { id: -1 };
  function F() {
    b = 0, L.length = 0, M.length = 0, D.length = 0;
  }
  function N(k, H, W, $, j, q) {
    let Y = e[b];
    const J = B.get(W);
    return Y === void 0 ? (Y = {
      id: k.id,
      object: k,
      geometry: H,
      material: W,
      program: J.program || I,
      groupOrder: $,
      renderOrder: k.renderOrder,
      z: j,
      group: q
    }, e[b] = Y) : (Y.id = k.id, Y.object = k, Y.geometry = H, Y.material = W, Y.program = J.program || I, Y.groupOrder = $, Y.renderOrder = k.renderOrder, Y.z = j, Y.group = q), b++, Y;
  }
  function U(k, H, W, $, j, q) {
    const Y = N(k, H, W, $, j, q);
    W.transmission > 0 ? M.push(Y) : W.transparent === !0 ? D.push(Y) : L.push(Y);
  }
  function G(k, H, W, $, j, q) {
    const Y = N(k, H, W, $, j, q);
    W.transmission > 0 ? M.unshift(Y) : W.transparent === !0 ? D.unshift(Y) : L.unshift(Y);
  }
  function V(k, H) {
    L.length > 1 && L.sort(k || painterSortStable), M.length > 1 && M.sort(H || reversePainterSortStable), D.length > 1 && D.sort(H || reversePainterSortStable);
  }
  function z() {
    for (let k = b, H = e.length; k < H; k++) {
      const W = e[k];
      if (W.id === null) break;
      W.id = null, W.object = null, W.geometry = null, W.material = null, W.program = null, W.group = null;
    }
  }
  return {
    opaque: L,
    transmissive: M,
    transparent: D,
    init: F,
    push: U,
    unshift: G,
    finish: z,
    sort: V
  };
}
function WebGLRenderLists(B) {
  let e = /* @__PURE__ */ new WeakMap();
  function b(M, D) {
    let I;
    return e.has(M) === !1 ? (I = new WebGLRenderList(B), e.set(M, [I])) : D >= e.get(M).length ? (I = new WebGLRenderList(B), e.get(M).push(I)) : I = e.get(M)[D], I;
  }
  function L() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: b,
    dispose: L
  };
}
function UniformsCache() {
  const B = {};
  return {
    get: function(e) {
      if (B[e.id] !== void 0)
        return B[e.id];
      let b;
      switch (e.type) {
        case "DirectionalLight":
          b = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          b = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          b = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          b = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          b = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      return B[e.id] = b, b;
    }
  };
}
function ShadowUniformsCache() {
  const B = {};
  return {
    get: function(e) {
      if (B[e.id] !== void 0)
        return B[e.id];
      let b;
      switch (e.type) {
        case "DirectionalLight":
          b = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          b = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          b = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return B[e.id] = b, b;
    }
  };
}
let nextVersion = 0;
function shadowCastingLightsFirst(B, e) {
  return (e.castShadow ? 1 : 0) - (B.castShadow ? 1 : 0);
}
function WebGLLights(B, e) {
  const b = new UniformsCache(), L = ShadowUniformsCache(), M = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let G = 0; G < 9; G++) M.probe.push(new Vector3());
  const D = new Vector3(), I = new Matrix4(), F = new Matrix4();
  function N(G) {
    let V = 0, z = 0, k = 0;
    for (let Z = 0; Z < 9; Z++) M.probe[Z].set(0, 0, 0);
    let H = 0, W = 0, $ = 0, j = 0, q = 0, Y = 0, J = 0, K = 0;
    G.sort(shadowCastingLightsFirst);
    for (let Z = 0, Q = G.length; Z < Q; Z++) {
      const ne = G[Z], le = ne.color, pe = ne.intensity, ue = ne.distance, oe = ne.shadow && ne.shadow.map ? ne.shadow.map.texture : null;
      if (ne.isAmbientLight)
        V += le.r * pe, z += le.g * pe, k += le.b * pe;
      else if (ne.isLightProbe)
        for (let ae = 0; ae < 9; ae++)
          M.probe[ae].addScaledVector(ne.sh.coefficients[ae], pe);
      else if (ne.isDirectionalLight) {
        const ae = b.get(ne);
        if (ae.color.copy(ne.color).multiplyScalar(ne.intensity), ne.castShadow) {
          const se = ne.shadow, ie = L.get(ne);
          ie.shadowBias = se.bias, ie.shadowNormalBias = se.normalBias, ie.shadowRadius = se.radius, ie.shadowMapSize = se.mapSize, M.directionalShadow[H] = ie, M.directionalShadowMap[H] = oe, M.directionalShadowMatrix[H] = ne.shadow.matrix, Y++;
        }
        M.directional[H] = ae, H++;
      } else if (ne.isSpotLight) {
        const ae = b.get(ne);
        if (ae.position.setFromMatrixPosition(ne.matrixWorld), ae.color.copy(le).multiplyScalar(pe), ae.distance = ue, ae.coneCos = Math.cos(ne.angle), ae.penumbraCos = Math.cos(ne.angle * (1 - ne.penumbra)), ae.decay = ne.decay, ne.castShadow) {
          const se = ne.shadow, ie = L.get(ne);
          ie.shadowBias = se.bias, ie.shadowNormalBias = se.normalBias, ie.shadowRadius = se.radius, ie.shadowMapSize = se.mapSize, M.spotShadow[$] = ie, M.spotShadowMap[$] = oe, M.spotShadowMatrix[$] = ne.shadow.matrix, K++;
        }
        M.spot[$] = ae, $++;
      } else if (ne.isRectAreaLight) {
        const ae = b.get(ne);
        ae.color.copy(le).multiplyScalar(pe), ae.halfWidth.set(ne.width * 0.5, 0, 0), ae.halfHeight.set(0, ne.height * 0.5, 0), M.rectArea[j] = ae, j++;
      } else if (ne.isPointLight) {
        const ae = b.get(ne);
        if (ae.color.copy(ne.color).multiplyScalar(ne.intensity), ae.distance = ne.distance, ae.decay = ne.decay, ne.castShadow) {
          const se = ne.shadow, ie = L.get(ne);
          ie.shadowBias = se.bias, ie.shadowNormalBias = se.normalBias, ie.shadowRadius = se.radius, ie.shadowMapSize = se.mapSize, ie.shadowCameraNear = se.camera.near, ie.shadowCameraFar = se.camera.far, M.pointShadow[W] = ie, M.pointShadowMap[W] = oe, M.pointShadowMatrix[W] = ne.shadow.matrix, J++;
        }
        M.point[W] = ae, W++;
      } else if (ne.isHemisphereLight) {
        const ae = b.get(ne);
        ae.skyColor.copy(ne.color).multiplyScalar(pe), ae.groundColor.copy(ne.groundColor).multiplyScalar(pe), M.hemi[q] = ae, q++;
      }
    }
    j > 0 && (e.isWebGL2 || B.has("OES_texture_float_linear") === !0 ? (M.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1, M.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2) : B.has("OES_texture_half_float_linear") === !0 ? (M.rectAreaLTC1 = UniformsLib.LTC_HALF_1, M.rectAreaLTC2 = UniformsLib.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), M.ambient[0] = V, M.ambient[1] = z, M.ambient[2] = k;
    const X = M.hash;
    (X.directionalLength !== H || X.pointLength !== W || X.spotLength !== $ || X.rectAreaLength !== j || X.hemiLength !== q || X.numDirectionalShadows !== Y || X.numPointShadows !== J || X.numSpotShadows !== K) && (M.directional.length = H, M.spot.length = $, M.rectArea.length = j, M.point.length = W, M.hemi.length = q, M.directionalShadow.length = Y, M.directionalShadowMap.length = Y, M.pointShadow.length = J, M.pointShadowMap.length = J, M.spotShadow.length = K, M.spotShadowMap.length = K, M.directionalShadowMatrix.length = Y, M.pointShadowMatrix.length = J, M.spotShadowMatrix.length = K, X.directionalLength = H, X.pointLength = W, X.spotLength = $, X.rectAreaLength = j, X.hemiLength = q, X.numDirectionalShadows = Y, X.numPointShadows = J, X.numSpotShadows = K, M.version = nextVersion++);
  }
  function U(G, V) {
    let z = 0, k = 0, H = 0, W = 0, $ = 0;
    const j = V.matrixWorldInverse;
    for (let q = 0, Y = G.length; q < Y; q++) {
      const J = G[q];
      if (J.isDirectionalLight) {
        const K = M.directional[z];
        K.direction.setFromMatrixPosition(J.matrixWorld), D.setFromMatrixPosition(J.target.matrixWorld), K.direction.sub(D), K.direction.transformDirection(j), z++;
      } else if (J.isSpotLight) {
        const K = M.spot[H];
        K.position.setFromMatrixPosition(J.matrixWorld), K.position.applyMatrix4(j), K.direction.setFromMatrixPosition(J.matrixWorld), D.setFromMatrixPosition(J.target.matrixWorld), K.direction.sub(D), K.direction.transformDirection(j), H++;
      } else if (J.isRectAreaLight) {
        const K = M.rectArea[W];
        K.position.setFromMatrixPosition(J.matrixWorld), K.position.applyMatrix4(j), F.identity(), I.copy(J.matrixWorld), I.premultiply(j), F.extractRotation(I), K.halfWidth.set(J.width * 0.5, 0, 0), K.halfHeight.set(0, J.height * 0.5, 0), K.halfWidth.applyMatrix4(F), K.halfHeight.applyMatrix4(F), W++;
      } else if (J.isPointLight) {
        const K = M.point[k];
        K.position.setFromMatrixPosition(J.matrixWorld), K.position.applyMatrix4(j), k++;
      } else if (J.isHemisphereLight) {
        const K = M.hemi[$];
        K.direction.setFromMatrixPosition(J.matrixWorld), K.direction.transformDirection(j), K.direction.normalize(), $++;
      }
    }
  }
  return {
    setup: N,
    setupView: U,
    state: M
  };
}
function WebGLRenderState(B, e) {
  const b = new WebGLLights(B, e), L = [], M = [];
  function D() {
    L.length = 0, M.length = 0;
  }
  function I(V) {
    L.push(V);
  }
  function F(V) {
    M.push(V);
  }
  function N() {
    b.setup(L);
  }
  function U(V) {
    b.setupView(L, V);
  }
  return {
    init: D,
    state: {
      lightsArray: L,
      shadowsArray: M,
      lights: b
    },
    setupLights: N,
    setupLightsView: U,
    pushLight: I,
    pushShadow: F
  };
}
function WebGLRenderStates(B, e) {
  let b = /* @__PURE__ */ new WeakMap();
  function L(D, I = 0) {
    let F;
    return b.has(D) === !1 ? (F = new WebGLRenderState(B, e), b.set(D, [F])) : I >= b.get(D).length ? (F = new WebGLRenderState(B, e), b.get(D).push(F)) : F = b.get(D)[I], F;
  }
  function M() {
    b = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: L,
    dispose: M
  };
}
class MeshDepthMaterial extends Material {
  constructor(e) {
    super(), this.type = "MeshDepthMaterial", this.depthPacking = BasicDepthPacking, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
MeshDepthMaterial.prototype.isMeshDepthMaterial = !0;
class MeshDistanceMaterial extends Material {
  constructor(e) {
    super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Vector3(), this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = !0;
var vsm_frag = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`, vsm_vert = `void main() {
	gl_Position = vec4( position, 1.0 );
}`;
function WebGLShadowMap(B, e, b) {
  let L = new Frustum();
  const M = new Vector2(), D = new Vector2(), I = new Vector4(), F = [], N = [], U = {}, G = b.maxTextureSize, V = { 0: BackSide, 1: FrontSide, 2: DoubleSide }, z = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  }), k = z.clone();
  k.defines.HORIZONTAL_PASS = 1;
  const H = new BufferGeometry();
  H.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const W = new Mesh(H, z), $ = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = PCFShadowMap, this.render = function(X, Z, Q) {
    if ($.enabled === !1 || $.autoUpdate === !1 && $.needsUpdate === !1 || X.length === 0) return;
    const ne = B.getRenderTarget(), le = B.getActiveCubeFace(), pe = B.getActiveMipmapLevel(), ue = B.state;
    ue.setBlending(NoBlending), ue.buffers.color.setClear(1, 1, 1, 1), ue.buffers.depth.setTest(!0), ue.setScissorTest(!1);
    for (let oe = 0, ae = X.length; oe < ae; oe++) {
      const se = X[oe], ie = se.shadow;
      if (ie === void 0) {
        console.warn("THREE.WebGLShadowMap:", se, "has no shadow.");
        continue;
      }
      if (ie.autoUpdate === !1 && ie.needsUpdate === !1) continue;
      M.copy(ie.mapSize);
      const ye = ie.getFrameExtents();
      if (M.multiply(ye), D.copy(ie.mapSize), (M.x > G || M.y > G) && (M.x > G && (D.x = Math.floor(G / ye.x), M.x = D.x * ye.x, ie.mapSize.x = D.x), M.y > G && (D.y = Math.floor(G / ye.y), M.y = D.y * ye.y, ie.mapSize.y = D.y)), ie.map === null && !ie.isPointLightShadow && this.type === VSMShadowMap) {
        const de = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
        ie.map = new WebGLRenderTarget(M.x, M.y, de), ie.map.texture.name = se.name + ".shadowMap", ie.mapPass = new WebGLRenderTarget(M.x, M.y, de), ie.camera.updateProjectionMatrix();
      }
      if (ie.map === null) {
        const de = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
        ie.map = new WebGLRenderTarget(M.x, M.y, de), ie.map.texture.name = se.name + ".shadowMap", ie.camera.updateProjectionMatrix();
      }
      B.setRenderTarget(ie.map), B.clear();
      const Ce = ie.getViewportCount();
      for (let de = 0; de < Ce; de++) {
        const ve = ie.getViewport(de);
        I.set(
          D.x * ve.x,
          D.y * ve.y,
          D.x * ve.z,
          D.y * ve.w
        ), ue.viewport(I), ie.updateMatrices(se, de), L = ie.getFrustum(), K(Z, Q, ie.camera, se, this.type);
      }
      !ie.isPointLightShadow && this.type === VSMShadowMap && j(ie, Q), ie.needsUpdate = !1;
    }
    $.needsUpdate = !1, B.setRenderTarget(ne, le, pe);
  };
  function j(X, Z) {
    const Q = e.update(W);
    z.uniforms.shadow_pass.value = X.map.texture, z.uniforms.resolution.value = X.mapSize, z.uniforms.radius.value = X.radius, B.setRenderTarget(X.mapPass), B.clear(), B.renderBufferDirect(Z, null, Q, z, W, null), k.uniforms.shadow_pass.value = X.mapPass.texture, k.uniforms.resolution.value = X.mapSize, k.uniforms.radius.value = X.radius, B.setRenderTarget(X.map), B.clear(), B.renderBufferDirect(Z, null, Q, k, W, null);
  }
  function q(X) {
    const Z = X << 0;
    let Q = F[Z];
    return Q === void 0 && (Q = new MeshDepthMaterial({
      depthPacking: RGBADepthPacking,
      morphTargets: X
    }), F[Z] = Q), Q;
  }
  function Y(X) {
    const Z = X << 0;
    let Q = N[Z];
    return Q === void 0 && (Q = new MeshDistanceMaterial({
      morphTargets: X
    }), N[Z] = Q), Q;
  }
  function J(X, Z, Q, ne, le, pe, ue) {
    let oe = null, ae = q, se = X.customDepthMaterial;
    if (ne.isPointLight === !0 && (ae = Y, se = X.customDistanceMaterial), se === void 0) {
      let ie = !1;
      Q.morphTargets === !0 && (ie = Z.morphAttributes && Z.morphAttributes.position && Z.morphAttributes.position.length > 0), oe = ae(ie);
    } else
      oe = se;
    if (B.localClippingEnabled && Q.clipShadows === !0 && Q.clippingPlanes.length !== 0) {
      const ie = oe.uuid, ye = Q.uuid;
      let Ce = U[ie];
      Ce === void 0 && (Ce = {}, U[ie] = Ce);
      let de = Ce[ye];
      de === void 0 && (de = oe.clone(), Ce[ye] = de), oe = de;
    }
    return oe.visible = Q.visible, oe.wireframe = Q.wireframe, ue === VSMShadowMap ? oe.side = Q.shadowSide !== null ? Q.shadowSide : Q.side : oe.side = Q.shadowSide !== null ? Q.shadowSide : V[Q.side], oe.clipShadows = Q.clipShadows, oe.clippingPlanes = Q.clippingPlanes, oe.clipIntersection = Q.clipIntersection, oe.wireframeLinewidth = Q.wireframeLinewidth, oe.linewidth = Q.linewidth, ne.isPointLight === !0 && oe.isMeshDistanceMaterial === !0 && (oe.referencePosition.setFromMatrixPosition(ne.matrixWorld), oe.nearDistance = le, oe.farDistance = pe), oe;
  }
  function K(X, Z, Q, ne, le) {
    if (X.visible === !1) return;
    if (X.layers.test(Z.layers) && (X.isMesh || X.isLine || X.isPoints) && (X.castShadow || X.receiveShadow && le === VSMShadowMap) && (!X.frustumCulled || L.intersectsObject(X))) {
      X.modelViewMatrix.multiplyMatrices(Q.matrixWorldInverse, X.matrixWorld);
      const oe = e.update(X), ae = X.material;
      if (Array.isArray(ae)) {
        const se = oe.groups;
        for (let ie = 0, ye = se.length; ie < ye; ie++) {
          const Ce = se[ie], de = ae[Ce.materialIndex];
          if (de && de.visible) {
            const ve = J(X, oe, de, ne, Q.near, Q.far, le);
            B.renderBufferDirect(Q, null, oe, ve, X, Ce);
          }
        }
      } else if (ae.visible) {
        const se = J(X, oe, ae, ne, Q.near, Q.far, le);
        B.renderBufferDirect(Q, null, oe, se, X, null);
      }
    }
    const ue = X.children;
    for (let oe = 0, ae = ue.length; oe < ae; oe++)
      K(ue[oe], Z, Q, ne, le);
  }
}
function WebGLState(B, e, b) {
  const L = b.isWebGL2;
  function M() {
    let he = !1;
    const Le = new Vector4();
    let Te = null;
    const je = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(We) {
        Te !== We && !he && (B.colorMask(We, We, We, We), Te = We);
      },
      setLocked: function(We) {
        he = We;
      },
      setClear: function(We, rt, Qe, et, Ye) {
        Ye === !0 && (We *= et, rt *= et, Qe *= et), Le.set(We, rt, Qe, et), je.equals(Le) === !1 && (B.clearColor(We, rt, Qe, et), je.copy(Le));
      },
      reset: function() {
        he = !1, Te = null, je.set(-1, 0, 0, 0);
      }
    };
  }
  function D() {
    let he = !1, Le = null, Te = null, je = null;
    return {
      setTest: function(We) {
        We ? Me(2929) : xe(2929);
      },
      setMask: function(We) {
        Le !== We && !he && (B.depthMask(We), Le = We);
      },
      setFunc: function(We) {
        if (Te !== We) {
          if (We)
            switch (We) {
              case NeverDepth:
                B.depthFunc(512);
                break;
              case AlwaysDepth:
                B.depthFunc(519);
                break;
              case LessDepth:
                B.depthFunc(513);
                break;
              case LessEqualDepth:
                B.depthFunc(515);
                break;
              case EqualDepth:
                B.depthFunc(514);
                break;
              case GreaterEqualDepth:
                B.depthFunc(518);
                break;
              case GreaterDepth:
                B.depthFunc(516);
                break;
              case NotEqualDepth:
                B.depthFunc(517);
                break;
              default:
                B.depthFunc(515);
            }
          else
            B.depthFunc(515);
          Te = We;
        }
      },
      setLocked: function(We) {
        he = We;
      },
      setClear: function(We) {
        je !== We && (B.clearDepth(We), je = We);
      },
      reset: function() {
        he = !1, Le = null, Te = null, je = null;
      }
    };
  }
  function I() {
    let he = !1, Le = null, Te = null, je = null, We = null, rt = null, Qe = null, et = null, Ye = null;
    return {
      setTest: function(st) {
        he || (st ? Me(2960) : xe(2960));
      },
      setMask: function(st) {
        Le !== st && !he && (B.stencilMask(st), Le = st);
      },
      setFunc: function(st, ut, vt) {
        (Te !== st || je !== ut || We !== vt) && (B.stencilFunc(st, ut, vt), Te = st, je = ut, We = vt);
      },
      setOp: function(st, ut, vt) {
        (rt !== st || Qe !== ut || et !== vt) && (B.stencilOp(st, ut, vt), rt = st, Qe = ut, et = vt);
      },
      setLocked: function(st) {
        he = st;
      },
      setClear: function(st) {
        Ye !== st && (B.clearStencil(st), Ye = st);
      },
      reset: function() {
        he = !1, Le = null, Te = null, je = null, We = null, rt = null, Qe = null, et = null, Ye = null;
      }
    };
  }
  const F = new M(), N = new D(), U = new I();
  let G = {}, V = null, z = {}, k = null, H = !1, W = null, $ = null, j = null, q = null, Y = null, J = null, K = null, X = !1, Z = null, Q = null, ne = null, le = null, pe = null;
  const ue = B.getParameter(35661);
  let oe = !1, ae = 0;
  const se = B.getParameter(7938);
  se.indexOf("WebGL") !== -1 ? (ae = parseFloat(/^WebGL (\d)/.exec(se)[1]), oe = ae >= 1) : se.indexOf("OpenGL ES") !== -1 && (ae = parseFloat(/^OpenGL ES (\d)/.exec(se)[1]), oe = ae >= 2);
  let ie = null, ye = {};
  const Ce = B.getParameter(3088), de = B.getParameter(2978), ve = new Vector4().fromArray(Ce), ce = new Vector4().fromArray(de);
  function ge(he, Le, Te) {
    const je = new Uint8Array(4), We = B.createTexture();
    B.bindTexture(he, We), B.texParameteri(he, 10241, 9728), B.texParameteri(he, 10240, 9728);
    for (let rt = 0; rt < Te; rt++)
      B.texImage2D(Le + rt, 0, 6408, 1, 1, 0, 6408, 5121, je);
    return We;
  }
  const _e = {};
  _e[3553] = ge(3553, 3553, 1), _e[34067] = ge(34067, 34069, 6), F.setClear(0, 0, 0, 1), N.setClear(1), U.setClear(0), Me(2929), N.setFunc(LessEqualDepth), Ie(!1), Be(CullFaceBack), Me(2884), Oe(NoBlending);
  function Me(he) {
    G[he] !== !0 && (B.enable(he), G[he] = !0);
  }
  function xe(he) {
    G[he] !== !1 && (B.disable(he), G[he] = !1);
  }
  function fe(he) {
    he !== V && (B.bindFramebuffer(36160, he), V = he);
  }
  function Re(he, Le) {
    return Le === null && V !== null && (Le = V), z[he] !== Le ? (B.bindFramebuffer(he, Le), z[he] = Le, L && (he === 36009 && (z[36160] = Le), he === 36160 && (z[36009] = Le)), !0) : !1;
  }
  function Pe(he) {
    return k !== he ? (B.useProgram(he), k = he, !0) : !1;
  }
  const Ue = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (L)
    Ue[MinEquation] = 32775, Ue[MaxEquation] = 32776;
  else {
    const he = e.get("EXT_blend_minmax");
    he !== null && (Ue[MinEquation] = he.MIN_EXT, Ue[MaxEquation] = he.MAX_EXT);
  }
  const Ve = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function Oe(he, Le, Te, je, We, rt, Qe, et) {
    if (he === NoBlending) {
      H === !0 && (xe(3042), H = !1);
      return;
    }
    if (H === !1 && (Me(3042), H = !0), he !== CustomBlending) {
      if (he !== W || et !== X) {
        if (($ !== AddEquation || Y !== AddEquation) && (B.blendEquation(32774), $ = AddEquation, Y = AddEquation), et)
          switch (he) {
            case NormalBlending:
              B.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              B.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              B.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              B.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", he);
              break;
          }
        else
          switch (he) {
            case NormalBlending:
              B.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              B.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              B.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              B.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", he);
              break;
          }
        j = null, q = null, J = null, K = null, W = he, X = et;
      }
      return;
    }
    We = We || Le, rt = rt || Te, Qe = Qe || je, (Le !== $ || We !== Y) && (B.blendEquationSeparate(Ue[Le], Ue[We]), $ = Le, Y = We), (Te !== j || je !== q || rt !== J || Qe !== K) && (B.blendFuncSeparate(Ve[Te], Ve[je], Ve[rt], Ve[Qe]), j = Te, q = je, J = rt, K = Qe), W = he, X = null;
  }
  function me(he, Le) {
    he.side === DoubleSide ? xe(2884) : Me(2884);
    let Te = he.side === BackSide;
    Le && (Te = !Te), Ie(Te), he.blending === NormalBlending && he.transparent === !1 ? Oe(NoBlending) : Oe(he.blending, he.blendEquation, he.blendSrc, he.blendDst, he.blendEquationAlpha, he.blendSrcAlpha, he.blendDstAlpha, he.premultipliedAlpha), N.setFunc(he.depthFunc), N.setTest(he.depthTest), N.setMask(he.depthWrite), F.setMask(he.colorWrite);
    const je = he.stencilWrite;
    U.setTest(je), je && (U.setMask(he.stencilWriteMask), U.setFunc(he.stencilFunc, he.stencilRef, he.stencilFuncMask), U.setOp(he.stencilFail, he.stencilZFail, he.stencilZPass)), Fe(he.polygonOffset, he.polygonOffsetFactor, he.polygonOffsetUnits), he.alphaToCoverage === !0 ? Me(32926) : xe(32926);
  }
  function Ie(he) {
    Z !== he && (he ? B.frontFace(2304) : B.frontFace(2305), Z = he);
  }
  function Be(he) {
    he !== CullFaceNone ? (Me(2884), he !== Q && (he === CullFaceBack ? B.cullFace(1029) : he === CullFaceFront ? B.cullFace(1028) : B.cullFace(1032))) : xe(2884), Q = he;
  }
  function Ne(he) {
    he !== ne && (oe && B.lineWidth(he), ne = he);
  }
  function Fe(he, Le, Te) {
    he ? (Me(32823), (le !== Le || pe !== Te) && (B.polygonOffset(Le, Te), le = Le, pe = Te)) : xe(32823);
  }
  function te(he) {
    he ? Me(3089) : xe(3089);
  }
  function ee(he) {
    he === void 0 && (he = 33984 + ue - 1), ie !== he && (B.activeTexture(he), ie = he);
  }
  function Se(he, Le) {
    ie === null && ee();
    let Te = ye[ie];
    Te === void 0 && (Te = { type: void 0, texture: void 0 }, ye[ie] = Te), (Te.type !== he || Te.texture !== Le) && (B.bindTexture(he, Le || _e[he]), Te.type = he, Te.texture = Le);
  }
  function Ee() {
    const he = ye[ie];
    he !== void 0 && he.type !== void 0 && (B.bindTexture(he.type, null), he.type = void 0, he.texture = void 0);
  }
  function be() {
    try {
      B.compressedTexImage2D.apply(B, arguments);
    } catch (he) {
      console.error("THREE.WebGLState:", he);
    }
  }
  function ze() {
    try {
      B.texImage2D.apply(B, arguments);
    } catch (he) {
      console.error("THREE.WebGLState:", he);
    }
  }
  function Ge() {
    try {
      B.texImage3D.apply(B, arguments);
    } catch (he) {
      console.error("THREE.WebGLState:", he);
    }
  }
  function He(he) {
    ve.equals(he) === !1 && (B.scissor(he.x, he.y, he.z, he.w), ve.copy(he));
  }
  function ke(he) {
    ce.equals(he) === !1 && (B.viewport(he.x, he.y, he.z, he.w), ce.copy(he));
  }
  function $e() {
    B.disable(3042), B.disable(2884), B.disable(2929), B.disable(32823), B.disable(3089), B.disable(2960), B.disable(32926), B.blendEquation(32774), B.blendFunc(1, 0), B.blendFuncSeparate(1, 0, 1, 0), B.colorMask(!0, !0, !0, !0), B.clearColor(0, 0, 0, 0), B.depthMask(!0), B.depthFunc(513), B.clearDepth(1), B.stencilMask(4294967295), B.stencilFunc(519, 0, 4294967295), B.stencilOp(7680, 7680, 7680), B.clearStencil(0), B.cullFace(1029), B.frontFace(2305), B.polygonOffset(0, 0), B.activeTexture(33984), B.bindFramebuffer(36160, null), L === !0 && (B.bindFramebuffer(36009, null), B.bindFramebuffer(36008, null)), B.useProgram(null), B.lineWidth(1), B.scissor(0, 0, B.canvas.width, B.canvas.height), B.viewport(0, 0, B.canvas.width, B.canvas.height), G = {}, ie = null, ye = {}, V = null, z = {}, k = null, H = !1, W = null, $ = null, j = null, q = null, Y = null, J = null, K = null, X = !1, Z = null, Q = null, ne = null, le = null, pe = null, ve.set(0, 0, B.canvas.width, B.canvas.height), ce.set(0, 0, B.canvas.width, B.canvas.height), F.reset(), N.reset(), U.reset();
  }
  return {
    buffers: {
      color: F,
      depth: N,
      stencil: U
    },
    enable: Me,
    disable: xe,
    bindFramebuffer: Re,
    bindXRFramebuffer: fe,
    useProgram: Pe,
    setBlending: Oe,
    setMaterial: me,
    setFlipSided: Ie,
    setCullFace: Be,
    setLineWidth: Ne,
    setPolygonOffset: Fe,
    setScissorTest: te,
    activeTexture: ee,
    bindTexture: Se,
    unbindTexture: Ee,
    compressedTexImage2D: be,
    texImage2D: ze,
    texImage3D: Ge,
    scissor: He,
    viewport: ke,
    reset: $e
  };
}
function WebGLTextures(B, e, b, L, M, D, I) {
  const F = M.isWebGL2, N = M.maxTextures, U = M.maxCubemapSize, G = M.maxTextureSize, V = M.maxSamples, z = /* @__PURE__ */ new WeakMap();
  let k, H = !1;
  try {
    H = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function W(te, ee) {
    return H ? new OffscreenCanvas(te, ee) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function $(te, ee, Se, Ee) {
    let be = 1;
    if ((te.width > Ee || te.height > Ee) && (be = Ee / Math.max(te.width, te.height)), be < 1 || ee === !0)
      if (typeof HTMLImageElement < "u" && te instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && te instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && te instanceof ImageBitmap) {
        const ze = ee ? floorPowerOfTwo : Math.floor, Ge = ze(be * te.width), He = ze(be * te.height);
        k === void 0 && (k = W(Ge, He));
        const ke = Se ? W(Ge, He) : k;
        return ke.width = Ge, ke.height = He, ke.getContext("2d").drawImage(te, 0, 0, Ge, He), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + te.width + "x" + te.height + ") to (" + Ge + "x" + He + ")."), ke;
      } else
        return "data" in te && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + te.width + "x" + te.height + ")."), te;
    return te;
  }
  function j(te) {
    return isPowerOfTwo(te.width) && isPowerOfTwo(te.height);
  }
  function q(te) {
    return F ? !1 : te.wrapS !== ClampToEdgeWrapping || te.wrapT !== ClampToEdgeWrapping || te.minFilter !== NearestFilter && te.minFilter !== LinearFilter;
  }
  function Y(te, ee) {
    return te.generateMipmaps && ee && te.minFilter !== NearestFilter && te.minFilter !== LinearFilter;
  }
  function J(te, ee, Se, Ee, be = 1) {
    B.generateMipmap(te);
    const ze = L.get(ee);
    ze.__maxMipLevel = Math.log2(Math.max(Se, Ee, be));
  }
  function K(te, ee, Se) {
    if (F === !1) return ee;
    if (te !== null) {
      if (B[te] !== void 0) return B[te];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + te + "'");
    }
    let Ee = ee;
    return ee === 6403 && (Se === 5126 && (Ee = 33326), Se === 5131 && (Ee = 33325), Se === 5121 && (Ee = 33321)), ee === 6407 && (Se === 5126 && (Ee = 34837), Se === 5131 && (Ee = 34843), Se === 5121 && (Ee = 32849)), ee === 6408 && (Se === 5126 && (Ee = 34836), Se === 5131 && (Ee = 34842), Se === 5121 && (Ee = 32856)), (Ee === 33325 || Ee === 33326 || Ee === 34842 || Ee === 34836) && e.get("EXT_color_buffer_float"), Ee;
  }
  function X(te) {
    return te === NearestFilter || te === NearestMipmapNearestFilter || te === NearestMipmapLinearFilter ? 9728 : 9729;
  }
  function Z(te) {
    const ee = te.target;
    ee.removeEventListener("dispose", Z), ne(ee), ee.isVideoTexture && z.delete(ee), I.memory.textures--;
  }
  function Q(te) {
    const ee = te.target;
    ee.removeEventListener("dispose", Q), le(ee);
  }
  function ne(te) {
    const ee = L.get(te);
    ee.__webglInit !== void 0 && (B.deleteTexture(ee.__webglTexture), L.remove(te));
  }
  function le(te) {
    const ee = te.texture, Se = L.get(te), Ee = L.get(ee);
    if (te) {
      if (Ee.__webglTexture !== void 0 && (B.deleteTexture(Ee.__webglTexture), I.memory.textures--), te.depthTexture && te.depthTexture.dispose(), te.isWebGLCubeRenderTarget)
        for (let be = 0; be < 6; be++)
          B.deleteFramebuffer(Se.__webglFramebuffer[be]), Se.__webglDepthbuffer && B.deleteRenderbuffer(Se.__webglDepthbuffer[be]);
      else
        B.deleteFramebuffer(Se.__webglFramebuffer), Se.__webglDepthbuffer && B.deleteRenderbuffer(Se.__webglDepthbuffer), Se.__webglMultisampledFramebuffer && B.deleteFramebuffer(Se.__webglMultisampledFramebuffer), Se.__webglColorRenderbuffer && B.deleteRenderbuffer(Se.__webglColorRenderbuffer), Se.__webglDepthRenderbuffer && B.deleteRenderbuffer(Se.__webglDepthRenderbuffer);
      if (te.isWebGLMultipleRenderTargets)
        for (let be = 0, ze = ee.length; be < ze; be++) {
          const Ge = L.get(ee[be]);
          Ge.__webglTexture && (B.deleteTexture(Ge.__webglTexture), I.memory.textures--), L.remove(ee[be]);
        }
      L.remove(ee), L.remove(te);
    }
  }
  let pe = 0;
  function ue() {
    pe = 0;
  }
  function oe() {
    const te = pe;
    return te >= N && console.warn("THREE.WebGLTextures: Trying to use " + te + " texture units while this GPU supports only " + N), pe += 1, te;
  }
  function ae(te, ee) {
    const Se = L.get(te);
    if (te.isVideoTexture && me(te), te.version > 0 && Se.__version !== te.version) {
      const Ee = te.image;
      if (Ee === void 0)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      else if (Ee.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        ge(Se, te, ee);
        return;
      }
    }
    b.activeTexture(33984 + ee), b.bindTexture(3553, Se.__webglTexture);
  }
  function se(te, ee) {
    const Se = L.get(te);
    if (te.version > 0 && Se.__version !== te.version) {
      ge(Se, te, ee);
      return;
    }
    b.activeTexture(33984 + ee), b.bindTexture(35866, Se.__webglTexture);
  }
  function ie(te, ee) {
    const Se = L.get(te);
    if (te.version > 0 && Se.__version !== te.version) {
      ge(Se, te, ee);
      return;
    }
    b.activeTexture(33984 + ee), b.bindTexture(32879, Se.__webglTexture);
  }
  function ye(te, ee) {
    const Se = L.get(te);
    if (te.version > 0 && Se.__version !== te.version) {
      _e(Se, te, ee);
      return;
    }
    b.activeTexture(33984 + ee), b.bindTexture(34067, Se.__webglTexture);
  }
  const Ce = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  }, de = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function ve(te, ee, Se) {
    if (Se ? (B.texParameteri(te, 10242, Ce[ee.wrapS]), B.texParameteri(te, 10243, Ce[ee.wrapT]), (te === 32879 || te === 35866) && B.texParameteri(te, 32882, Ce[ee.wrapR]), B.texParameteri(te, 10240, de[ee.magFilter]), B.texParameteri(te, 10241, de[ee.minFilter])) : (B.texParameteri(te, 10242, 33071), B.texParameteri(te, 10243, 33071), (te === 32879 || te === 35866) && B.texParameteri(te, 32882, 33071), (ee.wrapS !== ClampToEdgeWrapping || ee.wrapT !== ClampToEdgeWrapping) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), B.texParameteri(te, 10240, X(ee.magFilter)), B.texParameteri(te, 10241, X(ee.minFilter)), ee.minFilter !== NearestFilter && ee.minFilter !== LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) {
      const Ee = e.get("EXT_texture_filter_anisotropic");
      if (ee.type === FloatType && e.has("OES_texture_float_linear") === !1 || F === !1 && ee.type === HalfFloatType && e.has("OES_texture_half_float_linear") === !1) return;
      (ee.anisotropy > 1 || L.get(ee).__currentAnisotropy) && (B.texParameterf(te, Ee.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(ee.anisotropy, M.getMaxAnisotropy())), L.get(ee).__currentAnisotropy = ee.anisotropy);
    }
  }
  function ce(te, ee) {
    te.__webglInit === void 0 && (te.__webglInit = !0, ee.addEventListener("dispose", Z), te.__webglTexture = B.createTexture(), I.memory.textures++);
  }
  function ge(te, ee, Se) {
    let Ee = 3553;
    ee.isDataTexture2DArray && (Ee = 35866), ee.isDataTexture3D && (Ee = 32879), ce(te, ee), b.activeTexture(33984 + Se), b.bindTexture(Ee, te.__webglTexture), B.pixelStorei(37440, ee.flipY), B.pixelStorei(37441, ee.premultiplyAlpha), B.pixelStorei(3317, ee.unpackAlignment), B.pixelStorei(37443, 0);
    const be = q(ee) && j(ee.image) === !1, ze = $(ee.image, be, !1, G), Ge = j(ze) || F, He = D.convert(ee.format);
    let ke = D.convert(ee.type), $e = K(ee.internalFormat, He, ke);
    ve(Ee, ee, Ge);
    let he;
    const Le = ee.mipmaps;
    if (ee.isDepthTexture)
      $e = 6402, F ? ee.type === FloatType ? $e = 36012 : ee.type === UnsignedIntType ? $e = 33190 : ee.type === UnsignedInt248Type ? $e = 35056 : $e = 33189 : ee.type === FloatType && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), ee.format === DepthFormat && $e === 6402 && ee.type !== UnsignedShortType && ee.type !== UnsignedIntType && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), ee.type = UnsignedShortType, ke = D.convert(ee.type)), ee.format === DepthStencilFormat && $e === 6402 && ($e = 34041, ee.type !== UnsignedInt248Type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), ee.type = UnsignedInt248Type, ke = D.convert(ee.type))), b.texImage2D(3553, 0, $e, ze.width, ze.height, 0, He, ke, null);
    else if (ee.isDataTexture)
      if (Le.length > 0 && Ge) {
        for (let Te = 0, je = Le.length; Te < je; Te++)
          he = Le[Te], b.texImage2D(3553, Te, $e, he.width, he.height, 0, He, ke, he.data);
        ee.generateMipmaps = !1, te.__maxMipLevel = Le.length - 1;
      } else
        b.texImage2D(3553, 0, $e, ze.width, ze.height, 0, He, ke, ze.data), te.__maxMipLevel = 0;
    else if (ee.isCompressedTexture) {
      for (let Te = 0, je = Le.length; Te < je; Te++)
        he = Le[Te], ee.format !== RGBAFormat && ee.format !== RGBFormat ? He !== null ? b.compressedTexImage2D(3553, Te, $e, he.width, he.height, 0, he.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : b.texImage2D(3553, Te, $e, he.width, he.height, 0, He, ke, he.data);
      te.__maxMipLevel = Le.length - 1;
    } else if (ee.isDataTexture2DArray)
      b.texImage3D(35866, 0, $e, ze.width, ze.height, ze.depth, 0, He, ke, ze.data), te.__maxMipLevel = 0;
    else if (ee.isDataTexture3D)
      b.texImage3D(32879, 0, $e, ze.width, ze.height, ze.depth, 0, He, ke, ze.data), te.__maxMipLevel = 0;
    else if (Le.length > 0 && Ge) {
      for (let Te = 0, je = Le.length; Te < je; Te++)
        he = Le[Te], b.texImage2D(3553, Te, $e, He, ke, he);
      ee.generateMipmaps = !1, te.__maxMipLevel = Le.length - 1;
    } else
      b.texImage2D(3553, 0, $e, He, ke, ze), te.__maxMipLevel = 0;
    Y(ee, Ge) && J(Ee, ee, ze.width, ze.height), te.__version = ee.version, ee.onUpdate && ee.onUpdate(ee);
  }
  function _e(te, ee, Se) {
    if (ee.image.length !== 6) return;
    ce(te, ee), b.activeTexture(33984 + Se), b.bindTexture(34067, te.__webglTexture), B.pixelStorei(37440, ee.flipY), B.pixelStorei(37441, ee.premultiplyAlpha), B.pixelStorei(3317, ee.unpackAlignment), B.pixelStorei(37443, 0);
    const Ee = ee && (ee.isCompressedTexture || ee.image[0].isCompressedTexture), be = ee.image[0] && ee.image[0].isDataTexture, ze = [];
    for (let Te = 0; Te < 6; Te++)
      !Ee && !be ? ze[Te] = $(ee.image[Te], !1, !0, U) : ze[Te] = be ? ee.image[Te].image : ee.image[Te];
    const Ge = ze[0], He = j(Ge) || F, ke = D.convert(ee.format), $e = D.convert(ee.type), he = K(ee.internalFormat, ke, $e);
    ve(34067, ee, He);
    let Le;
    if (Ee) {
      for (let Te = 0; Te < 6; Te++) {
        Le = ze[Te].mipmaps;
        for (let je = 0; je < Le.length; je++) {
          const We = Le[je];
          ee.format !== RGBAFormat && ee.format !== RGBFormat ? ke !== null ? b.compressedTexImage2D(34069 + Te, je, he, We.width, We.height, 0, We.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : b.texImage2D(34069 + Te, je, he, We.width, We.height, 0, ke, $e, We.data);
        }
      }
      te.__maxMipLevel = Le.length - 1;
    } else {
      Le = ee.mipmaps;
      for (let Te = 0; Te < 6; Te++)
        if (be) {
          b.texImage2D(34069 + Te, 0, he, ze[Te].width, ze[Te].height, 0, ke, $e, ze[Te].data);
          for (let je = 0; je < Le.length; je++) {
            const rt = Le[je].image[Te].image;
            b.texImage2D(34069 + Te, je + 1, he, rt.width, rt.height, 0, ke, $e, rt.data);
          }
        } else {
          b.texImage2D(34069 + Te, 0, he, ke, $e, ze[Te]);
          for (let je = 0; je < Le.length; je++) {
            const We = Le[je];
            b.texImage2D(34069 + Te, je + 1, he, ke, $e, We.image[Te]);
          }
        }
      te.__maxMipLevel = Le.length;
    }
    Y(ee, He) && J(34067, ee, Ge.width, Ge.height), te.__version = ee.version, ee.onUpdate && ee.onUpdate(ee);
  }
  function Me(te, ee, Se, Ee, be) {
    const ze = D.convert(Se.format), Ge = D.convert(Se.type), He = K(Se.internalFormat, ze, Ge);
    be === 32879 || be === 35866 ? b.texImage3D(be, 0, He, ee.width, ee.height, ee.depth, 0, ze, Ge, null) : b.texImage2D(be, 0, He, ee.width, ee.height, 0, ze, Ge, null), b.bindFramebuffer(36160, te), B.framebufferTexture2D(36160, Ee, be, L.get(Se).__webglTexture, 0), b.bindFramebuffer(36160, null);
  }
  function xe(te, ee, Se) {
    if (B.bindRenderbuffer(36161, te), ee.depthBuffer && !ee.stencilBuffer) {
      let Ee = 33189;
      if (Se) {
        const be = ee.depthTexture;
        be && be.isDepthTexture && (be.type === FloatType ? Ee = 36012 : be.type === UnsignedIntType && (Ee = 33190));
        const ze = Oe(ee);
        B.renderbufferStorageMultisample(36161, ze, Ee, ee.width, ee.height);
      } else
        B.renderbufferStorage(36161, Ee, ee.width, ee.height);
      B.framebufferRenderbuffer(36160, 36096, 36161, te);
    } else if (ee.depthBuffer && ee.stencilBuffer) {
      if (Se) {
        const Ee = Oe(ee);
        B.renderbufferStorageMultisample(36161, Ee, 35056, ee.width, ee.height);
      } else
        B.renderbufferStorage(36161, 34041, ee.width, ee.height);
      B.framebufferRenderbuffer(36160, 33306, 36161, te);
    } else {
      const Ee = ee.isWebGLMultipleRenderTargets === !0 ? ee.texture[0] : ee.texture, be = D.convert(Ee.format), ze = D.convert(Ee.type), Ge = K(Ee.internalFormat, be, ze);
      if (Se) {
        const He = Oe(ee);
        B.renderbufferStorageMultisample(36161, He, Ge, ee.width, ee.height);
      } else
        B.renderbufferStorage(36161, Ge, ee.width, ee.height);
    }
    B.bindRenderbuffer(36161, null);
  }
  function fe(te, ee) {
    if (ee && ee.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (b.bindFramebuffer(36160, te), !(ee.depthTexture && ee.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!L.get(ee.depthTexture).__webglTexture || ee.depthTexture.image.width !== ee.width || ee.depthTexture.image.height !== ee.height) && (ee.depthTexture.image.width = ee.width, ee.depthTexture.image.height = ee.height, ee.depthTexture.needsUpdate = !0), ae(ee.depthTexture, 0);
    const Ee = L.get(ee.depthTexture).__webglTexture;
    if (ee.depthTexture.format === DepthFormat)
      B.framebufferTexture2D(36160, 36096, 3553, Ee, 0);
    else if (ee.depthTexture.format === DepthStencilFormat)
      B.framebufferTexture2D(36160, 33306, 3553, Ee, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function Re(te) {
    const ee = L.get(te), Se = te.isWebGLCubeRenderTarget === !0;
    if (te.depthTexture) {
      if (Se) throw new Error("target.depthTexture not supported in Cube render targets");
      fe(ee.__webglFramebuffer, te);
    } else if (Se) {
      ee.__webglDepthbuffer = [];
      for (let Ee = 0; Ee < 6; Ee++)
        b.bindFramebuffer(36160, ee.__webglFramebuffer[Ee]), ee.__webglDepthbuffer[Ee] = B.createRenderbuffer(), xe(ee.__webglDepthbuffer[Ee], te, !1);
    } else
      b.bindFramebuffer(36160, ee.__webglFramebuffer), ee.__webglDepthbuffer = B.createRenderbuffer(), xe(ee.__webglDepthbuffer, te, !1);
    b.bindFramebuffer(36160, null);
  }
  function Pe(te) {
    const ee = te.texture, Se = L.get(te), Ee = L.get(ee);
    te.addEventListener("dispose", Q), te.isWebGLMultipleRenderTargets !== !0 && (Ee.__webglTexture = B.createTexture(), Ee.__version = ee.version, I.memory.textures++);
    const be = te.isWebGLCubeRenderTarget === !0, ze = te.isWebGLMultipleRenderTargets === !0, Ge = te.isWebGLMultisampleRenderTarget === !0, He = ee.isDataTexture3D || ee.isDataTexture2DArray, ke = j(te) || F;
    if (F && ee.format === RGBFormat && (ee.type === FloatType || ee.type === HalfFloatType) && (ee.format = RGBAFormat, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), be) {
      Se.__webglFramebuffer = [];
      for (let $e = 0; $e < 6; $e++)
        Se.__webglFramebuffer[$e] = B.createFramebuffer();
    } else if (Se.__webglFramebuffer = B.createFramebuffer(), ze)
      if (M.drawBuffers) {
        const $e = te.texture;
        for (let he = 0, Le = $e.length; he < Le; he++) {
          const Te = L.get($e[he]);
          Te.__webglTexture === void 0 && (Te.__webglTexture = B.createTexture(), I.memory.textures++);
        }
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
    else if (Ge)
      if (F) {
        Se.__webglMultisampledFramebuffer = B.createFramebuffer(), Se.__webglColorRenderbuffer = B.createRenderbuffer(), B.bindRenderbuffer(36161, Se.__webglColorRenderbuffer);
        const $e = D.convert(ee.format), he = D.convert(ee.type), Le = K(ee.internalFormat, $e, he), Te = Oe(te);
        B.renderbufferStorageMultisample(36161, Te, Le, te.width, te.height), b.bindFramebuffer(36160, Se.__webglMultisampledFramebuffer), B.framebufferRenderbuffer(36160, 36064, 36161, Se.__webglColorRenderbuffer), B.bindRenderbuffer(36161, null), te.depthBuffer && (Se.__webglDepthRenderbuffer = B.createRenderbuffer(), xe(Se.__webglDepthRenderbuffer, te, !0)), b.bindFramebuffer(36160, null);
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
    if (be) {
      b.bindTexture(34067, Ee.__webglTexture), ve(34067, ee, ke);
      for (let $e = 0; $e < 6; $e++)
        Me(Se.__webglFramebuffer[$e], te, ee, 36064, 34069 + $e);
      Y(ee, ke) && J(34067, ee, te.width, te.height), b.bindTexture(34067, null);
    } else if (ze) {
      const $e = te.texture;
      for (let he = 0, Le = $e.length; he < Le; he++) {
        const Te = $e[he], je = L.get(Te);
        b.bindTexture(3553, je.__webglTexture), ve(3553, Te, ke), Me(Se.__webglFramebuffer, te, Te, 36064 + he, 3553), Y(Te, ke) && J(3553, Te, te.width, te.height);
      }
      b.bindTexture(3553, null);
    } else {
      let $e = 3553;
      He && (F ? $e = ee.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), b.bindTexture($e, Ee.__webglTexture), ve($e, ee, ke), Me(Se.__webglFramebuffer, te, ee, 36064, $e), Y(ee, ke) && J($e, ee, te.width, te.height, te.depth), b.bindTexture($e, null);
    }
    te.depthBuffer && Re(te);
  }
  function Ue(te) {
    const ee = j(te) || F, Se = te.isWebGLMultipleRenderTargets === !0 ? te.texture : [te.texture];
    for (let Ee = 0, be = Se.length; Ee < be; Ee++) {
      const ze = Se[Ee];
      if (Y(ze, ee)) {
        const Ge = te.isWebGLCubeRenderTarget ? 34067 : 3553, He = L.get(ze).__webglTexture;
        b.bindTexture(Ge, He), J(Ge, ze, te.width, te.height), b.bindTexture(Ge, null);
      }
    }
  }
  function Ve(te) {
    if (te.isWebGLMultisampleRenderTarget)
      if (F) {
        const ee = te.width, Se = te.height;
        let Ee = 16384;
        te.depthBuffer && (Ee |= 256), te.stencilBuffer && (Ee |= 1024);
        const be = L.get(te);
        b.bindFramebuffer(36008, be.__webglMultisampledFramebuffer), b.bindFramebuffer(36009, be.__webglFramebuffer), B.blitFramebuffer(0, 0, ee, Se, 0, 0, ee, Se, Ee, 9728), b.bindFramebuffer(36008, null), b.bindFramebuffer(36009, be.__webglMultisampledFramebuffer);
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
  }
  function Oe(te) {
    return F && te.isWebGLMultisampleRenderTarget ? Math.min(V, te.samples) : 0;
  }
  function me(te) {
    const ee = I.render.frame;
    z.get(te) !== ee && (z.set(te, ee), te.update());
  }
  let Ie = !1, Be = !1;
  function Ne(te, ee) {
    te && te.isWebGLRenderTarget && (Ie === !1 && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), Ie = !0), te = te.texture), ae(te, ee);
  }
  function Fe(te, ee) {
    te && te.isWebGLCubeRenderTarget && (Be === !1 && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), Be = !0), te = te.texture), ye(te, ee);
  }
  this.allocateTextureUnit = oe, this.resetTextureUnits = ue, this.setTexture2D = ae, this.setTexture2DArray = se, this.setTexture3D = ie, this.setTextureCube = ye, this.setupRenderTarget = Pe, this.updateRenderTargetMipmap = Ue, this.updateMultisampleRenderTarget = Ve, this.safeSetTexture2D = Ne, this.safeSetTextureCube = Fe;
}
function WebGLUtils(B, e, b) {
  const L = b.isWebGL2;
  function M(D) {
    let I;
    if (D === UnsignedByteType) return 5121;
    if (D === UnsignedShort4444Type) return 32819;
    if (D === UnsignedShort5551Type) return 32820;
    if (D === UnsignedShort565Type) return 33635;
    if (D === ByteType) return 5120;
    if (D === ShortType) return 5122;
    if (D === UnsignedShortType) return 5123;
    if (D === IntType) return 5124;
    if (D === UnsignedIntType) return 5125;
    if (D === FloatType) return 5126;
    if (D === HalfFloatType)
      return L ? 5131 : (I = e.get("OES_texture_half_float"), I !== null ? I.HALF_FLOAT_OES : null);
    if (D === AlphaFormat) return 6406;
    if (D === RGBFormat) return 6407;
    if (D === RGBAFormat) return 6408;
    if (D === LuminanceFormat) return 6409;
    if (D === LuminanceAlphaFormat) return 6410;
    if (D === DepthFormat) return 6402;
    if (D === DepthStencilFormat) return 34041;
    if (D === RedFormat) return 6403;
    if (D === RedIntegerFormat) return 36244;
    if (D === RGFormat) return 33319;
    if (D === RGIntegerFormat) return 33320;
    if (D === RGBIntegerFormat) return 36248;
    if (D === RGBAIntegerFormat) return 36249;
    if (D === RGB_S3TC_DXT1_Format || D === RGBA_S3TC_DXT1_Format || D === RGBA_S3TC_DXT3_Format || D === RGBA_S3TC_DXT5_Format)
      if (I = e.get("WEBGL_compressed_texture_s3tc"), I !== null) {
        if (D === RGB_S3TC_DXT1_Format) return I.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (D === RGBA_S3TC_DXT1_Format) return I.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (D === RGBA_S3TC_DXT3_Format) return I.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (D === RGBA_S3TC_DXT5_Format) return I.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (D === RGB_PVRTC_4BPPV1_Format || D === RGB_PVRTC_2BPPV1_Format || D === RGBA_PVRTC_4BPPV1_Format || D === RGBA_PVRTC_2BPPV1_Format)
      if (I = e.get("WEBGL_compressed_texture_pvrtc"), I !== null) {
        if (D === RGB_PVRTC_4BPPV1_Format) return I.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (D === RGB_PVRTC_2BPPV1_Format) return I.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (D === RGBA_PVRTC_4BPPV1_Format) return I.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (D === RGBA_PVRTC_2BPPV1_Format) return I.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (D === RGB_ETC1_Format)
      return I = e.get("WEBGL_compressed_texture_etc1"), I !== null ? I.COMPRESSED_RGB_ETC1_WEBGL : null;
    if ((D === RGB_ETC2_Format || D === RGBA_ETC2_EAC_Format) && (I = e.get("WEBGL_compressed_texture_etc"), I !== null)) {
      if (D === RGB_ETC2_Format) return I.COMPRESSED_RGB8_ETC2;
      if (D === RGBA_ETC2_EAC_Format) return I.COMPRESSED_RGBA8_ETC2_EAC;
    }
    if (D === RGBA_ASTC_4x4_Format || D === RGBA_ASTC_5x4_Format || D === RGBA_ASTC_5x5_Format || D === RGBA_ASTC_6x5_Format || D === RGBA_ASTC_6x6_Format || D === RGBA_ASTC_8x5_Format || D === RGBA_ASTC_8x6_Format || D === RGBA_ASTC_8x8_Format || D === RGBA_ASTC_10x5_Format || D === RGBA_ASTC_10x6_Format || D === RGBA_ASTC_10x8_Format || D === RGBA_ASTC_10x10_Format || D === RGBA_ASTC_12x10_Format || D === RGBA_ASTC_12x12_Format || D === SRGB8_ALPHA8_ASTC_4x4_Format || D === SRGB8_ALPHA8_ASTC_5x4_Format || D === SRGB8_ALPHA8_ASTC_5x5_Format || D === SRGB8_ALPHA8_ASTC_6x5_Format || D === SRGB8_ALPHA8_ASTC_6x6_Format || D === SRGB8_ALPHA8_ASTC_8x5_Format || D === SRGB8_ALPHA8_ASTC_8x6_Format || D === SRGB8_ALPHA8_ASTC_8x8_Format || D === SRGB8_ALPHA8_ASTC_10x5_Format || D === SRGB8_ALPHA8_ASTC_10x6_Format || D === SRGB8_ALPHA8_ASTC_10x8_Format || D === SRGB8_ALPHA8_ASTC_10x10_Format || D === SRGB8_ALPHA8_ASTC_12x10_Format || D === SRGB8_ALPHA8_ASTC_12x12_Format)
      return I = e.get("WEBGL_compressed_texture_astc"), I !== null ? D : null;
    if (D === RGBA_BPTC_Format)
      return I = e.get("EXT_texture_compression_bptc"), I !== null ? D : null;
    if (D === UnsignedInt248Type)
      return L ? 34042 : (I = e.get("WEBGL_depth_texture"), I !== null ? I.UNSIGNED_INT_24_8_WEBGL : null);
  }
  return { convert: M };
}
class ArrayCamera extends PerspectiveCamera {
  constructor(e = []) {
    super(), this.cameras = e;
  }
}
ArrayCamera.prototype.isArrayCamera = !0;
class Group extends Object3D {
  constructor() {
    super(), this.type = "Group";
  }
}
Group.prototype.isGroup = !0;
const _moveEvent = { type: "move" };
class WebXRController {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Group(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Group(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Vector3(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Vector3()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Group(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Vector3(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Vector3()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, b, L) {
    let M = null, D = null, I = null;
    const F = this._targetRay, N = this._grip, U = this._hand;
    if (e && b.session.visibilityState !== "visible-blurred")
      if (F !== null && (M = b.getPose(e.targetRaySpace, L), M !== null && (F.matrix.fromArray(M.transform.matrix), F.matrix.decompose(F.position, F.rotation, F.scale), M.linearVelocity ? (F.hasLinearVelocity = !0, F.linearVelocity.copy(M.linearVelocity)) : F.hasLinearVelocity = !1, M.angularVelocity ? (F.hasAngularVelocity = !0, F.angularVelocity.copy(M.angularVelocity)) : F.hasAngularVelocity = !1, this.dispatchEvent(_moveEvent))), U && e.hand) {
        I = !0;
        for (const W of e.hand.values()) {
          const $ = b.getJointPose(W, L);
          if (U.joints[W.jointName] === void 0) {
            const q = new Group();
            q.matrixAutoUpdate = !1, q.visible = !1, U.joints[W.jointName] = q, U.add(q);
          }
          const j = U.joints[W.jointName];
          $ !== null && (j.matrix.fromArray($.transform.matrix), j.matrix.decompose(j.position, j.rotation, j.scale), j.jointRadius = $.radius), j.visible = $ !== null;
        }
        const G = U.joints["index-finger-tip"], V = U.joints["thumb-tip"], z = G.position.distanceTo(V.position), k = 0.02, H = 5e-3;
        U.inputState.pinching && z > k + H ? (U.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !U.inputState.pinching && z <= k - H && (U.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        N !== null && e.gripSpace && (D = b.getPose(e.gripSpace, L), D !== null && (N.matrix.fromArray(D.transform.matrix), N.matrix.decompose(N.position, N.rotation, N.scale), D.linearVelocity ? (N.hasLinearVelocity = !0, N.linearVelocity.copy(D.linearVelocity)) : N.hasLinearVelocity = !1, D.angularVelocity ? (N.hasAngularVelocity = !0, N.angularVelocity.copy(D.angularVelocity)) : N.hasAngularVelocity = !1));
    return F !== null && (F.visible = M !== null), N !== null && (N.visible = D !== null), U !== null && (U.visible = I !== null), this;
  }
}
class WebXRManager extends EventDispatcher$1 {
  constructor(e, b) {
    super();
    const L = this, M = e.state;
    let D = null, I = 1, F = null, N = "local-floor", U = null, G = null, V = null, z = null;
    const k = [], H = /* @__PURE__ */ new Map(), W = new PerspectiveCamera();
    W.layers.enable(1), W.viewport = new Vector4();
    const $ = new PerspectiveCamera();
    $.layers.enable(2), $.viewport = new Vector4();
    const j = [W, $], q = new ArrayCamera();
    q.layers.enable(1), q.layers.enable(2);
    let Y = null, J = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(se) {
      let ie = k[se];
      return ie === void 0 && (ie = new WebXRController(), k[se] = ie), ie.getTargetRaySpace();
    }, this.getControllerGrip = function(se) {
      let ie = k[se];
      return ie === void 0 && (ie = new WebXRController(), k[se] = ie), ie.getGripSpace();
    }, this.getHand = function(se) {
      let ie = k[se];
      return ie === void 0 && (ie = new WebXRController(), k[se] = ie), ie.getHandSpace();
    };
    function K(se) {
      const ie = H.get(se.inputSource);
      ie && ie.dispatchEvent({ type: se.type, data: se.inputSource });
    }
    function X() {
      H.forEach(function(se, ie) {
        se.disconnect(ie);
      }), H.clear(), Y = null, J = null, M.bindXRFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), ae.stop(), L.isPresenting = !1, L.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(se) {
      I = se, L.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(se) {
      N = se, L.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return F;
    }, this.getSession = function() {
      return D;
    }, this.setSession = async function(se) {
      if (D = se, D !== null) {
        D.addEventListener("select", K), D.addEventListener("selectstart", K), D.addEventListener("selectend", K), D.addEventListener("squeeze", K), D.addEventListener("squeezestart", K), D.addEventListener("squeezeend", K), D.addEventListener("end", X), D.addEventListener("inputsourceschange", Z);
        const ie = b.getContextAttributes();
        if (ie.xrCompatible !== !0 && await b.makeXRCompatible(), D.renderState.layers === void 0) {
          const ye = {
            antialias: ie.antialias,
            alpha: ie.alpha,
            depth: ie.depth,
            stencil: ie.stencil,
            framebufferScaleFactor: I
          }, Ce = new XRWebGLLayer(D, b, ye);
          D.updateRenderState({ baseLayer: Ce });
        } else {
          let ye = 0;
          ie.depth && (ye = ie.stencil ? 34041 : 6402);
          const Ce = {
            colorFormat: ie.alpha ? 6408 : 6407,
            depthFormat: ye,
            scaleFactor: I
          };
          G = new XRWebGLBinding(D, b), z = G.createProjectionLayer(Ce), V = b.createFramebuffer(), D.updateRenderState({ layers: [z] });
        }
        F = await D.requestReferenceSpace(N), ae.setContext(D), ae.start(), L.isPresenting = !0, L.dispatchEvent({ type: "sessionstart" });
      }
    };
    function Z(se) {
      const ie = D.inputSources;
      for (let ye = 0; ye < k.length; ye++)
        H.set(ie[ye], k[ye]);
      for (let ye = 0; ye < se.removed.length; ye++) {
        const Ce = se.removed[ye], de = H.get(Ce);
        de && (de.dispatchEvent({ type: "disconnected", data: Ce }), H.delete(Ce));
      }
      for (let ye = 0; ye < se.added.length; ye++) {
        const Ce = se.added[ye], de = H.get(Ce);
        de && de.dispatchEvent({ type: "connected", data: Ce });
      }
    }
    const Q = new Vector3(), ne = new Vector3();
    function le(se, ie, ye) {
      Q.setFromMatrixPosition(ie.matrixWorld), ne.setFromMatrixPosition(ye.matrixWorld);
      const Ce = Q.distanceTo(ne), de = ie.projectionMatrix.elements, ve = ye.projectionMatrix.elements, ce = de[14] / (de[10] - 1), ge = de[14] / (de[10] + 1), _e = (de[9] + 1) / de[5], Me = (de[9] - 1) / de[5], xe = (de[8] - 1) / de[0], fe = (ve[8] + 1) / ve[0], Re = ce * xe, Pe = ce * fe, Ue = Ce / (-xe + fe), Ve = Ue * -xe;
      ie.matrixWorld.decompose(se.position, se.quaternion, se.scale), se.translateX(Ve), se.translateZ(Ue), se.matrixWorld.compose(se.position, se.quaternion, se.scale), se.matrixWorldInverse.copy(se.matrixWorld).invert();
      const Oe = ce + Ue, me = ge + Ue, Ie = Re - Ve, Be = Pe + (Ce - Ve), Ne = _e * ge / me * Oe, Fe = Me * ge / me * Oe;
      se.projectionMatrix.makePerspective(Ie, Be, Ne, Fe, Oe, me);
    }
    function pe(se, ie) {
      ie === null ? se.matrixWorld.copy(se.matrix) : se.matrixWorld.multiplyMatrices(ie.matrixWorld, se.matrix), se.matrixWorldInverse.copy(se.matrixWorld).invert();
    }
    this.updateCamera = function(se) {
      if (D === null) return;
      q.near = $.near = W.near = se.near, q.far = $.far = W.far = se.far, (Y !== q.near || J !== q.far) && (D.updateRenderState({
        depthNear: q.near,
        depthFar: q.far
      }), Y = q.near, J = q.far);
      const ie = se.parent, ye = q.cameras;
      pe(q, ie);
      for (let de = 0; de < ye.length; de++)
        pe(ye[de], ie);
      q.matrixWorld.decompose(q.position, q.quaternion, q.scale), se.position.copy(q.position), se.quaternion.copy(q.quaternion), se.scale.copy(q.scale), se.matrix.copy(q.matrix), se.matrixWorld.copy(q.matrixWorld);
      const Ce = se.children;
      for (let de = 0, ve = Ce.length; de < ve; de++)
        Ce[de].updateMatrixWorld(!0);
      ye.length === 2 ? le(q, W, $) : q.projectionMatrix.copy(W.projectionMatrix);
    }, this.getCamera = function() {
      return q;
    };
    let ue = null;
    function oe(se, ie) {
      if (U = ie.getViewerPose(F), U !== null) {
        const Ce = U.views, de = D.renderState.baseLayer;
        D.renderState.layers === void 0 && M.bindXRFramebuffer(de.framebuffer);
        let ve = !1;
        Ce.length !== q.cameras.length && (q.cameras.length = 0, ve = !0);
        for (let ce = 0; ce < Ce.length; ce++) {
          const ge = Ce[ce];
          let _e = null;
          if (D.renderState.layers === void 0)
            _e = de.getViewport(ge);
          else {
            const xe = G.getViewSubImage(z, ge);
            M.bindXRFramebuffer(V), b.framebufferTexture2D(36160, 36064, 3553, xe.colorTexture, 0), xe.depthStencilTexture !== void 0 && b.framebufferTexture2D(36160, 36096, 3553, xe.depthStencilTexture, 0), _e = xe.viewport;
          }
          const Me = j[ce];
          Me.matrix.fromArray(ge.transform.matrix), Me.projectionMatrix.fromArray(ge.projectionMatrix), Me.viewport.set(_e.x, _e.y, _e.width, _e.height), ce === 0 && q.matrix.copy(Me.matrix), ve === !0 && q.cameras.push(Me);
        }
      }
      const ye = D.inputSources;
      for (let Ce = 0; Ce < k.length; Ce++) {
        const de = k[Ce], ve = ye[Ce];
        de.update(ve, ie, F);
      }
      ue && ue(se, ie);
    }
    const ae = new WebGLAnimation();
    ae.setAnimationLoop(oe), this.setAnimationLoop = function(se) {
      ue = se;
    }, this.dispose = function() {
    };
  }
}
function WebGLMaterials(B) {
  function e(j, q) {
    j.fogColor.value.copy(q.color), q.isFog ? (j.fogNear.value = q.near, j.fogFar.value = q.far) : q.isFogExp2 && (j.fogDensity.value = q.density);
  }
  function b(j, q, Y, J, K) {
    q.isMeshBasicMaterial ? L(j, q) : q.isMeshLambertMaterial ? (L(j, q), N(j, q)) : q.isMeshToonMaterial ? (L(j, q), G(j, q)) : q.isMeshPhongMaterial ? (L(j, q), U(j, q)) : q.isMeshStandardMaterial ? (L(j, q), q.isMeshPhysicalMaterial ? z(j, q, K) : V(j, q)) : q.isMeshMatcapMaterial ? (L(j, q), k(j, q)) : q.isMeshDepthMaterial ? (L(j, q), H(j, q)) : q.isMeshDistanceMaterial ? (L(j, q), W(j, q)) : q.isMeshNormalMaterial ? (L(j, q), $(j, q)) : q.isLineBasicMaterial ? (M(j, q), q.isLineDashedMaterial && D(j, q)) : q.isPointsMaterial ? I(j, q, Y, J) : q.isSpriteMaterial ? F(j, q) : q.isShadowMaterial ? (j.color.value.copy(q.color), j.opacity.value = q.opacity) : q.isShaderMaterial && (q.uniformsNeedUpdate = !1);
  }
  function L(j, q) {
    j.opacity.value = q.opacity, q.color && j.diffuse.value.copy(q.color), q.emissive && j.emissive.value.copy(q.emissive).multiplyScalar(q.emissiveIntensity), q.map && (j.map.value = q.map), q.alphaMap && (j.alphaMap.value = q.alphaMap), q.specularMap && (j.specularMap.value = q.specularMap);
    const Y = B.get(q).envMap;
    if (Y) {
      j.envMap.value = Y, j.flipEnvMap.value = Y.isCubeTexture && Y._needsFlipEnvMap ? -1 : 1, j.reflectivity.value = q.reflectivity, j.refractionRatio.value = q.refractionRatio;
      const X = B.get(Y).__maxMipLevel;
      X !== void 0 && (j.maxMipLevel.value = X);
    }
    q.lightMap && (j.lightMap.value = q.lightMap, j.lightMapIntensity.value = q.lightMapIntensity), q.aoMap && (j.aoMap.value = q.aoMap, j.aoMapIntensity.value = q.aoMapIntensity);
    let J;
    q.map ? J = q.map : q.specularMap ? J = q.specularMap : q.displacementMap ? J = q.displacementMap : q.normalMap ? J = q.normalMap : q.bumpMap ? J = q.bumpMap : q.roughnessMap ? J = q.roughnessMap : q.metalnessMap ? J = q.metalnessMap : q.alphaMap ? J = q.alphaMap : q.emissiveMap ? J = q.emissiveMap : q.clearcoatMap ? J = q.clearcoatMap : q.clearcoatNormalMap ? J = q.clearcoatNormalMap : q.clearcoatRoughnessMap && (J = q.clearcoatRoughnessMap), J !== void 0 && (J.isWebGLRenderTarget && (J = J.texture), J.matrixAutoUpdate === !0 && J.updateMatrix(), j.uvTransform.value.copy(J.matrix));
    let K;
    q.aoMap ? K = q.aoMap : q.lightMap && (K = q.lightMap), K !== void 0 && (K.isWebGLRenderTarget && (K = K.texture), K.matrixAutoUpdate === !0 && K.updateMatrix(), j.uv2Transform.value.copy(K.matrix));
  }
  function M(j, q) {
    j.diffuse.value.copy(q.color), j.opacity.value = q.opacity;
  }
  function D(j, q) {
    j.dashSize.value = q.dashSize, j.totalSize.value = q.dashSize + q.gapSize, j.scale.value = q.scale;
  }
  function I(j, q, Y, J) {
    j.diffuse.value.copy(q.color), j.opacity.value = q.opacity, j.size.value = q.size * Y, j.scale.value = J * 0.5, q.map && (j.map.value = q.map), q.alphaMap && (j.alphaMap.value = q.alphaMap);
    let K;
    q.map ? K = q.map : q.alphaMap && (K = q.alphaMap), K !== void 0 && (K.matrixAutoUpdate === !0 && K.updateMatrix(), j.uvTransform.value.copy(K.matrix));
  }
  function F(j, q) {
    j.diffuse.value.copy(q.color), j.opacity.value = q.opacity, j.rotation.value = q.rotation, q.map && (j.map.value = q.map), q.alphaMap && (j.alphaMap.value = q.alphaMap);
    let Y;
    q.map ? Y = q.map : q.alphaMap && (Y = q.alphaMap), Y !== void 0 && (Y.matrixAutoUpdate === !0 && Y.updateMatrix(), j.uvTransform.value.copy(Y.matrix));
  }
  function N(j, q) {
    q.emissiveMap && (j.emissiveMap.value = q.emissiveMap);
  }
  function U(j, q) {
    j.specular.value.copy(q.specular), j.shininess.value = Math.max(q.shininess, 1e-4), q.emissiveMap && (j.emissiveMap.value = q.emissiveMap), q.bumpMap && (j.bumpMap.value = q.bumpMap, j.bumpScale.value = q.bumpScale, q.side === BackSide && (j.bumpScale.value *= -1)), q.normalMap && (j.normalMap.value = q.normalMap, j.normalScale.value.copy(q.normalScale), q.side === BackSide && j.normalScale.value.negate()), q.displacementMap && (j.displacementMap.value = q.displacementMap, j.displacementScale.value = q.displacementScale, j.displacementBias.value = q.displacementBias);
  }
  function G(j, q) {
    q.gradientMap && (j.gradientMap.value = q.gradientMap), q.emissiveMap && (j.emissiveMap.value = q.emissiveMap), q.bumpMap && (j.bumpMap.value = q.bumpMap, j.bumpScale.value = q.bumpScale, q.side === BackSide && (j.bumpScale.value *= -1)), q.normalMap && (j.normalMap.value = q.normalMap, j.normalScale.value.copy(q.normalScale), q.side === BackSide && j.normalScale.value.negate()), q.displacementMap && (j.displacementMap.value = q.displacementMap, j.displacementScale.value = q.displacementScale, j.displacementBias.value = q.displacementBias);
  }
  function V(j, q) {
    j.roughness.value = q.roughness, j.metalness.value = q.metalness, q.roughnessMap && (j.roughnessMap.value = q.roughnessMap), q.metalnessMap && (j.metalnessMap.value = q.metalnessMap), q.emissiveMap && (j.emissiveMap.value = q.emissiveMap), q.bumpMap && (j.bumpMap.value = q.bumpMap, j.bumpScale.value = q.bumpScale, q.side === BackSide && (j.bumpScale.value *= -1)), q.normalMap && (j.normalMap.value = q.normalMap, j.normalScale.value.copy(q.normalScale), q.side === BackSide && j.normalScale.value.negate()), q.displacementMap && (j.displacementMap.value = q.displacementMap, j.displacementScale.value = q.displacementScale, j.displacementBias.value = q.displacementBias), B.get(q).envMap && (j.envMapIntensity.value = q.envMapIntensity);
  }
  function z(j, q, Y) {
    V(j, q), j.reflectivity.value = q.reflectivity, j.clearcoat.value = q.clearcoat, j.clearcoatRoughness.value = q.clearcoatRoughness, q.sheen && j.sheen.value.copy(q.sheen), q.clearcoatMap && (j.clearcoatMap.value = q.clearcoatMap), q.clearcoatRoughnessMap && (j.clearcoatRoughnessMap.value = q.clearcoatRoughnessMap), q.clearcoatNormalMap && (j.clearcoatNormalScale.value.copy(q.clearcoatNormalScale), j.clearcoatNormalMap.value = q.clearcoatNormalMap, q.side === BackSide && j.clearcoatNormalScale.value.negate()), j.transmission.value = q.transmission, q.transmissionMap && (j.transmissionMap.value = q.transmissionMap), q.transmission > 0 && (j.transmissionSamplerMap.value = Y.texture, j.transmissionSamplerSize.value.set(Y.width, Y.height)), j.thickness.value = q.thickness, q.thicknessMap && (j.thicknessMap.value = q.thicknessMap), j.attenuationDistance.value = q.attenuationDistance, j.attenuationColor.value.copy(q.attenuationColor);
  }
  function k(j, q) {
    q.matcap && (j.matcap.value = q.matcap), q.bumpMap && (j.bumpMap.value = q.bumpMap, j.bumpScale.value = q.bumpScale, q.side === BackSide && (j.bumpScale.value *= -1)), q.normalMap && (j.normalMap.value = q.normalMap, j.normalScale.value.copy(q.normalScale), q.side === BackSide && j.normalScale.value.negate()), q.displacementMap && (j.displacementMap.value = q.displacementMap, j.displacementScale.value = q.displacementScale, j.displacementBias.value = q.displacementBias);
  }
  function H(j, q) {
    q.displacementMap && (j.displacementMap.value = q.displacementMap, j.displacementScale.value = q.displacementScale, j.displacementBias.value = q.displacementBias);
  }
  function W(j, q) {
    q.displacementMap && (j.displacementMap.value = q.displacementMap, j.displacementScale.value = q.displacementScale, j.displacementBias.value = q.displacementBias), j.referencePosition.value.copy(q.referencePosition), j.nearDistance.value = q.nearDistance, j.farDistance.value = q.farDistance;
  }
  function $(j, q) {
    q.bumpMap && (j.bumpMap.value = q.bumpMap, j.bumpScale.value = q.bumpScale, q.side === BackSide && (j.bumpScale.value *= -1)), q.normalMap && (j.normalMap.value = q.normalMap, j.normalScale.value.copy(q.normalScale), q.side === BackSide && j.normalScale.value.negate()), q.displacementMap && (j.displacementMap.value = q.displacementMap, j.displacementScale.value = q.displacementScale, j.displacementBias.value = q.displacementBias);
  }
  return {
    refreshFogUniforms: e,
    refreshMaterialUniforms: b
  };
}
function createCanvasElement() {
  const B = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  return B.style.display = "block", B;
}
function WebGLRenderer$1(B = {}) {
  const e = B.canvas !== void 0 ? B.canvas : createCanvasElement(), b = B.context !== void 0 ? B.context : null, L = B.alpha !== void 0 ? B.alpha : !1, M = B.depth !== void 0 ? B.depth : !0, D = B.stencil !== void 0 ? B.stencil : !0, I = B.antialias !== void 0 ? B.antialias : !1, F = B.premultipliedAlpha !== void 0 ? B.premultipliedAlpha : !0, N = B.preserveDrawingBuffer !== void 0 ? B.preserveDrawingBuffer : !1, U = B.powerPreference !== void 0 ? B.powerPreference : "default", G = B.failIfMajorPerformanceCaveat !== void 0 ? B.failIfMajorPerformanceCaveat : !1;
  let V = null, z = null;
  const k = [], H = [];
  this.domElement = e, this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: !0
  }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = LinearEncoding, this.physicallyCorrectLights = !1, this.toneMapping = NoToneMapping, this.toneMappingExposure = 1;
  const W = this;
  let $ = !1, j = 0, q = 0, Y = null, J = -1, K = null;
  const X = new Vector4(), Z = new Vector4();
  let Q = null, ne = e.width, le = e.height, pe = 1, ue = null, oe = null;
  const ae = new Vector4(0, 0, ne, le), se = new Vector4(0, 0, ne, le);
  let ie = !1;
  const ye = [], Ce = new Frustum();
  let de = !1, ve = !1, ce = null;
  const ge = new Matrix4(), _e = new Vector3(), Me = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
  function xe() {
    return Y === null ? pe : 1;
  }
  let fe = b;
  function Re(re, Ae) {
    for (let we = 0; we < re.length; we++) {
      const De = re[we], qe = e.getContext(De, Ae);
      if (qe !== null) return qe;
    }
    return null;
  }
  try {
    const re = {
      alpha: L,
      depth: M,
      stencil: D,
      antialias: I,
      premultipliedAlpha: F,
      preserveDrawingBuffer: N,
      powerPreference: U,
      failIfMajorPerformanceCaveat: G
    };
    if (e.addEventListener("webglcontextlost", rt, !1), e.addEventListener("webglcontextrestored", Qe, !1), fe === null) {
      const Ae = ["webgl2", "webgl", "experimental-webgl"];
      if (W.isWebGL1Renderer === !0 && Ae.shift(), fe = Re(Ae, re), fe === null)
        throw Re(Ae) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    fe.getShaderPrecisionFormat === void 0 && (fe.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (re) {
    throw console.error("THREE.WebGLRenderer: " + re.message), re;
  }
  let Pe, Ue, Ve, Oe, me, Ie, Be, Ne, Fe, te, ee, Se, Ee, be, ze, Ge, He, ke, $e, he, Le, Te;
  function je() {
    Pe = new WebGLExtensions(fe), Ue = new WebGLCapabilities(fe, Pe, B), Pe.init(Ue), Le = new WebGLUtils(fe, Pe, Ue), Ve = new WebGLState(fe, Pe, Ue), ye[0] = 1029, Oe = new WebGLInfo(), me = new WebGLProperties(), Ie = new WebGLTextures(fe, Pe, Ve, me, Ue, Le, Oe), Be = new WebGLCubeMaps(W), Ne = new WebGLAttributes(fe, Ue), Te = new WebGLBindingStates(fe, Pe, Ne, Ue), Fe = new WebGLGeometries(fe, Ne, Oe, Te), te = new WebGLObjects(fe, Fe, Ne, Oe), ke = new WebGLMorphtargets(fe), ze = new WebGLClipping(me), ee = new WebGLPrograms(W, Be, Pe, Ue, Te, ze), Se = new WebGLMaterials(me), Ee = new WebGLRenderLists(me), be = new WebGLRenderStates(Pe, Ue), He = new WebGLBackground(W, Be, Ve, te, F), Ge = new WebGLShadowMap(W, te, Ue), $e = new WebGLBufferRenderer(fe, Pe, Oe, Ue), he = new WebGLIndexedBufferRenderer(fe, Pe, Oe, Ue), Oe.programs = ee.programs, W.capabilities = Ue, W.extensions = Pe, W.properties = me, W.renderLists = Ee, W.shadowMap = Ge, W.state = Ve, W.info = Oe;
  }
  je();
  const We = new WebXRManager(W, fe);
  this.xr = We, this.getContext = function() {
    return fe;
  }, this.getContextAttributes = function() {
    return fe.getContextAttributes();
  }, this.forceContextLoss = function() {
    const re = Pe.get("WEBGL_lose_context");
    re && re.loseContext();
  }, this.forceContextRestore = function() {
    const re = Pe.get("WEBGL_lose_context");
    re && re.restoreContext();
  }, this.getPixelRatio = function() {
    return pe;
  }, this.setPixelRatio = function(re) {
    re !== void 0 && (pe = re, this.setSize(ne, le, !1));
  }, this.getSize = function(re) {
    return re.set(ne, le);
  }, this.setSize = function(re, Ae, we) {
    if (We.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    ne = re, le = Ae, e.width = Math.floor(re * pe), e.height = Math.floor(Ae * pe), we !== !1 && (e.style.width = re + "px", e.style.height = Ae + "px"), this.setViewport(0, 0, re, Ae);
  }, this.getDrawingBufferSize = function(re) {
    return re.set(ne * pe, le * pe).floor();
  }, this.setDrawingBufferSize = function(re, Ae, we) {
    ne = re, le = Ae, pe = we, e.width = Math.floor(re * we), e.height = Math.floor(Ae * we), this.setViewport(0, 0, re, Ae);
  }, this.getCurrentViewport = function(re) {
    return re.copy(X);
  }, this.getViewport = function(re) {
    return re.copy(ae);
  }, this.setViewport = function(re, Ae, we, De) {
    re.isVector4 ? ae.set(re.x, re.y, re.z, re.w) : ae.set(re, Ae, we, De), Ve.viewport(X.copy(ae).multiplyScalar(pe).floor());
  }, this.getScissor = function(re) {
    return re.copy(se);
  }, this.setScissor = function(re, Ae, we, De) {
    re.isVector4 ? se.set(re.x, re.y, re.z, re.w) : se.set(re, Ae, we, De), Ve.scissor(Z.copy(se).multiplyScalar(pe).floor());
  }, this.getScissorTest = function() {
    return ie;
  }, this.setScissorTest = function(re) {
    Ve.setScissorTest(ie = re);
  }, this.setOpaqueSort = function(re) {
    ue = re;
  }, this.setTransparentSort = function(re) {
    oe = re;
  }, this.getClearColor = function(re) {
    return re.copy(He.getClearColor());
  }, this.setClearColor = function() {
    He.setClearColor.apply(He, arguments);
  }, this.getClearAlpha = function() {
    return He.getClearAlpha();
  }, this.setClearAlpha = function() {
    He.setClearAlpha.apply(He, arguments);
  }, this.clear = function(re, Ae, we) {
    let De = 0;
    (re === void 0 || re) && (De |= 16384), (Ae === void 0 || Ae) && (De |= 256), (we === void 0 || we) && (De |= 1024), fe.clear(De);
  }, this.clearColor = function() {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function() {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function() {
    this.clear(!1, !1, !0);
  }, this.dispose = function() {
    e.removeEventListener("webglcontextlost", rt, !1), e.removeEventListener("webglcontextrestored", Qe, !1), Ee.dispose(), be.dispose(), me.dispose(), Be.dispose(), te.dispose(), Te.dispose(), We.dispose(), We.removeEventListener("sessionstart", tt), We.removeEventListener("sessionend", dt), ce && (ce.dispose(), ce = null), Tt.stop();
  };
  function rt(re) {
    re.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), $ = !0;
  }
  function Qe() {
    console.log("THREE.WebGLRenderer: Context Restored."), $ = !1;
    const re = Oe.autoReset, Ae = Ge.enabled, we = Ge.autoUpdate, De = Ge.needsUpdate, qe = Ge.type;
    je(), Oe.autoReset = re, Ge.enabled = Ae, Ge.autoUpdate = we, Ge.needsUpdate = De, Ge.type = qe;
  }
  function et(re) {
    const Ae = re.target;
    Ae.removeEventListener("dispose", et), Ye(Ae);
  }
  function Ye(re) {
    st(re), me.remove(re);
  }
  function st(re) {
    const Ae = me.get(re).programs;
    Ae !== void 0 && Ae.forEach(function(we) {
      ee.releaseProgram(we);
    });
  }
  function ut(re, Ae) {
    re.render(function(we) {
      W.renderBufferImmediate(we, Ae);
    });
  }
  this.renderBufferImmediate = function(re, Ae) {
    Te.initAttributes();
    const we = me.get(re);
    re.hasPositions && !we.position && (we.position = fe.createBuffer()), re.hasNormals && !we.normal && (we.normal = fe.createBuffer()), re.hasUvs && !we.uv && (we.uv = fe.createBuffer()), re.hasColors && !we.color && (we.color = fe.createBuffer());
    const De = Ae.getAttributes();
    re.hasPositions && (fe.bindBuffer(34962, we.position), fe.bufferData(34962, re.positionArray, 35048), Te.enableAttribute(De.position), fe.vertexAttribPointer(De.position, 3, 5126, !1, 0, 0)), re.hasNormals && (fe.bindBuffer(34962, we.normal), fe.bufferData(34962, re.normalArray, 35048), Te.enableAttribute(De.normal), fe.vertexAttribPointer(De.normal, 3, 5126, !1, 0, 0)), re.hasUvs && (fe.bindBuffer(34962, we.uv), fe.bufferData(34962, re.uvArray, 35048), Te.enableAttribute(De.uv), fe.vertexAttribPointer(De.uv, 2, 5126, !1, 0, 0)), re.hasColors && (fe.bindBuffer(34962, we.color), fe.bufferData(34962, re.colorArray, 35048), Te.enableAttribute(De.color), fe.vertexAttribPointer(De.color, 3, 5126, !1, 0, 0)), Te.disableUnusedAttributes(), fe.drawArrays(4, 0, re.count), re.count = 0;
  }, this.renderBufferDirect = function(re, Ae, we, De, qe, nt) {
    Ae === null && (Ae = Me);
    const Je = qe.isMesh && qe.matrixWorld.determinant() < 0, Xe = St(re, Ae, De, qe);
    Ve.setMaterial(De, Je);
    let at = we.index;
    const Ke = we.attributes.position;
    if (at === null) {
      if (Ke === void 0 || Ke.count === 0) return;
    } else if (at.count === 0)
      return;
    let ct = 1;
    De.wireframe === !0 && (at = Fe.getWireframeAttribute(we), ct = 2), (De.morphTargets || De.morphNormals) && ke.update(qe, we, De, Xe), Te.setup(qe, De, Xe, we, at);
    let it, ht = $e;
    at !== null && (it = Ne.get(at), ht = he, ht.setIndex(it));
    const Et = at !== null ? at.count : Ke.count, wt = we.drawRange.start * ct, It = we.drawRange.count * ct, pt = nt !== null ? nt.start * ct : 0, Rt = nt !== null ? nt.count * ct : 1 / 0, bt = Math.max(wt, pt), Ze = Math.min(Et, wt + It, pt + Rt) - 1, Bt = Math.max(0, Ze - bt + 1);
    if (Bt !== 0) {
      if (qe.isMesh)
        De.wireframe === !0 ? (Ve.setLineWidth(De.wireframeLinewidth * xe()), ht.setMode(1)) : ht.setMode(4);
      else if (qe.isLine) {
        let Ut = De.linewidth;
        Ut === void 0 && (Ut = 1), Ve.setLineWidth(Ut * xe()), qe.isLineSegments ? ht.setMode(1) : qe.isLineLoop ? ht.setMode(2) : ht.setMode(3);
      } else qe.isPoints ? ht.setMode(0) : qe.isSprite && ht.setMode(4);
      if (qe.isInstancedMesh)
        ht.renderInstances(bt, Bt, qe.count);
      else if (we.isInstancedBufferGeometry) {
        const Ut = Math.min(we.instanceCount, we._maxInstanceCount);
        ht.renderInstances(bt, Bt, Ut);
      } else
        ht.render(bt, Bt);
    }
  }, this.compile = function(re, Ae) {
    z = be.get(re), z.init(), re.traverseVisible(function(we) {
      we.isLight && we.layers.test(Ae.layers) && (z.pushLight(we), we.castShadow && z.pushShadow(we));
    }), z.setupLights(), re.traverse(function(we) {
      const De = we.material;
      if (De)
        if (Array.isArray(De))
          for (let qe = 0; qe < De.length; qe++) {
            const nt = De[qe];
            ot(nt, re, we);
          }
        else
          ot(De, re, we);
    });
  };
  let vt = null;
  function mt(re) {
    vt && vt(re);
  }
  function tt() {
    Tt.stop();
  }
  function dt() {
    Tt.start();
  }
  const Tt = new WebGLAnimation();
  Tt.setAnimationLoop(mt), typeof window < "u" && Tt.setContext(window), this.setAnimationLoop = function(re) {
    vt = re, We.setAnimationLoop(re), re === null ? Tt.stop() : Tt.start();
  }, We.addEventListener("sessionstart", tt), We.addEventListener("sessionend", dt), this.render = function(re, Ae) {
    if (Ae !== void 0 && Ae.isCamera !== !0) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if ($ === !0) return;
    re.autoUpdate === !0 && re.updateMatrixWorld(), Ae.parent === null && Ae.updateMatrixWorld(), We.enabled === !0 && We.isPresenting === !0 && (We.cameraAutoUpdate === !0 && We.updateCamera(Ae), Ae = We.getCamera()), re.isScene === !0 && re.onBeforeRender(W, re, Ae, Y), z = be.get(re, H.length), z.init(), H.push(z), ge.multiplyMatrices(Ae.projectionMatrix, Ae.matrixWorldInverse), Ce.setFromProjectionMatrix(ge), ve = this.localClippingEnabled, de = ze.init(this.clippingPlanes, ve, Ae), V = Ee.get(re, k.length), V.init(), k.push(V), ft(re, Ae, 0, W.sortObjects), V.finish(), W.sortObjects === !0 && V.sort(ue, oe), de === !0 && ze.beginShadows();
    const we = z.state.shadowsArray;
    Ge.render(we, re, Ae), z.setupLights(), z.setupLightsView(Ae), de === !0 && ze.endShadows(), this.info.autoReset === !0 && this.info.reset(), He.render(V, re);
    const De = V.opaque, qe = V.transmissive, nt = V.transparent;
    De.length > 0 && _t(De, re, Ae), qe.length > 0 && lt(De, qe, re, Ae), nt.length > 0 && _t(nt, re, Ae), Y !== null && (Ie.updateMultisampleRenderTarget(Y), Ie.updateRenderTargetMipmap(Y)), re.isScene === !0 && re.onAfterRender(W, re, Ae), Ve.buffers.depth.setTest(!0), Ve.buffers.depth.setMask(!0), Ve.buffers.color.setMask(!0), Ve.setPolygonOffset(!1), Te.resetDefaultState(), J = -1, K = null, H.pop(), H.length > 0 ? z = H[H.length - 1] : z = null, k.pop(), k.length > 0 ? V = k[k.length - 1] : V = null;
  };
  function ft(re, Ae, we, De) {
    if (re.visible === !1) return;
    if (re.layers.test(Ae.layers)) {
      if (re.isGroup)
        we = re.renderOrder;
      else if (re.isLOD)
        re.autoUpdate === !0 && re.update(Ae);
      else if (re.isLight)
        z.pushLight(re), re.castShadow && z.pushShadow(re);
      else if (re.isSprite) {
        if (!re.frustumCulled || Ce.intersectsSprite(re)) {
          De && _e.setFromMatrixPosition(re.matrixWorld).applyMatrix4(ge);
          const Je = te.update(re), Xe = re.material;
          Xe.visible && V.push(re, Je, Xe, we, _e.z, null);
        }
      } else if (re.isImmediateRenderObject)
        De && _e.setFromMatrixPosition(re.matrixWorld).applyMatrix4(ge), V.push(re, null, re.material, we, _e.z, null);
      else if ((re.isMesh || re.isLine || re.isPoints) && (re.isSkinnedMesh && re.skeleton.frame !== Oe.render.frame && (re.skeleton.update(), re.skeleton.frame = Oe.render.frame), !re.frustumCulled || Ce.intersectsObject(re))) {
        De && _e.setFromMatrixPosition(re.matrixWorld).applyMatrix4(ge);
        const Je = te.update(re), Xe = re.material;
        if (Array.isArray(Xe)) {
          const at = Je.groups;
          for (let Ke = 0, ct = at.length; Ke < ct; Ke++) {
            const it = at[Ke], ht = Xe[it.materialIndex];
            ht && ht.visible && V.push(re, Je, ht, we, _e.z, it);
          }
        } else Xe.visible && V.push(re, Je, Xe, we, _e.z, null);
      }
    }
    const nt = re.children;
    for (let Je = 0, Xe = nt.length; Je < Xe; Je++)
      ft(nt[Je], Ae, we, De);
  }
  function lt(re, Ae, we, De) {
    if (ce === null) {
      const Xe = I === !0 && Ue.isWebGL2 === !0 ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
      ce = new Xe(1024, 1024, {
        generateMipmaps: !0,
        type: Le.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
        minFilter: LinearMipmapLinearFilter,
        magFilter: NearestFilter,
        wrapS: ClampToEdgeWrapping,
        wrapT: ClampToEdgeWrapping
      });
    }
    const qe = W.getRenderTarget();
    W.setRenderTarget(ce), W.clear();
    const nt = W.toneMapping;
    W.toneMapping = NoToneMapping, _t(re, we, De), W.toneMapping = nt, Ie.updateMultisampleRenderTarget(ce), Ie.updateRenderTargetMipmap(ce), W.setRenderTarget(qe), _t(Ae, we, De);
  }
  function _t(re, Ae, we) {
    const De = Ae.isScene === !0 ? Ae.overrideMaterial : null;
    for (let qe = 0, nt = re.length; qe < nt; qe++) {
      const Je = re[qe], Xe = Je.object, at = Je.geometry, Ke = De === null ? Je.material : De, ct = Je.group;
      if (we.isArrayCamera) {
        const it = we.cameras;
        for (let ht = 0, Et = it.length; ht < Et; ht++) {
          const wt = it[ht];
          Xe.layers.test(wt.layers) && (Ve.viewport(X.copy(wt.viewport)), z.setupLightsView(wt), gt(Xe, Ae, wt, at, Ke, ct));
        }
      } else
        gt(Xe, Ae, we, at, Ke, ct);
    }
  }
  function gt(re, Ae, we, De, qe, nt) {
    if (re.onBeforeRender(W, Ae, we, De, qe, nt), re.modelViewMatrix.multiplyMatrices(we.matrixWorldInverse, re.matrixWorld), re.normalMatrix.getNormalMatrix(re.modelViewMatrix), re.isImmediateRenderObject) {
      const Je = St(we, Ae, qe, re);
      Ve.setMaterial(qe), Te.reset(), ut(re, Je);
    } else
      qe.transparent === !0 && qe.side === DoubleSide ? (qe.side = BackSide, qe.needsUpdate = !0, W.renderBufferDirect(we, Ae, De, qe, re, nt), qe.side = FrontSide, qe.needsUpdate = !0, W.renderBufferDirect(we, Ae, De, qe, re, nt), qe.side = DoubleSide) : W.renderBufferDirect(we, Ae, De, qe, re, nt);
    re.onAfterRender(W, Ae, we, De, qe, nt);
  }
  function ot(re, Ae, we) {
    Ae.isScene !== !0 && (Ae = Me);
    const De = me.get(re), qe = z.state.lights, nt = z.state.shadowsArray, Je = qe.state.version, Xe = ee.getParameters(re, qe.state, nt, Ae, we), at = ee.getProgramCacheKey(Xe);
    let Ke = De.programs;
    De.environment = re.isMeshStandardMaterial ? Ae.environment : null, De.fog = Ae.fog, De.envMap = Be.get(re.envMap || De.environment), Ke === void 0 && (re.addEventListener("dispose", et), Ke = /* @__PURE__ */ new Map(), De.programs = Ke);
    let ct = Ke.get(at);
    if (ct !== void 0) {
      if (De.currentProgram === ct && De.lightsStateVersion === Je)
        return yt(re, Xe), ct;
    } else
      Xe.uniforms = ee.getUniforms(re), re.onBuild(Xe, W), re.onBeforeCompile(Xe, W), ct = ee.acquireProgram(Xe, at), Ke.set(at, ct), De.uniforms = Xe.uniforms;
    const it = De.uniforms;
    (!re.isShaderMaterial && !re.isRawShaderMaterial || re.clipping === !0) && (it.clippingPlanes = ze.uniform), yt(re, Xe), De.needsLights = xt(re), De.lightsStateVersion = Je, De.needsLights && (it.ambientLightColor.value = qe.state.ambient, it.lightProbe.value = qe.state.probe, it.directionalLights.value = qe.state.directional, it.directionalLightShadows.value = qe.state.directionalShadow, it.spotLights.value = qe.state.spot, it.spotLightShadows.value = qe.state.spotShadow, it.rectAreaLights.value = qe.state.rectArea, it.ltc_1.value = qe.state.rectAreaLTC1, it.ltc_2.value = qe.state.rectAreaLTC2, it.pointLights.value = qe.state.point, it.pointLightShadows.value = qe.state.pointShadow, it.hemisphereLights.value = qe.state.hemi, it.directionalShadowMap.value = qe.state.directionalShadowMap, it.directionalShadowMatrix.value = qe.state.directionalShadowMatrix, it.spotShadowMap.value = qe.state.spotShadowMap, it.spotShadowMatrix.value = qe.state.spotShadowMatrix, it.pointShadowMap.value = qe.state.pointShadowMap, it.pointShadowMatrix.value = qe.state.pointShadowMatrix);
    const ht = ct.getUniforms(), Et = WebGLUniforms.seqWithValue(ht.seq, it);
    return De.currentProgram = ct, De.uniformsList = Et, ct;
  }
  function yt(re, Ae) {
    const we = me.get(re);
    we.outputEncoding = Ae.outputEncoding, we.instancing = Ae.instancing, we.skinning = Ae.skinning, we.numClippingPlanes = Ae.numClippingPlanes, we.numIntersection = Ae.numClipIntersection, we.vertexAlphas = Ae.vertexAlphas;
  }
  function St(re, Ae, we, De) {
    Ae.isScene !== !0 && (Ae = Me), Ie.resetTextureUnits();
    const qe = Ae.fog, nt = we.isMeshStandardMaterial ? Ae.environment : null, Je = Y === null ? W.outputEncoding : Y.texture.encoding, Xe = Be.get(we.envMap || nt), at = we.vertexColors === !0 && De.geometry && De.geometry.attributes.color && De.geometry.attributes.color.itemSize === 4, Ke = me.get(we), ct = z.state.lights;
    if (de === !0 && (ve === !0 || re !== K)) {
      const bt = re === K && we.id === J;
      ze.setState(we, re, bt);
    }
    let it = !1;
    we.version === Ke.__version ? (Ke.needsLights && Ke.lightsStateVersion !== ct.state.version || Ke.outputEncoding !== Je || De.isInstancedMesh && Ke.instancing === !1 || !De.isInstancedMesh && Ke.instancing === !0 || De.isSkinnedMesh && Ke.skinning === !1 || !De.isSkinnedMesh && Ke.skinning === !0 || Ke.envMap !== Xe || we.fog && Ke.fog !== qe || Ke.numClippingPlanes !== void 0 && (Ke.numClippingPlanes !== ze.numPlanes || Ke.numIntersection !== ze.numIntersection) || Ke.vertexAlphas !== at) && (it = !0) : (it = !0, Ke.__version = we.version);
    let ht = Ke.currentProgram;
    it === !0 && (ht = ot(we, Ae, De));
    let Et = !1, wt = !1, It = !1;
    const pt = ht.getUniforms(), Rt = Ke.uniforms;
    if (Ve.useProgram(ht.program) && (Et = !0, wt = !0, It = !0), we.id !== J && (J = we.id, wt = !0), Et || K !== re) {
      if (pt.setValue(fe, "projectionMatrix", re.projectionMatrix), Ue.logarithmicDepthBuffer && pt.setValue(
        fe,
        "logDepthBufFC",
        2 / (Math.log(re.far + 1) / Math.LN2)
      ), K !== re && (K = re, wt = !0, It = !0), we.isShaderMaterial || we.isMeshPhongMaterial || we.isMeshToonMaterial || we.isMeshStandardMaterial || we.envMap) {
        const bt = pt.map.cameraPosition;
        bt !== void 0 && bt.setValue(
          fe,
          _e.setFromMatrixPosition(re.matrixWorld)
        );
      }
      (we.isMeshPhongMaterial || we.isMeshToonMaterial || we.isMeshLambertMaterial || we.isMeshBasicMaterial || we.isMeshStandardMaterial || we.isShaderMaterial) && pt.setValue(fe, "isOrthographic", re.isOrthographicCamera === !0), (we.isMeshPhongMaterial || we.isMeshToonMaterial || we.isMeshLambertMaterial || we.isMeshBasicMaterial || we.isMeshStandardMaterial || we.isShaderMaterial || we.isShadowMaterial || De.isSkinnedMesh) && pt.setValue(fe, "viewMatrix", re.matrixWorldInverse);
    }
    if (De.isSkinnedMesh) {
      pt.setOptional(fe, De, "bindMatrix"), pt.setOptional(fe, De, "bindMatrixInverse");
      const bt = De.skeleton;
      bt && (Ue.floatVertexTextures ? (bt.boneTexture === null && bt.computeBoneTexture(), pt.setValue(fe, "boneTexture", bt.boneTexture, Ie), pt.setValue(fe, "boneTextureSize", bt.boneTextureSize)) : pt.setOptional(fe, bt, "boneMatrices"));
    }
    return (wt || Ke.receiveShadow !== De.receiveShadow) && (Ke.receiveShadow = De.receiveShadow, pt.setValue(fe, "receiveShadow", De.receiveShadow)), wt && (pt.setValue(fe, "toneMappingExposure", W.toneMappingExposure), Ke.needsLights && Mt(Rt, It), qe && we.fog && Se.refreshFogUniforms(Rt, qe), Se.refreshMaterialUniforms(Rt, we, pe, le, ce), WebGLUniforms.upload(fe, Ke.uniformsList, Rt, Ie)), we.isShaderMaterial && we.uniformsNeedUpdate === !0 && (WebGLUniforms.upload(fe, Ke.uniformsList, Rt, Ie), we.uniformsNeedUpdate = !1), we.isSpriteMaterial && pt.setValue(fe, "center", De.center), pt.setValue(fe, "modelViewMatrix", De.modelViewMatrix), pt.setValue(fe, "normalMatrix", De.normalMatrix), pt.setValue(fe, "modelMatrix", De.matrixWorld), ht;
  }
  function Mt(re, Ae) {
    re.ambientLightColor.needsUpdate = Ae, re.lightProbe.needsUpdate = Ae, re.directionalLights.needsUpdate = Ae, re.directionalLightShadows.needsUpdate = Ae, re.pointLights.needsUpdate = Ae, re.pointLightShadows.needsUpdate = Ae, re.spotLights.needsUpdate = Ae, re.spotLightShadows.needsUpdate = Ae, re.rectAreaLights.needsUpdate = Ae, re.hemisphereLights.needsUpdate = Ae;
  }
  function xt(re) {
    return re.isMeshLambertMaterial || re.isMeshToonMaterial || re.isMeshPhongMaterial || re.isMeshStandardMaterial || re.isShadowMaterial || re.isShaderMaterial && re.lights === !0;
  }
  this.getActiveCubeFace = function() {
    return j;
  }, this.getActiveMipmapLevel = function() {
    return q;
  }, this.getRenderTarget = function() {
    return Y;
  }, this.setRenderTarget = function(re, Ae = 0, we = 0) {
    Y = re, j = Ae, q = we, re && me.get(re).__webglFramebuffer === void 0 && Ie.setupRenderTarget(re);
    let De = null, qe = !1, nt = !1;
    if (re) {
      const Xe = re.texture;
      (Xe.isDataTexture3D || Xe.isDataTexture2DArray) && (nt = !0);
      const at = me.get(re).__webglFramebuffer;
      re.isWebGLCubeRenderTarget ? (De = at[Ae], qe = !0) : re.isWebGLMultisampleRenderTarget ? De = me.get(re).__webglMultisampledFramebuffer : De = at, X.copy(re.viewport), Z.copy(re.scissor), Q = re.scissorTest;
    } else
      X.copy(ae).multiplyScalar(pe).floor(), Z.copy(se).multiplyScalar(pe).floor(), Q = ie;
    if (Ve.bindFramebuffer(36160, De) && Ue.drawBuffers) {
      let Xe = !1;
      if (re)
        if (re.isWebGLMultipleRenderTargets) {
          const at = re.texture;
          if (ye.length !== at.length || ye[0] !== 36064) {
            for (let Ke = 0, ct = at.length; Ke < ct; Ke++)
              ye[Ke] = 36064 + Ke;
            ye.length = at.length, Xe = !0;
          }
        } else
          (ye.length !== 1 || ye[0] !== 36064) && (ye[0] = 36064, ye.length = 1, Xe = !0);
      else
        (ye.length !== 1 || ye[0] !== 1029) && (ye[0] = 1029, ye.length = 1, Xe = !0);
      Xe && (Ue.isWebGL2 ? fe.drawBuffers(ye) : Pe.get("WEBGL_draw_buffers").drawBuffersWEBGL(ye));
    }
    if (Ve.viewport(X), Ve.scissor(Z), Ve.setScissorTest(Q), qe) {
      const Xe = me.get(re.texture);
      fe.framebufferTexture2D(36160, 36064, 34069 + Ae, Xe.__webglTexture, we);
    } else if (nt) {
      const Xe = me.get(re.texture), at = Ae || 0;
      fe.framebufferTextureLayer(36160, 36064, Xe.__webglTexture, we || 0, at);
    }
  }, this.readRenderTargetPixels = function(re, Ae, we, De, qe, nt, Je) {
    if (!(re && re.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let Xe = me.get(re).__webglFramebuffer;
    if (re.isWebGLCubeRenderTarget && Je !== void 0 && (Xe = Xe[Je]), Xe) {
      Ve.bindFramebuffer(36160, Xe);
      try {
        const at = re.texture, Ke = at.format, ct = at.type;
        if (Ke !== RGBAFormat && Le.convert(Ke) !== fe.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const it = ct === HalfFloatType && (Pe.has("EXT_color_buffer_half_float") || Ue.isWebGL2 && Pe.has("EXT_color_buffer_float"));
        if (ct !== UnsignedByteType && Le.convert(ct) !== fe.getParameter(35738) && // Edge and Chrome Mac < 52 (#9513)
        !(ct === FloatType && (Ue.isWebGL2 || Pe.has("OES_texture_float") || Pe.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
        !it) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        fe.checkFramebufferStatus(36160) === 36053 ? Ae >= 0 && Ae <= re.width - De && we >= 0 && we <= re.height - qe && fe.readPixels(Ae, we, De, qe, Le.convert(Ke), Le.convert(ct), nt) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
      } finally {
        const at = Y !== null ? me.get(Y).__webglFramebuffer : null;
        Ve.bindFramebuffer(36160, at);
      }
    }
  }, this.copyFramebufferToTexture = function(re, Ae, we = 0) {
    const De = Math.pow(2, -we), qe = Math.floor(Ae.image.width * De), nt = Math.floor(Ae.image.height * De);
    let Je = Le.convert(Ae.format);
    Ue.isWebGL2 && (Je === 6407 && (Je = 32849), Je === 6408 && (Je = 32856)), Ie.setTexture2D(Ae, 0), fe.copyTexImage2D(3553, we, Je, re.x, re.y, qe, nt, 0), Ve.unbindTexture();
  }, this.copyTextureToTexture = function(re, Ae, we, De = 0) {
    const qe = Ae.image.width, nt = Ae.image.height, Je = Le.convert(we.format), Xe = Le.convert(we.type);
    Ie.setTexture2D(we, 0), fe.pixelStorei(37440, we.flipY), fe.pixelStorei(37441, we.premultiplyAlpha), fe.pixelStorei(3317, we.unpackAlignment), Ae.isDataTexture ? fe.texSubImage2D(3553, De, re.x, re.y, qe, nt, Je, Xe, Ae.image.data) : Ae.isCompressedTexture ? fe.compressedTexSubImage2D(3553, De, re.x, re.y, Ae.mipmaps[0].width, Ae.mipmaps[0].height, Je, Ae.mipmaps[0].data) : fe.texSubImage2D(3553, De, re.x, re.y, Je, Xe, Ae.image), De === 0 && we.generateMipmaps && fe.generateMipmap(3553), Ve.unbindTexture();
  }, this.copyTextureToTexture3D = function(re, Ae, we, De, qe = 0) {
    if (W.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const nt = re.max.x - re.min.x + 1, Je = re.max.y - re.min.y + 1, Xe = re.max.z - re.min.z + 1, at = Le.convert(De.format), Ke = Le.convert(De.type);
    let ct;
    if (De.isDataTexture3D)
      Ie.setTexture3D(De, 0), ct = 32879;
    else if (De.isDataTexture2DArray)
      Ie.setTexture2DArray(De, 0), ct = 35866;
    else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    fe.pixelStorei(37440, De.flipY), fe.pixelStorei(37441, De.premultiplyAlpha), fe.pixelStorei(3317, De.unpackAlignment);
    const it = fe.getParameter(3314), ht = fe.getParameter(32878), Et = fe.getParameter(3316), wt = fe.getParameter(3315), It = fe.getParameter(32877), pt = we.isCompressedTexture ? we.mipmaps[0] : we.image;
    fe.pixelStorei(3314, pt.width), fe.pixelStorei(32878, pt.height), fe.pixelStorei(3316, re.min.x), fe.pixelStorei(3315, re.min.y), fe.pixelStorei(32877, re.min.z), we.isDataTexture || we.isDataTexture3D ? fe.texSubImage3D(ct, qe, Ae.x, Ae.y, Ae.z, nt, Je, Xe, at, Ke, pt.data) : we.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), fe.compressedTexSubImage3D(ct, qe, Ae.x, Ae.y, Ae.z, nt, Je, Xe, at, pt.data)) : fe.texSubImage3D(ct, qe, Ae.x, Ae.y, Ae.z, nt, Je, Xe, at, Ke, pt), fe.pixelStorei(3314, it), fe.pixelStorei(32878, ht), fe.pixelStorei(3316, Et), fe.pixelStorei(3315, wt), fe.pixelStorei(32877, It), qe === 0 && De.generateMipmaps && fe.generateMipmap(ct), Ve.unbindTexture();
  }, this.initTexture = function(re) {
    Ie.setTexture2D(re, 0), Ve.unbindTexture();
  }, this.resetState = function() {
    j = 0, q = 0, Y = null, Ve.reset(), Te.reset();
  }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
class WebGL1Renderer extends WebGLRenderer$1 {
}
WebGL1Renderer.prototype.isWebGL1Renderer = !0;
class FogExp2 {
  constructor(e, b = 25e-5) {
    this.name = "", this.color = new Color(e), this.density = b;
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
}
FogExp2.prototype.isFogExp2 = !0;
class Fog {
  constructor(e, b = 1, L = 1e3) {
    this.name = "", this.color = new Color(e), this.near = b, this.far = L;
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
Fog.prototype.isFog = !0;
let Scene$1 = class extends Object3D {
  constructor() {
    super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, b) {
    return super.copy(e, b), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const b = super.toJSON(e);
    return this.fog !== null && (b.object.fog = this.fog.toJSON()), b;
  }
};
Scene$1.prototype.isScene = !0;
class InterleavedBuffer {
  constructor(e, b) {
    this.array = e, this.stride = b, this.count = e !== void 0 ? e.length / b : 0, this.usage = StaticDrawUsage, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = generateUUID$1();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, b, L) {
    e *= this.stride, L *= b.stride;
    for (let M = 0, D = this.stride; M < D; M++)
      this.array[e + M] = b.array[L + M];
    return this;
  }
  set(e, b = 0) {
    return this.array.set(e, b), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID$1()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const b = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), L = new this.constructor(b, this.stride);
    return L.setUsage(this.usage), L;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID$1()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
InterleavedBuffer.prototype.isInterleavedBuffer = !0;
const _vector$6 = /* @__PURE__ */ new Vector3();
class InterleavedBufferAttribute {
  constructor(e, b, L, M = !1) {
    this.name = "", this.data = e, this.itemSize = b, this.offset = L, this.normalized = M === !0;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let b = 0, L = this.data.count; b < L; b++)
      _vector$6.x = this.getX(b), _vector$6.y = this.getY(b), _vector$6.z = this.getZ(b), _vector$6.applyMatrix4(e), this.setXYZ(b, _vector$6.x, _vector$6.y, _vector$6.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let b = 0, L = this.count; b < L; b++)
      _vector$6.x = this.getX(b), _vector$6.y = this.getY(b), _vector$6.z = this.getZ(b), _vector$6.applyNormalMatrix(e), this.setXYZ(b, _vector$6.x, _vector$6.y, _vector$6.z);
    return this;
  }
  transformDirection(e) {
    for (let b = 0, L = this.count; b < L; b++)
      _vector$6.x = this.getX(b), _vector$6.y = this.getY(b), _vector$6.z = this.getZ(b), _vector$6.transformDirection(e), this.setXYZ(b, _vector$6.x, _vector$6.y, _vector$6.z);
    return this;
  }
  setX(e, b) {
    return this.data.array[e * this.data.stride + this.offset] = b, this;
  }
  setY(e, b) {
    return this.data.array[e * this.data.stride + this.offset + 1] = b, this;
  }
  setZ(e, b) {
    return this.data.array[e * this.data.stride + this.offset + 2] = b, this;
  }
  setW(e, b) {
    return this.data.array[e * this.data.stride + this.offset + 3] = b, this;
  }
  getX(e) {
    return this.data.array[e * this.data.stride + this.offset];
  }
  getY(e) {
    return this.data.array[e * this.data.stride + this.offset + 1];
  }
  getZ(e) {
    return this.data.array[e * this.data.stride + this.offset + 2];
  }
  getW(e) {
    return this.data.array[e * this.data.stride + this.offset + 3];
  }
  setXY(e, b, L) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = b, this.data.array[e + 1] = L, this;
  }
  setXYZ(e, b, L, M) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = b, this.data.array[e + 1] = L, this.data.array[e + 2] = M, this;
  }
  setXYZW(e, b, L, M, D) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = b, this.data.array[e + 1] = L, this.data.array[e + 2] = M, this.data.array[e + 3] = D, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const b = [];
      for (let L = 0; L < this.count; L++) {
        const M = L * this.data.stride + this.offset;
        for (let D = 0; D < this.itemSize; D++)
          b.push(this.data.array[M + D]);
      }
      return new BufferAttribute(new this.array.constructor(b), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new InterleavedBufferAttribute(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const b = [];
      for (let L = 0; L < this.count; L++) {
        const M = L * this.data.stride + this.offset;
        for (let D = 0; D < this.itemSize; D++)
          b.push(this.data.array[M + D]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: b,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = !0;
class SpriteMaterial extends Material {
  constructor(e) {
    super(), this.type = "SpriteMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this;
  }
}
SpriteMaterial.prototype.isSpriteMaterial = !0;
let _geometry;
const _intersectPoint = /* @__PURE__ */ new Vector3(), _worldScale = /* @__PURE__ */ new Vector3(), _mvPosition = /* @__PURE__ */ new Vector3(), _alignedPosition = /* @__PURE__ */ new Vector2(), _rotatedPosition = /* @__PURE__ */ new Vector2(), _viewWorldMatrix = /* @__PURE__ */ new Matrix4(), _vA = /* @__PURE__ */ new Vector3(), _vB = /* @__PURE__ */ new Vector3(), _vC = /* @__PURE__ */ new Vector3(), _uvA = /* @__PURE__ */ new Vector2(), _uvB = /* @__PURE__ */ new Vector2(), _uvC = /* @__PURE__ */ new Vector2();
class Sprite extends Object3D {
  constructor(e) {
    if (super(), this.type = "Sprite", _geometry === void 0) {
      _geometry = new BufferGeometry();
      const b = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), L = new InterleavedBuffer(b, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]), _geometry.setAttribute("position", new InterleavedBufferAttribute(L, 3, 0, !1)), _geometry.setAttribute("uv", new InterleavedBufferAttribute(L, 2, 3, !1));
    }
    this.geometry = _geometry, this.material = e !== void 0 ? e : new SpriteMaterial(), this.center = new Vector2(0.5, 0.5);
  }
  raycast(e, b) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), _worldScale.setFromMatrixScale(this.matrixWorld), _viewWorldMatrix.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), _mvPosition.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && _worldScale.multiplyScalar(-_mvPosition.z);
    const L = this.material.rotation;
    let M, D;
    L !== 0 && (D = Math.cos(L), M = Math.sin(L));
    const I = this.center;
    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, I, _worldScale, M, D), transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, I, _worldScale, M, D), transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, I, _worldScale, M, D), _uvA.set(0, 0), _uvB.set(1, 0), _uvC.set(1, 1);
    let F = e.ray.intersectTriangle(_vA, _vB, _vC, !1, _intersectPoint);
    if (F === null && (transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, I, _worldScale, M, D), _uvB.set(0, 1), F = e.ray.intersectTriangle(_vA, _vC, _vB, !1, _intersectPoint), F === null))
      return;
    const N = e.ray.origin.distanceTo(_intersectPoint);
    N < e.near || N > e.far || b.push({
      distance: N,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
      face: null,
      object: this
    });
  }
  copy(e) {
    return super.copy(e), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
Sprite.prototype.isSprite = !0;
function transformVertex(B, e, b, L, M, D) {
  _alignedPosition.subVectors(B, b).addScalar(0.5).multiply(L), M !== void 0 ? (_rotatedPosition.x = D * _alignedPosition.x - M * _alignedPosition.y, _rotatedPosition.y = M * _alignedPosition.x + D * _alignedPosition.y) : _rotatedPosition.copy(_alignedPosition), B.copy(e), B.x += _rotatedPosition.x, B.y += _rotatedPosition.y, B.applyMatrix4(_viewWorldMatrix);
}
const _v1$2 = /* @__PURE__ */ new Vector3(), _v2$1 = /* @__PURE__ */ new Vector3();
class LOD extends Object3D {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const b = e.levels;
    for (let L = 0, M = b.length; L < M; L++) {
      const D = b[L];
      this.addLevel(D.object.clone(), D.distance);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, b = 0) {
    b = Math.abs(b);
    const L = this.levels;
    let M;
    for (M = 0; M < L.length && !(b < L[M].distance); M++)
      ;
    return L.splice(M, 0, { distance: b, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const b = this.levels;
    if (b.length > 0) {
      let L, M;
      for (L = 1, M = b.length; L < M && !(e < b[L].distance); L++)
        ;
      return b[L - 1].object;
    }
    return null;
  }
  raycast(e, b) {
    if (this.levels.length > 0) {
      _v1$2.setFromMatrixPosition(this.matrixWorld);
      const M = e.ray.origin.distanceTo(_v1$2);
      this.getObjectForDistance(M).raycast(e, b);
    }
  }
  update(e) {
    const b = this.levels;
    if (b.length > 1) {
      _v1$2.setFromMatrixPosition(e.matrixWorld), _v2$1.setFromMatrixPosition(this.matrixWorld);
      const L = _v1$2.distanceTo(_v2$1) / e.zoom;
      b[0].object.visible = !0;
      let M, D;
      for (M = 1, D = b.length; M < D && L >= b[M].distance; M++)
        b[M - 1].object.visible = !1, b[M].object.visible = !0;
      for (this._currentLevel = M - 1; M < D; M++)
        b[M].object.visible = !1;
    }
  }
  toJSON(e) {
    const b = super.toJSON(e);
    this.autoUpdate === !1 && (b.object.autoUpdate = !1), b.object.levels = [];
    const L = this.levels;
    for (let M = 0, D = L.length; M < D; M++) {
      const I = L[M];
      b.object.levels.push({
        object: I.object.uuid,
        distance: I.distance
      });
    }
    return b;
  }
}
const _basePosition = /* @__PURE__ */ new Vector3(), _skinIndex = /* @__PURE__ */ new Vector4(), _skinWeight = /* @__PURE__ */ new Vector4(), _vector$5 = /* @__PURE__ */ new Vector3(), _matrix = /* @__PURE__ */ new Matrix4();
class SkinnedMesh extends Mesh {
  constructor(e, b) {
    super(e, b), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Matrix4(), this.bindMatrixInverse = new Matrix4();
  }
  copy(e) {
    return super.copy(e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this;
  }
  bind(e, b) {
    this.skeleton = e, b === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), b = this.matrixWorld), this.bindMatrix.copy(b), this.bindMatrixInverse.copy(b).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Vector4(), b = this.geometry.attributes.skinWeight;
    for (let L = 0, M = b.count; L < M; L++) {
      e.x = b.getX(L), e.y = b.getY(L), e.z = b.getZ(L), e.w = b.getW(L);
      const D = 1 / e.manhattanLength();
      D !== 1 / 0 ? e.multiplyScalar(D) : e.set(1, 0, 0, 0), b.setXYZW(L, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  boneTransform(e, b) {
    const L = this.skeleton, M = this.geometry;
    _skinIndex.fromBufferAttribute(M.attributes.skinIndex, e), _skinWeight.fromBufferAttribute(M.attributes.skinWeight, e), _basePosition.fromBufferAttribute(M.attributes.position, e).applyMatrix4(this.bindMatrix), b.set(0, 0, 0);
    for (let D = 0; D < 4; D++) {
      const I = _skinWeight.getComponent(D);
      if (I !== 0) {
        const F = _skinIndex.getComponent(D);
        _matrix.multiplyMatrices(L.bones[F].matrixWorld, L.boneInverses[F]), b.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), I);
      }
    }
    return b.applyMatrix4(this.bindMatrixInverse);
  }
}
SkinnedMesh.prototype.isSkinnedMesh = !0;
class Bone extends Object3D {
  constructor() {
    super(), this.type = "Bone";
  }
}
Bone.prototype.isBone = !0;
class DataTexture extends Texture {
  constructor(e = null, b = 1, L = 1, M, D, I, F, N, U = NearestFilter, G = NearestFilter, V, z) {
    super(null, I, F, N, U, G, M, D, V, z), this.image = { data: e, width: b, height: L }, this.magFilter = U, this.minFilter = G, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0;
  }
}
DataTexture.prototype.isDataTexture = !0;
const _offsetMatrix = /* @__PURE__ */ new Matrix4(), _identityMatrix = /* @__PURE__ */ new Matrix4();
class Skeleton {
  constructor(e = [], b = []) {
    this.uuid = generateUUID$1(), this.bones = e.slice(0), this.boneInverses = b, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }
  init() {
    const e = this.bones, b = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), b.length === 0)
      this.calculateInverses();
    else if (e.length !== b.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let L = 0, M = this.bones.length; L < M; L++)
        this.boneInverses.push(new Matrix4());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, b = this.bones.length; e < b; e++) {
      const L = new Matrix4();
      this.bones[e] && L.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(L);
    }
  }
  pose() {
    for (let e = 0, b = this.bones.length; e < b; e++) {
      const L = this.bones[e];
      L && L.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, b = this.bones.length; e < b; e++) {
      const L = this.bones[e];
      L && (L.parent && L.parent.isBone ? (L.matrix.copy(L.parent.matrixWorld).invert(), L.matrix.multiply(L.matrixWorld)) : L.matrix.copy(L.matrixWorld), L.matrix.decompose(L.position, L.quaternion, L.scale));
    }
  }
  update() {
    const e = this.bones, b = this.boneInverses, L = this.boneMatrices, M = this.boneTexture;
    for (let D = 0, I = e.length; D < I; D++) {
      const F = e[D] ? e[D].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(F, b[D]), _offsetMatrix.toArray(L, D * 16);
    }
    M !== null && (M.needsUpdate = !0);
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = ceilPowerOfTwo(e), e = Math.max(e, 4);
    const b = new Float32Array(e * e * 4);
    b.set(this.boneMatrices);
    const L = new DataTexture(b, e, e, RGBAFormat, FloatType);
    return this.boneMatrices = b, this.boneTexture = L, this.boneTextureSize = e, this;
  }
  getBoneByName(e) {
    for (let b = 0, L = this.bones.length; b < L; b++) {
      const M = this.bones[b];
      if (M.name === e)
        return M;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, b) {
    this.uuid = e.uuid;
    for (let L = 0, M = e.bones.length; L < M; L++) {
      const D = e.bones[L];
      let I = b[D];
      I === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", D), I = new Bone()), this.bones.push(I), this.boneInverses.push(new Matrix4().fromArray(e.boneInverses[L]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const b = this.bones, L = this.boneInverses;
    for (let M = 0, D = b.length; M < D; M++) {
      const I = b[M];
      e.bones.push(I.uuid);
      const F = L[M];
      e.boneInverses.push(F.toArray());
    }
    return e;
  }
}
const _instanceLocalMatrix = /* @__PURE__ */ new Matrix4(), _instanceWorldMatrix = /* @__PURE__ */ new Matrix4(), _instanceIntersects = [], _mesh = /* @__PURE__ */ new Mesh();
class InstancedMesh extends Mesh {
  constructor(e, b, L) {
    super(e, b), this.instanceMatrix = new BufferAttribute(new Float32Array(L * 16), 16), this.instanceColor = null, this.count = L, this.frustumCulled = !1;
  }
  copy(e) {
    return super.copy(e), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this;
  }
  getColorAt(e, b) {
    b.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, b) {
    b.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, b) {
    const L = this.matrixWorld, M = this.count;
    if (_mesh.geometry = this.geometry, _mesh.material = this.material, _mesh.material !== void 0)
      for (let D = 0; D < M; D++) {
        this.getMatrixAt(D, _instanceLocalMatrix), _instanceWorldMatrix.multiplyMatrices(L, _instanceLocalMatrix), _mesh.matrixWorld = _instanceWorldMatrix, _mesh.raycast(e, _instanceIntersects);
        for (let I = 0, F = _instanceIntersects.length; I < F; I++) {
          const N = _instanceIntersects[I];
          N.instanceId = D, N.object = this, b.push(N);
        }
        _instanceIntersects.length = 0;
      }
  }
  setColorAt(e, b) {
    this.instanceColor === null && (this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3)), b.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, b) {
    b.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
InstancedMesh.prototype.isInstancedMesh = !0;
class LineBasicMaterial extends Material {
  constructor(e) {
    super(), this.type = "LineBasicMaterial", this.color = new Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.morphTargets = e.morphTargets, this;
  }
}
LineBasicMaterial.prototype.isLineBasicMaterial = !0;
const _start$1 = /* @__PURE__ */ new Vector3(), _end$1 = /* @__PURE__ */ new Vector3(), _inverseMatrix$1 = /* @__PURE__ */ new Matrix4(), _ray$1 = /* @__PURE__ */ new Ray(), _sphere$1 = /* @__PURE__ */ new Sphere();
class Line extends Object3D {
  constructor(e = new BufferGeometry(), b = new LineBasicMaterial()) {
    super(), this.type = "Line", this.geometry = e, this.material = b, this.updateMorphTargets();
  }
  copy(e) {
    return super.copy(e), this.material = e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.isBufferGeometry)
      if (e.index === null) {
        const b = e.attributes.position, L = [0];
        for (let M = 1, D = b.count; M < D; M++)
          _start$1.fromBufferAttribute(b, M - 1), _end$1.fromBufferAttribute(b, M), L[M] = L[M - 1], L[M] += _start$1.distanceTo(_end$1);
        e.setAttribute("lineDistance", new Float32BufferAttribute(L, 1));
      } else
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    return this;
  }
  raycast(e, b) {
    const L = this.geometry, M = this.matrixWorld, D = e.params.Line.threshold, I = L.drawRange;
    if (L.boundingSphere === null && L.computeBoundingSphere(), _sphere$1.copy(L.boundingSphere), _sphere$1.applyMatrix4(M), _sphere$1.radius += D, e.ray.intersectsSphere(_sphere$1) === !1) return;
    _inverseMatrix$1.copy(M).invert(), _ray$1.copy(e.ray).applyMatrix4(_inverseMatrix$1);
    const F = D / ((this.scale.x + this.scale.y + this.scale.z) / 3), N = F * F, U = new Vector3(), G = new Vector3(), V = new Vector3(), z = new Vector3(), k = this.isLineSegments ? 2 : 1;
    if (L.isBufferGeometry) {
      const H = L.index, $ = L.attributes.position;
      if (H !== null) {
        const j = Math.max(0, I.start), q = Math.min(H.count, I.start + I.count);
        for (let Y = j, J = q - 1; Y < J; Y += k) {
          const K = H.getX(Y), X = H.getX(Y + 1);
          if (U.fromBufferAttribute($, K), G.fromBufferAttribute($, X), _ray$1.distanceSqToSegment(U, G, z, V) > N) continue;
          z.applyMatrix4(this.matrixWorld);
          const Q = e.ray.origin.distanceTo(z);
          Q < e.near || Q > e.far || b.push({
            distance: Q,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: V.clone().applyMatrix4(this.matrixWorld),
            index: Y,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const j = Math.max(0, I.start), q = Math.min($.count, I.start + I.count);
        for (let Y = j, J = q - 1; Y < J; Y += k) {
          if (U.fromBufferAttribute($, Y), G.fromBufferAttribute($, Y + 1), _ray$1.distanceSqToSegment(U, G, z, V) > N) continue;
          z.applyMatrix4(this.matrixWorld);
          const X = e.ray.origin.distanceTo(z);
          X < e.near || X > e.far || b.push({
            distance: X,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: V.clone().applyMatrix4(this.matrixWorld),
            index: Y,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else L.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  }
  updateMorphTargets() {
    const e = this.geometry;
    if (e.isBufferGeometry) {
      const b = e.morphAttributes, L = Object.keys(b);
      if (L.length > 0) {
        const M = b[L[0]];
        if (M !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let D = 0, I = M.length; D < I; D++) {
            const F = M[D].name || String(D);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[F] = D;
          }
        }
      }
    } else {
      const b = e.morphTargets;
      b !== void 0 && b.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
}
Line.prototype.isLine = !0;
const _start = /* @__PURE__ */ new Vector3(), _end = /* @__PURE__ */ new Vector3();
class LineSegments extends Line {
  constructor(e, b) {
    super(e, b), this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.isBufferGeometry)
      if (e.index === null) {
        const b = e.attributes.position, L = [];
        for (let M = 0, D = b.count; M < D; M += 2)
          _start.fromBufferAttribute(b, M), _end.fromBufferAttribute(b, M + 1), L[M] = M === 0 ? 0 : L[M - 1], L[M + 1] = L[M] + _start.distanceTo(_end);
        e.setAttribute("lineDistance", new Float32BufferAttribute(L, 1));
      } else
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    return this;
  }
}
LineSegments.prototype.isLineSegments = !0;
class LineLoop extends Line {
  constructor(e, b) {
    super(e, b), this.type = "LineLoop";
  }
}
LineLoop.prototype.isLineLoop = !0;
class PointsMaterial extends Material {
  constructor(e) {
    super(), this.type = "PointsMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this;
  }
}
PointsMaterial.prototype.isPointsMaterial = !0;
const _inverseMatrix = /* @__PURE__ */ new Matrix4(), _ray = /* @__PURE__ */ new Ray(), _sphere = /* @__PURE__ */ new Sphere(), _position$2 = /* @__PURE__ */ new Vector3();
class Points extends Object3D {
  constructor(e = new BufferGeometry(), b = new PointsMaterial()) {
    super(), this.type = "Points", this.geometry = e, this.material = b, this.updateMorphTargets();
  }
  copy(e) {
    return super.copy(e), this.material = e.material, this.geometry = e.geometry, this;
  }
  raycast(e, b) {
    const L = this.geometry, M = this.matrixWorld, D = e.params.Points.threshold, I = L.drawRange;
    if (L.boundingSphere === null && L.computeBoundingSphere(), _sphere.copy(L.boundingSphere), _sphere.applyMatrix4(M), _sphere.radius += D, e.ray.intersectsSphere(_sphere) === !1) return;
    _inverseMatrix.copy(M).invert(), _ray.copy(e.ray).applyMatrix4(_inverseMatrix);
    const F = D / ((this.scale.x + this.scale.y + this.scale.z) / 3), N = F * F;
    if (L.isBufferGeometry) {
      const U = L.index, V = L.attributes.position;
      if (U !== null) {
        const z = Math.max(0, I.start), k = Math.min(U.count, I.start + I.count);
        for (let H = z, W = k; H < W; H++) {
          const $ = U.getX(H);
          _position$2.fromBufferAttribute(V, $), testPoint(_position$2, $, N, M, e, b, this);
        }
      } else {
        const z = Math.max(0, I.start), k = Math.min(V.count, I.start + I.count);
        for (let H = z, W = k; H < W; H++)
          _position$2.fromBufferAttribute(V, H), testPoint(_position$2, H, N, M, e, b, this);
      }
    } else
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  }
  updateMorphTargets() {
    const e = this.geometry;
    if (e.isBufferGeometry) {
      const b = e.morphAttributes, L = Object.keys(b);
      if (L.length > 0) {
        const M = b[L[0]];
        if (M !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let D = 0, I = M.length; D < I; D++) {
            const F = M[D].name || String(D);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[F] = D;
          }
        }
      }
    } else {
      const b = e.morphTargets;
      b !== void 0 && b.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
}
Points.prototype.isPoints = !0;
function testPoint(B, e, b, L, M, D, I) {
  const F = _ray.distanceSqToPoint(B);
  if (F < b) {
    const N = new Vector3();
    _ray.closestPointToPoint(B, N), N.applyMatrix4(L);
    const U = M.ray.origin.distanceTo(N);
    if (U < M.near || U > M.far) return;
    D.push({
      distance: U,
      distanceToRay: Math.sqrt(F),
      point: N,
      index: e,
      face: null,
      object: I
    });
  }
}
class VideoTexture extends Texture {
  constructor(e, b, L, M, D, I, F, N, U) {
    super(e, b, L, M, D, I, F, N, U), this.format = F !== void 0 ? F : RGBFormat, this.minFilter = I !== void 0 ? I : LinearFilter, this.magFilter = D !== void 0 ? D : LinearFilter, this.generateMipmaps = !1;
    const G = this;
    function V() {
      G.needsUpdate = !0, e.requestVideoFrameCallback(V);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(V);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
VideoTexture.prototype.isVideoTexture = !0;
class CompressedTexture extends Texture {
  constructor(e, b, L, M, D, I, F, N, U, G, V, z) {
    super(null, I, F, N, U, G, M, D, V, z), this.image = { width: b, height: L }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
CompressedTexture.prototype.isCompressedTexture = !0;
class CanvasTexture extends Texture {
  constructor(e, b, L, M, D, I, F, N, U) {
    super(e, b, L, M, D, I, F, N, U), this.needsUpdate = !0;
  }
}
CanvasTexture.prototype.isCanvasTexture = !0;
class DepthTexture extends Texture {
  constructor(e, b, L, M, D, I, F, N, U, G) {
    if (G = G !== void 0 ? G : DepthFormat, G !== DepthFormat && G !== DepthStencilFormat)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    L === void 0 && G === DepthFormat && (L = UnsignedShortType), L === void 0 && G === DepthStencilFormat && (L = UnsignedInt248Type), super(null, M, D, I, F, N, G, L, U), this.image = { width: e, height: b }, this.magFilter = F !== void 0 ? F : NearestFilter, this.minFilter = N !== void 0 ? N : NearestFilter, this.flipY = !1, this.generateMipmaps = !1;
  }
}
DepthTexture.prototype.isDepthTexture = !0;
class CircleGeometry extends BufferGeometry {
  constructor(e = 1, b = 8, L = 0, M = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: b,
      thetaStart: L,
      thetaLength: M
    }, b = Math.max(3, b);
    const D = [], I = [], F = [], N = [], U = new Vector3(), G = new Vector2();
    I.push(0, 0, 0), F.push(0, 0, 1), N.push(0.5, 0.5);
    for (let V = 0, z = 3; V <= b; V++, z += 3) {
      const k = L + V / b * M;
      U.x = e * Math.cos(k), U.y = e * Math.sin(k), I.push(U.x, U.y, U.z), F.push(0, 0, 1), G.x = (I[z] / e + 1) / 2, G.y = (I[z + 1] / e + 1) / 2, N.push(G.x, G.y);
    }
    for (let V = 1; V <= b; V++)
      D.push(V, V + 1, 0);
    this.setIndex(D), this.setAttribute("position", new Float32BufferAttribute(I, 3)), this.setAttribute("normal", new Float32BufferAttribute(F, 3)), this.setAttribute("uv", new Float32BufferAttribute(N, 2));
  }
  static fromJSON(e) {
    return new CircleGeometry(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class CylinderGeometry extends BufferGeometry {
  constructor(e = 1, b = 1, L = 1, M = 8, D = 1, I = !1, F = 0, N = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: b,
      height: L,
      radialSegments: M,
      heightSegments: D,
      openEnded: I,
      thetaStart: F,
      thetaLength: N
    };
    const U = this;
    M = Math.floor(M), D = Math.floor(D);
    const G = [], V = [], z = [], k = [];
    let H = 0;
    const W = [], $ = L / 2;
    let j = 0;
    q(), I === !1 && (e > 0 && Y(!0), b > 0 && Y(!1)), this.setIndex(G), this.setAttribute("position", new Float32BufferAttribute(V, 3)), this.setAttribute("normal", new Float32BufferAttribute(z, 3)), this.setAttribute("uv", new Float32BufferAttribute(k, 2));
    function q() {
      const J = new Vector3(), K = new Vector3();
      let X = 0;
      const Z = (b - e) / L;
      for (let Q = 0; Q <= D; Q++) {
        const ne = [], le = Q / D, pe = le * (b - e) + e;
        for (let ue = 0; ue <= M; ue++) {
          const oe = ue / M, ae = oe * N + F, se = Math.sin(ae), ie = Math.cos(ae);
          K.x = pe * se, K.y = -le * L + $, K.z = pe * ie, V.push(K.x, K.y, K.z), J.set(se, Z, ie).normalize(), z.push(J.x, J.y, J.z), k.push(oe, 1 - le), ne.push(H++);
        }
        W.push(ne);
      }
      for (let Q = 0; Q < M; Q++)
        for (let ne = 0; ne < D; ne++) {
          const le = W[ne][Q], pe = W[ne + 1][Q], ue = W[ne + 1][Q + 1], oe = W[ne][Q + 1];
          G.push(le, pe, oe), G.push(pe, ue, oe), X += 6;
        }
      U.addGroup(j, X, 0), j += X;
    }
    function Y(J) {
      const K = H, X = new Vector2(), Z = new Vector3();
      let Q = 0;
      const ne = J === !0 ? e : b, le = J === !0 ? 1 : -1;
      for (let ue = 1; ue <= M; ue++)
        V.push(0, $ * le, 0), z.push(0, le, 0), k.push(0.5, 0.5), H++;
      const pe = H;
      for (let ue = 0; ue <= M; ue++) {
        const ae = ue / M * N + F, se = Math.cos(ae), ie = Math.sin(ae);
        Z.x = ne * ie, Z.y = $ * le, Z.z = ne * se, V.push(Z.x, Z.y, Z.z), z.push(0, le, 0), X.x = se * 0.5 + 0.5, X.y = ie * 0.5 * le + 0.5, k.push(X.x, X.y), H++;
      }
      for (let ue = 0; ue < M; ue++) {
        const oe = K + ue, ae = pe + ue;
        J === !0 ? G.push(ae, ae + 1, oe) : G.push(ae + 1, ae, oe), Q += 3;
      }
      U.addGroup(j, Q, J === !0 ? 1 : 2), j += Q;
    }
  }
  static fromJSON(e) {
    return new CylinderGeometry(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(e = 1, b = 1, L = 8, M = 1, D = !1, I = 0, F = Math.PI * 2) {
    super(0, e, b, L, M, D, I, F), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: b,
      radialSegments: L,
      heightSegments: M,
      openEnded: D,
      thetaStart: I,
      thetaLength: F
    };
  }
  static fromJSON(e) {
    return new ConeGeometry(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class PolyhedronGeometry extends BufferGeometry {
  constructor(e, b, L = 1, M = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: b,
      radius: L,
      detail: M
    };
    const D = [], I = [];
    F(M), U(L), G(), this.setAttribute("position", new Float32BufferAttribute(D, 3)), this.setAttribute("normal", new Float32BufferAttribute(D.slice(), 3)), this.setAttribute("uv", new Float32BufferAttribute(I, 2)), M === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function F(q) {
      const Y = new Vector3(), J = new Vector3(), K = new Vector3();
      for (let X = 0; X < b.length; X += 3)
        k(b[X + 0], Y), k(b[X + 1], J), k(b[X + 2], K), N(Y, J, K, q);
    }
    function N(q, Y, J, K) {
      const X = K + 1, Z = [];
      for (let Q = 0; Q <= X; Q++) {
        Z[Q] = [];
        const ne = q.clone().lerp(J, Q / X), le = Y.clone().lerp(J, Q / X), pe = X - Q;
        for (let ue = 0; ue <= pe; ue++)
          ue === 0 && Q === X ? Z[Q][ue] = ne : Z[Q][ue] = ne.clone().lerp(le, ue / pe);
      }
      for (let Q = 0; Q < X; Q++)
        for (let ne = 0; ne < 2 * (X - Q) - 1; ne++) {
          const le = Math.floor(ne / 2);
          ne % 2 === 0 ? (z(Z[Q][le + 1]), z(Z[Q + 1][le]), z(Z[Q][le])) : (z(Z[Q][le + 1]), z(Z[Q + 1][le + 1]), z(Z[Q + 1][le]));
        }
    }
    function U(q) {
      const Y = new Vector3();
      for (let J = 0; J < D.length; J += 3)
        Y.x = D[J + 0], Y.y = D[J + 1], Y.z = D[J + 2], Y.normalize().multiplyScalar(q), D[J + 0] = Y.x, D[J + 1] = Y.y, D[J + 2] = Y.z;
    }
    function G() {
      const q = new Vector3();
      for (let Y = 0; Y < D.length; Y += 3) {
        q.x = D[Y + 0], q.y = D[Y + 1], q.z = D[Y + 2];
        const J = $(q) / 2 / Math.PI + 0.5, K = j(q) / Math.PI + 0.5;
        I.push(J, 1 - K);
      }
      H(), V();
    }
    function V() {
      for (let q = 0; q < I.length; q += 6) {
        const Y = I[q + 0], J = I[q + 2], K = I[q + 4], X = Math.max(Y, J, K), Z = Math.min(Y, J, K);
        X > 0.9 && Z < 0.1 && (Y < 0.2 && (I[q + 0] += 1), J < 0.2 && (I[q + 2] += 1), K < 0.2 && (I[q + 4] += 1));
      }
    }
    function z(q) {
      D.push(q.x, q.y, q.z);
    }
    function k(q, Y) {
      const J = q * 3;
      Y.x = e[J + 0], Y.y = e[J + 1], Y.z = e[J + 2];
    }
    function H() {
      const q = new Vector3(), Y = new Vector3(), J = new Vector3(), K = new Vector3(), X = new Vector2(), Z = new Vector2(), Q = new Vector2();
      for (let ne = 0, le = 0; ne < D.length; ne += 9, le += 6) {
        q.set(D[ne + 0], D[ne + 1], D[ne + 2]), Y.set(D[ne + 3], D[ne + 4], D[ne + 5]), J.set(D[ne + 6], D[ne + 7], D[ne + 8]), X.set(I[le + 0], I[le + 1]), Z.set(I[le + 2], I[le + 3]), Q.set(I[le + 4], I[le + 5]), K.copy(q).add(Y).add(J).divideScalar(3);
        const pe = $(K);
        W(X, le + 0, q, pe), W(Z, le + 2, Y, pe), W(Q, le + 4, J, pe);
      }
    }
    function W(q, Y, J, K) {
      K < 0 && q.x === 1 && (I[Y] = q.x - 1), J.x === 0 && J.z === 0 && (I[Y] = K / 2 / Math.PI + 0.5);
    }
    function $(q) {
      return Math.atan2(q.z, -q.x);
    }
    function j(q) {
      return Math.atan2(-q.y, Math.sqrt(q.x * q.x + q.z * q.z));
    }
  }
  static fromJSON(e) {
    return new PolyhedronGeometry(e.vertices, e.indices, e.radius, e.details);
  }
}
class DodecahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, b = 0) {
    const L = (1 + Math.sqrt(5)) / 2, M = 1 / L, D = [
      // (±1, ±1, ±1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, ±1/φ, ±φ)
      0,
      -M,
      -L,
      0,
      -M,
      L,
      0,
      M,
      -L,
      0,
      M,
      L,
      // (±1/φ, ±φ, 0)
      -M,
      -L,
      0,
      -M,
      L,
      0,
      M,
      -L,
      0,
      M,
      L,
      0,
      // (±φ, 0, ±1/φ)
      -L,
      0,
      -M,
      L,
      0,
      -M,
      -L,
      0,
      M,
      L,
      0,
      M
    ], I = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(D, I, e, b), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: b
    };
  }
  static fromJSON(e) {
    return new DodecahedronGeometry(e.radius, e.detail);
  }
}
const _v0 = new Vector3(), _v1$1 = new Vector3(), _normal = new Vector3(), _triangle = new Triangle();
class EdgesGeometry extends BufferGeometry {
  constructor(e, b) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      thresholdAngle: b
    }, b = b !== void 0 ? b : 1, e.isGeometry === !0) {
      console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return;
    }
    const M = Math.pow(10, 4), D = Math.cos(DEG2RAD * b), I = e.getIndex(), F = e.getAttribute("position"), N = I ? I.count : F.count, U = [0, 0, 0], G = ["a", "b", "c"], V = new Array(3), z = {}, k = [];
    for (let H = 0; H < N; H += 3) {
      I ? (U[0] = I.getX(H), U[1] = I.getX(H + 1), U[2] = I.getX(H + 2)) : (U[0] = H, U[1] = H + 1, U[2] = H + 2);
      const { a: W, b: $, c: j } = _triangle;
      if (W.fromBufferAttribute(F, U[0]), $.fromBufferAttribute(F, U[1]), j.fromBufferAttribute(F, U[2]), _triangle.getNormal(_normal), V[0] = `${Math.round(W.x * M)},${Math.round(W.y * M)},${Math.round(W.z * M)}`, V[1] = `${Math.round($.x * M)},${Math.round($.y * M)},${Math.round($.z * M)}`, V[2] = `${Math.round(j.x * M)},${Math.round(j.y * M)},${Math.round(j.z * M)}`, !(V[0] === V[1] || V[1] === V[2] || V[2] === V[0]))
        for (let q = 0; q < 3; q++) {
          const Y = (q + 1) % 3, J = V[q], K = V[Y], X = _triangle[G[q]], Z = _triangle[G[Y]], Q = `${J}_${K}`, ne = `${K}_${J}`;
          ne in z && z[ne] ? (_normal.dot(z[ne].normal) <= D && (k.push(X.x, X.y, X.z), k.push(Z.x, Z.y, Z.z)), z[ne] = null) : Q in z || (z[Q] = {
            index0: U[q],
            index1: U[Y],
            normal: _normal.clone()
          });
        }
    }
    for (const H in z)
      if (z[H]) {
        const { index0: W, index1: $ } = z[H];
        _v0.fromBufferAttribute(F, W), _v1$1.fromBufferAttribute(F, $), k.push(_v0.x, _v0.y, _v0.z), k.push(_v1$1.x, _v1$1.y, _v1$1.z);
      }
    this.setAttribute("position", new Float32BufferAttribute(k, 3));
  }
}
class Curve {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, b) {
    const L = this.getUtoTmapping(e);
    return this.getPoint(L, b);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const b = [];
    for (let L = 0; L <= e; L++)
      b.push(this.getPoint(L / e));
    return b;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const b = [];
    for (let L = 0; L <= e; L++)
      b.push(this.getPointAt(L / e));
    return b;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const b = [];
    let L, M = this.getPoint(0), D = 0;
    b.push(0);
    for (let I = 1; I <= e; I++)
      L = this.getPoint(I / e), D += L.distanceTo(M), b.push(D), M = L;
    return this.cacheArcLengths = b, b;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, b) {
    const L = this.getLengths();
    let M = 0;
    const D = L.length;
    let I;
    b ? I = b : I = e * L[D - 1];
    let F = 0, N = D - 1, U;
    for (; F <= N; )
      if (M = Math.floor(F + (N - F) / 2), U = L[M] - I, U < 0)
        F = M + 1;
      else if (U > 0)
        N = M - 1;
      else {
        N = M;
        break;
      }
    if (M = N, L[M] === I)
      return M / (D - 1);
    const G = L[M], z = L[M + 1] - G, k = (I - G) / z;
    return (M + k) / (D - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, b) {
    let M = e - 1e-4, D = e + 1e-4;
    M < 0 && (M = 0), D > 1 && (D = 1);
    const I = this.getPoint(M), F = this.getPoint(D), N = b || (I.isVector2 ? new Vector2() : new Vector3());
    return N.copy(F).sub(I).normalize(), N;
  }
  getTangentAt(e, b) {
    const L = this.getUtoTmapping(e);
    return this.getTangent(L, b);
  }
  computeFrenetFrames(e, b) {
    const L = new Vector3(), M = [], D = [], I = [], F = new Vector3(), N = new Matrix4();
    for (let k = 0; k <= e; k++) {
      const H = k / e;
      M[k] = this.getTangentAt(H, new Vector3()), M[k].normalize();
    }
    D[0] = new Vector3(), I[0] = new Vector3();
    let U = Number.MAX_VALUE;
    const G = Math.abs(M[0].x), V = Math.abs(M[0].y), z = Math.abs(M[0].z);
    G <= U && (U = G, L.set(1, 0, 0)), V <= U && (U = V, L.set(0, 1, 0)), z <= U && L.set(0, 0, 1), F.crossVectors(M[0], L).normalize(), D[0].crossVectors(M[0], F), I[0].crossVectors(M[0], D[0]);
    for (let k = 1; k <= e; k++) {
      if (D[k] = D[k - 1].clone(), I[k] = I[k - 1].clone(), F.crossVectors(M[k - 1], M[k]), F.length() > Number.EPSILON) {
        F.normalize();
        const H = Math.acos(clamp(M[k - 1].dot(M[k]), -1, 1));
        D[k].applyMatrix4(N.makeRotationAxis(F, H));
      }
      I[k].crossVectors(M[k], D[k]);
    }
    if (b === !0) {
      let k = Math.acos(clamp(D[0].dot(D[e]), -1, 1));
      k /= e, M[0].dot(F.crossVectors(D[0], D[e])) > 0 && (k = -k);
      for (let H = 1; H <= e; H++)
        D[H].applyMatrix4(N.makeRotationAxis(M[H], k * H)), I[H].crossVectors(M[H], D[H]);
    }
    return {
      tangents: M,
      normals: D,
      binormals: I
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class EllipseCurve extends Curve {
  constructor(e = 0, b = 0, L = 1, M = 1, D = 0, I = Math.PI * 2, F = !1, N = 0) {
    super(), this.type = "EllipseCurve", this.aX = e, this.aY = b, this.xRadius = L, this.yRadius = M, this.aStartAngle = D, this.aEndAngle = I, this.aClockwise = F, this.aRotation = N;
  }
  getPoint(e, b) {
    const L = b || new Vector2(), M = Math.PI * 2;
    let D = this.aEndAngle - this.aStartAngle;
    const I = Math.abs(D) < Number.EPSILON;
    for (; D < 0; ) D += M;
    for (; D > M; ) D -= M;
    D < Number.EPSILON && (I ? D = 0 : D = M), this.aClockwise === !0 && !I && (D === M ? D = -M : D = D - M);
    const F = this.aStartAngle + e * D;
    let N = this.aX + this.xRadius * Math.cos(F), U = this.aY + this.yRadius * Math.sin(F);
    if (this.aRotation !== 0) {
      const G = Math.cos(this.aRotation), V = Math.sin(this.aRotation), z = N - this.aX, k = U - this.aY;
      N = z * G - k * V + this.aX, U = z * V + k * G + this.aY;
    }
    return L.set(N, U);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
EllipseCurve.prototype.isEllipseCurve = !0;
class ArcCurve extends EllipseCurve {
  constructor(e, b, L, M, D, I) {
    super(e, b, L, L, M, D, I), this.type = "ArcCurve";
  }
}
ArcCurve.prototype.isArcCurve = !0;
function CubicPoly() {
  let B = 0, e = 0, b = 0, L = 0;
  function M(D, I, F, N) {
    B = D, e = F, b = -3 * D + 3 * I - 2 * F - N, L = 2 * D - 2 * I + F + N;
  }
  return {
    initCatmullRom: function(D, I, F, N, U) {
      M(I, F, U * (F - D), U * (N - I));
    },
    initNonuniformCatmullRom: function(D, I, F, N, U, G, V) {
      let z = (I - D) / U - (F - D) / (U + G) + (F - I) / G, k = (F - I) / G - (N - I) / (G + V) + (N - F) / V;
      z *= G, k *= G, M(I, F, z, k);
    },
    calc: function(D) {
      const I = D * D, F = I * D;
      return B + e * D + b * I + L * F;
    }
  };
}
const tmp = new Vector3(), px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
class CatmullRomCurve3 extends Curve {
  constructor(e = [], b = !1, L = "centripetal", M = 0.5) {
    super(), this.type = "CatmullRomCurve3", this.points = e, this.closed = b, this.curveType = L, this.tension = M;
  }
  getPoint(e, b = new Vector3()) {
    const L = b, M = this.points, D = M.length, I = (D - (this.closed ? 0 : 1)) * e;
    let F = Math.floor(I), N = I - F;
    this.closed ? F += F > 0 ? 0 : (Math.floor(Math.abs(F) / D) + 1) * D : N === 0 && F === D - 1 && (F = D - 2, N = 1);
    let U, G;
    this.closed || F > 0 ? U = M[(F - 1) % D] : (tmp.subVectors(M[0], M[1]).add(M[0]), U = tmp);
    const V = M[F % D], z = M[(F + 1) % D];
    if (this.closed || F + 2 < D ? G = M[(F + 2) % D] : (tmp.subVectors(M[D - 1], M[D - 2]).add(M[D - 1]), G = tmp), this.curveType === "centripetal" || this.curveType === "chordal") {
      const k = this.curveType === "chordal" ? 0.5 : 0.25;
      let H = Math.pow(U.distanceToSquared(V), k), W = Math.pow(V.distanceToSquared(z), k), $ = Math.pow(z.distanceToSquared(G), k);
      W < 1e-4 && (W = 1), H < 1e-4 && (H = W), $ < 1e-4 && ($ = W), px.initNonuniformCatmullRom(U.x, V.x, z.x, G.x, H, W, $), py.initNonuniformCatmullRom(U.y, V.y, z.y, G.y, H, W, $), pz.initNonuniformCatmullRom(U.z, V.z, z.z, G.z, H, W, $);
    } else this.curveType === "catmullrom" && (px.initCatmullRom(U.x, V.x, z.x, G.x, this.tension), py.initCatmullRom(U.y, V.y, z.y, G.y, this.tension), pz.initCatmullRom(U.z, V.z, z.z, G.z, this.tension));
    return L.set(
      px.calc(N),
      py.calc(N),
      pz.calc(N)
    ), L;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let b = 0, L = e.points.length; b < L; b++) {
      const M = e.points[b];
      this.points.push(M.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let b = 0, L = this.points.length; b < L; b++) {
      const M = this.points[b];
      e.points.push(M.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let b = 0, L = e.points.length; b < L; b++) {
      const M = e.points[b];
      this.points.push(new Vector3().fromArray(M));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
CatmullRomCurve3.prototype.isCatmullRomCurve3 = !0;
function CatmullRom(B, e, b, L, M) {
  const D = (L - e) * 0.5, I = (M - b) * 0.5, F = B * B, N = B * F;
  return (2 * b - 2 * L + D + I) * N + (-3 * b + 3 * L - 2 * D - I) * F + D * B + b;
}
function QuadraticBezierP0(B, e) {
  const b = 1 - B;
  return b * b * e;
}
function QuadraticBezierP1(B, e) {
  return 2 * (1 - B) * B * e;
}
function QuadraticBezierP2(B, e) {
  return B * B * e;
}
function QuadraticBezier(B, e, b, L) {
  return QuadraticBezierP0(B, e) + QuadraticBezierP1(B, b) + QuadraticBezierP2(B, L);
}
function CubicBezierP0(B, e) {
  const b = 1 - B;
  return b * b * b * e;
}
function CubicBezierP1(B, e) {
  const b = 1 - B;
  return 3 * b * b * B * e;
}
function CubicBezierP2(B, e) {
  return 3 * (1 - B) * B * B * e;
}
function CubicBezierP3(B, e) {
  return B * B * B * e;
}
function CubicBezier(B, e, b, L, M) {
  return CubicBezierP0(B, e) + CubicBezierP1(B, b) + CubicBezierP2(B, L) + CubicBezierP3(B, M);
}
class CubicBezierCurve extends Curve {
  constructor(e = new Vector2(), b = new Vector2(), L = new Vector2(), M = new Vector2()) {
    super(), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = b, this.v2 = L, this.v3 = M;
  }
  getPoint(e, b = new Vector2()) {
    const L = b, M = this.v0, D = this.v1, I = this.v2, F = this.v3;
    return L.set(
      CubicBezier(e, M.x, D.x, I.x, F.x),
      CubicBezier(e, M.y, D.y, I.y, F.y)
    ), L;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
CubicBezierCurve.prototype.isCubicBezierCurve = !0;
class CubicBezierCurve3 extends Curve {
  constructor(e = new Vector3(), b = new Vector3(), L = new Vector3(), M = new Vector3()) {
    super(), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = b, this.v2 = L, this.v3 = M;
  }
  getPoint(e, b = new Vector3()) {
    const L = b, M = this.v0, D = this.v1, I = this.v2, F = this.v3;
    return L.set(
      CubicBezier(e, M.x, D.x, I.x, F.x),
      CubicBezier(e, M.y, D.y, I.y, F.y),
      CubicBezier(e, M.z, D.z, I.z, F.z)
    ), L;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
CubicBezierCurve3.prototype.isCubicBezierCurve3 = !0;
class LineCurve extends Curve {
  constructor(e = new Vector2(), b = new Vector2()) {
    super(), this.type = "LineCurve", this.v1 = e, this.v2 = b;
  }
  getPoint(e, b = new Vector2()) {
    const L = b;
    return e === 1 ? L.copy(this.v2) : (L.copy(this.v2).sub(this.v1), L.multiplyScalar(e).add(this.v1)), L;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, b) {
    return this.getPoint(e, b);
  }
  getTangent(e, b) {
    const L = b || new Vector2();
    return L.copy(this.v2).sub(this.v1).normalize(), L;
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
LineCurve.prototype.isLineCurve = !0;
class LineCurve3 extends Curve {
  constructor(e = new Vector3(), b = new Vector3()) {
    super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = e, this.v2 = b;
  }
  getPoint(e, b = new Vector3()) {
    const L = b;
    return e === 1 ? L.copy(this.v2) : (L.copy(this.v2).sub(this.v1), L.multiplyScalar(e).add(this.v1)), L;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, b) {
    return this.getPoint(e, b);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class QuadraticBezierCurve extends Curve {
  constructor(e = new Vector2(), b = new Vector2(), L = new Vector2()) {
    super(), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = b, this.v2 = L;
  }
  getPoint(e, b = new Vector2()) {
    const L = b, M = this.v0, D = this.v1, I = this.v2;
    return L.set(
      QuadraticBezier(e, M.x, D.x, I.x),
      QuadraticBezier(e, M.y, D.y, I.y)
    ), L;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = !0;
class QuadraticBezierCurve3 extends Curve {
  constructor(e = new Vector3(), b = new Vector3(), L = new Vector3()) {
    super(), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = b, this.v2 = L;
  }
  getPoint(e, b = new Vector3()) {
    const L = b, M = this.v0, D = this.v1, I = this.v2;
    return L.set(
      QuadraticBezier(e, M.x, D.x, I.x),
      QuadraticBezier(e, M.y, D.y, I.y),
      QuadraticBezier(e, M.z, D.z, I.z)
    ), L;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = !0;
class SplineCurve extends Curve {
  constructor(e = []) {
    super(), this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, b = new Vector2()) {
    const L = b, M = this.points, D = (M.length - 1) * e, I = Math.floor(D), F = D - I, N = M[I === 0 ? I : I - 1], U = M[I], G = M[I > M.length - 2 ? M.length - 1 : I + 1], V = M[I > M.length - 3 ? M.length - 1 : I + 2];
    return L.set(
      CatmullRom(F, N.x, U.x, G.x, V.x),
      CatmullRom(F, N.y, U.y, G.y, V.y)
    ), L;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let b = 0, L = e.points.length; b < L; b++) {
      const M = e.points[b];
      this.points.push(M.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let b = 0, L = this.points.length; b < L; b++) {
      const M = this.points[b];
      e.points.push(M.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let b = 0, L = e.points.length; b < L; b++) {
      const M = e.points[b];
      this.points.push(new Vector2().fromArray(M));
    }
    return this;
  }
}
SplineCurve.prototype.isSplineCurve = !0;
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
const Earcut = {
  triangulate: function(B, e, b = 2) {
    const L = e && e.length, M = L ? e[0] * b : B.length;
    let D = linkedList(B, 0, M, b, !0);
    const I = [];
    if (!D || D.next === D.prev) return I;
    let F, N, U, G, V, z, k;
    if (L && (D = eliminateHoles(B, e, D, b)), B.length > 80 * b) {
      F = U = B[0], N = G = B[1];
      for (let H = b; H < M; H += b)
        V = B[H], z = B[H + 1], V < F && (F = V), z < N && (N = z), V > U && (U = V), z > G && (G = z);
      k = Math.max(U - F, G - N), k = k !== 0 ? 1 / k : 0;
    }
    return earcutLinked(D, I, b, F, N, k), I;
  }
};
function linkedList(B, e, b, L, M) {
  let D, I;
  if (M === signedArea(B, e, b, L) > 0)
    for (D = e; D < b; D += L) I = insertNode(D, B[D], B[D + 1], I);
  else
    for (D = b - L; D >= e; D -= L) I = insertNode(D, B[D], B[D + 1], I);
  return I && equals(I, I.next) && (removeNode(I), I = I.next), I;
}
function filterPoints(B, e) {
  if (!B) return B;
  e || (e = B);
  let b = B, L;
  do
    if (L = !1, !b.steiner && (equals(b, b.next) || area(b.prev, b, b.next) === 0)) {
      if (removeNode(b), b = e = b.prev, b === b.next) break;
      L = !0;
    } else
      b = b.next;
  while (L || b !== e);
  return e;
}
function earcutLinked(B, e, b, L, M, D, I) {
  if (!B) return;
  !I && D && indexCurve(B, L, M, D);
  let F = B, N, U;
  for (; B.prev !== B.next; ) {
    if (N = B.prev, U = B.next, D ? isEarHashed(B, L, M, D) : isEar(B)) {
      e.push(N.i / b), e.push(B.i / b), e.push(U.i / b), removeNode(B), B = U.next, F = U.next;
      continue;
    }
    if (B = U, B === F) {
      I ? I === 1 ? (B = cureLocalIntersections(filterPoints(B), e, b), earcutLinked(B, e, b, L, M, D, 2)) : I === 2 && splitEarcut(B, e, b, L, M, D) : earcutLinked(filterPoints(B), e, b, L, M, D, 1);
      break;
    }
  }
}
function isEar(B) {
  const e = B.prev, b = B, L = B.next;
  if (area(e, b, L) >= 0) return !1;
  let M = B.next.next;
  for (; M !== B.prev; ) {
    if (pointInTriangle(e.x, e.y, b.x, b.y, L.x, L.y, M.x, M.y) && area(M.prev, M, M.next) >= 0) return !1;
    M = M.next;
  }
  return !0;
}
function isEarHashed(B, e, b, L) {
  const M = B.prev, D = B, I = B.next;
  if (area(M, D, I) >= 0) return !1;
  const F = M.x < D.x ? M.x < I.x ? M.x : I.x : D.x < I.x ? D.x : I.x, N = M.y < D.y ? M.y < I.y ? M.y : I.y : D.y < I.y ? D.y : I.y, U = M.x > D.x ? M.x > I.x ? M.x : I.x : D.x > I.x ? D.x : I.x, G = M.y > D.y ? M.y > I.y ? M.y : I.y : D.y > I.y ? D.y : I.y, V = zOrder(F, N, e, b, L), z = zOrder(U, G, e, b, L);
  let k = B.prevZ, H = B.nextZ;
  for (; k && k.z >= V && H && H.z <= z; ) {
    if (k !== B.prev && k !== B.next && pointInTriangle(M.x, M.y, D.x, D.y, I.x, I.y, k.x, k.y) && area(k.prev, k, k.next) >= 0 || (k = k.prevZ, H !== B.prev && H !== B.next && pointInTriangle(M.x, M.y, D.x, D.y, I.x, I.y, H.x, H.y) && area(H.prev, H, H.next) >= 0)) return !1;
    H = H.nextZ;
  }
  for (; k && k.z >= V; ) {
    if (k !== B.prev && k !== B.next && pointInTriangle(M.x, M.y, D.x, D.y, I.x, I.y, k.x, k.y) && area(k.prev, k, k.next) >= 0) return !1;
    k = k.prevZ;
  }
  for (; H && H.z <= z; ) {
    if (H !== B.prev && H !== B.next && pointInTriangle(M.x, M.y, D.x, D.y, I.x, I.y, H.x, H.y) && area(H.prev, H, H.next) >= 0) return !1;
    H = H.nextZ;
  }
  return !0;
}
function cureLocalIntersections(B, e, b) {
  let L = B;
  do {
    const M = L.prev, D = L.next.next;
    !equals(M, D) && intersects(M, L, L.next, D) && locallyInside(M, D) && locallyInside(D, M) && (e.push(M.i / b), e.push(L.i / b), e.push(D.i / b), removeNode(L), removeNode(L.next), L = B = D), L = L.next;
  } while (L !== B);
  return filterPoints(L);
}
function splitEarcut(B, e, b, L, M, D) {
  let I = B;
  do {
    let F = I.next.next;
    for (; F !== I.prev; ) {
      if (I.i !== F.i && isValidDiagonal(I, F)) {
        let N = splitPolygon(I, F);
        I = filterPoints(I, I.next), N = filterPoints(N, N.next), earcutLinked(I, e, b, L, M, D), earcutLinked(N, e, b, L, M, D);
        return;
      }
      F = F.next;
    }
    I = I.next;
  } while (I !== B);
}
function eliminateHoles(B, e, b, L) {
  const M = [];
  let D, I, F, N, U;
  for (D = 0, I = e.length; D < I; D++)
    F = e[D] * L, N = D < I - 1 ? e[D + 1] * L : B.length, U = linkedList(B, F, N, L, !1), U === U.next && (U.steiner = !0), M.push(getLeftmost(U));
  for (M.sort(compareX), D = 0; D < M.length; D++)
    eliminateHole(M[D], b), b = filterPoints(b, b.next);
  return b;
}
function compareX(B, e) {
  return B.x - e.x;
}
function eliminateHole(B, e) {
  if (e = findHoleBridge(B, e), e) {
    const b = splitPolygon(e, B);
    filterPoints(e, e.next), filterPoints(b, b.next);
  }
}
function findHoleBridge(B, e) {
  let b = e;
  const L = B.x, M = B.y;
  let D = -1 / 0, I;
  do {
    if (M <= b.y && M >= b.next.y && b.next.y !== b.y) {
      const z = b.x + (M - b.y) * (b.next.x - b.x) / (b.next.y - b.y);
      if (z <= L && z > D) {
        if (D = z, z === L) {
          if (M === b.y) return b;
          if (M === b.next.y) return b.next;
        }
        I = b.x < b.next.x ? b : b.next;
      }
    }
    b = b.next;
  } while (b !== e);
  if (!I) return null;
  if (L === D) return I;
  const F = I, N = I.x, U = I.y;
  let G = 1 / 0, V;
  b = I;
  do
    L >= b.x && b.x >= N && L !== b.x && pointInTriangle(M < U ? L : D, M, N, U, M < U ? D : L, M, b.x, b.y) && (V = Math.abs(M - b.y) / (L - b.x), locallyInside(b, B) && (V < G || V === G && (b.x > I.x || b.x === I.x && sectorContainsSector(I, b))) && (I = b, G = V)), b = b.next;
  while (b !== F);
  return I;
}
function sectorContainsSector(B, e) {
  return area(B.prev, B, e.prev) < 0 && area(e.next, B, B.next) < 0;
}
function indexCurve(B, e, b, L) {
  let M = B;
  do
    M.z === null && (M.z = zOrder(M.x, M.y, e, b, L)), M.prevZ = M.prev, M.nextZ = M.next, M = M.next;
  while (M !== B);
  M.prevZ.nextZ = null, M.prevZ = null, sortLinked(M);
}
function sortLinked(B) {
  let e, b, L, M, D, I, F, N, U = 1;
  do {
    for (b = B, B = null, D = null, I = 0; b; ) {
      for (I++, L = b, F = 0, e = 0; e < U && (F++, L = L.nextZ, !!L); e++)
        ;
      for (N = U; F > 0 || N > 0 && L; )
        F !== 0 && (N === 0 || !L || b.z <= L.z) ? (M = b, b = b.nextZ, F--) : (M = L, L = L.nextZ, N--), D ? D.nextZ = M : B = M, M.prevZ = D, D = M;
      b = L;
    }
    D.nextZ = null, U *= 2;
  } while (I > 1);
  return B;
}
function zOrder(B, e, b, L, M) {
  return B = 32767 * (B - b) * M, e = 32767 * (e - L) * M, B = (B | B << 8) & 16711935, B = (B | B << 4) & 252645135, B = (B | B << 2) & 858993459, B = (B | B << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, B | e << 1;
}
function getLeftmost(B) {
  let e = B, b = B;
  do
    (e.x < b.x || e.x === b.x && e.y < b.y) && (b = e), e = e.next;
  while (e !== B);
  return b;
}
function pointInTriangle(B, e, b, L, M, D, I, F) {
  return (M - I) * (e - F) - (B - I) * (D - F) >= 0 && (B - I) * (L - F) - (b - I) * (e - F) >= 0 && (b - I) * (D - F) - (M - I) * (L - F) >= 0;
}
function isValidDiagonal(B, e) {
  return B.next.i !== e.i && B.prev.i !== e.i && !intersectsPolygon(B, e) && // dones't intersect other edges
  (locallyInside(B, e) && locallyInside(e, B) && middleInside(B, e) && // locally visible
  (area(B.prev, B, e.prev) || area(B, e.prev, e)) || // does not create opposite-facing sectors
  equals(B, e) && area(B.prev, B, B.next) > 0 && area(e.prev, e, e.next) > 0);
}
function area(B, e, b) {
  return (e.y - B.y) * (b.x - e.x) - (e.x - B.x) * (b.y - e.y);
}
function equals(B, e) {
  return B.x === e.x && B.y === e.y;
}
function intersects(B, e, b, L) {
  const M = sign(area(B, e, b)), D = sign(area(B, e, L)), I = sign(area(b, L, B)), F = sign(area(b, L, e));
  return !!(M !== D && I !== F || M === 0 && onSegment(B, b, e) || D === 0 && onSegment(B, L, e) || I === 0 && onSegment(b, B, L) || F === 0 && onSegment(b, e, L));
}
function onSegment(B, e, b) {
  return e.x <= Math.max(B.x, b.x) && e.x >= Math.min(B.x, b.x) && e.y <= Math.max(B.y, b.y) && e.y >= Math.min(B.y, b.y);
}
function sign(B) {
  return B > 0 ? 1 : B < 0 ? -1 : 0;
}
function intersectsPolygon(B, e) {
  let b = B;
  do {
    if (b.i !== B.i && b.next.i !== B.i && b.i !== e.i && b.next.i !== e.i && intersects(b, b.next, B, e)) return !0;
    b = b.next;
  } while (b !== B);
  return !1;
}
function locallyInside(B, e) {
  return area(B.prev, B, B.next) < 0 ? area(B, e, B.next) >= 0 && area(B, B.prev, e) >= 0 : area(B, e, B.prev) < 0 || area(B, B.next, e) < 0;
}
function middleInside(B, e) {
  let b = B, L = !1;
  const M = (B.x + e.x) / 2, D = (B.y + e.y) / 2;
  do
    b.y > D != b.next.y > D && b.next.y !== b.y && M < (b.next.x - b.x) * (D - b.y) / (b.next.y - b.y) + b.x && (L = !L), b = b.next;
  while (b !== B);
  return L;
}
function splitPolygon(B, e) {
  const b = new Node(B.i, B.x, B.y), L = new Node(e.i, e.x, e.y), M = B.next, D = e.prev;
  return B.next = e, e.prev = B, b.next = M, M.prev = b, L.next = b, b.prev = L, D.next = L, L.prev = D, L;
}
function insertNode(B, e, b, L) {
  const M = new Node(B, e, b);
  return L ? (M.next = L.next, M.prev = L, L.next.prev = M, L.next = M) : (M.prev = M, M.next = M), M;
}
function removeNode(B) {
  B.next.prev = B.prev, B.prev.next = B.next, B.prevZ && (B.prevZ.nextZ = B.nextZ), B.nextZ && (B.nextZ.prevZ = B.prevZ);
}
function Node(B, e, b) {
  this.i = B, this.x = e, this.y = b, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function signedArea(B, e, b, L) {
  let M = 0;
  for (let D = e, I = b - L; D < b; D += L)
    M += (B[I] - B[D]) * (B[D + 1] + B[I + 1]), I = D;
  return M;
}
class ShapeUtils {
  // calculate area of the contour polygon
  static area(e) {
    const b = e.length;
    let L = 0;
    for (let M = b - 1, D = 0; D < b; M = D++)
      L += e[M].x * e[D].y - e[D].x * e[M].y;
    return L * 0.5;
  }
  static isClockWise(e) {
    return ShapeUtils.area(e) < 0;
  }
  static triangulateShape(e, b) {
    const L = [], M = [], D = [];
    removeDupEndPts(e), addContour(L, e);
    let I = e.length;
    b.forEach(removeDupEndPts);
    for (let N = 0; N < b.length; N++)
      M.push(I), I += b[N].length, addContour(L, b[N]);
    const F = Earcut.triangulate(L, M);
    for (let N = 0; N < F.length; N += 3)
      D.push(F.slice(N, N + 3));
    return D;
  }
}
function removeDupEndPts(B) {
  const e = B.length;
  e > 2 && B[e - 1].equals(B[0]) && B.pop();
}
function addContour(B, e) {
  for (let b = 0; b < e.length; b++)
    B.push(e[b].x), B.push(e[b].y);
}
class ExtrudeGeometry extends BufferGeometry {
  constructor(e, b) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: b
    }, e = Array.isArray(e) ? e : [e];
    const L = this, M = [], D = [];
    for (let F = 0, N = e.length; F < N; F++) {
      const U = e[F];
      I(U);
    }
    this.setAttribute("position", new Float32BufferAttribute(M, 3)), this.setAttribute("uv", new Float32BufferAttribute(D, 2)), this.computeVertexNormals();
    function I(F) {
      const N = [], U = b.curveSegments !== void 0 ? b.curveSegments : 12, G = b.steps !== void 0 ? b.steps : 1;
      let V = b.depth !== void 0 ? b.depth : 100, z = b.bevelEnabled !== void 0 ? b.bevelEnabled : !0, k = b.bevelThickness !== void 0 ? b.bevelThickness : 6, H = b.bevelSize !== void 0 ? b.bevelSize : k - 2, W = b.bevelOffset !== void 0 ? b.bevelOffset : 0, $ = b.bevelSegments !== void 0 ? b.bevelSegments : 3;
      const j = b.extrudePath, q = b.UVGenerator !== void 0 ? b.UVGenerator : WorldUVGenerator;
      b.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), V = b.amount);
      let Y, J = !1, K, X, Z, Q;
      j && (Y = j.getSpacedPoints(G), J = !0, z = !1, K = j.computeFrenetFrames(G, !1), X = new Vector3(), Z = new Vector3(), Q = new Vector3()), z || ($ = 0, k = 0, H = 0, W = 0);
      const ne = F.extractPoints(U);
      let le = ne.shape;
      const pe = ne.holes;
      if (!ShapeUtils.isClockWise(le)) {
        le = le.reverse();
        for (let me = 0, Ie = pe.length; me < Ie; me++) {
          const Be = pe[me];
          ShapeUtils.isClockWise(Be) && (pe[me] = Be.reverse());
        }
      }
      const oe = ShapeUtils.triangulateShape(le, pe), ae = le;
      for (let me = 0, Ie = pe.length; me < Ie; me++) {
        const Be = pe[me];
        le = le.concat(Be);
      }
      function se(me, Ie, Be) {
        return Ie || console.error("THREE.ExtrudeGeometry: vec does not exist"), Ie.clone().multiplyScalar(Be).add(me);
      }
      const ie = le.length, ye = oe.length;
      function Ce(me, Ie, Be) {
        let Ne, Fe, te;
        const ee = me.x - Ie.x, Se = me.y - Ie.y, Ee = Be.x - me.x, be = Be.y - me.y, ze = ee * ee + Se * Se, Ge = ee * be - Se * Ee;
        if (Math.abs(Ge) > Number.EPSILON) {
          const He = Math.sqrt(ze), ke = Math.sqrt(Ee * Ee + be * be), $e = Ie.x - Se / He, he = Ie.y + ee / He, Le = Be.x - be / ke, Te = Be.y + Ee / ke, je = ((Le - $e) * be - (Te - he) * Ee) / (ee * be - Se * Ee);
          Ne = $e + ee * je - me.x, Fe = he + Se * je - me.y;
          const We = Ne * Ne + Fe * Fe;
          if (We <= 2)
            return new Vector2(Ne, Fe);
          te = Math.sqrt(We / 2);
        } else {
          let He = !1;
          ee > Number.EPSILON ? Ee > Number.EPSILON && (He = !0) : ee < -Number.EPSILON ? Ee < -Number.EPSILON && (He = !0) : Math.sign(Se) === Math.sign(be) && (He = !0), He ? (Ne = -Se, Fe = ee, te = Math.sqrt(ze)) : (Ne = ee, Fe = Se, te = Math.sqrt(ze / 2));
        }
        return new Vector2(Ne / te, Fe / te);
      }
      const de = [];
      for (let me = 0, Ie = ae.length, Be = Ie - 1, Ne = me + 1; me < Ie; me++, Be++, Ne++)
        Be === Ie && (Be = 0), Ne === Ie && (Ne = 0), de[me] = Ce(ae[me], ae[Be], ae[Ne]);
      const ve = [];
      let ce, ge = de.concat();
      for (let me = 0, Ie = pe.length; me < Ie; me++) {
        const Be = pe[me];
        ce = [];
        for (let Ne = 0, Fe = Be.length, te = Fe - 1, ee = Ne + 1; Ne < Fe; Ne++, te++, ee++)
          te === Fe && (te = 0), ee === Fe && (ee = 0), ce[Ne] = Ce(Be[Ne], Be[te], Be[ee]);
        ve.push(ce), ge = ge.concat(ce);
      }
      for (let me = 0; me < $; me++) {
        const Ie = me / $, Be = k * Math.cos(Ie * Math.PI / 2), Ne = H * Math.sin(Ie * Math.PI / 2) + W;
        for (let Fe = 0, te = ae.length; Fe < te; Fe++) {
          const ee = se(ae[Fe], de[Fe], Ne);
          Re(ee.x, ee.y, -Be);
        }
        for (let Fe = 0, te = pe.length; Fe < te; Fe++) {
          const ee = pe[Fe];
          ce = ve[Fe];
          for (let Se = 0, Ee = ee.length; Se < Ee; Se++) {
            const be = se(ee[Se], ce[Se], Ne);
            Re(be.x, be.y, -Be);
          }
        }
      }
      const _e = H + W;
      for (let me = 0; me < ie; me++) {
        const Ie = z ? se(le[me], ge[me], _e) : le[me];
        J ? (Z.copy(K.normals[0]).multiplyScalar(Ie.x), X.copy(K.binormals[0]).multiplyScalar(Ie.y), Q.copy(Y[0]).add(Z).add(X), Re(Q.x, Q.y, Q.z)) : Re(Ie.x, Ie.y, 0);
      }
      for (let me = 1; me <= G; me++)
        for (let Ie = 0; Ie < ie; Ie++) {
          const Be = z ? se(le[Ie], ge[Ie], _e) : le[Ie];
          J ? (Z.copy(K.normals[me]).multiplyScalar(Be.x), X.copy(K.binormals[me]).multiplyScalar(Be.y), Q.copy(Y[me]).add(Z).add(X), Re(Q.x, Q.y, Q.z)) : Re(Be.x, Be.y, V / G * me);
        }
      for (let me = $ - 1; me >= 0; me--) {
        const Ie = me / $, Be = k * Math.cos(Ie * Math.PI / 2), Ne = H * Math.sin(Ie * Math.PI / 2) + W;
        for (let Fe = 0, te = ae.length; Fe < te; Fe++) {
          const ee = se(ae[Fe], de[Fe], Ne);
          Re(ee.x, ee.y, V + Be);
        }
        for (let Fe = 0, te = pe.length; Fe < te; Fe++) {
          const ee = pe[Fe];
          ce = ve[Fe];
          for (let Se = 0, Ee = ee.length; Se < Ee; Se++) {
            const be = se(ee[Se], ce[Se], Ne);
            J ? Re(be.x, be.y + Y[G - 1].y, Y[G - 1].x + Be) : Re(be.x, be.y, V + Be);
          }
        }
      }
      Me(), xe();
      function Me() {
        const me = M.length / 3;
        if (z) {
          let Ie = 0, Be = ie * Ie;
          for (let Ne = 0; Ne < ye; Ne++) {
            const Fe = oe[Ne];
            Pe(Fe[2] + Be, Fe[1] + Be, Fe[0] + Be);
          }
          Ie = G + $ * 2, Be = ie * Ie;
          for (let Ne = 0; Ne < ye; Ne++) {
            const Fe = oe[Ne];
            Pe(Fe[0] + Be, Fe[1] + Be, Fe[2] + Be);
          }
        } else {
          for (let Ie = 0; Ie < ye; Ie++) {
            const Be = oe[Ie];
            Pe(Be[2], Be[1], Be[0]);
          }
          for (let Ie = 0; Ie < ye; Ie++) {
            const Be = oe[Ie];
            Pe(Be[0] + ie * G, Be[1] + ie * G, Be[2] + ie * G);
          }
        }
        L.addGroup(me, M.length / 3 - me, 0);
      }
      function xe() {
        const me = M.length / 3;
        let Ie = 0;
        fe(ae, Ie), Ie += ae.length;
        for (let Be = 0, Ne = pe.length; Be < Ne; Be++) {
          const Fe = pe[Be];
          fe(Fe, Ie), Ie += Fe.length;
        }
        L.addGroup(me, M.length / 3 - me, 1);
      }
      function fe(me, Ie) {
        let Be = me.length;
        for (; --Be >= 0; ) {
          const Ne = Be;
          let Fe = Be - 1;
          Fe < 0 && (Fe = me.length - 1);
          for (let te = 0, ee = G + $ * 2; te < ee; te++) {
            const Se = ie * te, Ee = ie * (te + 1), be = Ie + Ne + Se, ze = Ie + Fe + Se, Ge = Ie + Fe + Ee, He = Ie + Ne + Ee;
            Ue(be, ze, Ge, He);
          }
        }
      }
      function Re(me, Ie, Be) {
        N.push(me), N.push(Ie), N.push(Be);
      }
      function Pe(me, Ie, Be) {
        Ve(me), Ve(Ie), Ve(Be);
        const Ne = M.length / 3, Fe = q.generateTopUV(L, M, Ne - 3, Ne - 2, Ne - 1);
        Oe(Fe[0]), Oe(Fe[1]), Oe(Fe[2]);
      }
      function Ue(me, Ie, Be, Ne) {
        Ve(me), Ve(Ie), Ve(Ne), Ve(Ie), Ve(Be), Ve(Ne);
        const Fe = M.length / 3, te = q.generateSideWallUV(L, M, Fe - 6, Fe - 3, Fe - 2, Fe - 1);
        Oe(te[0]), Oe(te[1]), Oe(te[3]), Oe(te[1]), Oe(te[2]), Oe(te[3]);
      }
      function Ve(me) {
        M.push(N[me * 3 + 0]), M.push(N[me * 3 + 1]), M.push(N[me * 3 + 2]);
      }
      function Oe(me) {
        D.push(me.x), D.push(me.y);
      }
    }
  }
  toJSON() {
    const e = super.toJSON(), b = this.parameters.shapes, L = this.parameters.options;
    return toJSON$1(b, L, e);
  }
  static fromJSON(e, b) {
    const L = [];
    for (let D = 0, I = e.shapes.length; D < I; D++) {
      const F = b[e.shapes[D]];
      L.push(F);
    }
    const M = e.options.extrudePath;
    return M !== void 0 && (e.options.extrudePath = new Curves[M.type]().fromJSON(M)), new ExtrudeGeometry(L, e.options);
  }
}
const WorldUVGenerator = {
  generateTopUV: function(B, e, b, L, M) {
    const D = e[b * 3], I = e[b * 3 + 1], F = e[L * 3], N = e[L * 3 + 1], U = e[M * 3], G = e[M * 3 + 1];
    return [
      new Vector2(D, I),
      new Vector2(F, N),
      new Vector2(U, G)
    ];
  },
  generateSideWallUV: function(B, e, b, L, M, D) {
    const I = e[b * 3], F = e[b * 3 + 1], N = e[b * 3 + 2], U = e[L * 3], G = e[L * 3 + 1], V = e[L * 3 + 2], z = e[M * 3], k = e[M * 3 + 1], H = e[M * 3 + 2], W = e[D * 3], $ = e[D * 3 + 1], j = e[D * 3 + 2];
    return Math.abs(F - G) < Math.abs(I - U) ? [
      new Vector2(I, 1 - N),
      new Vector2(U, 1 - V),
      new Vector2(z, 1 - H),
      new Vector2(W, 1 - j)
    ] : [
      new Vector2(F, 1 - N),
      new Vector2(G, 1 - V),
      new Vector2(k, 1 - H),
      new Vector2($, 1 - j)
    ];
  }
};
function toJSON$1(B, e, b) {
  if (b.shapes = [], Array.isArray(B))
    for (let L = 0, M = B.length; L < M; L++) {
      const D = B[L];
      b.shapes.push(D.uuid);
    }
  else
    b.shapes.push(B.uuid);
  return e.extrudePath !== void 0 && (b.options.extrudePath = e.extrudePath.toJSON()), b;
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, b = 0) {
    const L = (1 + Math.sqrt(5)) / 2, M = [
      -1,
      L,
      0,
      1,
      L,
      0,
      -1,
      -L,
      0,
      1,
      -L,
      0,
      0,
      -1,
      L,
      0,
      1,
      L,
      0,
      -1,
      -L,
      0,
      1,
      -L,
      L,
      0,
      -1,
      L,
      0,
      1,
      -L,
      0,
      -1,
      -L,
      0,
      1
    ], D = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(M, D, e, b), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: b
    };
  }
  static fromJSON(e) {
    return new IcosahedronGeometry(e.radius, e.detail);
  }
}
class LatheGeometry extends BufferGeometry {
  constructor(e, b = 12, L = 0, M = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: b,
      phiStart: L,
      phiLength: M
    }, b = Math.floor(b), M = clamp(M, 0, Math.PI * 2);
    const D = [], I = [], F = [], N = 1 / b, U = new Vector3(), G = new Vector2();
    for (let V = 0; V <= b; V++) {
      const z = L + V * N * M, k = Math.sin(z), H = Math.cos(z);
      for (let W = 0; W <= e.length - 1; W++)
        U.x = e[W].x * k, U.y = e[W].y, U.z = e[W].x * H, I.push(U.x, U.y, U.z), G.x = V / b, G.y = W / (e.length - 1), F.push(G.x, G.y);
    }
    for (let V = 0; V < b; V++)
      for (let z = 0; z < e.length - 1; z++) {
        const k = z + V * e.length, H = k, W = k + e.length, $ = k + e.length + 1, j = k + 1;
        D.push(H, W, j), D.push(W, $, j);
      }
    if (this.setIndex(D), this.setAttribute("position", new Float32BufferAttribute(I, 3)), this.setAttribute("uv", new Float32BufferAttribute(F, 2)), this.computeVertexNormals(), M === Math.PI * 2) {
      const V = this.attributes.normal.array, z = new Vector3(), k = new Vector3(), H = new Vector3(), W = b * e.length * 3;
      for (let $ = 0, j = 0; $ < e.length; $++, j += 3)
        z.x = V[j + 0], z.y = V[j + 1], z.z = V[j + 2], k.x = V[W + j + 0], k.y = V[W + j + 1], k.z = V[W + j + 2], H.addVectors(z, k).normalize(), V[j + 0] = V[W + j + 0] = H.x, V[j + 1] = V[W + j + 1] = H.y, V[j + 2] = V[W + j + 2] = H.z;
    }
  }
  static fromJSON(e) {
    return new LatheGeometry(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, b = 0) {
    const L = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], M = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(L, M, e, b), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: b
    };
  }
  static fromJSON(e) {
    return new OctahedronGeometry(e.radius, e.detail);
  }
}
class ParametricGeometry extends BufferGeometry {
  constructor(e, b, L) {
    super(), this.type = "ParametricGeometry", this.parameters = {
      func: e,
      slices: b,
      stacks: L
    };
    const M = [], D = [], I = [], F = [], N = 1e-5, U = new Vector3(), G = new Vector3(), V = new Vector3(), z = new Vector3(), k = new Vector3();
    e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
    const H = b + 1;
    for (let W = 0; W <= L; W++) {
      const $ = W / L;
      for (let j = 0; j <= b; j++) {
        const q = j / b;
        e(q, $, G), D.push(G.x, G.y, G.z), q - N >= 0 ? (e(q - N, $, V), z.subVectors(G, V)) : (e(q + N, $, V), z.subVectors(V, G)), $ - N >= 0 ? (e(q, $ - N, V), k.subVectors(G, V)) : (e(q, $ + N, V), k.subVectors(V, G)), U.crossVectors(z, k).normalize(), I.push(U.x, U.y, U.z), F.push(q, $);
      }
    }
    for (let W = 0; W < L; W++)
      for (let $ = 0; $ < b; $++) {
        const j = W * H + $, q = W * H + $ + 1, Y = (W + 1) * H + $ + 1, J = (W + 1) * H + $;
        M.push(j, q, J), M.push(q, Y, J);
      }
    this.setIndex(M), this.setAttribute("position", new Float32BufferAttribute(D, 3)), this.setAttribute("normal", new Float32BufferAttribute(I, 3)), this.setAttribute("uv", new Float32BufferAttribute(F, 2));
  }
}
class RingGeometry extends BufferGeometry {
  constructor(e = 0.5, b = 1, L = 8, M = 1, D = 0, I = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: b,
      thetaSegments: L,
      phiSegments: M,
      thetaStart: D,
      thetaLength: I
    }, L = Math.max(3, L), M = Math.max(1, M);
    const F = [], N = [], U = [], G = [];
    let V = e;
    const z = (b - e) / M, k = new Vector3(), H = new Vector2();
    for (let W = 0; W <= M; W++) {
      for (let $ = 0; $ <= L; $++) {
        const j = D + $ / L * I;
        k.x = V * Math.cos(j), k.y = V * Math.sin(j), N.push(k.x, k.y, k.z), U.push(0, 0, 1), H.x = (k.x / b + 1) / 2, H.y = (k.y / b + 1) / 2, G.push(H.x, H.y);
      }
      V += z;
    }
    for (let W = 0; W < M; W++) {
      const $ = W * (L + 1);
      for (let j = 0; j < L; j++) {
        const q = j + $, Y = q, J = q + L + 1, K = q + L + 2, X = q + 1;
        F.push(Y, J, X), F.push(J, K, X);
      }
    }
    this.setIndex(F), this.setAttribute("position", new Float32BufferAttribute(N, 3)), this.setAttribute("normal", new Float32BufferAttribute(U, 3)), this.setAttribute("uv", new Float32BufferAttribute(G, 2));
  }
  static fromJSON(e) {
    return new RingGeometry(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class ShapeGeometry extends BufferGeometry {
  constructor(e, b = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: b
    };
    const L = [], M = [], D = [], I = [];
    let F = 0, N = 0;
    if (Array.isArray(e) === !1)
      U(e);
    else
      for (let G = 0; G < e.length; G++)
        U(e[G]), this.addGroup(F, N, G), F += N, N = 0;
    this.setIndex(L), this.setAttribute("position", new Float32BufferAttribute(M, 3)), this.setAttribute("normal", new Float32BufferAttribute(D, 3)), this.setAttribute("uv", new Float32BufferAttribute(I, 2));
    function U(G) {
      const V = M.length / 3, z = G.extractPoints(b);
      let k = z.shape;
      const H = z.holes;
      ShapeUtils.isClockWise(k) === !1 && (k = k.reverse());
      for (let $ = 0, j = H.length; $ < j; $++) {
        const q = H[$];
        ShapeUtils.isClockWise(q) === !0 && (H[$] = q.reverse());
      }
      const W = ShapeUtils.triangulateShape(k, H);
      for (let $ = 0, j = H.length; $ < j; $++) {
        const q = H[$];
        k = k.concat(q);
      }
      for (let $ = 0, j = k.length; $ < j; $++) {
        const q = k[$];
        M.push(q.x, q.y, 0), D.push(0, 0, 1), I.push(q.x, q.y);
      }
      for (let $ = 0, j = W.length; $ < j; $++) {
        const q = W[$], Y = q[0] + V, J = q[1] + V, K = q[2] + V;
        L.push(Y, J, K), N += 3;
      }
    }
  }
  toJSON() {
    const e = super.toJSON(), b = this.parameters.shapes;
    return toJSON(b, e);
  }
  static fromJSON(e, b) {
    const L = [];
    for (let M = 0, D = e.shapes.length; M < D; M++) {
      const I = b[e.shapes[M]];
      L.push(I);
    }
    return new ShapeGeometry(L, e.curveSegments);
  }
}
function toJSON(B, e) {
  if (e.shapes = [], Array.isArray(B))
    for (let b = 0, L = B.length; b < L; b++) {
      const M = B[b];
      e.shapes.push(M.uuid);
    }
  else
    e.shapes.push(B.uuid);
  return e;
}
class SphereGeometry extends BufferGeometry {
  constructor(e = 1, b = 8, L = 6, M = 0, D = Math.PI * 2, I = 0, F = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: b,
      heightSegments: L,
      phiStart: M,
      phiLength: D,
      thetaStart: I,
      thetaLength: F
    }, b = Math.max(3, Math.floor(b)), L = Math.max(2, Math.floor(L));
    const N = Math.min(I + F, Math.PI);
    let U = 0;
    const G = [], V = new Vector3(), z = new Vector3(), k = [], H = [], W = [], $ = [];
    for (let j = 0; j <= L; j++) {
      const q = [], Y = j / L;
      let J = 0;
      j == 0 && I == 0 ? J = 0.5 / b : j == L && N == Math.PI && (J = -0.5 / b);
      for (let K = 0; K <= b; K++) {
        const X = K / b;
        V.x = -e * Math.cos(M + X * D) * Math.sin(I + Y * F), V.y = e * Math.cos(I + Y * F), V.z = e * Math.sin(M + X * D) * Math.sin(I + Y * F), H.push(V.x, V.y, V.z), z.copy(V).normalize(), W.push(z.x, z.y, z.z), $.push(X + J, 1 - Y), q.push(U++);
      }
      G.push(q);
    }
    for (let j = 0; j < L; j++)
      for (let q = 0; q < b; q++) {
        const Y = G[j][q + 1], J = G[j][q], K = G[j + 1][q], X = G[j + 1][q + 1];
        (j !== 0 || I > 0) && k.push(Y, J, X), (j !== L - 1 || N < Math.PI) && k.push(J, K, X);
      }
    this.setIndex(k), this.setAttribute("position", new Float32BufferAttribute(H, 3)), this.setAttribute("normal", new Float32BufferAttribute(W, 3)), this.setAttribute("uv", new Float32BufferAttribute($, 2));
  }
  static fromJSON(e) {
    return new SphereGeometry(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class TetrahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, b = 0) {
    const L = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], M = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(L, M, e, b), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: b
    };
  }
  static fromJSON(e) {
    return new TetrahedronGeometry(e.radius, e.detail);
  }
}
class TextGeometry extends ExtrudeGeometry {
  constructor(e, b = {}) {
    const L = b.font;
    if (!(L && L.isFont))
      return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new BufferGeometry();
    const M = L.generateShapes(e, b.size);
    b.depth = b.height !== void 0 ? b.height : 50, b.bevelThickness === void 0 && (b.bevelThickness = 10), b.bevelSize === void 0 && (b.bevelSize = 8), b.bevelEnabled === void 0 && (b.bevelEnabled = !1), super(M, b), this.type = "TextGeometry";
  }
}
class TorusGeometry extends BufferGeometry {
  constructor(e = 1, b = 0.4, L = 8, M = 6, D = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: b,
      radialSegments: L,
      tubularSegments: M,
      arc: D
    }, L = Math.floor(L), M = Math.floor(M);
    const I = [], F = [], N = [], U = [], G = new Vector3(), V = new Vector3(), z = new Vector3();
    for (let k = 0; k <= L; k++)
      for (let H = 0; H <= M; H++) {
        const W = H / M * D, $ = k / L * Math.PI * 2;
        V.x = (e + b * Math.cos($)) * Math.cos(W), V.y = (e + b * Math.cos($)) * Math.sin(W), V.z = b * Math.sin($), F.push(V.x, V.y, V.z), G.x = e * Math.cos(W), G.y = e * Math.sin(W), z.subVectors(V, G).normalize(), N.push(z.x, z.y, z.z), U.push(H / M), U.push(k / L);
      }
    for (let k = 1; k <= L; k++)
      for (let H = 1; H <= M; H++) {
        const W = (M + 1) * k + H - 1, $ = (M + 1) * (k - 1) + H - 1, j = (M + 1) * (k - 1) + H, q = (M + 1) * k + H;
        I.push(W, $, q), I.push($, j, q);
      }
    this.setIndex(I), this.setAttribute("position", new Float32BufferAttribute(F, 3)), this.setAttribute("normal", new Float32BufferAttribute(N, 3)), this.setAttribute("uv", new Float32BufferAttribute(U, 2));
  }
  static fromJSON(e) {
    return new TorusGeometry(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class TorusKnotGeometry extends BufferGeometry {
  constructor(e = 1, b = 0.4, L = 64, M = 8, D = 2, I = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: b,
      tubularSegments: L,
      radialSegments: M,
      p: D,
      q: I
    }, L = Math.floor(L), M = Math.floor(M);
    const F = [], N = [], U = [], G = [], V = new Vector3(), z = new Vector3(), k = new Vector3(), H = new Vector3(), W = new Vector3(), $ = new Vector3(), j = new Vector3();
    for (let Y = 0; Y <= L; ++Y) {
      const J = Y / L * D * Math.PI * 2;
      q(J, D, I, e, k), q(J + 0.01, D, I, e, H), $.subVectors(H, k), j.addVectors(H, k), W.crossVectors($, j), j.crossVectors(W, $), W.normalize(), j.normalize();
      for (let K = 0; K <= M; ++K) {
        const X = K / M * Math.PI * 2, Z = -b * Math.cos(X), Q = b * Math.sin(X);
        V.x = k.x + (Z * j.x + Q * W.x), V.y = k.y + (Z * j.y + Q * W.y), V.z = k.z + (Z * j.z + Q * W.z), N.push(V.x, V.y, V.z), z.subVectors(V, k).normalize(), U.push(z.x, z.y, z.z), G.push(Y / L), G.push(K / M);
      }
    }
    for (let Y = 1; Y <= L; Y++)
      for (let J = 1; J <= M; J++) {
        const K = (M + 1) * (Y - 1) + (J - 1), X = (M + 1) * Y + (J - 1), Z = (M + 1) * Y + J, Q = (M + 1) * (Y - 1) + J;
        F.push(K, X, Q), F.push(X, Z, Q);
      }
    this.setIndex(F), this.setAttribute("position", new Float32BufferAttribute(N, 3)), this.setAttribute("normal", new Float32BufferAttribute(U, 3)), this.setAttribute("uv", new Float32BufferAttribute(G, 2));
    function q(Y, J, K, X, Z) {
      const Q = Math.cos(Y), ne = Math.sin(Y), le = K / J * Y, pe = Math.cos(le);
      Z.x = X * (2 + pe) * 0.5 * Q, Z.y = X * (2 + pe) * ne * 0.5, Z.z = X * Math.sin(le) * 0.5;
    }
  }
  static fromJSON(e) {
    return new TorusKnotGeometry(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class TubeGeometry extends BufferGeometry {
  constructor(e, b = 64, L = 1, M = 8, D = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: b,
      radius: L,
      radialSegments: M,
      closed: D
    };
    const I = e.computeFrenetFrames(b, D);
    this.tangents = I.tangents, this.normals = I.normals, this.binormals = I.binormals;
    const F = new Vector3(), N = new Vector3(), U = new Vector2();
    let G = new Vector3();
    const V = [], z = [], k = [], H = [];
    W(), this.setIndex(H), this.setAttribute("position", new Float32BufferAttribute(V, 3)), this.setAttribute("normal", new Float32BufferAttribute(z, 3)), this.setAttribute("uv", new Float32BufferAttribute(k, 2));
    function W() {
      for (let Y = 0; Y < b; Y++)
        $(Y);
      $(D === !1 ? b : 0), q(), j();
    }
    function $(Y) {
      G = e.getPointAt(Y / b, G);
      const J = I.normals[Y], K = I.binormals[Y];
      for (let X = 0; X <= M; X++) {
        const Z = X / M * Math.PI * 2, Q = Math.sin(Z), ne = -Math.cos(Z);
        N.x = ne * J.x + Q * K.x, N.y = ne * J.y + Q * K.y, N.z = ne * J.z + Q * K.z, N.normalize(), z.push(N.x, N.y, N.z), F.x = G.x + L * N.x, F.y = G.y + L * N.y, F.z = G.z + L * N.z, V.push(F.x, F.y, F.z);
      }
    }
    function j() {
      for (let Y = 1; Y <= b; Y++)
        for (let J = 1; J <= M; J++) {
          const K = (M + 1) * (Y - 1) + (J - 1), X = (M + 1) * Y + (J - 1), Z = (M + 1) * Y + J, Q = (M + 1) * (Y - 1) + J;
          H.push(K, X, Q), H.push(X, Z, Q);
        }
    }
    function q() {
      for (let Y = 0; Y <= b; Y++)
        for (let J = 0; J <= M; J++)
          U.x = Y / b, U.y = J / M, k.push(U.x, U.y);
    }
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new TubeGeometry(
      new Curves[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class WireframeGeometry extends BufferGeometry {
  constructor(e) {
    if (super(), this.type = "WireframeGeometry", e.isGeometry === !0) {
      console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return;
    }
    const b = [], L = [0, 0], M = {}, D = new Vector3();
    if (e.index !== null) {
      const I = e.attributes.position, F = e.index;
      let N = e.groups;
      N.length === 0 && (N = [{ start: 0, count: F.count, materialIndex: 0 }]);
      for (let U = 0, G = N.length; U < G; ++U) {
        const V = N[U], z = V.start, k = V.count;
        for (let H = z, W = z + k; H < W; H += 3)
          for (let $ = 0; $ < 3; $++) {
            const j = F.getX(H + $), q = F.getX(H + ($ + 1) % 3);
            L[0] = Math.min(j, q), L[1] = Math.max(j, q);
            const Y = L[0] + "," + L[1];
            M[Y] === void 0 && (M[Y] = { index1: L[0], index2: L[1] });
          }
      }
      for (const U in M) {
        const G = M[U];
        D.fromBufferAttribute(I, G.index1), b.push(D.x, D.y, D.z), D.fromBufferAttribute(I, G.index2), b.push(D.x, D.y, D.z);
      }
    } else {
      const I = e.attributes.position;
      for (let F = 0, N = I.count / 3; F < N; F++)
        for (let U = 0; U < 3; U++) {
          const G = 3 * F + U;
          D.fromBufferAttribute(I, G), b.push(D.x, D.y, D.z);
          const V = 3 * F + (U + 1) % 3;
          D.fromBufferAttribute(I, V), b.push(D.x, D.y, D.z);
        }
    }
    this.setAttribute("position", new Float32BufferAttribute(b, 3));
  }
}
var Geometries = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry,
  BoxBufferGeometry: BoxGeometry,
  CircleGeometry,
  CircleBufferGeometry: CircleGeometry,
  ConeGeometry,
  ConeBufferGeometry: ConeGeometry,
  CylinderGeometry,
  CylinderBufferGeometry: CylinderGeometry,
  DodecahedronGeometry,
  DodecahedronBufferGeometry: DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  ExtrudeBufferGeometry: ExtrudeGeometry,
  IcosahedronGeometry,
  IcosahedronBufferGeometry: IcosahedronGeometry,
  LatheGeometry,
  LatheBufferGeometry: LatheGeometry,
  OctahedronGeometry,
  OctahedronBufferGeometry: OctahedronGeometry,
  ParametricGeometry,
  ParametricBufferGeometry: ParametricGeometry,
  PlaneGeometry,
  PlaneBufferGeometry: PlaneGeometry,
  PolyhedronGeometry,
  PolyhedronBufferGeometry: PolyhedronGeometry,
  RingGeometry,
  RingBufferGeometry: RingGeometry,
  ShapeGeometry,
  ShapeBufferGeometry: ShapeGeometry,
  SphereGeometry,
  SphereBufferGeometry: SphereGeometry,
  TetrahedronGeometry,
  TetrahedronBufferGeometry: TetrahedronGeometry,
  TextGeometry,
  TextBufferGeometry: TextGeometry,
  TorusGeometry,
  TorusBufferGeometry: TorusGeometry,
  TorusKnotGeometry,
  TorusKnotBufferGeometry: TorusKnotGeometry,
  TubeGeometry,
  TubeBufferGeometry: TubeGeometry,
  WireframeGeometry
});
class ShadowMaterial extends Material {
  constructor(e) {
    super(), this.type = "ShadowMaterial", this.color = new Color(0), this.transparent = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this;
  }
}
ShadowMaterial.prototype.isShadowMaterial = !0;
class RawShaderMaterial extends ShaderMaterial {
  constructor(e) {
    super(e), this.type = "RawShaderMaterial";
  }
}
RawShaderMaterial.prototype.isRawShaderMaterial = !0;
class MeshStandardMaterial extends Material {
  constructor(e) {
    super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Color(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.vertexTangents = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this.vertexTangents = e.vertexTangents, this;
  }
}
MeshStandardMaterial.prototype.isMeshStandardMaterial = !0;
class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(e) {
    super(), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2(1, 1), this.clearcoatNormalMap = null, this.reflectivity = 0.5, Object.defineProperty(this, "ior", {
      get: function() {
        return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
      },
      set: function(b) {
        this.reflectivity = clamp(2.5 * (b - 1) / (b + 1), 0, 1);
      }
    }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.thickness = 0.01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Color(1, 1, 1), this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.reflectivity = e.reflectivity, e.sheen ? this.sheen = (this.sheen || new Color()).copy(e.sheen) : this.sheen = null, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this;
  }
}
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = !0;
class MeshPhongMaterial extends Material {
  constructor(e) {
    super(), this.type = "MeshPhongMaterial", this.color = new Color(16777215), this.specular = new Color(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this;
  }
}
MeshPhongMaterial.prototype.isMeshPhongMaterial = !0;
class MeshToonMaterial extends Material {
  constructor(e) {
    super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Color(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
  }
}
MeshToonMaterial.prototype.isMeshToonMaterial = !0;
class MeshNormalMaterial extends Material {
  constructor(e) {
    super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this;
  }
}
MeshNormalMaterial.prototype.isMeshNormalMaterial = !0;
class MeshLambertMaterial extends Material {
  constructor(e) {
    super(), this.type = "MeshLambertMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
  }
}
MeshLambertMaterial.prototype.isMeshLambertMaterial = !0;
class MeshMatcapMaterial extends Material {
  constructor(e) {
    super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Color(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this;
  }
}
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = !0;
class LineDashedMaterial extends LineBasicMaterial {
  constructor(e) {
    super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
LineDashedMaterial.prototype.isLineDashedMaterial = !0;
var Materials = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ShadowMaterial,
  SpriteMaterial,
  RawShaderMaterial,
  ShaderMaterial,
  PointsMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshPhongMaterial,
  MeshToonMaterial,
  MeshNormalMaterial,
  MeshLambertMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshBasicMaterial,
  MeshMatcapMaterial,
  LineDashedMaterial,
  LineBasicMaterial,
  Material
});
const AnimationUtils = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function(B, e, b) {
    return AnimationUtils.isTypedArray(B) ? new B.constructor(B.subarray(e, b !== void 0 ? b : B.length)) : B.slice(e, b);
  },
  // converts an array to a specific type
  convertArray: function(B, e, b) {
    return !B || // let 'undefined' and 'null' pass
    !b && B.constructor === e ? B : typeof e.BYTES_PER_ELEMENT == "number" ? new e(B) : Array.prototype.slice.call(B);
  },
  isTypedArray: function(B) {
    return ArrayBuffer.isView(B) && !(B instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function(B) {
    function e(M, D) {
      return B[M] - B[D];
    }
    const b = B.length, L = new Array(b);
    for (let M = 0; M !== b; ++M) L[M] = M;
    return L.sort(e), L;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function(B, e, b) {
    const L = B.length, M = new B.constructor(L);
    for (let D = 0, I = 0; I !== L; ++D) {
      const F = b[D] * e;
      for (let N = 0; N !== e; ++N)
        M[I++] = B[F + N];
    }
    return M;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function(B, e, b, L) {
    let M = 1, D = B[0];
    for (; D !== void 0 && D[L] === void 0; )
      D = B[M++];
    if (D === void 0) return;
    let I = D[L];
    if (I !== void 0)
      if (Array.isArray(I))
        do
          I = D[L], I !== void 0 && (e.push(D.time), b.push.apply(b, I)), D = B[M++];
        while (D !== void 0);
      else if (I.toArray !== void 0)
        do
          I = D[L], I !== void 0 && (e.push(D.time), I.toArray(b, b.length)), D = B[M++];
        while (D !== void 0);
      else
        do
          I = D[L], I !== void 0 && (e.push(D.time), b.push(I)), D = B[M++];
        while (D !== void 0);
  },
  subclip: function(B, e, b, L, M = 30) {
    const D = B.clone();
    D.name = e;
    const I = [];
    for (let N = 0; N < D.tracks.length; ++N) {
      const U = D.tracks[N], G = U.getValueSize(), V = [], z = [];
      for (let k = 0; k < U.times.length; ++k) {
        const H = U.times[k] * M;
        if (!(H < b || H >= L)) {
          V.push(U.times[k]);
          for (let W = 0; W < G; ++W)
            z.push(U.values[k * G + W]);
        }
      }
      V.length !== 0 && (U.times = AnimationUtils.convertArray(V, U.times.constructor), U.values = AnimationUtils.convertArray(z, U.values.constructor), I.push(U));
    }
    D.tracks = I;
    let F = 1 / 0;
    for (let N = 0; N < D.tracks.length; ++N)
      F > D.tracks[N].times[0] && (F = D.tracks[N].times[0]);
    for (let N = 0; N < D.tracks.length; ++N)
      D.tracks[N].shift(-1 * F);
    return D.resetDuration(), D;
  },
  makeClipAdditive: function(B, e = 0, b = B, L = 30) {
    L <= 0 && (L = 30);
    const M = b.tracks.length, D = e / L;
    for (let I = 0; I < M; ++I) {
      const F = b.tracks[I], N = F.ValueTypeName;
      if (N === "bool" || N === "string") continue;
      const U = B.tracks.find(function(j) {
        return j.name === F.name && j.ValueTypeName === N;
      });
      if (U === void 0) continue;
      let G = 0;
      const V = F.getValueSize();
      F.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (G = V / 3);
      let z = 0;
      const k = U.getValueSize();
      U.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (z = k / 3);
      const H = F.times.length - 1;
      let W;
      if (D <= F.times[0]) {
        const j = G, q = V - G;
        W = AnimationUtils.arraySlice(F.values, j, q);
      } else if (D >= F.times[H]) {
        const j = H * V + G, q = j + V - G;
        W = AnimationUtils.arraySlice(F.values, j, q);
      } else {
        const j = F.createInterpolant(), q = G, Y = V - G;
        j.evaluate(D), W = AnimationUtils.arraySlice(j.resultBuffer, q, Y);
      }
      N === "quaternion" && new Quaternion().fromArray(W).normalize().conjugate().toArray(W);
      const $ = U.times.length;
      for (let j = 0; j < $; ++j) {
        const q = j * k + z;
        if (N === "quaternion")
          Quaternion.multiplyQuaternionsFlat(
            U.values,
            q,
            W,
            0,
            U.values,
            q
          );
        else {
          const Y = k - z * 2;
          for (let J = 0; J < Y; ++J)
            U.values[q + J] -= W[J];
        }
      }
    }
    return B.blendMode = AdditiveAnimationBlendMode, B;
  }
};
class Interpolant {
  constructor(e, b, L, M) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = M !== void 0 ? M : new b.constructor(L), this.sampleValues = b, this.valueSize = L, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const b = this.parameterPositions;
    let L = this._cachedIndex, M = b[L], D = b[L - 1];
    e: {
      t: {
        let I;
        n: {
          i: if (!(e < M)) {
            for (let F = L + 2; ; ) {
              if (M === void 0) {
                if (e < D) break i;
                return L = b.length, this._cachedIndex = L, this.afterEnd_(L - 1, e, D);
              }
              if (L === F) break;
              if (D = M, M = b[++L], e < M)
                break t;
            }
            I = b.length;
            break n;
          }
          if (!(e >= D)) {
            const F = b[1];
            e < F && (L = 2, D = F);
            for (let N = L - 2; ; ) {
              if (D === void 0)
                return this._cachedIndex = 0, this.beforeStart_(0, e, M);
              if (L === N) break;
              if (M = D, D = b[--L - 1], e >= D)
                break t;
            }
            I = L, L = 0;
            break n;
          }
          break e;
        }
        for (; L < I; ) {
          const F = L + I >>> 1;
          e < b[F] ? I = F : L = F + 1;
        }
        if (M = b[L], D = b[L - 1], D === void 0)
          return this._cachedIndex = 0, this.beforeStart_(0, e, M);
        if (M === void 0)
          return L = b.length, this._cachedIndex = L, this.afterEnd_(L - 1, D, e);
      }
      this._cachedIndex = L, this.intervalChanged_(L, D, M);
    }
    return this.interpolate_(L, D, e, M);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const b = this.resultBuffer, L = this.sampleValues, M = this.valueSize, D = e * M;
    for (let I = 0; I !== M; ++I)
      b[I] = L[D + I];
    return b;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
class CubicInterpolant extends Interpolant {
  constructor(e, b, L, M) {
    super(e, b, L, M), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(e, b, L) {
    const M = this.parameterPositions;
    let D = e - 2, I = e + 1, F = M[D], N = M[I];
    if (F === void 0)
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          D = e, F = 2 * b - L;
          break;
        case WrapAroundEnding:
          D = M.length - 2, F = b + M[D] - M[D + 1];
          break;
        default:
          D = e, F = L;
      }
    if (N === void 0)
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          I = e, N = 2 * L - b;
          break;
        case WrapAroundEnding:
          I = 1, N = L + M[1] - M[0];
          break;
        default:
          I = e - 1, N = b;
      }
    const U = (L - b) * 0.5, G = this.valueSize;
    this._weightPrev = U / (b - F), this._weightNext = U / (N - L), this._offsetPrev = D * G, this._offsetNext = I * G;
  }
  interpolate_(e, b, L, M) {
    const D = this.resultBuffer, I = this.sampleValues, F = this.valueSize, N = e * F, U = N - F, G = this._offsetPrev, V = this._offsetNext, z = this._weightPrev, k = this._weightNext, H = (L - b) / (M - b), W = H * H, $ = W * H, j = -z * $ + 2 * z * W - z * H, q = (1 + z) * $ + (-1.5 - 2 * z) * W + (-0.5 + z) * H + 1, Y = (-1 - k) * $ + (1.5 + k) * W + 0.5 * H, J = k * $ - k * W;
    for (let K = 0; K !== F; ++K)
      D[K] = j * I[G + K] + q * I[U + K] + Y * I[N + K] + J * I[V + K];
    return D;
  }
}
class LinearInterpolant extends Interpolant {
  constructor(e, b, L, M) {
    super(e, b, L, M);
  }
  interpolate_(e, b, L, M) {
    const D = this.resultBuffer, I = this.sampleValues, F = this.valueSize, N = e * F, U = N - F, G = (L - b) / (M - b), V = 1 - G;
    for (let z = 0; z !== F; ++z)
      D[z] = I[U + z] * V + I[N + z] * G;
    return D;
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(e, b, L, M) {
    super(e, b, L, M);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class KeyframeTrack {
  constructor(e, b, L, M) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (b === void 0 || b.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = AnimationUtils.convertArray(b, this.TimeBufferType), this.values = AnimationUtils.convertArray(L, this.ValueBufferType), this.setInterpolation(M || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const b = e.constructor;
    let L;
    if (b.toJSON !== this.toJSON)
      L = b.toJSON(e);
    else {
      L = {
        name: e.name,
        times: AnimationUtils.convertArray(e.times, Array),
        values: AnimationUtils.convertArray(e.values, Array)
      };
      const M = e.getInterpolation();
      M !== e.DefaultInterpolation && (L.interpolation = M);
    }
    return L.type = e.ValueTypeName, L;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let b;
    switch (e) {
      case InterpolateDiscrete:
        b = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        b = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        b = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (b === void 0) {
      const L = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(L);
      return console.warn("THREE.KeyframeTrack:", L), this;
    }
    return this.createInterpolant = b, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const b = this.times;
      for (let L = 0, M = b.length; L !== M; ++L)
        b[L] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const b = this.times;
      for (let L = 0, M = b.length; L !== M; ++L)
        b[L] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, b) {
    const L = this.times, M = L.length;
    let D = 0, I = M - 1;
    for (; D !== M && L[D] < e; )
      ++D;
    for (; I !== -1 && L[I] > b; )
      --I;
    if (++I, D !== 0 || I !== M) {
      D >= I && (I = Math.max(I, 1), D = I - 1);
      const F = this.getValueSize();
      this.times = AnimationUtils.arraySlice(L, D, I), this.values = AnimationUtils.arraySlice(this.values, D * F, I * F);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const b = this.getValueSize();
    b - Math.floor(b) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const L = this.times, M = this.values, D = L.length;
    D === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let I = null;
    for (let F = 0; F !== D; F++) {
      const N = L[F];
      if (typeof N == "number" && isNaN(N)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, F, N), e = !1;
        break;
      }
      if (I !== null && I > N) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, F, N, I), e = !1;
        break;
      }
      I = N;
    }
    if (M !== void 0 && AnimationUtils.isTypedArray(M))
      for (let F = 0, N = M.length; F !== N; ++F) {
        const U = M[F];
        if (isNaN(U)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, F, U), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = AnimationUtils.arraySlice(this.times), b = AnimationUtils.arraySlice(this.values), L = this.getValueSize(), M = this.getInterpolation() === InterpolateSmooth, D = e.length - 1;
    let I = 1;
    for (let F = 1; F < D; ++F) {
      let N = !1;
      const U = e[F], G = e[F + 1];
      if (U !== G && (F !== 1 || U !== e[0]))
        if (M)
          N = !0;
        else {
          const V = F * L, z = V - L, k = V + L;
          for (let H = 0; H !== L; ++H) {
            const W = b[V + H];
            if (W !== b[z + H] || W !== b[k + H]) {
              N = !0;
              break;
            }
          }
        }
      if (N) {
        if (F !== I) {
          e[I] = e[F];
          const V = F * L, z = I * L;
          for (let k = 0; k !== L; ++k)
            b[z + k] = b[V + k];
        }
        ++I;
      }
    }
    if (D > 0) {
      e[I] = e[D];
      for (let F = D * L, N = I * L, U = 0; U !== L; ++U)
        b[N + U] = b[F + U];
      ++I;
    }
    return I !== e.length ? (this.times = AnimationUtils.arraySlice(e, 0, I), this.values = AnimationUtils.arraySlice(b, 0, I * L)) : (this.times = e, this.values = b), this;
  }
  clone() {
    const e = AnimationUtils.arraySlice(this.times, 0), b = AnimationUtils.arraySlice(this.values, 0), L = this.constructor, M = new L(this.name, e, b);
    return M.createInterpolant = this.createInterpolant, M;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
  constructor(e, b, L, M) {
    super(e, b, L, M);
  }
  interpolate_(e, b, L, M) {
    const D = this.resultBuffer, I = this.sampleValues, F = this.valueSize, N = (L - b) / (M - b);
    let U = e * F;
    for (let G = U + F; U !== G; U += 4)
      Quaternion.slerpFlat(D, 0, I, U - F, I, U, N);
    return D;
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(e) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), e);
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(e, b = -1, L, M = NormalAnimationBlendMode) {
    this.name = e, this.tracks = L, this.duration = b, this.blendMode = M, this.uuid = generateUUID$1(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const b = [], L = e.tracks, M = 1 / (e.fps || 1);
    for (let I = 0, F = L.length; I !== F; ++I)
      b.push(parseKeyframeTrack(L[I]).scale(M));
    const D = new this(e.name, e.duration, b, e.blendMode);
    return D.uuid = e.uuid, D;
  }
  static toJSON(e) {
    const b = [], L = e.tracks, M = {
      name: e.name,
      duration: e.duration,
      tracks: b,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let D = 0, I = L.length; D !== I; ++D)
      b.push(KeyframeTrack.toJSON(L[D]));
    return M;
  }
  static CreateFromMorphTargetSequence(e, b, L, M) {
    const D = b.length, I = [];
    for (let F = 0; F < D; F++) {
      let N = [], U = [];
      N.push(
        (F + D - 1) % D,
        F,
        (F + 1) % D
      ), U.push(0, 1, 0);
      const G = AnimationUtils.getKeyframeOrder(N);
      N = AnimationUtils.sortedArray(N, 1, G), U = AnimationUtils.sortedArray(U, 1, G), !M && N[0] === 0 && (N.push(D), U.push(U[0])), I.push(
        new NumberKeyframeTrack(
          ".morphTargetInfluences[" + b[F].name + "]",
          N,
          U
        ).scale(1 / L)
      );
    }
    return new this(e, -1, I);
  }
  static findByName(e, b) {
    let L = e;
    if (!Array.isArray(e)) {
      const M = e;
      L = M.geometry && M.geometry.animations || M.animations;
    }
    for (let M = 0; M < L.length; M++)
      if (L[M].name === b)
        return L[M];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, b, L) {
    const M = {}, D = /^([\w-]*?)([\d]+)$/;
    for (let F = 0, N = e.length; F < N; F++) {
      const U = e[F], G = U.name.match(D);
      if (G && G.length > 1) {
        const V = G[1];
        let z = M[V];
        z || (M[V] = z = []), z.push(U);
      }
    }
    const I = [];
    for (const F in M)
      I.push(this.CreateFromMorphTargetSequence(F, M[F], b, L));
    return I;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, b) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const L = function(V, z, k, H, W) {
      if (k.length !== 0) {
        const $ = [], j = [];
        AnimationUtils.flattenJSON(k, $, j, H), $.length !== 0 && W.push(new V(z, $, j));
      }
    }, M = [], D = e.name || "default", I = e.fps || 30, F = e.blendMode;
    let N = e.length || -1;
    const U = e.hierarchy || [];
    for (let V = 0; V < U.length; V++) {
      const z = U[V].keys;
      if (!(!z || z.length === 0))
        if (z[0].morphTargets) {
          const k = {};
          let H;
          for (H = 0; H < z.length; H++)
            if (z[H].morphTargets)
              for (let W = 0; W < z[H].morphTargets.length; W++)
                k[z[H].morphTargets[W]] = -1;
          for (const W in k) {
            const $ = [], j = [];
            for (let q = 0; q !== z[H].morphTargets.length; ++q) {
              const Y = z[H];
              $.push(Y.time), j.push(Y.morphTarget === W ? 1 : 0);
            }
            M.push(new NumberKeyframeTrack(".morphTargetInfluence[" + W + "]", $, j));
          }
          N = k.length * (I || 1);
        } else {
          const k = ".bones[" + b[V].name + "]";
          L(
            VectorKeyframeTrack,
            k + ".position",
            z,
            "pos",
            M
          ), L(
            QuaternionKeyframeTrack,
            k + ".quaternion",
            z,
            "rot",
            M
          ), L(
            VectorKeyframeTrack,
            k + ".scale",
            z,
            "scl",
            M
          );
        }
    }
    return M.length === 0 ? null : new this(D, N, M, F);
  }
  resetDuration() {
    const e = this.tracks;
    let b = 0;
    for (let L = 0, M = e.length; L !== M; ++L) {
      const D = this.tracks[L];
      b = Math.max(b, D.times[D.times.length - 1]);
    }
    return this.duration = b, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let b = 0; b < this.tracks.length; b++)
      e = e && this.tracks[b].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let b = 0; b < this.tracks.length; b++)
      e.push(this.tracks[b].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(B) {
  switch (B.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + B);
}
function parseKeyframeTrack(B) {
  if (B.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = getTrackTypeForValueTypeName(B.type);
  if (B.times === void 0) {
    const b = [], L = [];
    AnimationUtils.flattenJSON(B.keys, b, L, "value"), B.times = b, B.values = L;
  }
  return e.parse !== void 0 ? e.parse(B) : new e(B.name, B.times, B.values, B.interpolation);
}
const Cache = {
  enabled: !1,
  files: {},
  add: function(B, e) {
    this.enabled !== !1 && (this.files[B] = e);
  },
  get: function(B) {
    if (this.enabled !== !1)
      return this.files[B];
  },
  remove: function(B) {
    delete this.files[B];
  },
  clear: function() {
    this.files = {};
  }
};
class LoadingManager {
  constructor(e, b, L) {
    const M = this;
    let D = !1, I = 0, F = 0, N;
    const U = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = b, this.onError = L, this.itemStart = function(G) {
      F++, D === !1 && M.onStart !== void 0 && M.onStart(G, I, F), D = !0;
    }, this.itemEnd = function(G) {
      I++, M.onProgress !== void 0 && M.onProgress(G, I, F), I === F && (D = !1, M.onLoad !== void 0 && M.onLoad());
    }, this.itemError = function(G) {
      M.onError !== void 0 && M.onError(G);
    }, this.resolveURL = function(G) {
      return N ? N(G) : G;
    }, this.setURLModifier = function(G) {
      return N = G, this;
    }, this.addHandler = function(G, V) {
      return U.push(G, V), this;
    }, this.removeHandler = function(G) {
      const V = U.indexOf(G);
      return V !== -1 && U.splice(V, 2), this;
    }, this.getHandler = function(G) {
      for (let V = 0, z = U.length; V < z; V += 2) {
        const k = U[V], H = U[V + 1];
        if (k.global && (k.lastIndex = 0), k.test(G))
          return H;
      }
      return null;
    };
  }
}
const DefaultLoadingManager = new LoadingManager();
class Loader {
  constructor(e) {
    this.manager = e !== void 0 ? e : DefaultLoadingManager, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, b) {
    const L = this;
    return new Promise(function(M, D) {
      L.load(e, M, b, D);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
const loading = {};
class FileLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, b, L, M) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const D = this, I = Cache.get(e);
    if (I !== void 0)
      return D.manager.itemStart(e), setTimeout(function() {
        b && b(I), D.manager.itemEnd(e);
      }, 0), I;
    if (loading[e] !== void 0) {
      loading[e].push({
        onLoad: b,
        onProgress: L,
        onError: M
      });
      return;
    }
    const F = /^data:(.*?)(;base64)?,(.*)$/, N = e.match(F);
    let U;
    if (N) {
      const G = N[1], V = !!N[2];
      let z = N[3];
      z = decodeURIComponent(z), V && (z = atob(z));
      try {
        let k;
        const H = (this.responseType || "").toLowerCase();
        switch (H) {
          case "arraybuffer":
          case "blob":
            const W = new Uint8Array(z.length);
            for (let j = 0; j < z.length; j++)
              W[j] = z.charCodeAt(j);
            H === "blob" ? k = new Blob([W.buffer], { type: G }) : k = W.buffer;
            break;
          case "document":
            k = new DOMParser().parseFromString(z, G);
            break;
          case "json":
            k = JSON.parse(z);
            break;
          default:
            k = z;
            break;
        }
        setTimeout(function() {
          b && b(k), D.manager.itemEnd(e);
        }, 0);
      } catch (k) {
        setTimeout(function() {
          M && M(k), D.manager.itemError(e), D.manager.itemEnd(e);
        }, 0);
      }
    } else {
      loading[e] = [], loading[e].push({
        onLoad: b,
        onProgress: L,
        onError: M
      }), U = new XMLHttpRequest(), U.open("GET", e, !0), U.addEventListener("load", function(G) {
        const V = this.response, z = loading[e];
        if (delete loading[e], this.status === 200 || this.status === 0) {
          this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), Cache.add(e, V);
          for (let k = 0, H = z.length; k < H; k++) {
            const W = z[k];
            W.onLoad && W.onLoad(V);
          }
          D.manager.itemEnd(e);
        } else {
          for (let k = 0, H = z.length; k < H; k++) {
            const W = z[k];
            W.onError && W.onError(G);
          }
          D.manager.itemError(e), D.manager.itemEnd(e);
        }
      }, !1), U.addEventListener("progress", function(G) {
        const V = loading[e];
        for (let z = 0, k = V.length; z < k; z++) {
          const H = V[z];
          H.onProgress && H.onProgress(G);
        }
      }, !1), U.addEventListener("error", function(G) {
        const V = loading[e];
        delete loading[e];
        for (let z = 0, k = V.length; z < k; z++) {
          const H = V[z];
          H.onError && H.onError(G);
        }
        D.manager.itemError(e), D.manager.itemEnd(e);
      }, !1), U.addEventListener("abort", function(G) {
        const V = loading[e];
        delete loading[e];
        for (let z = 0, k = V.length; z < k; z++) {
          const H = V[z];
          H.onError && H.onError(G);
        }
        D.manager.itemError(e), D.manager.itemEnd(e);
      }, !1), this.responseType !== void 0 && (U.responseType = this.responseType), this.withCredentials !== void 0 && (U.withCredentials = this.withCredentials), U.overrideMimeType && U.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (const G in this.requestHeader)
        U.setRequestHeader(G, this.requestHeader[G]);
      U.send(null);
    }
    return D.manager.itemStart(e), U;
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class AnimationLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, b, L, M) {
    const D = this, I = new FileLoader(this.manager);
    I.setPath(this.path), I.setRequestHeader(this.requestHeader), I.setWithCredentials(this.withCredentials), I.load(e, function(F) {
      try {
        b(D.parse(JSON.parse(F)));
      } catch (N) {
        M ? M(N) : console.error(N), D.manager.itemError(e);
      }
    }, L, M);
  }
  parse(e) {
    const b = [];
    for (let L = 0; L < e.length; L++) {
      const M = AnimationClip.parse(e[L]);
      b.push(M);
    }
    return b;
  }
}
class CompressedTextureLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, b, L, M) {
    const D = this, I = [], F = new CompressedTexture(), N = new FileLoader(this.manager);
    N.setPath(this.path), N.setResponseType("arraybuffer"), N.setRequestHeader(this.requestHeader), N.setWithCredentials(D.withCredentials);
    let U = 0;
    function G(V) {
      N.load(e[V], function(z) {
        const k = D.parse(z, !0);
        I[V] = {
          width: k.width,
          height: k.height,
          format: k.format,
          mipmaps: k.mipmaps
        }, U += 1, U === 6 && (k.mipmapCount === 1 && (F.minFilter = LinearFilter), F.image = I, F.format = k.format, F.needsUpdate = !0, b && b(F));
      }, L, M);
    }
    if (Array.isArray(e))
      for (let V = 0, z = e.length; V < z; ++V)
        G(V);
    else
      N.load(e, function(V) {
        const z = D.parse(V, !0);
        if (z.isCubemap) {
          const k = z.mipmaps.length / z.mipmapCount;
          for (let H = 0; H < k; H++) {
            I[H] = { mipmaps: [] };
            for (let W = 0; W < z.mipmapCount; W++)
              I[H].mipmaps.push(z.mipmaps[H * z.mipmapCount + W]), I[H].format = z.format, I[H].width = z.width, I[H].height = z.height;
          }
          F.image = I;
        } else
          F.image.width = z.width, F.image.height = z.height, F.mipmaps = z.mipmaps;
        z.mipmapCount === 1 && (F.minFilter = LinearFilter), F.format = z.format, F.needsUpdate = !0, b && b(F);
      }, L, M);
    return F;
  }
}
class ImageLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, b, L, M) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const D = this, I = Cache.get(e);
    if (I !== void 0)
      return D.manager.itemStart(e), setTimeout(function() {
        b && b(I), D.manager.itemEnd(e);
      }, 0), I;
    const F = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function N() {
      F.removeEventListener("load", N, !1), F.removeEventListener("error", U, !1), Cache.add(e, this), b && b(this), D.manager.itemEnd(e);
    }
    function U(G) {
      F.removeEventListener("load", N, !1), F.removeEventListener("error", U, !1), M && M(G), D.manager.itemError(e), D.manager.itemEnd(e);
    }
    return F.addEventListener("load", N, !1), F.addEventListener("error", U, !1), e.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (F.crossOrigin = this.crossOrigin), D.manager.itemStart(e), F.src = e, F;
  }
}
class CubeTextureLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, b, L, M) {
    const D = new CubeTexture(), I = new ImageLoader(this.manager);
    I.setCrossOrigin(this.crossOrigin), I.setPath(this.path);
    let F = 0;
    function N(U) {
      I.load(e[U], function(G) {
        D.images[U] = G, F++, F === 6 && (D.needsUpdate = !0, b && b(D));
      }, void 0, M);
    }
    for (let U = 0; U < e.length; ++U)
      N(U);
    return D;
  }
}
class DataTextureLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, b, L, M) {
    const D = this, I = new DataTexture(), F = new FileLoader(this.manager);
    return F.setResponseType("arraybuffer"), F.setRequestHeader(this.requestHeader), F.setPath(this.path), F.setWithCredentials(D.withCredentials), F.load(e, function(N) {
      const U = D.parse(N);
      U && (U.image !== void 0 ? I.image = U.image : U.data !== void 0 && (I.image.width = U.width, I.image.height = U.height, I.image.data = U.data), I.wrapS = U.wrapS !== void 0 ? U.wrapS : ClampToEdgeWrapping, I.wrapT = U.wrapT !== void 0 ? U.wrapT : ClampToEdgeWrapping, I.magFilter = U.magFilter !== void 0 ? U.magFilter : LinearFilter, I.minFilter = U.minFilter !== void 0 ? U.minFilter : LinearFilter, I.anisotropy = U.anisotropy !== void 0 ? U.anisotropy : 1, U.encoding !== void 0 && (I.encoding = U.encoding), U.flipY !== void 0 && (I.flipY = U.flipY), U.format !== void 0 && (I.format = U.format), U.type !== void 0 && (I.type = U.type), U.mipmaps !== void 0 && (I.mipmaps = U.mipmaps, I.minFilter = LinearMipmapLinearFilter), U.mipmapCount === 1 && (I.minFilter = LinearFilter), U.generateMipmaps !== void 0 && (I.generateMipmaps = U.generateMipmaps), I.needsUpdate = !0, b && b(I, U));
    }, L, M), I;
  }
}
class TextureLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, b, L, M) {
    const D = new Texture(), I = new ImageLoader(this.manager);
    return I.setCrossOrigin(this.crossOrigin), I.setPath(this.path), I.load(e, function(F) {
      D.image = F;
      const N = e.search(/\.jpe?g($|\?)/i) > 0 || e.search(/^data\:image\/jpeg/) === 0;
      D.format = N ? RGBFormat : RGBAFormat, D.needsUpdate = !0, b !== void 0 && b(D);
    }, L, M), D;
  }
}
class CurvePath extends Curve {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(b) || this.curves.push(new LineCurve(b, e));
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e) {
    const b = e * this.getLength(), L = this.getCurveLengths();
    let M = 0;
    for (; M < L.length; ) {
      if (L[M] >= b) {
        const D = L[M] - b, I = this.curves[M], F = I.getLength(), N = F === 0 ? 0 : 1 - D / F;
        return I.getPointAt(N);
      }
      M++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let b = 0;
    for (let L = 0, M = this.curves.length; L < M; L++)
      b += this.curves[L].getLength(), e.push(b);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const b = [];
    for (let L = 0; L <= e; L++)
      b.push(this.getPoint(L / e));
    return this.autoClose && b.push(b[0]), b;
  }
  getPoints(e = 12) {
    const b = [];
    let L;
    for (let M = 0, D = this.curves; M < D.length; M++) {
      const I = D[M], F = I && I.isEllipseCurve ? e * 2 : I && (I.isLineCurve || I.isLineCurve3) ? 1 : I && I.isSplineCurve ? e * I.points.length : e, N = I.getPoints(F);
      for (let U = 0; U < N.length; U++) {
        const G = N[U];
        L && L.equals(G) || (b.push(G), L = G);
      }
    }
    return this.autoClose && b.length > 1 && !b[b.length - 1].equals(b[0]) && b.push(b[0]), b;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let b = 0, L = e.curves.length; b < L; b++) {
      const M = e.curves[b];
      this.curves.push(M.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let b = 0, L = this.curves.length; b < L; b++) {
      const M = this.curves[b];
      e.curves.push(M.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let b = 0, L = e.curves.length; b < L; b++) {
      const M = e.curves[b];
      this.curves.push(new Curves[M.type]().fromJSON(M));
    }
    return this;
  }
}
class Path extends CurvePath {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Vector2(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let b = 1, L = e.length; b < L; b++)
      this.lineTo(e[b].x, e[b].y);
    return this;
  }
  moveTo(e, b) {
    return this.currentPoint.set(e, b), this;
  }
  lineTo(e, b) {
    const L = new LineCurve(this.currentPoint.clone(), new Vector2(e, b));
    return this.curves.push(L), this.currentPoint.set(e, b), this;
  }
  quadraticCurveTo(e, b, L, M) {
    const D = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2(e, b),
      new Vector2(L, M)
    );
    return this.curves.push(D), this.currentPoint.set(L, M), this;
  }
  bezierCurveTo(e, b, L, M, D, I) {
    const F = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2(e, b),
      new Vector2(L, M),
      new Vector2(D, I)
    );
    return this.curves.push(F), this.currentPoint.set(D, I), this;
  }
  splineThru(e) {
    const b = [this.currentPoint.clone()].concat(e), L = new SplineCurve(b);
    return this.curves.push(L), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, b, L, M, D, I) {
    const F = this.currentPoint.x, N = this.currentPoint.y;
    return this.absarc(
      e + F,
      b + N,
      L,
      M,
      D,
      I
    ), this;
  }
  absarc(e, b, L, M, D, I) {
    return this.absellipse(e, b, L, L, M, D, I), this;
  }
  ellipse(e, b, L, M, D, I, F, N) {
    const U = this.currentPoint.x, G = this.currentPoint.y;
    return this.absellipse(e + U, b + G, L, M, D, I, F, N), this;
  }
  absellipse(e, b, L, M, D, I, F, N) {
    const U = new EllipseCurve(e, b, L, M, D, I, F, N);
    if (this.curves.length > 0) {
      const V = U.getPoint(0);
      V.equals(this.currentPoint) || this.lineTo(V.x, V.y);
    }
    this.curves.push(U);
    const G = U.getPoint(1);
    return this.currentPoint.copy(G), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
let Shape$1 = class extends Path {
  constructor(e) {
    super(e), this.uuid = generateUUID$1(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const b = [];
    for (let L = 0, M = this.holes.length; L < M; L++)
      b[L] = this.holes[L].getPoints(e);
    return b;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let b = 0, L = e.holes.length; b < L; b++) {
      const M = e.holes[b];
      this.holes.push(M.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let b = 0, L = this.holes.length; b < L; b++) {
      const M = this.holes[b];
      e.holes.push(M.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let b = 0, L = e.holes.length; b < L; b++) {
      const M = e.holes[b];
      this.holes.push(new Path().fromJSON(M));
    }
    return this;
  }
};
class Light extends Object3D {
  constructor(e, b = 1) {
    super(), this.type = "Light", this.color = new Color(e), this.intensity = b;
  }
  dispose() {
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const b = super.toJSON(e);
    return b.object.color = this.color.getHex(), b.object.intensity = this.intensity, this.groundColor !== void 0 && (b.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (b.object.distance = this.distance), this.angle !== void 0 && (b.object.angle = this.angle), this.decay !== void 0 && (b.object.decay = this.decay), this.penumbra !== void 0 && (b.object.penumbra = this.penumbra), this.shadow !== void 0 && (b.object.shadow = this.shadow.toJSON()), b;
  }
}
Light.prototype.isLight = !0;
class HemisphereLight extends Light {
  constructor(e, b, L) {
    super(e, L), this.type = "HemisphereLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.groundColor = new Color(b);
  }
  copy(e) {
    return Light.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this;
  }
}
HemisphereLight.prototype.isHemisphereLight = !0;
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4(), _lightPositionWorld$1 = /* @__PURE__ */ new Vector3(), _lookTarget$1 = /* @__PURE__ */ new Vector3();
class LightShadow {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new Vector2(512, 512), this.map = null, this.mapPass = null, this.matrix = new Matrix4(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Frustum(), this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const b = this.camera, L = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(e.matrixWorld), b.position.copy(_lightPositionWorld$1), _lookTarget$1.setFromMatrixPosition(e.target.matrixWorld), b.lookAt(_lookTarget$1), b.updateMatrixWorld(), _projScreenMatrix$1.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix$1), L.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), L.multiply(b.projectionMatrix), L.multiply(b.matrixWorldInverse);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500)), this.focus = 1;
  }
  updateMatrices(e) {
    const b = this.camera, L = RAD2DEG * 2 * e.angle * this.focus, M = this.mapSize.width / this.mapSize.height, D = e.distance || b.far;
    (L !== b.fov || M !== b.aspect || D !== b.far) && (b.fov = L, b.aspect = M, b.far = D, b.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
SpotLightShadow.prototype.isSpotLightShadow = !0;
class SpotLight extends Light {
  constructor(e, b, L = 0, M = Math.PI / 3, D = 0, I = 1) {
    super(e, b), this.type = "SpotLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D(), this.distance = L, this.angle = M, this.penumbra = D, this.decay = I, this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
SpotLight.prototype.isSpotLight = !0;
const _projScreenMatrix = /* @__PURE__ */ new Matrix4(), _lightPositionWorld = /* @__PURE__ */ new Vector3(), _lookTarget = /* @__PURE__ */ new Vector3();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500)), this._frameExtents = new Vector2(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Vector4(2, 1, 1, 1),
      // negative X
      new Vector4(0, 1, 1, 1),
      // positive Z
      new Vector4(3, 1, 1, 1),
      // negative Z
      new Vector4(1, 1, 1, 1),
      // positive Y
      new Vector4(3, 0, 1, 1),
      // negative Y
      new Vector4(1, 0, 1, 1)
    ], this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ], this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(e, b = 0) {
    const L = this.camera, M = this.matrix, D = e.distance || L.far;
    D !== L.far && (L.far = D, L.updateProjectionMatrix()), _lightPositionWorld.setFromMatrixPosition(e.matrixWorld), L.position.copy(_lightPositionWorld), _lookTarget.copy(L.position), _lookTarget.add(this._cubeDirections[b]), L.up.copy(this._cubeUps[b]), L.lookAt(_lookTarget), L.updateMatrixWorld(), M.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z), _projScreenMatrix.multiplyMatrices(L.projectionMatrix, L.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
PointLightShadow.prototype.isPointLightShadow = !0;
class PointLight extends Light {
  constructor(e, b, L = 0, M = 1) {
    super(e, b), this.type = "PointLight", this.distance = L, this.decay = M, this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
PointLight.prototype.isPointLight = !0;
class OrthographicCamera extends Camera$1 {
  constructor(e = -1, b = 1, L = 1, M = -1, D = 0.1, I = 2e3) {
    super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = b, this.top = L, this.bottom = M, this.near = D, this.far = I, this.updateProjectionMatrix();
  }
  copy(e, b) {
    return super.copy(e, b), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, b, L, M, D, I) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = b, this.view.offsetX = L, this.view.offsetY = M, this.view.width = D, this.view.height = I, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), b = (this.top - this.bottom) / (2 * this.zoom), L = (this.right + this.left) / 2, M = (this.top + this.bottom) / 2;
    let D = L - e, I = L + e, F = M + b, N = M - b;
    if (this.view !== null && this.view.enabled) {
      const U = (this.right - this.left) / this.view.fullWidth / this.zoom, G = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      D += U * this.view.offsetX, I = D + U * this.view.width, F -= G * this.view.offsetY, N = F - G * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(D, I, F, N, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const b = super.toJSON(e);
    return b.object.zoom = this.zoom, b.object.left = this.left, b.object.right = this.right, b.object.top = this.top, b.object.bottom = this.bottom, b.object.near = this.near, b.object.far = this.far, this.view !== null && (b.object.view = Object.assign({}, this.view)), b;
  }
}
OrthographicCamera.prototype.isOrthographicCamera = !0;
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
}
DirectionalLightShadow.prototype.isDirectionalLightShadow = !0;
class DirectionalLight extends Light {
  constructor(e, b) {
    super(e, b), this.type = "DirectionalLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D(), this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
DirectionalLight.prototype.isDirectionalLight = !0;
class AmbientLight extends Light {
  constructor(e, b) {
    super(e, b), this.type = "AmbientLight";
  }
}
AmbientLight.prototype.isAmbientLight = !0;
class RectAreaLight extends Light {
  constructor(e, b, L = 10, M = 10) {
    super(e, b), this.type = "RectAreaLight", this.width = L, this.height = M;
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const b = super.toJSON(e);
    return b.object.width = this.width, b.object.height = this.height, b;
  }
}
RectAreaLight.prototype.isRectAreaLight = !0;
class SphericalHarmonics3 {
  constructor() {
    this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new Vector3());
  }
  set(e) {
    for (let b = 0; b < 9; b++)
      this.coefficients[b].copy(e[b]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, b) {
    const L = e.x, M = e.y, D = e.z, I = this.coefficients;
    return b.copy(I[0]).multiplyScalar(0.282095), b.addScaledVector(I[1], 0.488603 * M), b.addScaledVector(I[2], 0.488603 * D), b.addScaledVector(I[3], 0.488603 * L), b.addScaledVector(I[4], 1.092548 * (L * M)), b.addScaledVector(I[5], 1.092548 * (M * D)), b.addScaledVector(I[6], 0.315392 * (3 * D * D - 1)), b.addScaledVector(I[7], 1.092548 * (L * D)), b.addScaledVector(I[8], 0.546274 * (L * L - M * M)), b;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, b) {
    const L = e.x, M = e.y, D = e.z, I = this.coefficients;
    return b.copy(I[0]).multiplyScalar(0.886227), b.addScaledVector(I[1], 2 * 0.511664 * M), b.addScaledVector(I[2], 2 * 0.511664 * D), b.addScaledVector(I[3], 2 * 0.511664 * L), b.addScaledVector(I[4], 2 * 0.429043 * L * M), b.addScaledVector(I[5], 2 * 0.429043 * M * D), b.addScaledVector(I[6], 0.743125 * D * D - 0.247708), b.addScaledVector(I[7], 2 * 0.429043 * L * D), b.addScaledVector(I[8], 0.429043 * (L * L - M * M)), b;
  }
  add(e) {
    for (let b = 0; b < 9; b++)
      this.coefficients[b].add(e.coefficients[b]);
    return this;
  }
  addScaledSH(e, b) {
    for (let L = 0; L < 9; L++)
      this.coefficients[L].addScaledVector(e.coefficients[L], b);
    return this;
  }
  scale(e) {
    for (let b = 0; b < 9; b++)
      this.coefficients[b].multiplyScalar(e);
    return this;
  }
  lerp(e, b) {
    for (let L = 0; L < 9; L++)
      this.coefficients[L].lerp(e.coefficients[L], b);
    return this;
  }
  equals(e) {
    for (let b = 0; b < 9; b++)
      if (!this.coefficients[b].equals(e.coefficients[b]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, b = 0) {
    const L = this.coefficients;
    for (let M = 0; M < 9; M++)
      L[M].fromArray(e, b + M * 3);
    return this;
  }
  toArray(e = [], b = 0) {
    const L = this.coefficients;
    for (let M = 0; M < 9; M++)
      L[M].toArray(e, b + M * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, b) {
    const L = e.x, M = e.y, D = e.z;
    b[0] = 0.282095, b[1] = 0.488603 * M, b[2] = 0.488603 * D, b[3] = 0.488603 * L, b[4] = 1.092548 * L * M, b[5] = 1.092548 * M * D, b[6] = 0.315392 * (3 * D * D - 1), b[7] = 1.092548 * L * D, b[8] = 0.546274 * (L * L - M * M);
  }
}
SphericalHarmonics3.prototype.isSphericalHarmonics3 = !0;
class LightProbe extends Light {
  constructor(e = new SphericalHarmonics3(), b = 1) {
    super(void 0, b), this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const b = super.toJSON(e);
    return b.object.sh = this.sh.toArray(), b;
  }
}
LightProbe.prototype.isLightProbe = !0;
class MaterialLoader extends Loader {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, b, L, M) {
    const D = this, I = new FileLoader(D.manager);
    I.setPath(D.path), I.setRequestHeader(D.requestHeader), I.setWithCredentials(D.withCredentials), I.load(e, function(F) {
      try {
        b(D.parse(JSON.parse(F)));
      } catch (N) {
        M ? M(N) : console.error(N), D.manager.itemError(e);
      }
    }, L, M);
  }
  parse(e) {
    const b = this.textures;
    function L(D) {
      return b[D] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", D), b[D];
    }
    const M = new Materials[e.type]();
    if (e.uuid !== void 0 && (M.uuid = e.uuid), e.name !== void 0 && (M.name = e.name), e.color !== void 0 && M.color !== void 0 && M.color.setHex(e.color), e.roughness !== void 0 && (M.roughness = e.roughness), e.metalness !== void 0 && (M.metalness = e.metalness), e.sheen !== void 0 && (M.sheen = new Color().setHex(e.sheen)), e.emissive !== void 0 && M.emissive !== void 0 && M.emissive.setHex(e.emissive), e.specular !== void 0 && M.specular !== void 0 && M.specular.setHex(e.specular), e.shininess !== void 0 && (M.shininess = e.shininess), e.clearcoat !== void 0 && (M.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (M.clearcoatRoughness = e.clearcoatRoughness), e.transmission !== void 0 && (M.transmission = e.transmission), e.thickness !== void 0 && (M.thickness = e.thickness), e.attenuationDistance !== void 0 && (M.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && M.attenuationColor !== void 0 && M.attenuationColor.setHex(e.attenuationColor), e.fog !== void 0 && (M.fog = e.fog), e.flatShading !== void 0 && (M.flatShading = e.flatShading), e.blending !== void 0 && (M.blending = e.blending), e.combine !== void 0 && (M.combine = e.combine), e.side !== void 0 && (M.side = e.side), e.shadowSide !== void 0 && (M.shadowSide = e.shadowSide), e.opacity !== void 0 && (M.opacity = e.opacity), e.transparent !== void 0 && (M.transparent = e.transparent), e.alphaTest !== void 0 && (M.alphaTest = e.alphaTest), e.depthTest !== void 0 && (M.depthTest = e.depthTest), e.depthWrite !== void 0 && (M.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (M.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (M.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (M.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (M.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (M.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (M.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (M.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (M.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (M.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (M.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (M.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (M.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (M.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (M.rotation = e.rotation), e.linewidth !== 1 && (M.linewidth = e.linewidth), e.dashSize !== void 0 && (M.dashSize = e.dashSize), e.gapSize !== void 0 && (M.gapSize = e.gapSize), e.scale !== void 0 && (M.scale = e.scale), e.polygonOffset !== void 0 && (M.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (M.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (M.polygonOffsetUnits = e.polygonOffsetUnits), e.morphTargets !== void 0 && (M.morphTargets = e.morphTargets), e.morphNormals !== void 0 && (M.morphNormals = e.morphNormals), e.dithering !== void 0 && (M.dithering = e.dithering), e.alphaToCoverage !== void 0 && (M.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (M.premultipliedAlpha = e.premultipliedAlpha), e.vertexTangents !== void 0 && (M.vertexTangents = e.vertexTangents), e.visible !== void 0 && (M.visible = e.visible), e.toneMapped !== void 0 && (M.toneMapped = e.toneMapped), e.userData !== void 0 && (M.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? M.vertexColors = e.vertexColors > 0 : M.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const D in e.uniforms) {
        const I = e.uniforms[D];
        switch (M.uniforms[D] = {}, I.type) {
          case "t":
            M.uniforms[D].value = L(I.value);
            break;
          case "c":
            M.uniforms[D].value = new Color().setHex(I.value);
            break;
          case "v2":
            M.uniforms[D].value = new Vector2().fromArray(I.value);
            break;
          case "v3":
            M.uniforms[D].value = new Vector3().fromArray(I.value);
            break;
          case "v4":
            M.uniforms[D].value = new Vector4().fromArray(I.value);
            break;
          case "m3":
            M.uniforms[D].value = new Matrix3().fromArray(I.value);
            break;
          case "m4":
            M.uniforms[D].value = new Matrix4().fromArray(I.value);
            break;
          default:
            M.uniforms[D].value = I.value;
        }
      }
    if (e.defines !== void 0 && (M.defines = e.defines), e.vertexShader !== void 0 && (M.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (M.fragmentShader = e.fragmentShader), e.extensions !== void 0)
      for (const D in e.extensions)
        M.extensions[D] = e.extensions[D];
    if (e.shading !== void 0 && (M.flatShading = e.shading === 1), e.size !== void 0 && (M.size = e.size), e.sizeAttenuation !== void 0 && (M.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (M.map = L(e.map)), e.matcap !== void 0 && (M.matcap = L(e.matcap)), e.alphaMap !== void 0 && (M.alphaMap = L(e.alphaMap)), e.bumpMap !== void 0 && (M.bumpMap = L(e.bumpMap)), e.bumpScale !== void 0 && (M.bumpScale = e.bumpScale), e.normalMap !== void 0 && (M.normalMap = L(e.normalMap)), e.normalMapType !== void 0 && (M.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let D = e.normalScale;
      Array.isArray(D) === !1 && (D = [D, D]), M.normalScale = new Vector2().fromArray(D);
    }
    return e.displacementMap !== void 0 && (M.displacementMap = L(e.displacementMap)), e.displacementScale !== void 0 && (M.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (M.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (M.roughnessMap = L(e.roughnessMap)), e.metalnessMap !== void 0 && (M.metalnessMap = L(e.metalnessMap)), e.emissiveMap !== void 0 && (M.emissiveMap = L(e.emissiveMap)), e.emissiveIntensity !== void 0 && (M.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (M.specularMap = L(e.specularMap)), e.envMap !== void 0 && (M.envMap = L(e.envMap)), e.envMapIntensity !== void 0 && (M.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (M.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (M.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (M.lightMap = L(e.lightMap)), e.lightMapIntensity !== void 0 && (M.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (M.aoMap = L(e.aoMap)), e.aoMapIntensity !== void 0 && (M.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (M.gradientMap = L(e.gradientMap)), e.clearcoatMap !== void 0 && (M.clearcoatMap = L(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (M.clearcoatRoughnessMap = L(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (M.clearcoatNormalMap = L(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (M.clearcoatNormalScale = new Vector2().fromArray(e.clearcoatNormalScale)), e.transmissionMap !== void 0 && (M.transmissionMap = L(e.transmissionMap)), e.thicknessMap !== void 0 && (M.thicknessMap = L(e.thicknessMap)), M;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
}
class LoaderUtils {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let b = "";
    for (let L = 0, M = e.length; L < M; L++)
      b += String.fromCharCode(e[L]);
    try {
      return decodeURIComponent(escape(b));
    } catch {
      return b;
    }
  }
  static extractUrlBase(e) {
    const b = e.lastIndexOf("/");
    return b === -1 ? "./" : e.substr(0, b + 1);
  }
}
class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = super.toJSON(this);
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
InstancedBufferGeometry.prototype.isInstancedBufferGeometry = !0;
class InstancedBufferAttribute extends BufferAttribute {
  constructor(e, b, L, M = 1) {
    typeof L == "number" && (M = L, L = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, b, L), this.meshPerAttribute = M;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
InstancedBufferAttribute.prototype.isInstancedBufferAttribute = !0;
class BufferGeometryLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, b, L, M) {
    const D = this, I = new FileLoader(D.manager);
    I.setPath(D.path), I.setRequestHeader(D.requestHeader), I.setWithCredentials(D.withCredentials), I.load(e, function(F) {
      try {
        b(D.parse(JSON.parse(F)));
      } catch (N) {
        M ? M(N) : console.error(N), D.manager.itemError(e);
      }
    }, L, M);
  }
  parse(e) {
    const b = {}, L = {};
    function M(k, H) {
      if (b[H] !== void 0) return b[H];
      const $ = k.interleavedBuffers[H], j = D(k, $.buffer), q = getTypedArray($.type, j), Y = new InterleavedBuffer(q, $.stride);
      return Y.uuid = $.uuid, b[H] = Y, Y;
    }
    function D(k, H) {
      if (L[H] !== void 0) return L[H];
      const $ = k.arrayBuffers[H], j = new Uint32Array($).buffer;
      return L[H] = j, j;
    }
    const I = e.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry(), F = e.data.index;
    if (F !== void 0) {
      const k = getTypedArray(F.type, F.array);
      I.setIndex(new BufferAttribute(k, 1));
    }
    const N = e.data.attributes;
    for (const k in N) {
      const H = N[k];
      let W;
      if (H.isInterleavedBufferAttribute) {
        const $ = M(e.data, H.data);
        W = new InterleavedBufferAttribute($, H.itemSize, H.offset, H.normalized);
      } else {
        const $ = getTypedArray(H.type, H.array), j = H.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
        W = new j($, H.itemSize, H.normalized);
      }
      H.name !== void 0 && (W.name = H.name), H.usage !== void 0 && W.setUsage(H.usage), H.updateRange !== void 0 && (W.updateRange.offset = H.updateRange.offset, W.updateRange.count = H.updateRange.count), I.setAttribute(k, W);
    }
    const U = e.data.morphAttributes;
    if (U)
      for (const k in U) {
        const H = U[k], W = [];
        for (let $ = 0, j = H.length; $ < j; $++) {
          const q = H[$];
          let Y;
          if (q.isInterleavedBufferAttribute) {
            const J = M(e.data, q.data);
            Y = new InterleavedBufferAttribute(J, q.itemSize, q.offset, q.normalized);
          } else {
            const J = getTypedArray(q.type, q.array);
            Y = new BufferAttribute(J, q.itemSize, q.normalized);
          }
          q.name !== void 0 && (Y.name = q.name), W.push(Y);
        }
        I.morphAttributes[k] = W;
      }
    e.data.morphTargetsRelative && (I.morphTargetsRelative = !0);
    const V = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (V !== void 0)
      for (let k = 0, H = V.length; k !== H; ++k) {
        const W = V[k];
        I.addGroup(W.start, W.count, W.materialIndex);
      }
    const z = e.data.boundingSphere;
    if (z !== void 0) {
      const k = new Vector3();
      z.center !== void 0 && k.fromArray(z.center), I.boundingSphere = new Sphere(k, z.radius);
    }
    return e.name && (I.name = e.name), e.userData && (I.userData = e.userData), I;
  }
}
class ObjectLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, b, L, M) {
    const D = this, I = this.path === "" ? LoaderUtils.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || I;
    const F = new FileLoader(this.manager);
    F.setPath(this.path), F.setRequestHeader(this.requestHeader), F.setWithCredentials(this.withCredentials), F.load(e, function(N) {
      let U = null;
      try {
        U = JSON.parse(N);
      } catch (V) {
        M !== void 0 && M(V), console.error("THREE:ObjectLoader: Can't parse " + e + ".", V.message);
        return;
      }
      const G = U.metadata;
      if (G === void 0 || G.type === void 0 || G.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      D.parse(U, b);
    }, L, M);
  }
  async loadAsync(e, b) {
    const L = this, M = this.path === "" ? LoaderUtils.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || M;
    const D = new FileLoader(this.manager);
    D.setPath(this.path), D.setRequestHeader(this.requestHeader), D.setWithCredentials(this.withCredentials);
    const I = await D.loadAsync(e, b), F = JSON.parse(I), N = F.metadata;
    if (N === void 0 || N.type === void 0 || N.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await L.parseAsync(F);
  }
  parse(e, b) {
    const L = this.parseAnimations(e.animations), M = this.parseShapes(e.shapes), D = this.parseGeometries(e.geometries, M), I = this.parseImages(e.images, function() {
      b !== void 0 && b(U);
    }), F = this.parseTextures(e.textures, I), N = this.parseMaterials(e.materials, F), U = this.parseObject(e.object, D, N, F, L), G = this.parseSkeletons(e.skeletons, U);
    if (this.bindSkeletons(U, G), b !== void 0) {
      let V = !1;
      for (const z in I)
        if (I[z] instanceof HTMLImageElement) {
          V = !0;
          break;
        }
      V === !1 && b(U);
    }
    return U;
  }
  async parseAsync(e) {
    const b = this.parseAnimations(e.animations), L = this.parseShapes(e.shapes), M = this.parseGeometries(e.geometries, L), D = await this.parseImagesAsync(e.images), I = this.parseTextures(e.textures, D), F = this.parseMaterials(e.materials, I), N = this.parseObject(e.object, M, F, I, b), U = this.parseSkeletons(e.skeletons, N);
    return this.bindSkeletons(N, U), N;
  }
  parseShapes(e) {
    const b = {};
    if (e !== void 0)
      for (let L = 0, M = e.length; L < M; L++) {
        const D = new Shape$1().fromJSON(e[L]);
        b[D.uuid] = D;
      }
    return b;
  }
  parseSkeletons(e, b) {
    const L = {}, M = {};
    if (b.traverse(function(D) {
      D.isBone && (M[D.uuid] = D);
    }), e !== void 0)
      for (let D = 0, I = e.length; D < I; D++) {
        const F = new Skeleton().fromJSON(e[D], M);
        L[F.uuid] = F;
      }
    return L;
  }
  parseGeometries(e, b) {
    const L = {};
    if (e !== void 0) {
      const M = new BufferGeometryLoader();
      for (let D = 0, I = e.length; D < I; D++) {
        let F;
        const N = e[D];
        switch (N.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            F = M.parse(N);
            break;
          case "Geometry":
            console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
            break;
          default:
            N.type in Geometries ? F = Geometries[N.type].fromJSON(N, b) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${N.type}"`);
        }
        F.uuid = N.uuid, N.name !== void 0 && (F.name = N.name), F.isBufferGeometry === !0 && N.userData !== void 0 && (F.userData = N.userData), L[N.uuid] = F;
      }
    }
    return L;
  }
  parseMaterials(e, b) {
    const L = {}, M = {};
    if (e !== void 0) {
      const D = new MaterialLoader();
      D.setTextures(b);
      for (let I = 0, F = e.length; I < F; I++) {
        const N = e[I];
        if (N.type === "MultiMaterial") {
          const U = [];
          for (let G = 0; G < N.materials.length; G++) {
            const V = N.materials[G];
            L[V.uuid] === void 0 && (L[V.uuid] = D.parse(V)), U.push(L[V.uuid]);
          }
          M[N.uuid] = U;
        } else
          L[N.uuid] === void 0 && (L[N.uuid] = D.parse(N)), M[N.uuid] = L[N.uuid];
      }
    }
    return M;
  }
  parseAnimations(e) {
    const b = {};
    if (e !== void 0)
      for (let L = 0; L < e.length; L++) {
        const M = e[L], D = AnimationClip.parse(M);
        b[D.uuid] = D;
      }
    return b;
  }
  parseImages(e, b) {
    const L = this, M = {};
    let D;
    function I(N) {
      return L.manager.itemStart(N), D.load(N, function() {
        L.manager.itemEnd(N);
      }, void 0, function() {
        L.manager.itemError(N), L.manager.itemEnd(N);
      });
    }
    function F(N) {
      if (typeof N == "string") {
        const U = N, G = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(U) ? U : L.resourcePath + U;
        return I(G);
      } else
        return N.data ? {
          data: getTypedArray(N.type, N.data),
          width: N.width,
          height: N.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const N = new LoadingManager(b);
      D = new ImageLoader(N), D.setCrossOrigin(this.crossOrigin);
      for (let U = 0, G = e.length; U < G; U++) {
        const V = e[U], z = V.url;
        if (Array.isArray(z)) {
          M[V.uuid] = [];
          for (let k = 0, H = z.length; k < H; k++) {
            const W = z[k], $ = F(W);
            $ !== null && ($ instanceof HTMLImageElement ? M[V.uuid].push($) : M[V.uuid].push(new DataTexture($.data, $.width, $.height)));
          }
        } else {
          const k = F(V.url);
          k !== null && (M[V.uuid] = k);
        }
      }
    }
    return M;
  }
  async parseImagesAsync(e) {
    const b = this, L = {};
    let M;
    async function D(I) {
      if (typeof I == "string") {
        const F = I, N = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(F) ? F : b.resourcePath + F;
        return await M.loadAsync(N);
      } else
        return I.data ? {
          data: getTypedArray(I.type, I.data),
          width: I.width,
          height: I.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      M = new ImageLoader(this.manager), M.setCrossOrigin(this.crossOrigin);
      for (let I = 0, F = e.length; I < F; I++) {
        const N = e[I], U = N.url;
        if (Array.isArray(U)) {
          L[N.uuid] = [];
          for (let G = 0, V = U.length; G < V; G++) {
            const z = U[G], k = await D(z);
            k !== null && (k instanceof HTMLImageElement ? L[N.uuid].push(k) : L[N.uuid].push(new DataTexture(k.data, k.width, k.height)));
          }
        } else {
          const G = await D(N.url);
          G !== null && (L[N.uuid] = G);
        }
      }
    }
    return L;
  }
  parseTextures(e, b) {
    function L(D, I) {
      return typeof D == "number" ? D : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", D), I[D]);
    }
    const M = {};
    if (e !== void 0)
      for (let D = 0, I = e.length; D < I; D++) {
        const F = e[D];
        F.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', F.uuid), b[F.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", F.image);
        let N;
        const U = b[F.image];
        Array.isArray(U) ? (N = new CubeTexture(U), U.length === 6 && (N.needsUpdate = !0)) : (U && U.data ? N = new DataTexture(U.data, U.width, U.height) : N = new Texture(U), U && (N.needsUpdate = !0)), N.uuid = F.uuid, F.name !== void 0 && (N.name = F.name), F.mapping !== void 0 && (N.mapping = L(F.mapping, TEXTURE_MAPPING)), F.offset !== void 0 && N.offset.fromArray(F.offset), F.repeat !== void 0 && N.repeat.fromArray(F.repeat), F.center !== void 0 && N.center.fromArray(F.center), F.rotation !== void 0 && (N.rotation = F.rotation), F.wrap !== void 0 && (N.wrapS = L(F.wrap[0], TEXTURE_WRAPPING), N.wrapT = L(F.wrap[1], TEXTURE_WRAPPING)), F.format !== void 0 && (N.format = F.format), F.type !== void 0 && (N.type = F.type), F.encoding !== void 0 && (N.encoding = F.encoding), F.minFilter !== void 0 && (N.minFilter = L(F.minFilter, TEXTURE_FILTER)), F.magFilter !== void 0 && (N.magFilter = L(F.magFilter, TEXTURE_FILTER)), F.anisotropy !== void 0 && (N.anisotropy = F.anisotropy), F.flipY !== void 0 && (N.flipY = F.flipY), F.premultiplyAlpha !== void 0 && (N.premultiplyAlpha = F.premultiplyAlpha), F.unpackAlignment !== void 0 && (N.unpackAlignment = F.unpackAlignment), M[F.uuid] = N;
      }
    return M;
  }
  parseObject(e, b, L, M, D) {
    let I;
    function F(z) {
      return b[z] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", z), b[z];
    }
    function N(z) {
      if (z !== void 0) {
        if (Array.isArray(z)) {
          const k = [];
          for (let H = 0, W = z.length; H < W; H++) {
            const $ = z[H];
            L[$] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", $), k.push(L[$]);
          }
          return k;
        }
        return L[z] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", z), L[z];
      }
    }
    function U(z) {
      return M[z] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", z), M[z];
    }
    let G, V;
    switch (e.type) {
      case "Scene":
        I = new Scene$1(), e.background !== void 0 && (Number.isInteger(e.background) ? I.background = new Color(e.background) : I.background = U(e.background)), e.environment !== void 0 && (I.environment = U(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? I.fog = new Fog(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (I.fog = new FogExp2(e.fog.color, e.fog.density)));
        break;
      case "PerspectiveCamera":
        I = new PerspectiveCamera(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (I.focus = e.focus), e.zoom !== void 0 && (I.zoom = e.zoom), e.filmGauge !== void 0 && (I.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (I.filmOffset = e.filmOffset), e.view !== void 0 && (I.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        I = new OrthographicCamera(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (I.zoom = e.zoom), e.view !== void 0 && (I.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        I = new AmbientLight(e.color, e.intensity);
        break;
      case "DirectionalLight":
        I = new DirectionalLight(e.color, e.intensity);
        break;
      case "PointLight":
        I = new PointLight(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        I = new RectAreaLight(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        I = new SpotLight(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        I = new HemisphereLight(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        I = new LightProbe().fromJSON(e);
        break;
      case "SkinnedMesh":
        G = F(e.geometry), V = N(e.material), I = new SkinnedMesh(G, V), e.bindMode !== void 0 && (I.bindMode = e.bindMode), e.bindMatrix !== void 0 && I.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (I.skeleton = e.skeleton);
        break;
      case "Mesh":
        G = F(e.geometry), V = N(e.material), I = new Mesh(G, V);
        break;
      case "InstancedMesh":
        G = F(e.geometry), V = N(e.material);
        const z = e.count, k = e.instanceMatrix, H = e.instanceColor;
        I = new InstancedMesh(G, V, z), I.instanceMatrix = new BufferAttribute(new Float32Array(k.array), 16), H !== void 0 && (I.instanceColor = new BufferAttribute(new Float32Array(H.array), H.itemSize));
        break;
      case "LOD":
        I = new LOD();
        break;
      case "Line":
        I = new Line(F(e.geometry), N(e.material));
        break;
      case "LineLoop":
        I = new LineLoop(F(e.geometry), N(e.material));
        break;
      case "LineSegments":
        I = new LineSegments(F(e.geometry), N(e.material));
        break;
      case "PointCloud":
      case "Points":
        I = new Points(F(e.geometry), N(e.material));
        break;
      case "Sprite":
        I = new Sprite(N(e.material));
        break;
      case "Group":
        I = new Group();
        break;
      case "Bone":
        I = new Bone();
        break;
      default:
        I = new Object3D();
    }
    if (I.uuid = e.uuid, e.name !== void 0 && (I.name = e.name), e.matrix !== void 0 ? (I.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (I.matrixAutoUpdate = e.matrixAutoUpdate), I.matrixAutoUpdate && I.matrix.decompose(I.position, I.quaternion, I.scale)) : (e.position !== void 0 && I.position.fromArray(e.position), e.rotation !== void 0 && I.rotation.fromArray(e.rotation), e.quaternion !== void 0 && I.quaternion.fromArray(e.quaternion), e.scale !== void 0 && I.scale.fromArray(e.scale)), e.castShadow !== void 0 && (I.castShadow = e.castShadow), e.receiveShadow !== void 0 && (I.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (I.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (I.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (I.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && I.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (I.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (I.visible = e.visible), e.frustumCulled !== void 0 && (I.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (I.renderOrder = e.renderOrder), e.userData !== void 0 && (I.userData = e.userData), e.layers !== void 0 && (I.layers.mask = e.layers), e.children !== void 0) {
      const z = e.children;
      for (let k = 0; k < z.length; k++)
        I.add(this.parseObject(z[k], b, L, M, D));
    }
    if (e.animations !== void 0) {
      const z = e.animations;
      for (let k = 0; k < z.length; k++) {
        const H = z[k];
        I.animations.push(D[H]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (I.autoUpdate = e.autoUpdate);
      const z = e.levels;
      for (let k = 0; k < z.length; k++) {
        const H = z[k], W = I.getObjectByProperty("uuid", H.object);
        W !== void 0 && I.addLevel(W, H.distance);
      }
    }
    return I;
  }
  bindSkeletons(e, b) {
    Object.keys(b).length !== 0 && e.traverse(function(L) {
      if (L.isSkinnedMesh === !0 && L.skeleton !== void 0) {
        const M = b[L.skeleton];
        M === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", L.skeleton) : L.bind(M, L.bindMatrix);
      }
    });
  }
  /* DEPRECATED */
  setTexturePath(e) {
    return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e);
  }
}
const TEXTURE_MAPPING = {
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  CubeUVReflectionMapping,
  CubeUVRefractionMapping
}, TEXTURE_WRAPPING = {
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping
}, TEXTURE_FILTER = {
  NearestFilter,
  NearestMipmapNearestFilter,
  NearestMipmapLinearFilter,
  LinearFilter,
  LinearMipmapNearestFilter,
  LinearMipmapLinearFilter
};
class ImageBitmapLoader extends Loader {
  constructor(e) {
    super(e), typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, b, L, M) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const D = this, I = Cache.get(e);
    if (I !== void 0)
      return D.manager.itemStart(e), setTimeout(function() {
        b && b(I), D.manager.itemEnd(e);
      }, 0), I;
    const F = {};
    F.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", F.headers = this.requestHeader, fetch(e, F).then(function(N) {
      return N.blob();
    }).then(function(N) {
      return createImageBitmap(N, Object.assign(D.options, { colorSpaceConversion: "none" }));
    }).then(function(N) {
      Cache.add(e, N), b && b(N), D.manager.itemEnd(e);
    }).catch(function(N) {
      M && M(N), D.manager.itemError(e), D.manager.itemEnd(e);
    }), D.manager.itemStart(e);
  }
}
ImageBitmapLoader.prototype.isImageBitmapLoader = !0;
class ShapePath {
  constructor() {
    this.type = "ShapePath", this.color = new Color(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, b) {
    return this.currentPath = new Path(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, b), this;
  }
  lineTo(e, b) {
    return this.currentPath.lineTo(e, b), this;
  }
  quadraticCurveTo(e, b, L, M) {
    return this.currentPath.quadraticCurveTo(e, b, L, M), this;
  }
  bezierCurveTo(e, b, L, M, D, I) {
    return this.currentPath.bezierCurveTo(e, b, L, M, D, I), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e, b) {
    function L(q) {
      const Y = [];
      for (let J = 0, K = q.length; J < K; J++) {
        const X = q[J], Z = new Shape$1();
        Z.curves = X.curves, Y.push(Z);
      }
      return Y;
    }
    function M(q, Y) {
      const J = Y.length;
      let K = !1;
      for (let X = J - 1, Z = 0; Z < J; X = Z++) {
        let Q = Y[X], ne = Y[Z], le = ne.x - Q.x, pe = ne.y - Q.y;
        if (Math.abs(pe) > Number.EPSILON) {
          if (pe < 0 && (Q = Y[Z], le = -le, ne = Y[X], pe = -pe), q.y < Q.y || q.y > ne.y) continue;
          if (q.y === Q.y) {
            if (q.x === Q.x) return !0;
          } else {
            const ue = pe * (q.x - Q.x) - le * (q.y - Q.y);
            if (ue === 0) return !0;
            if (ue < 0) continue;
            K = !K;
          }
        } else {
          if (q.y !== Q.y) continue;
          if (ne.x <= q.x && q.x <= Q.x || Q.x <= q.x && q.x <= ne.x) return !0;
        }
      }
      return K;
    }
    const D = ShapeUtils.isClockWise, I = this.subPaths;
    if (I.length === 0) return [];
    if (b === !0) return L(I);
    let F, N, U;
    const G = [];
    if (I.length === 1)
      return N = I[0], U = new Shape$1(), U.curves = N.curves, G.push(U), G;
    let V = !D(I[0].getPoints());
    V = e ? !V : V;
    const z = [], k = [];
    let H = [], W = 0, $;
    k[W] = void 0, H[W] = [];
    for (let q = 0, Y = I.length; q < Y; q++)
      N = I[q], $ = N.getPoints(), F = D($), F = e ? !F : F, F ? (!V && k[W] && W++, k[W] = { s: new Shape$1(), p: $ }, k[W].s.curves = N.curves, V && W++, H[W] = []) : H[W].push({ h: N, p: $[0] });
    if (!k[0]) return L(I);
    if (k.length > 1) {
      let q = !1;
      const Y = [];
      for (let J = 0, K = k.length; J < K; J++)
        z[J] = [];
      for (let J = 0, K = k.length; J < K; J++) {
        const X = H[J];
        for (let Z = 0; Z < X.length; Z++) {
          const Q = X[Z];
          let ne = !0;
          for (let le = 0; le < k.length; le++)
            M(Q.p, k[le].p) && (J !== le && Y.push({ froms: J, tos: le, hole: Z }), ne ? (ne = !1, z[le].push(Q)) : q = !0);
          ne && z[J].push(Q);
        }
      }
      Y.length > 0 && (q || (H = z));
    }
    let j;
    for (let q = 0, Y = k.length; q < Y; q++) {
      U = k[q].s, G.push(U), j = H[q];
      for (let J = 0, K = j.length; J < K; J++)
        U.holes.push(j[J].h);
    }
    return G;
  }
}
class Font {
  constructor(e) {
    this.type = "Font", this.data = e;
  }
  generateShapes(e, b = 100) {
    const L = [], M = createPaths(e, b, this.data);
    for (let D = 0, I = M.length; D < I; D++)
      Array.prototype.push.apply(L, M[D].toShapes());
    return L;
  }
}
function createPaths(B, e, b) {
  const L = Array.from(B), M = e / b.resolution, D = (b.boundingBox.yMax - b.boundingBox.yMin + b.underlineThickness) * M, I = [];
  let F = 0, N = 0;
  for (let U = 0; U < L.length; U++) {
    const G = L[U];
    if (G === `
`)
      F = 0, N -= D;
    else {
      const V = createPath(G, M, F, N, b);
      F += V.offsetX, I.push(V.path);
    }
  }
  return I;
}
function createPath(B, e, b, L, M) {
  const D = M.glyphs[B] || M.glyphs["?"];
  if (!D) {
    console.error('THREE.Font: character "' + B + '" does not exists in font family ' + M.familyName + ".");
    return;
  }
  const I = new ShapePath();
  let F, N, U, G, V, z, k, H;
  if (D.o) {
    const W = D._cachedOutline || (D._cachedOutline = D.o.split(" "));
    for (let $ = 0, j = W.length; $ < j; )
      switch (W[$++]) {
        case "m":
          F = W[$++] * e + b, N = W[$++] * e + L, I.moveTo(F, N);
          break;
        case "l":
          F = W[$++] * e + b, N = W[$++] * e + L, I.lineTo(F, N);
          break;
        case "q":
          U = W[$++] * e + b, G = W[$++] * e + L, V = W[$++] * e + b, z = W[$++] * e + L, I.quadraticCurveTo(V, z, U, G);
          break;
        case "b":
          U = W[$++] * e + b, G = W[$++] * e + L, V = W[$++] * e + b, z = W[$++] * e + L, k = W[$++] * e + b, H = W[$++] * e + L, I.bezierCurveTo(V, z, k, H, U, G);
          break;
      }
  }
  return { offsetX: D.ha * e, path: I };
}
Font.prototype.isFont = !0;
class FontLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, b, L, M) {
    const D = this, I = new FileLoader(this.manager);
    I.setPath(this.path), I.setRequestHeader(this.requestHeader), I.setWithCredentials(D.withCredentials), I.load(e, function(F) {
      let N;
      try {
        N = JSON.parse(F);
      } catch {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), N = JSON.parse(F.substring(65, F.length - 2));
      }
      const U = D.parse(N);
      b && b(U);
    }, L, M);
  }
  parse(e) {
    return new Font(e);
  }
}
let _context;
const AudioContext = {
  getContext: function() {
    return _context === void 0 && (_context = new (window.AudioContext || window.webkitAudioContext)()), _context;
  },
  setContext: function(B) {
    _context = B;
  }
};
class AudioLoader extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, b, L, M) {
    const D = this, I = new FileLoader(this.manager);
    I.setResponseType("arraybuffer"), I.setPath(this.path), I.setRequestHeader(this.requestHeader), I.setWithCredentials(this.withCredentials), I.load(e, function(F) {
      try {
        const N = F.slice(0);
        AudioContext.getContext().decodeAudioData(N, function(G) {
          b(G);
        });
      } catch (N) {
        M ? M(N) : console.error(N), D.manager.itemError(e);
      }
    }, L, M);
  }
}
class HemisphereLightProbe extends LightProbe {
  constructor(e, b, L = 1) {
    super(void 0, L);
    const M = new Color().set(e), D = new Color().set(b), I = new Vector3(M.r, M.g, M.b), F = new Vector3(D.r, D.g, D.b), N = Math.sqrt(Math.PI), U = N * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(I).add(F).multiplyScalar(N), this.sh.coefficients[1].copy(I).sub(F).multiplyScalar(U);
  }
}
HemisphereLightProbe.prototype.isHemisphereLightProbe = !0;
class AmbientLightProbe extends LightProbe {
  constructor(e, b = 1) {
    super(void 0, b);
    const L = new Color().set(e);
    this.sh.coefficients[0].set(L.r, L.g, L.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
AmbientLightProbe.prototype.isAmbientLightProbe = !0;
const _eyeRight = /* @__PURE__ */ new Matrix4(), _eyeLeft = /* @__PURE__ */ new Matrix4();
class StereoCamera {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new PerspectiveCamera(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new PerspectiveCamera(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const b = this._cache;
    if (b.focus !== e.focus || b.fov !== e.fov || b.aspect !== e.aspect * this.aspect || b.near !== e.near || b.far !== e.far || b.zoom !== e.zoom || b.eyeSep !== this.eyeSep) {
      b.focus = e.focus, b.fov = e.fov, b.aspect = e.aspect * this.aspect, b.near = e.near, b.far = e.far, b.zoom = e.zoom, b.eyeSep = this.eyeSep;
      const M = e.projectionMatrix.clone(), D = b.eyeSep / 2, I = D * b.near / b.focus, F = b.near * Math.tan(DEG2RAD * b.fov * 0.5) / b.zoom;
      let N, U;
      _eyeLeft.elements[12] = -D, _eyeRight.elements[12] = D, N = -F * b.aspect + I, U = F * b.aspect + I, M.elements[0] = 2 * b.near / (U - N), M.elements[8] = (U + N) / (U - N), this.cameraL.projectionMatrix.copy(M), N = -F * b.aspect - I, U = F * b.aspect - I, M.elements[0] = 2 * b.near / (U - N), M.elements[8] = (U + N) / (U - N), this.cameraR.projectionMatrix.copy(M);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(_eyeLeft), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(_eyeRight);
  }
}
class Clock {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = now$3(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const b = now$3();
      e = (b - this.oldTime) / 1e3, this.oldTime = b, this.elapsedTime += e;
    }
    return e;
  }
}
function now$3() {
  return (typeof performance > "u" ? Date : performance).now();
}
const _position$1 = /* @__PURE__ */ new Vector3(), _quaternion$1 = /* @__PURE__ */ new Quaternion(), _scale$1 = /* @__PURE__ */ new Vector3(), _orientation$1 = /* @__PURE__ */ new Vector3();
class AudioListener extends Object3D {
  constructor() {
    super(), this.type = "AudioListener", this.context = AudioContext.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Clock();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const b = this.context.listener, L = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1), _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1), b.positionX) {
      const M = this.context.currentTime + this.timeDelta;
      b.positionX.linearRampToValueAtTime(_position$1.x, M), b.positionY.linearRampToValueAtTime(_position$1.y, M), b.positionZ.linearRampToValueAtTime(_position$1.z, M), b.forwardX.linearRampToValueAtTime(_orientation$1.x, M), b.forwardY.linearRampToValueAtTime(_orientation$1.y, M), b.forwardZ.linearRampToValueAtTime(_orientation$1.z, M), b.upX.linearRampToValueAtTime(L.x, M), b.upY.linearRampToValueAtTime(L.y, M), b.upZ.linearRampToValueAtTime(L.z, M);
    } else
      b.setPosition(_position$1.x, _position$1.y, _position$1.z), b.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, L.x, L.y, L.z);
  }
}
let Audio$1 = class extends Object3D {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const b = this.context.createBufferSource();
    return b.buffer = this.buffer, b.loop = this.loop, b.loopStart = this.loopStart, b.loopEnd = this.loopEnd, b.onended = this.onEnded.bind(this), b.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = b, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, b = this.filters.length; e < b; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let e = 1, b = this.filters.length; e < b; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else
      this.source.disconnect(this.getOutput());
    return this._connected = !1, this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
};
const _position = /* @__PURE__ */ new Vector3(), _quaternion = /* @__PURE__ */ new Quaternion(), _scale = /* @__PURE__ */ new Vector3(), _orientation = /* @__PURE__ */ new Vector3();
class PositionalAudio extends Audio$1 {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, b, L) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = b, this.panner.coneOuterGain = L, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
    this.matrixWorld.decompose(_position, _quaternion, _scale), _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
    const b = this.panner;
    if (b.positionX) {
      const L = this.context.currentTime + this.listener.timeDelta;
      b.positionX.linearRampToValueAtTime(_position.x, L), b.positionY.linearRampToValueAtTime(_position.y, L), b.positionZ.linearRampToValueAtTime(_position.z, L), b.orientationX.linearRampToValueAtTime(_orientation.x, L), b.orientationY.linearRampToValueAtTime(_orientation.y, L), b.orientationZ.linearRampToValueAtTime(_orientation.z, L);
    } else
      b.setPosition(_position.x, _position.y, _position.z), b.setOrientation(_orientation.x, _orientation.y, _orientation.z);
  }
}
class AudioAnalyser {
  constructor(e, b = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = b, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const b = this.getFrequencyData();
    for (let L = 0; L < b.length; L++)
      e += b[L];
    return e / b.length;
  }
}
class PropertyMixer {
  constructor(e, b, L) {
    this.binding = e, this.valueSize = L;
    let M, D, I;
    switch (b) {
      case "quaternion":
        M = this._slerp, D = this._slerpAdditive, I = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(L * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        M = this._select, D = this._select, I = this._setAdditiveIdentityOther, this.buffer = new Array(L * 5);
        break;
      default:
        M = this._lerp, D = this._lerpAdditive, I = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(L * 5);
    }
    this._mixBufferRegion = M, this._mixBufferRegionAdditive = D, this._setIdentity = I, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, b) {
    const L = this.buffer, M = this.valueSize, D = e * M + M;
    let I = this.cumulativeWeight;
    if (I === 0) {
      for (let F = 0; F !== M; ++F)
        L[D + F] = L[F];
      I = b;
    } else {
      I += b;
      const F = b / I;
      this._mixBufferRegion(L, D, 0, F, M);
    }
    this.cumulativeWeight = I;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const b = this.buffer, L = this.valueSize, M = L * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(b, M, 0, e, L), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const b = this.valueSize, L = this.buffer, M = e * b + b, D = this.cumulativeWeight, I = this.cumulativeWeightAdditive, F = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, D < 1) {
      const N = b * this._origIndex;
      this._mixBufferRegion(
        L,
        M,
        N,
        1 - D,
        b
      );
    }
    I > 0 && this._mixBufferRegionAdditive(L, M, this._addIndex * b, 1, b);
    for (let N = b, U = b + b; N !== U; ++N)
      if (L[N] !== L[N + b]) {
        F.setValue(L, M);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, b = this.buffer, L = this.valueSize, M = L * this._origIndex;
    e.getValue(b, M);
    for (let D = L, I = M; D !== I; ++D)
      b[D] = b[M + D % L];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, b = e + this.valueSize;
    for (let L = e; L < b; L++)
      this.buffer[L] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, b = this._addIndex * this.valueSize;
    for (let L = 0; L < this.valueSize; L++)
      this.buffer[b + L] = this.buffer[e + L];
  }
  // mix functions
  _select(e, b, L, M, D) {
    if (M >= 0.5)
      for (let I = 0; I !== D; ++I)
        e[b + I] = e[L + I];
  }
  _slerp(e, b, L, M) {
    Quaternion.slerpFlat(e, b, e, b, e, L, M);
  }
  _slerpAdditive(e, b, L, M, D) {
    const I = this._workIndex * D;
    Quaternion.multiplyQuaternionsFlat(e, I, e, b, e, L), Quaternion.slerpFlat(e, b, e, b, e, I, M);
  }
  _lerp(e, b, L, M, D) {
    const I = 1 - M;
    for (let F = 0; F !== D; ++F) {
      const N = b + F;
      e[N] = e[N] * I + e[L + F] * M;
    }
  }
  _lerpAdditive(e, b, L, M, D) {
    for (let I = 0; I !== D; ++I) {
      const F = b + I;
      e[F] = e[F] + e[L + I] * M;
    }
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/", _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g"), _wordChar = "[^" + _RESERVED_CHARS_RE + "]", _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]", _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar), _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot), _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar), _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar), _trackRe = new RegExp(
  "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
), _supportedObjectNames = ["material", "materials", "bones"];
class Composite {
  constructor(e, b, L) {
    const M = L || PropertyBinding.parseTrackName(b);
    this._targetGroup = e, this._bindings = e.subscribe_(b, M);
  }
  getValue(e, b) {
    this.bind();
    const L = this._targetGroup.nCachedObjects_, M = this._bindings[L];
    M !== void 0 && M.getValue(e, b);
  }
  setValue(e, b) {
    const L = this._bindings;
    for (let M = this._targetGroup.nCachedObjects_, D = L.length; M !== D; ++M)
      L[M].setValue(e, b);
  }
  bind() {
    const e = this._bindings;
    for (let b = this._targetGroup.nCachedObjects_, L = e.length; b !== L; ++b)
      e[b].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let b = this._targetGroup.nCachedObjects_, L = e.length; b !== L; ++b)
      e[b].unbind();
  }
}
class PropertyBinding {
  constructor(e, b, L) {
    this.path = b, this.parsedPath = L || PropertyBinding.parseTrackName(b), this.node = PropertyBinding.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, b, L) {
    return e && e.isAnimationObjectGroup ? new PropertyBinding.Composite(e, b, L) : new PropertyBinding(e, b, L);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(e) {
    const b = _trackRe.exec(e);
    if (!b)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const L = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: b[2],
      objectName: b[3],
      objectIndex: b[4],
      propertyName: b[5],
      // required
      propertyIndex: b[6]
    }, M = L.nodeName && L.nodeName.lastIndexOf(".");
    if (M !== void 0 && M !== -1) {
      const D = L.nodeName.substring(M + 1);
      _supportedObjectNames.indexOf(D) !== -1 && (L.nodeName = L.nodeName.substring(0, M), L.objectName = D);
    }
    if (L.propertyName === null || L.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return L;
  }
  static findNode(e, b) {
    if (!b || b === "" || b === "." || b === -1 || b === e.name || b === e.uuid)
      return e;
    if (e.skeleton) {
      const L = e.skeleton.getBoneByName(b);
      if (L !== void 0)
        return L;
    }
    if (e.children) {
      const L = function(D) {
        for (let I = 0; I < D.length; I++) {
          const F = D[I];
          if (F.name === b || F.uuid === b)
            return F;
          const N = L(F.children);
          if (N) return N;
        }
        return null;
      }, M = L(e.children);
      if (M)
        return M;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, b) {
    e[b] = this.node[this.propertyName];
  }
  _getValue_array(e, b) {
    const L = this.resolvedProperty;
    for (let M = 0, D = L.length; M !== D; ++M)
      e[b++] = L[M];
  }
  _getValue_arrayElement(e, b) {
    e[b] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, b) {
    this.resolvedProperty.toArray(e, b);
  }
  // Direct
  _setValue_direct(e, b) {
    this.targetObject[this.propertyName] = e[b];
  }
  _setValue_direct_setNeedsUpdate(e, b) {
    this.targetObject[this.propertyName] = e[b], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, b) {
    this.targetObject[this.propertyName] = e[b], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, b) {
    const L = this.resolvedProperty;
    for (let M = 0, D = L.length; M !== D; ++M)
      L[M] = e[b++];
  }
  _setValue_array_setNeedsUpdate(e, b) {
    const L = this.resolvedProperty;
    for (let M = 0, D = L.length; M !== D; ++M)
      L[M] = e[b++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, b) {
    const L = this.resolvedProperty;
    for (let M = 0, D = L.length; M !== D; ++M)
      L[M] = e[b++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, b) {
    this.resolvedProperty[this.propertyIndex] = e[b];
  }
  _setValue_arrayElement_setNeedsUpdate(e, b) {
    this.resolvedProperty[this.propertyIndex] = e[b], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, b) {
    this.resolvedProperty[this.propertyIndex] = e[b], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, b) {
    this.resolvedProperty.fromArray(e, b);
  }
  _setValue_fromArray_setNeedsUpdate(e, b) {
    this.resolvedProperty.fromArray(e, b), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, b) {
    this.resolvedProperty.fromArray(e, b), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, b) {
    this.bind(), this.getValue(e, b);
  }
  _setValue_unbound(e, b) {
    this.bind(), this.setValue(e, b);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const b = this.parsedPath, L = b.objectName, M = b.propertyName;
    let D = b.propertyIndex;
    if (e || (e = PropertyBinding.findNode(this.rootNode, b.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (L) {
      let U = b.objectIndex;
      switch (L) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let G = 0; G < e.length; G++)
            if (e[G].name === U) {
              U = G;
              break;
            }
          break;
        default:
          if (e[L] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[L];
      }
      if (U !== void 0) {
        if (e[U] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[U];
      }
    }
    const I = e[M];
    if (I === void 0) {
      const U = b.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + U + "." + M + " but it wasn't found.", e);
      return;
    }
    let F = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? F = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (F = this.Versioning.MatrixWorldNeedsUpdate);
    let N = this.BindingType.Direct;
    if (D !== void 0) {
      if (M === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (e.geometry.isBufferGeometry) {
          if (!e.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          e.morphTargetDictionary[D] !== void 0 && (D = e.morphTargetDictionary[D]);
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      N = this.BindingType.ArrayElement, this.resolvedProperty = I, this.propertyIndex = D;
    } else I.fromArray !== void 0 && I.toArray !== void 0 ? (N = this.BindingType.HasFromToArray, this.resolvedProperty = I) : Array.isArray(I) ? (N = this.BindingType.EntireArray, this.resolvedProperty = I) : this.propertyName = M;
    this.getValue = this.GetterByBindingType[N], this.setValue = this.SetterByBindingTypeAndVersioning[N][F];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class AnimationObjectGroup {
  constructor() {
    this.uuid = generateUUID$1(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let L = 0, M = arguments.length; L !== M; ++L)
      e[arguments[L].uuid] = L;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const b = this;
    this.stats = {
      objects: {
        get total() {
          return b._objects.length;
        },
        get inUse() {
          return this.total - b.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return b._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, b = this._indicesByUUID, L = this._paths, M = this._parsedPaths, D = this._bindings, I = D.length;
    let F, N = e.length, U = this.nCachedObjects_;
    for (let G = 0, V = arguments.length; G !== V; ++G) {
      const z = arguments[G], k = z.uuid;
      let H = b[k];
      if (H === void 0) {
        H = N++, b[k] = H, e.push(z);
        for (let W = 0, $ = I; W !== $; ++W)
          D[W].push(new PropertyBinding(z, L[W], M[W]));
      } else if (H < U) {
        F = e[H];
        const W = --U, $ = e[W];
        b[$.uuid] = H, e[H] = $, b[k] = W, e[W] = z;
        for (let j = 0, q = I; j !== q; ++j) {
          const Y = D[j], J = Y[W];
          let K = Y[H];
          Y[H] = J, K === void 0 && (K = new PropertyBinding(z, L[j], M[j])), Y[W] = K;
        }
      } else e[H] !== F && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = U;
  }
  remove() {
    const e = this._objects, b = this._indicesByUUID, L = this._bindings, M = L.length;
    let D = this.nCachedObjects_;
    for (let I = 0, F = arguments.length; I !== F; ++I) {
      const N = arguments[I], U = N.uuid, G = b[U];
      if (G !== void 0 && G >= D) {
        const V = D++, z = e[V];
        b[z.uuid] = G, e[G] = z, b[U] = V, e[V] = N;
        for (let k = 0, H = M; k !== H; ++k) {
          const W = L[k], $ = W[V], j = W[G];
          W[G] = $, W[V] = j;
        }
      }
    }
    this.nCachedObjects_ = D;
  }
  // remove & forget
  uncache() {
    const e = this._objects, b = this._indicesByUUID, L = this._bindings, M = L.length;
    let D = this.nCachedObjects_, I = e.length;
    for (let F = 0, N = arguments.length; F !== N; ++F) {
      const U = arguments[F], G = U.uuid, V = b[G];
      if (V !== void 0)
        if (delete b[G], V < D) {
          const z = --D, k = e[z], H = --I, W = e[H];
          b[k.uuid] = V, e[V] = k, b[W.uuid] = z, e[z] = W, e.pop();
          for (let $ = 0, j = M; $ !== j; ++$) {
            const q = L[$], Y = q[z], J = q[H];
            q[V] = Y, q[z] = J, q.pop();
          }
        } else {
          const z = --I, k = e[z];
          z > 0 && (b[k.uuid] = V), e[V] = k, e.pop();
          for (let H = 0, W = M; H !== W; ++H) {
            const $ = L[H];
            $[V] = $[z], $.pop();
          }
        }
    }
    this.nCachedObjects_ = D;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, b) {
    const L = this._bindingsIndicesByPath;
    let M = L[e];
    const D = this._bindings;
    if (M !== void 0) return D[M];
    const I = this._paths, F = this._parsedPaths, N = this._objects, U = N.length, G = this.nCachedObjects_, V = new Array(U);
    M = D.length, L[e] = M, I.push(e), F.push(b), D.push(V);
    for (let z = G, k = N.length; z !== k; ++z) {
      const H = N[z];
      V[z] = new PropertyBinding(H, e, b);
    }
    return V;
  }
  unsubscribe_(e) {
    const b = this._bindingsIndicesByPath, L = b[e];
    if (L !== void 0) {
      const M = this._paths, D = this._parsedPaths, I = this._bindings, F = I.length - 1, N = I[F], U = e[F];
      b[U] = L, I[L] = N, I.pop(), D[L] = D[F], D.pop(), M[L] = M[F], M.pop();
    }
  }
}
AnimationObjectGroup.prototype.isAnimationObjectGroup = !0;
class AnimationAction {
  constructor(e, b, L = null, M = b.blendMode) {
    this._mixer = e, this._clip = b, this._localRoot = L, this.blendMode = M;
    const D = b.tracks, I = D.length, F = new Array(I), N = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let U = 0; U !== I; ++U) {
      const G = D[U].createInterpolant(null);
      F[U] = G, G.settings = N;
    }
    this._interpolantSettings = N, this._interpolants = F, this._propertyBindings = new Array(I), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = LoopRepeat, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, b) {
    return this.loop = e, this.repetitions = b, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, b, L) {
    if (e.fadeOut(b), this.fadeIn(b), L) {
      const M = this._clip.duration, D = e._clip.duration, I = D / M, F = M / D;
      e.warp(1, I, b), this.warp(F, 1, b);
    }
    return this;
  }
  crossFadeTo(e, b, L) {
    return e.crossFadeFrom(this, b, L);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, b, L) {
    const M = this._mixer, D = M.time, I = this.timeScale;
    let F = this._timeScaleInterpolant;
    F === null && (F = M._lendControlInterpolant(), this._timeScaleInterpolant = F);
    const N = F.parameterPositions, U = F.sampleValues;
    return N[0] = D, N[1] = D + L, U[0] = e / I, U[1] = b / I, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, b, L, M) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const D = this._startTime;
    if (D !== null) {
      const N = (e - D) * L;
      if (N < 0 || L === 0)
        return;
      this._startTime = null, b = L * N;
    }
    b *= this._updateTimeScale(e);
    const I = this._updateTime(b), F = this._updateWeight(e);
    if (F > 0) {
      const N = this._interpolants, U = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let G = 0, V = N.length; G !== V; ++G)
            N[G].evaluate(I), U[G].accumulateAdditive(F);
          break;
        case NormalAnimationBlendMode:
        default:
          for (let G = 0, V = N.length; G !== V; ++G)
            N[G].evaluate(I), U[G].accumulate(M, F);
      }
    }
  }
  _updateWeight(e) {
    let b = 0;
    if (this.enabled) {
      b = this.weight;
      const L = this._weightInterpolant;
      if (L !== null) {
        const M = L.evaluate(e)[0];
        b *= M, e > L.parameterPositions[1] && (this.stopFading(), M === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = b, b;
  }
  _updateTimeScale(e) {
    let b = 0;
    if (!this.paused) {
      b = this.timeScale;
      const L = this._timeScaleInterpolant;
      if (L !== null) {
        const M = L.evaluate(e)[0];
        b *= M, e > L.parameterPositions[1] && (this.stopWarping(), b === 0 ? this.paused = !0 : this.timeScale = b);
      }
    }
    return this._effectiveTimeScale = b, b;
  }
  _updateTime(e) {
    const b = this._clip.duration, L = this.loop;
    let M = this.time + e, D = this._loopCount;
    const I = L === LoopPingPong;
    if (e === 0)
      return D === -1 ? M : I && (D & 1) === 1 ? b - M : M;
    if (L === LoopOnce) {
      D === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (M >= b)
          M = b;
        else if (M < 0)
          M = 0;
        else {
          this.time = M;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = M, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (D === -1 && (e >= 0 ? (D = 0, this._setEndings(!0, this.repetitions === 0, I)) : this._setEndings(this.repetitions === 0, !0, I)), M >= b || M < 0) {
        const F = Math.floor(M / b);
        M -= b * F, D += Math.abs(F);
        const N = this.repetitions - D;
        if (N <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, M = e > 0 ? b : 0, this.time = M, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (N === 1) {
            const U = e < 0;
            this._setEndings(U, !U, I);
          } else
            this._setEndings(!1, !1, I);
          this._loopCount = D, this.time = M, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: F
          });
        }
      } else
        this.time = M;
      if (I && (D & 1) === 1)
        return b - M;
    }
    return M;
  }
  _setEndings(e, b, L) {
    const M = this._interpolantSettings;
    L ? (M.endingStart = ZeroSlopeEnding, M.endingEnd = ZeroSlopeEnding) : (e ? M.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding : M.endingStart = WrapAroundEnding, b ? M.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding : M.endingEnd = WrapAroundEnding);
  }
  _scheduleFading(e, b, L) {
    const M = this._mixer, D = M.time;
    let I = this._weightInterpolant;
    I === null && (I = M._lendControlInterpolant(), this._weightInterpolant = I);
    const F = I.parameterPositions, N = I.sampleValues;
    return F[0] = D, N[0] = b, F[1] = D + e, N[1] = L, this;
  }
}
class AnimationMixer extends EventDispatcher$1 {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, b) {
    const L = e._localRoot || this._root, M = e._clip.tracks, D = M.length, I = e._propertyBindings, F = e._interpolants, N = L.uuid, U = this._bindingsByRootAndName;
    let G = U[N];
    G === void 0 && (G = {}, U[N] = G);
    for (let V = 0; V !== D; ++V) {
      const z = M[V], k = z.name;
      let H = G[k];
      if (H !== void 0)
        I[V] = H;
      else {
        if (H = I[V], H !== void 0) {
          H._cacheIndex === null && (++H.referenceCount, this._addInactiveBinding(H, N, k));
          continue;
        }
        const W = b && b._propertyBindings[V].binding.parsedPath;
        H = new PropertyMixer(
          PropertyBinding.create(L, k, W),
          z.ValueTypeName,
          z.getValueSize()
        ), ++H.referenceCount, this._addInactiveBinding(H, N, k), I[V] = H;
      }
      F[V].resultBuffer = H.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const L = (e._localRoot || this._root).uuid, M = e._clip.uuid, D = this._actionsByClip[M];
        this._bindAction(
          e,
          D && D.knownActions[0]
        ), this._addInactiveAction(e, M, L);
      }
      const b = e._propertyBindings;
      for (let L = 0, M = b.length; L !== M; ++L) {
        const D = b[L];
        D.useCount++ === 0 && (this._lendBinding(D), D.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const b = e._propertyBindings;
      for (let L = 0, M = b.length; L !== M; ++L) {
        const D = b[L];
        --D.useCount === 0 && (D.restoreOriginalState(), this._takeBackBinding(D));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const b = e._cacheIndex;
    return b !== null && b < this._nActiveActions;
  }
  _addInactiveAction(e, b, L) {
    const M = this._actions, D = this._actionsByClip;
    let I = D[b];
    if (I === void 0)
      I = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, D[b] = I;
    else {
      const F = I.knownActions;
      e._byClipCacheIndex = F.length, F.push(e);
    }
    e._cacheIndex = M.length, M.push(e), I.actionByRoot[L] = e;
  }
  _removeInactiveAction(e) {
    const b = this._actions, L = b[b.length - 1], M = e._cacheIndex;
    L._cacheIndex = M, b[M] = L, b.pop(), e._cacheIndex = null;
    const D = e._clip.uuid, I = this._actionsByClip, F = I[D], N = F.knownActions, U = N[N.length - 1], G = e._byClipCacheIndex;
    U._byClipCacheIndex = G, N[G] = U, N.pop(), e._byClipCacheIndex = null;
    const V = F.actionByRoot, z = (e._localRoot || this._root).uuid;
    delete V[z], N.length === 0 && delete I[D], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const b = e._propertyBindings;
    for (let L = 0, M = b.length; L !== M; ++L) {
      const D = b[L];
      --D.referenceCount === 0 && this._removeInactiveBinding(D);
    }
  }
  _lendAction(e) {
    const b = this._actions, L = e._cacheIndex, M = this._nActiveActions++, D = b[M];
    e._cacheIndex = M, b[M] = e, D._cacheIndex = L, b[L] = D;
  }
  _takeBackAction(e) {
    const b = this._actions, L = e._cacheIndex, M = --this._nActiveActions, D = b[M];
    e._cacheIndex = M, b[M] = e, D._cacheIndex = L, b[L] = D;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, b, L) {
    const M = this._bindingsByRootAndName, D = this._bindings;
    let I = M[b];
    I === void 0 && (I = {}, M[b] = I), I[L] = e, e._cacheIndex = D.length, D.push(e);
  }
  _removeInactiveBinding(e) {
    const b = this._bindings, L = e.binding, M = L.rootNode.uuid, D = L.path, I = this._bindingsByRootAndName, F = I[M], N = b[b.length - 1], U = e._cacheIndex;
    N._cacheIndex = U, b[U] = N, b.pop(), delete F[D], Object.keys(F).length === 0 && delete I[M];
  }
  _lendBinding(e) {
    const b = this._bindings, L = e._cacheIndex, M = this._nActiveBindings++, D = b[M];
    e._cacheIndex = M, b[M] = e, D._cacheIndex = L, b[L] = D;
  }
  _takeBackBinding(e) {
    const b = this._bindings, L = e._cacheIndex, M = --this._nActiveBindings, D = b[M];
    e._cacheIndex = M, b[M] = e, D._cacheIndex = L, b[L] = D;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, b = this._nActiveControlInterpolants++;
    let L = e[b];
    return L === void 0 && (L = new LinearInterpolant(
      new Float32Array(2),
      new Float32Array(2),
      1,
      this._controlInterpolantsResultBuffer
    ), L.__cacheIndex = b, e[b] = L), L;
  }
  _takeBackControlInterpolant(e) {
    const b = this._controlInterpolants, L = e.__cacheIndex, M = --this._nActiveControlInterpolants, D = b[M];
    e.__cacheIndex = M, b[M] = e, D.__cacheIndex = L, b[L] = D;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, b, L) {
    const M = b || this._root, D = M.uuid;
    let I = typeof e == "string" ? AnimationClip.findByName(M, e) : e;
    const F = I !== null ? I.uuid : e, N = this._actionsByClip[F];
    let U = null;
    if (L === void 0 && (I !== null ? L = I.blendMode : L = NormalAnimationBlendMode), N !== void 0) {
      const V = N.actionByRoot[D];
      if (V !== void 0 && V.blendMode === L)
        return V;
      U = N.knownActions[0], I === null && (I = U._clip);
    }
    if (I === null) return null;
    const G = new AnimationAction(this, I, b, L);
    return this._bindAction(G, U), this._addInactiveAction(G, F, D), G;
  }
  // get an existing action
  existingAction(e, b) {
    const L = b || this._root, M = L.uuid, D = typeof e == "string" ? AnimationClip.findByName(L, e) : e, I = D ? D.uuid : e, F = this._actionsByClip[I];
    return F !== void 0 && F.actionByRoot[M] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, b = this._nActiveActions;
    for (let L = b - 1; L >= 0; --L)
      e[L].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const b = this._actions, L = this._nActiveActions, M = this.time += e, D = Math.sign(e), I = this._accuIndex ^= 1;
    for (let U = 0; U !== L; ++U)
      b[U]._update(M, e, D, I);
    const F = this._bindings, N = this._nActiveBindings;
    for (let U = 0; U !== N; ++U)
      F[U].apply(I);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let b = 0; b < this._actions.length; b++)
      this._actions[b].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const b = this._actions, L = e.uuid, M = this._actionsByClip, D = M[L];
    if (D !== void 0) {
      const I = D.knownActions;
      for (let F = 0, N = I.length; F !== N; ++F) {
        const U = I[F];
        this._deactivateAction(U);
        const G = U._cacheIndex, V = b[b.length - 1];
        U._cacheIndex = null, U._byClipCacheIndex = null, V._cacheIndex = G, b[G] = V, b.pop(), this._removeInactiveBindingsForAction(U);
      }
      delete M[L];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const b = e.uuid, L = this._actionsByClip;
    for (const I in L) {
      const F = L[I].actionByRoot, N = F[b];
      N !== void 0 && (this._deactivateAction(N), this._removeInactiveAction(N));
    }
    const M = this._bindingsByRootAndName, D = M[b];
    if (D !== void 0)
      for (const I in D) {
        const F = D[I];
        F.restoreOriginalState(), this._removeInactiveBinding(F);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, b) {
    const L = this.existingAction(e, b);
    L !== null && (this._deactivateAction(L), this._removeInactiveAction(L));
  }
}
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
class Uniform {
  constructor(e) {
    typeof e == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e;
  }
  clone() {
    return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
  constructor(e, b, L = 1) {
    super(e, b), this.meshPerAttribute = L;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const b = super.clone(e);
    return b.meshPerAttribute = this.meshPerAttribute, b;
  }
  toJSON(e) {
    const b = super.toJSON(e);
    return b.isInstancedInterleavedBuffer = !0, b.meshPerAttribute = this.meshPerAttribute, b;
  }
}
InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = !0;
class GLBufferAttribute {
  constructor(e, b, L, M, D) {
    this.buffer = e, this.type = b, this.itemSize = L, this.elementSize = M, this.count = D, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, b) {
    return this.type = e, this.elementSize = b, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
GLBufferAttribute.prototype.isGLBufferAttribute = !0;
let Raycaster$1 = class {
  constructor(e, b, L = 0, M = 1 / 0) {
    this.ray = new Ray(e, b), this.near = L, this.far = M, this.camera = null, this.layers = new Layers(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, b) {
    this.ray.set(e, b);
  }
  setFromCamera(e, b) {
    b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(b).sub(this.ray.origin).normalize(), this.camera = b) : b && b.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld), this.camera = b) : console.error("THREE.Raycaster: Unsupported camera type: " + b.type);
  }
  intersectObject(e, b = !1, L = []) {
    return intersectObject(e, this, L, b), L.sort(ascSort), L;
  }
  intersectObjects(e, b = !1, L = []) {
    for (let M = 0, D = e.length; M < D; M++)
      intersectObject(e[M], this, L, b);
    return L.sort(ascSort), L;
  }
};
function ascSort(B, e) {
  return B.distance - e.distance;
}
function intersectObject(B, e, b, L) {
  if (B.layers.test(e.layers) && B.raycast(e, b), L === !0) {
    const M = B.children;
    for (let D = 0, I = M.length; D < I; D++)
      intersectObject(M[D], e, b, !0);
  }
}
class Spherical {
  constructor(e = 1, b = 0, L = 0) {
    return this.radius = e, this.phi = b, this.theta = L, this;
  }
  set(e, b, L) {
    return this.radius = e, this.phi = b, this.theta = L, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be betwee EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, b, L) {
    return this.radius = Math.sqrt(e * e + b * b + L * L), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, L), this.phi = Math.acos(clamp(b / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Cylindrical {
  constructor(e = 1, b = 0, L = 0) {
    return this.radius = e, this.theta = b, this.y = L, this;
  }
  set(e, b, L) {
    return this.radius = e, this.theta = b, this.y = L, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, b, L) {
    return this.radius = Math.sqrt(e * e + L * L), this.theta = Math.atan2(e, L), this.y = b, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$4 = /* @__PURE__ */ new Vector2();
class Box2 {
  constructor(e = new Vector2(1 / 0, 1 / 0), b = new Vector2(-1 / 0, -1 / 0)) {
    this.min = e, this.max = b;
  }
  set(e, b) {
    return this.min.copy(e), this.max.copy(b), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let b = 0, L = e.length; b < L; b++)
      this.expandByPoint(e[b]);
    return this;
  }
  setFromCenterAndSize(e, b) {
    const L = _vector$4.copy(b).multiplyScalar(0.5);
    return this.min.copy(e).sub(L), this.max.copy(e).add(L), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, b) {
    return b.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, b) {
    return b.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return _vector$4.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
Box2.prototype.isBox2 = !0;
const _startP = /* @__PURE__ */ new Vector3(), _startEnd = /* @__PURE__ */ new Vector3();
class Line3 {
  constructor(e = new Vector3(), b = new Vector3()) {
    this.start = e, this.end = b;
  }
  set(e, b) {
    return this.start.copy(e), this.end.copy(b), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, b) {
    return this.delta(b).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, b) {
    _startP.subVectors(e, this.start), _startEnd.subVectors(this.end, this.start);
    const L = _startEnd.dot(_startEnd);
    let D = _startEnd.dot(_startP) / L;
    return b && (D = clamp(D, 0, 1)), D;
  }
  closestPointToPoint(e, b, L) {
    const M = this.closestPointToPointParameter(e, b);
    return this.delta(L).multiplyScalar(M).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ImmediateRenderObject extends Object3D {
  constructor(e) {
    super(), this.material = e, this.render = function() {
    }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
  }
}
ImmediateRenderObject.prototype.isImmediateRenderObject = !0;
const _vector$3 = /* @__PURE__ */ new Vector3();
class SpotLightHelper extends Object3D {
  constructor(e, b) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = b;
    const L = new BufferGeometry(), M = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let I = 0, F = 1, N = 32; I < N; I++, F++) {
      const U = I / N * Math.PI * 2, G = F / N * Math.PI * 2;
      M.push(
        Math.cos(U),
        Math.sin(U),
        1,
        Math.cos(G),
        Math.sin(G),
        1
      );
    }
    L.setAttribute("position", new Float32BufferAttribute(M, 3));
    const D = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
    this.cone = new LineSegments(L, D), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateMatrixWorld();
    const e = this.light.distance ? this.light.distance : 1e3, b = e * Math.tan(this.light.angle);
    this.cone.scale.set(b, b, e), _vector$3.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(_vector$3), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const _vector$2 = /* @__PURE__ */ new Vector3(), _boneMatrix = /* @__PURE__ */ new Matrix4(), _matrixWorldInv = /* @__PURE__ */ new Matrix4();
class SkeletonHelper extends LineSegments {
  constructor(e) {
    const b = getBoneList(e), L = new BufferGeometry(), M = [], D = [], I = new Color(0, 0, 1), F = new Color(0, 1, 0);
    for (let U = 0; U < b.length; U++) {
      const G = b[U];
      G.parent && G.parent.isBone && (M.push(0, 0, 0), M.push(0, 0, 0), D.push(I.r, I.g, I.b), D.push(F.r, F.g, F.b));
    }
    L.setAttribute("position", new Float32BufferAttribute(M, 3)), L.setAttribute("color", new Float32BufferAttribute(D, 3));
    const N = new LineBasicMaterial({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(L, N), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = b, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const b = this.bones, L = this.geometry, M = L.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let D = 0, I = 0; D < b.length; D++) {
      const F = b[D];
      F.parent && F.parent.isBone && (_boneMatrix.multiplyMatrices(_matrixWorldInv, F.matrixWorld), _vector$2.setFromMatrixPosition(_boneMatrix), M.setXYZ(I, _vector$2.x, _vector$2.y, _vector$2.z), _boneMatrix.multiplyMatrices(_matrixWorldInv, F.parent.matrixWorld), _vector$2.setFromMatrixPosition(_boneMatrix), M.setXYZ(I + 1, _vector$2.x, _vector$2.y, _vector$2.z), I += 2);
    }
    L.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
}
function getBoneList(B) {
  const e = [];
  B && B.isBone && e.push(B);
  for (let b = 0; b < B.children.length; b++)
    e.push.apply(e, getBoneList(B.children[b]));
  return e;
}
class PointLightHelper extends Mesh {
  constructor(e, b, L) {
    const M = new SphereGeometry(b, 4, 2), D = new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(M, D), this.light = e, this.light.updateMatrixWorld(), this.color = L, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const _vector$1 = /* @__PURE__ */ new Vector3(), _color1 = /* @__PURE__ */ new Color(), _color2 = /* @__PURE__ */ new Color();
class HemisphereLightHelper extends Object3D {
  constructor(e, b, L) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = L;
    const M = new OctahedronGeometry(b);
    M.rotateY(Math.PI * 0.5), this.material = new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const D = M.getAttribute("position"), I = new Float32Array(D.count * 3);
    M.setAttribute("color", new BufferAttribute(I, 3)), this.add(new Mesh(M, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const b = e.geometry.getAttribute("color");
      _color1.copy(this.light.color), _color2.copy(this.light.groundColor);
      for (let L = 0, M = b.count; L < M; L++) {
        const D = L < M / 2 ? _color1 : _color2;
        b.setXYZ(L, D.r, D.g, D.b);
      }
      b.needsUpdate = !0;
    }
    e.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class GridHelper extends LineSegments {
  constructor(e = 10, b = 10, L = 4473924, M = 8947848) {
    L = new Color(L), M = new Color(M);
    const D = b / 2, I = e / b, F = e / 2, N = [], U = [];
    for (let z = 0, k = 0, H = -F; z <= b; z++, H += I) {
      N.push(-F, 0, H, F, 0, H), N.push(H, 0, -F, H, 0, F);
      const W = z === D ? L : M;
      W.toArray(U, k), k += 3, W.toArray(U, k), k += 3, W.toArray(U, k), k += 3, W.toArray(U, k), k += 3;
    }
    const G = new BufferGeometry();
    G.setAttribute("position", new Float32BufferAttribute(N, 3)), G.setAttribute("color", new Float32BufferAttribute(U, 3));
    const V = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
    super(G, V), this.type = "GridHelper";
  }
}
class PolarGridHelper extends LineSegments {
  constructor(e = 10, b = 16, L = 8, M = 64, D = 4473924, I = 8947848) {
    D = new Color(D), I = new Color(I);
    const F = [], N = [];
    for (let V = 0; V <= b; V++) {
      const z = V / b * (Math.PI * 2), k = Math.sin(z) * e, H = Math.cos(z) * e;
      F.push(0, 0, 0), F.push(k, 0, H);
      const W = V & 1 ? D : I;
      N.push(W.r, W.g, W.b), N.push(W.r, W.g, W.b);
    }
    for (let V = 0; V <= L; V++) {
      const z = V & 1 ? D : I, k = e - e / L * V;
      for (let H = 0; H < M; H++) {
        let W = H / M * (Math.PI * 2), $ = Math.sin(W) * k, j = Math.cos(W) * k;
        F.push($, 0, j), N.push(z.r, z.g, z.b), W = (H + 1) / M * (Math.PI * 2), $ = Math.sin(W) * k, j = Math.cos(W) * k, F.push($, 0, j), N.push(z.r, z.g, z.b);
      }
    }
    const U = new BufferGeometry();
    U.setAttribute("position", new Float32BufferAttribute(F, 3)), U.setAttribute("color", new Float32BufferAttribute(N, 3));
    const G = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
    super(U, G), this.type = "PolarGridHelper";
  }
}
const _v1 = /* @__PURE__ */ new Vector3(), _v2 = /* @__PURE__ */ new Vector3(), _v3 = /* @__PURE__ */ new Vector3();
class DirectionalLightHelper extends Object3D {
  constructor(e, b, L) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = L, b === void 0 && (b = 1);
    let M = new BufferGeometry();
    M.setAttribute("position", new Float32BufferAttribute([
      -b,
      b,
      0,
      b,
      b,
      0,
      b,
      -b,
      0,
      -b,
      -b,
      0,
      -b,
      b,
      0
    ], 3));
    const D = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
    this.lightPlane = new Line(M, D), this.add(this.lightPlane), M = new BufferGeometry(), M.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Line(M, D), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    _v1.setFromMatrixPosition(this.light.matrixWorld), _v2.setFromMatrixPosition(this.light.target.matrixWorld), _v3.subVectors(_v2, _v1), this.lightPlane.lookAt(_v2), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(_v2), this.targetLine.scale.z = _v3.length();
  }
}
const _vector = /* @__PURE__ */ new Vector3(), _camera = /* @__PURE__ */ new Camera$1();
class CameraHelper extends LineSegments {
  constructor(e) {
    const b = new BufferGeometry(), L = new LineBasicMaterial({ color: 16777215, vertexColors: !0, toneMapped: !1 }), M = [], D = [], I = {}, F = new Color(16755200), N = new Color(16711680), U = new Color(43775), G = new Color(16777215), V = new Color(3355443);
    z("n1", "n2", F), z("n2", "n4", F), z("n4", "n3", F), z("n3", "n1", F), z("f1", "f2", F), z("f2", "f4", F), z("f4", "f3", F), z("f3", "f1", F), z("n1", "f1", F), z("n2", "f2", F), z("n3", "f3", F), z("n4", "f4", F), z("p", "n1", N), z("p", "n2", N), z("p", "n3", N), z("p", "n4", N), z("u1", "u2", U), z("u2", "u3", U), z("u3", "u1", U), z("c", "t", G), z("p", "c", V), z("cn1", "cn2", V), z("cn3", "cn4", V), z("cf1", "cf2", V), z("cf3", "cf4", V);
    function z(H, W, $) {
      k(H, $), k(W, $);
    }
    function k(H, W) {
      M.push(0, 0, 0), D.push(W.r, W.g, W.b), I[H] === void 0 && (I[H] = []), I[H].push(M.length / 3 - 1);
    }
    b.setAttribute("position", new Float32BufferAttribute(M, 3)), b.setAttribute("color", new Float32BufferAttribute(D, 3)), super(b, L), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = I, this.update();
  }
  update() {
    const e = this.geometry, b = this.pointMap, L = 1, M = 1;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), setPoint("c", b, e, _camera, 0, 0, -1), setPoint("t", b, e, _camera, 0, 0, 1), setPoint("n1", b, e, _camera, -L, -M, -1), setPoint("n2", b, e, _camera, L, -M, -1), setPoint("n3", b, e, _camera, -L, M, -1), setPoint("n4", b, e, _camera, L, M, -1), setPoint("f1", b, e, _camera, -L, -M, 1), setPoint("f2", b, e, _camera, L, -M, 1), setPoint("f3", b, e, _camera, -L, M, 1), setPoint("f4", b, e, _camera, L, M, 1), setPoint("u1", b, e, _camera, L * 0.7, M * 1.1, -1), setPoint("u2", b, e, _camera, -L * 0.7, M * 1.1, -1), setPoint("u3", b, e, _camera, 0, M * 2, -1), setPoint("cf1", b, e, _camera, -L, 0, 1), setPoint("cf2", b, e, _camera, L, 0, 1), setPoint("cf3", b, e, _camera, 0, -M, 1), setPoint("cf4", b, e, _camera, 0, M, 1), setPoint("cn1", b, e, _camera, -L, 0, -1), setPoint("cn2", b, e, _camera, L, 0, -1), setPoint("cn3", b, e, _camera, 0, -M, -1), setPoint("cn4", b, e, _camera, 0, M, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function setPoint(B, e, b, L, M, D, I) {
  _vector.set(M, D, I).unproject(L);
  const F = e[B];
  if (F !== void 0) {
    const N = b.getAttribute("position");
    for (let U = 0, G = F.length; U < G; U++)
      N.setXYZ(F[U], _vector.x, _vector.y, _vector.z);
  }
}
const _box = /* @__PURE__ */ new Box3();
class BoxHelper extends LineSegments {
  constructor(e, b = 16776960) {
    const L = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), M = new Float32Array(8 * 3), D = new BufferGeometry();
    D.setIndex(new BufferAttribute(L, 1)), D.setAttribute("position", new BufferAttribute(M, 3)), super(D, new LineBasicMaterial({ color: b, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && _box.setFromObject(this.object), _box.isEmpty()) return;
    const b = _box.min, L = _box.max, M = this.geometry.attributes.position, D = M.array;
    D[0] = L.x, D[1] = L.y, D[2] = L.z, D[3] = b.x, D[4] = L.y, D[5] = L.z, D[6] = b.x, D[7] = b.y, D[8] = L.z, D[9] = L.x, D[10] = b.y, D[11] = L.z, D[12] = L.x, D[13] = L.y, D[14] = b.z, D[15] = b.x, D[16] = L.y, D[17] = b.z, D[18] = b.x, D[19] = b.y, D[20] = b.z, D[21] = L.x, D[22] = b.y, D[23] = b.z, M.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e) {
    return LineSegments.prototype.copy.call(this, e), this.object = e.object, this;
  }
}
class Box3Helper extends LineSegments {
  constructor(e, b = 16776960) {
    const L = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), M = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], D = new BufferGeometry();
    D.setIndex(new BufferAttribute(L, 1)), D.setAttribute("position", new Float32BufferAttribute(M, 3)), super(D, new LineBasicMaterial({ color: b, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const b = this.box;
    b.isEmpty() || (b.getCenter(this.position), b.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
}
class PlaneHelper extends Line {
  constructor(e, b = 1, L = 16776960) {
    const M = L, D = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], I = new BufferGeometry();
    I.setAttribute("position", new Float32BufferAttribute(D, 3)), I.computeBoundingSphere(), super(I, new LineBasicMaterial({ color: M, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = b;
    const F = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], N = new BufferGeometry();
    N.setAttribute("position", new Float32BufferAttribute(F, 3)), N.computeBoundingSphere(), this.add(new Mesh(N, new MeshBasicMaterial({ color: M, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    let b = -this.plane.constant;
    Math.abs(b) < 1e-8 && (b = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, b), this.children[0].material.side = b < 0 ? BackSide : FrontSide, this.lookAt(this.plane.normal), super.updateMatrixWorld(e);
  }
}
const _axis = /* @__PURE__ */ new Vector3();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
  // dir is assumed to be normalized
  constructor(e = new Vector3(0, 0, 1), b = new Vector3(0, 0, 0), L = 1, M = 16776960, D = L * 0.2, I = D * 0.2) {
    super(), this.type = "ArrowHelper", _lineGeometry === void 0 && (_lineGeometry = new BufferGeometry(), _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3)), _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1), _coneGeometry.translate(0, -0.5, 0)), this.position.copy(b), this.line = new Line(_lineGeometry, new LineBasicMaterial({ color: M, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color: M, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(L, D, I);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      _axis.set(e.z, 0, -e.x).normalize();
      const b = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(_axis, b);
    }
  }
  setLength(e, b = e * 0.2, L = b * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - b), 1), this.line.updateMatrix(), this.cone.scale.set(L, b, L), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
}
class AxesHelper extends LineSegments {
  constructor(e = 1) {
    const b = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], L = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], M = new BufferGeometry();
    M.setAttribute("position", new Float32BufferAttribute(b, 3)), M.setAttribute("color", new Float32BufferAttribute(L, 3));
    const D = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
    super(M, D), this.type = "AxesHelper";
  }
  setColors(e, b, L) {
    const M = new Color(), D = this.geometry.attributes.color.array;
    return M.set(e), M.toArray(D, 0), M.toArray(D, 3), M.set(b), M.toArray(D, 6), M.toArray(D, 9), M.set(L), M.toArray(D, 12), M.toArray(D, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const _floatView = new Float32Array(1), _int32View = new Int32Array(_floatView.buffer);
class DataUtils {
  // Converts float32 to float16 (stored as uint16 value).
  static toHalfFloat(e) {
    _floatView[0] = e;
    const b = _int32View[0];
    let L = b >> 16 & 32768, M = b >> 12 & 2047;
    const D = b >> 23 & 255;
    return D < 103 ? L : D > 142 ? (L |= 31744, L |= (D == 255 ? 0 : 1) && b & 8388607, L) : D < 113 ? (M |= 2048, L |= (M >> 114 - D) + (M >> 113 - D & 1), L) : (L |= D - 112 << 10 | M >> 1, L += M & 1, L);
  }
}
const LOD_MIN = 4, LOD_MAX = 8, SIZE_MAX = Math.pow(2, LOD_MAX), EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length, MAX_SAMPLES = 20, ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
}, backgroundMaterial = new MeshBasicMaterial({
  side: BackSide,
  depthWrite: !1,
  depthTest: !1
}), backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial), _flatCamera = /* @__PURE__ */ new OrthographicCamera(), { _lodPlanes, _sizeLods, _sigmas } = /* @__PURE__ */ _createPlanes(), _clearColor = /* @__PURE__ */ new Color();
let _oldTarget = null;
const PHI = (1 + Math.sqrt(5)) / 2, INV_PHI = 1 / PHI, _axisDirections = [
  /* @__PURE__ */ new Vector3(1, 1, 1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
];
function convertLinearToRGBE(B) {
  const e = Math.max(B.r, B.g, B.b), b = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
  return B.multiplyScalar(Math.pow(2, -b)), (b + 128) / 255;
}
class PMREMGenerator {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = _getBlurShader(MAX_SAMPLES), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, b = 0, L = 0.1, M = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    const D = this._allocateTargets();
    return this._sceneToCubeUV(e, L, M, D), b > 0 && this._blur(D, 0, 0, b), this._applyPMREM(D), this._cleanup(D), D;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e) {
    return this._fromTexture(e);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e) {
    return this._fromTexture(e);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapShader === null && (this._cubemapShader = _getCubemapShader(), this._compileMaterial(this._cubemapShader));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectShader === null && (this._equirectShader = _getEquirectShader(), this._compileMaterial(this._equirectShader));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._blurMaterial.dispose(), this._cubemapShader !== null && this._cubemapShader.dispose(), this._equirectShader !== null && this._equirectShader.dispose();
    for (let e = 0; e < _lodPlanes.length; e++)
      _lodPlanes[e].dispose();
  }
  // private interface
  _cleanup(e) {
    this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(_oldTarget), e.scissorTest = !1, _setViewport(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e) {
    _oldTarget = this._renderer.getRenderTarget();
    const b = this._allocateTargets(e);
    return this._textureToCubeUV(e, b), this._applyPMREM(b), this._cleanup(b), b;
  }
  _allocateTargets(e) {
    const b = {
      magFilter: NearestFilter,
      minFilter: NearestFilter,
      generateMipmaps: !1,
      type: UnsignedByteType,
      format: RGBEFormat,
      encoding: _isLDR(e) ? e.encoding : RGBEEncoding,
      depthBuffer: !1
    }, L = _createRenderTarget(b);
    return L.depthBuffer = !e, this._pingPongRenderTarget = _createRenderTarget(b), L;
  }
  _compileMaterial(e) {
    const b = new Mesh(_lodPlanes[0], e);
    this._renderer.compile(b, _flatCamera);
  }
  _sceneToCubeUV(e, b, L, M) {
    const F = new PerspectiveCamera(90, 1, b, L), N = [1, -1, 1, 1, 1, 1], U = [1, 1, 1, -1, -1, -1], G = this._renderer, V = G.autoClear, z = G.outputEncoding, k = G.toneMapping;
    G.getClearColor(_clearColor), G.toneMapping = NoToneMapping, G.outputEncoding = LinearEncoding, G.autoClear = !1;
    let H = !1;
    const W = e.background;
    if (W) {
      if (W.isColor) {
        backgroundMaterial.color.copy(W).convertSRGBToLinear(), e.background = null;
        const $ = convertLinearToRGBE(backgroundMaterial.color);
        backgroundMaterial.opacity = $, H = !0;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();
      const $ = convertLinearToRGBE(backgroundMaterial.color);
      backgroundMaterial.opacity = $, H = !0;
    }
    for (let $ = 0; $ < 6; $++) {
      const j = $ % 3;
      j == 0 ? (F.up.set(0, N[$], 0), F.lookAt(U[$], 0, 0)) : j == 1 ? (F.up.set(0, 0, N[$]), F.lookAt(0, U[$], 0)) : (F.up.set(0, N[$], 0), F.lookAt(0, 0, U[$])), _setViewport(
        M,
        j * SIZE_MAX,
        $ > 2 ? SIZE_MAX : 0,
        SIZE_MAX,
        SIZE_MAX
      ), G.setRenderTarget(M), H && G.render(backgroundBox, F), G.render(e, F);
    }
    G.toneMapping = k, G.outputEncoding = z, G.autoClear = V;
  }
  _textureToCubeUV(e, b) {
    const L = this._renderer;
    e.isCubeTexture ? this._cubemapShader == null && (this._cubemapShader = _getCubemapShader()) : this._equirectShader == null && (this._equirectShader = _getEquirectShader());
    const M = e.isCubeTexture ? this._cubemapShader : this._equirectShader, D = new Mesh(_lodPlanes[0], M), I = M.uniforms;
    I.envMap.value = e, e.isCubeTexture || I.texelSize.value.set(1 / e.image.width, 1 / e.image.height), I.inputEncoding.value = ENCODINGS[e.encoding], I.outputEncoding.value = ENCODINGS[b.texture.encoding], _setViewport(b, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX), L.setRenderTarget(b), L.render(D, _flatCamera);
  }
  _applyPMREM(e) {
    const b = this._renderer, L = b.autoClear;
    b.autoClear = !1;
    for (let M = 1; M < TOTAL_LODS; M++) {
      const D = Math.sqrt(_sigmas[M] * _sigmas[M] - _sigmas[M - 1] * _sigmas[M - 1]), I = _axisDirections[(M - 1) % _axisDirections.length];
      this._blur(e, M - 1, M, D, I);
    }
    b.autoClear = L;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, b, L, M, D) {
    const I = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      I,
      b,
      L,
      M,
      "latitudinal",
      D
    ), this._halfBlur(
      I,
      e,
      L,
      L,
      M,
      "longitudinal",
      D
    );
  }
  _halfBlur(e, b, L, M, D, I, F) {
    const N = this._renderer, U = this._blurMaterial;
    I !== "latitudinal" && I !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const G = 3, V = new Mesh(_lodPlanes[M], U), z = U.uniforms, k = _sizeLods[L] - 1, H = isFinite(D) ? Math.PI / (2 * k) : 2 * Math.PI / (2 * MAX_SAMPLES - 1), W = D / H, $ = isFinite(D) ? 1 + Math.floor(G * W) : MAX_SAMPLES;
    $ > MAX_SAMPLES && console.warn(`sigmaRadians, ${D}, is too large and will clip, as it requested ${$} samples when the maximum is set to ${MAX_SAMPLES}`);
    const j = [];
    let q = 0;
    for (let X = 0; X < MAX_SAMPLES; ++X) {
      const Z = X / W, Q = Math.exp(-Z * Z / 2);
      j.push(Q), X == 0 ? q += Q : X < $ && (q += 2 * Q);
    }
    for (let X = 0; X < j.length; X++)
      j[X] = j[X] / q;
    z.envMap.value = e.texture, z.samples.value = $, z.weights.value = j, z.latitudinal.value = I === "latitudinal", F && (z.poleAxis.value = F), z.dTheta.value = H, z.mipInt.value = LOD_MAX - L, z.inputEncoding.value = ENCODINGS[e.texture.encoding], z.outputEncoding.value = ENCODINGS[e.texture.encoding];
    const Y = _sizeLods[M], J = 3 * Math.max(0, SIZE_MAX - 2 * Y), K = (M === 0 ? 0 : 2 * SIZE_MAX) + 2 * Y * (M > LOD_MAX - LOD_MIN ? M - LOD_MAX + LOD_MIN : 0);
    _setViewport(b, J, K, 3 * Y, 2 * Y), N.setRenderTarget(b), N.render(V, _flatCamera);
  }
}
function _isLDR(B) {
  return B === void 0 || B.type !== UnsignedByteType ? !1 : B.encoding === LinearEncoding || B.encoding === sRGBEncoding || B.encoding === GammaEncoding;
}
function _createPlanes() {
  const B = [], e = [], b = [];
  let L = LOD_MAX;
  for (let M = 0; M < TOTAL_LODS; M++) {
    const D = Math.pow(2, L);
    e.push(D);
    let I = 1 / D;
    M > LOD_MAX - LOD_MIN ? I = EXTRA_LOD_SIGMA[M - LOD_MAX + LOD_MIN - 1] : M == 0 && (I = 0), b.push(I);
    const F = 1 / (D - 1), N = -F / 2, U = 1 + F / 2, G = [N, N, U, N, U, U, N, N, U, U, N, U], V = 6, z = 6, k = 3, H = 2, W = 1, $ = new Float32Array(k * z * V), j = new Float32Array(H * z * V), q = new Float32Array(W * z * V);
    for (let J = 0; J < V; J++) {
      const K = J % 3 * 2 / 3 - 1, X = J > 2 ? 0 : -1, Z = [
        K,
        X,
        0,
        K + 2 / 3,
        X,
        0,
        K + 2 / 3,
        X + 1,
        0,
        K,
        X,
        0,
        K + 2 / 3,
        X + 1,
        0,
        K,
        X + 1,
        0
      ];
      $.set(Z, k * z * J), j.set(G, H * z * J);
      const Q = [J, J, J, J, J, J];
      q.set(Q, W * z * J);
    }
    const Y = new BufferGeometry();
    Y.setAttribute("position", new BufferAttribute($, k)), Y.setAttribute("uv", new BufferAttribute(j, H)), Y.setAttribute("faceIndex", new BufferAttribute(q, W)), B.push(Y), L > LOD_MIN && L--;
  }
  return { _lodPlanes: B, _sizeLods: e, _sigmas: b };
}
function _createRenderTarget(B) {
  const e = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, B);
  return e.texture.mapping = CubeUVReflectionMapping, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e;
}
function _setViewport(B, e, b, L, M) {
  B.viewport.set(e, b, L, M), B.scissor.set(e, b, L, M);
}
function _getBlurShader(B) {
  const e = new Float32Array(B), b = new Vector3(0, 1, 0);
  return new RawShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: { n: B },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: e },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: b },
      inputEncoding: { value: ENCODINGS[LinearEncoding] },
      outputEncoding: { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`
    ),
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1
  });
}
function _getEquirectShader() {
  const B = new Vector2(1, 1);
  return new RawShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null },
      texelSize: { value: B },
      inputEncoding: { value: ENCODINGS[LinearEncoding] },
      outputEncoding: { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`
    ),
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1
  });
}
function _getCubemapShader() {
  return new RawShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      inputEncoding: { value: ENCODINGS[LinearEncoding] },
      outputEncoding: { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`
    ),
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1
  });
}
function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function _getEncodings() {
  return (
    /* glsl */
    `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`
  );
}
const LineStrip = 0, LinePieces = 1, NoColors = 0, FaceColors = 1, VertexColors = 2;
function MeshFaceMaterial(B) {
  return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), B;
}
function MultiMaterial(B = []) {
  return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), B.isMultiMaterial = !0, B.materials = B, B.clone = function() {
    return B.slice();
  }, B;
}
function PointCloud(B, e) {
  return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Points(B, e);
}
function Particle(B) {
  return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Sprite(B);
}
function ParticleSystem(B, e) {
  return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Points(B, e);
}
function PointCloudMaterial(B) {
  return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new PointsMaterial(B);
}
function ParticleBasicMaterial(B) {
  return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new PointsMaterial(B);
}
function ParticleSystemMaterial(B) {
  return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new PointsMaterial(B);
}
function Vertex(B, e, b) {
  return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Vector3(B, e, b);
}
function DynamicBufferAttribute(B, e) {
  return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new BufferAttribute(B, e).setUsage(DynamicDrawUsage);
}
function Int8Attribute(B, e) {
  return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Int8BufferAttribute(B, e);
}
function Uint8Attribute(B, e) {
  return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Uint8BufferAttribute(B, e);
}
function Uint8ClampedAttribute(B, e) {
  return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Uint8ClampedBufferAttribute(B, e);
}
function Int16Attribute(B, e) {
  return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Int16BufferAttribute(B, e);
}
function Uint16Attribute(B, e) {
  return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Uint16BufferAttribute(B, e);
}
function Int32Attribute(B, e) {
  return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Int32BufferAttribute(B, e);
}
function Uint32Attribute(B, e) {
  return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Uint32BufferAttribute(B, e);
}
function Float32Attribute(B, e) {
  return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Float32BufferAttribute(B, e);
}
function Float64Attribute(B, e) {
  return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Float64BufferAttribute(B, e);
}
Curve.create = function(B, e) {
  return console.log("THREE.Curve.create() has been deprecated"), B.prototype = Object.create(Curve.prototype), B.prototype.constructor = B, B.prototype.getPoint = e, B;
};
Path.prototype.fromPoints = function(B) {
  return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(B);
};
function AxisHelper(B) {
  return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new AxesHelper(B);
}
function BoundingBoxHelper(B, e) {
  return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new BoxHelper(B, e);
}
function EdgesHelper(B, e) {
  return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new LineSegments(new EdgesGeometry(B.geometry), new LineBasicMaterial({ color: e !== void 0 ? e : 16777215 }));
}
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
function WireframeHelper(B, e) {
  return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new LineSegments(new WireframeGeometry(B.geometry), new LineBasicMaterial({ color: e !== void 0 ? e : 16777215 }));
}
Loader.prototype.extractUrlBase = function(B) {
  return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), LoaderUtils.extractUrlBase(B);
};
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
function XHRLoader(B) {
  return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new FileLoader(B);
}
function BinaryTextureLoader(B) {
  return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new DataTextureLoader(B);
}
Box2.prototype.center = function(B) {
  return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(B);
};
Box2.prototype.empty = function() {
  return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
};
Box2.prototype.isIntersectionBox = function(B) {
  return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(B);
};
Box2.prototype.size = function(B) {
  return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(B);
};
Box3.prototype.center = function(B) {
  return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(B);
};
Box3.prototype.empty = function() {
  return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(B) {
  return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(B);
};
Box3.prototype.isIntersectionSphere = function(B) {
  return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(B);
};
Box3.prototype.size = function(B) {
  return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(B);
};
Sphere.prototype.empty = function() {
  return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
};
Frustum.prototype.setFromMatrix = function(B) {
  return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(B);
};
Line3.prototype.center = function(B) {
  return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(B);
};
Matrix3.prototype.flattenToArrayOffset = function(B, e) {
  return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(B, e);
};
Matrix3.prototype.multiplyVector3 = function(B) {
  return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), B.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Matrix3.prototype.applyToBufferAttribute = function(B) {
  return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), B.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Matrix3.prototype.getInverse = function(B) {
  return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(B).invert();
};
Matrix4.prototype.extractPosition = function(B) {
  return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(B);
};
Matrix4.prototype.flattenToArrayOffset = function(B, e) {
  return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(B, e);
};
Matrix4.prototype.getPosition = function() {
  return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new Vector3().setFromMatrixColumn(this, 3);
};
Matrix4.prototype.setRotationFromQuaternion = function(B) {
  return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(B);
};
Matrix4.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Matrix4.prototype.multiplyVector3 = function(B) {
  return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), B.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector4 = function(B) {
  return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), B.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Matrix4.prototype.rotateAxis = function(B) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), B.transformDirection(this);
};
Matrix4.prototype.crossVector = function(B) {
  return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), B.applyMatrix4(this);
};
Matrix4.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Matrix4.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Matrix4.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Matrix4.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Matrix4.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Matrix4.prototype.applyToBufferAttribute = function(B) {
  return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), B.applyMatrix4(this);
};
Matrix4.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Matrix4.prototype.makeFrustum = function(B, e, b, L, M, D) {
  return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(B, e, L, b, M, D);
};
Matrix4.prototype.getInverse = function(B) {
  return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(B).invert();
};
Plane.prototype.isIntersectionLine = function(B) {
  return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(B);
};
Quaternion.prototype.multiplyVector3 = function(B) {
  return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), B.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
  return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
};
Ray.prototype.isIntersectionBox = function(B) {
  return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(B);
};
Ray.prototype.isIntersectionPlane = function(B) {
  return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(B);
};
Ray.prototype.isIntersectionSphere = function(B) {
  return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(B);
};
Triangle.prototype.area = function() {
  return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(B, e) {
  return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(B, e);
};
Triangle.prototype.midpoint = function(B) {
  return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(B);
};
Triangle.prototypenormal = function(B) {
  return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(B);
};
Triangle.prototype.plane = function(B) {
  return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(B);
};
Triangle.barycoordFromPoint = function(B, e, b, L, M) {
  return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Triangle.getBarycoord(B, e, b, L, M);
};
Triangle.normal = function(B, e, b, L) {
  return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Triangle.getNormal(B, e, b, L);
};
Shape$1.prototype.extractAllPoints = function(B) {
  return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(B);
};
Shape$1.prototype.extrude = function(B) {
  return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new ExtrudeGeometry(this, B);
};
Shape$1.prototype.makeGeometry = function(B) {
  return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ShapeGeometry(this, B);
};
Vector2.prototype.fromAttribute = function(B, e, b) {
  return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(B, e, b);
};
Vector2.prototype.distanceToManhattan = function(B) {
  return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(B);
};
Vector2.prototype.lengthManhattan = function() {
  return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
};
Vector3.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
Vector3.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
Vector3.prototype.getPositionFromMatrix = function(B) {
  return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(B);
};
Vector3.prototype.getScaleFromMatrix = function(B) {
  return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(B);
};
Vector3.prototype.getColumnFromMatrix = function(B, e) {
  return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, B);
};
Vector3.prototype.applyProjection = function(B) {
  return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(B);
};
Vector3.prototype.fromAttribute = function(B, e, b) {
  return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(B, e, b);
};
Vector3.prototype.distanceToManhattan = function(B) {
  return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(B);
};
Vector3.prototype.lengthManhattan = function() {
  return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
};
Vector4.prototype.fromAttribute = function(B, e, b) {
  return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(B, e, b);
};
Vector4.prototype.lengthManhattan = function() {
  return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
};
Object3D.prototype.getChildByName = function(B) {
  return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(B);
};
Object3D.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
Object3D.prototype.translate = function(B, e) {
  return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, B);
};
Object3D.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
Object3D.prototype.applyMatrix = function(B) {
  return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(B);
};
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
    },
    set: function(B) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = B;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Mesh.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function() {
      return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
PerspectiveCamera.prototype.setLens = function(B, e) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), e !== void 0 && (this.filmGauge = e), this.setFocalLength(B);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(B) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = B;
    }
  },
  shadowCameraLeft: {
    set: function(B) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = B;
    }
  },
  shadowCameraRight: {
    set: function(B) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = B;
    }
  },
  shadowCameraTop: {
    set: function(B) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = B;
    }
  },
  shadowCameraBottom: {
    set: function(B) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = B;
    }
  },
  shadowCameraNear: {
    set: function(B) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = B;
    }
  },
  shadowCameraFar: {
    set: function(B) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = B;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(B) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = B;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(B) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = B;
    }
  },
  shadowMapHeight: {
    set: function(B) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = B;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
    }
  },
  dynamic: {
    get: function() {
      return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(DynamicDrawUsage);
    }
  }
});
BufferAttribute.prototype.setDynamic = function(B) {
  return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(B === !0 ? DynamicDrawUsage : StaticDrawUsage), this;
};
BufferAttribute.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, BufferAttribute.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
BufferGeometry.prototype.addIndex = function(B) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(B);
};
BufferGeometry.prototype.addAttribute = function(B, e) {
  return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute) ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(B, new BufferAttribute(arguments[1], arguments[2]))) : B === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(B, e);
};
BufferGeometry.prototype.addDrawCall = function(B, e, b) {
  b !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(B, e);
};
BufferGeometry.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
};
BufferGeometry.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
BufferGeometry.prototype.removeAttribute = function(B) {
  return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(B);
};
BufferGeometry.prototype.applyMatrix = function(B) {
  return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(B);
};
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
    }
  },
  offsets: {
    get: function() {
      return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
    }
  }
});
InterleavedBuffer.prototype.setDynamic = function(B) {
  return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(B === !0 ? DynamicDrawUsage : StaticDrawUsage), this;
};
InterleavedBuffer.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
ExtrudeGeometry.prototype.getArrays = function() {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
ExtrudeGeometry.prototype.addShapeList = function() {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
ExtrudeGeometry.prototype.addShape = function() {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Scene$1.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Uniform.prototype.onUpdate = function() {
  return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
};
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      return console.warn("THREE.Material: .wrapRGB has been removed."), new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(B) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = B === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
    },
    set: function(B) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = B;
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
    },
    set: function(B) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = B;
    }
  }
});
WebGLRenderer$1.prototype.clearTarget = function(B, e, b, L) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(B), this.clear(e, b, L);
};
WebGLRenderer$1.prototype.animate = function(B) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(B);
};
WebGLRenderer$1.prototype.getCurrentRenderTarget = function() {
  return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
};
WebGLRenderer$1.prototype.getMaxAnisotropy = function() {
  return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
};
WebGLRenderer$1.prototype.getPrecision = function() {
  return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
};
WebGLRenderer$1.prototype.resetGLState = function() {
  return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
};
WebGLRenderer$1.prototype.supportsFloatTextures = function() {
  return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
};
WebGLRenderer$1.prototype.supportsHalfFloatTextures = function() {
  return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
};
WebGLRenderer$1.prototype.supportsStandardDerivatives = function() {
  return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
};
WebGLRenderer$1.prototype.supportsCompressedTextureS3TC = function() {
  return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
};
WebGLRenderer$1.prototype.supportsCompressedTexturePVRTC = function() {
  return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
WebGLRenderer$1.prototype.supportsBlendMinMax = function() {
  return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
};
WebGLRenderer$1.prototype.supportsVertexTextures = function() {
  return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
};
WebGLRenderer$1.prototype.supportsInstancedArrays = function() {
  return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
};
WebGLRenderer$1.prototype.enableScissorTest = function(B) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(B);
};
WebGLRenderer$1.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
WebGLRenderer$1.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
WebGLRenderer$1.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
WebGLRenderer$1.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
WebGLRenderer$1.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
WebGLRenderer$1.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
WebGLRenderer$1.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
WebGLRenderer$1.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
WebGLRenderer$1.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
WebGLRenderer$1.prototype.getActiveMipMapLevel = function() {
  return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer$1.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(B) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = B;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(B) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = B;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
    }
  },
  vr: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
    }
  },
  gammaInput: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1;
    },
    set: function(B) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = B === !0 ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
function WebGLRenderTargetCube(B, e, b) {
  return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new WebGLCubeRenderTarget(B, b);
}
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
    },
    set: function(B) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = B;
    }
  },
  wrapT: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
    },
    set: function(B) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = B;
    }
  },
  magFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
    },
    set: function(B) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = B;
    }
  },
  minFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
    },
    set: function(B) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = B;
    }
  },
  anisotropy: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
    },
    set: function(B) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = B;
    }
  },
  offset: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
    },
    set: function(B) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = B;
    }
  },
  repeat: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
    },
    set: function(B) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = B;
    }
  },
  format: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
    },
    set: function(B) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = B;
    }
  },
  type: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
    },
    set: function(B) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = B;
    }
  },
  generateMipmaps: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
    },
    set: function(B) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = B;
    }
  }
});
Audio$1.prototype.load = function(B) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  const e = this;
  return new AudioLoader().load(B, function(L) {
    e.setBuffer(L);
  }), this;
};
AudioAnalyser.prototype.getData = function() {
  return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
};
CubeCamera.prototype.updateCubeMap = function(B, e) {
  return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(B, e);
};
CubeCamera.prototype.clear = function(B, e, b, L) {
  return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(B, e, b, L);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(B, e, b, L) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const M = new TextureLoader();
  M.setCrossOrigin(this.crossOrigin);
  const D = M.load(B, b, void 0, L);
  return e && (D.mapping = e), D;
};
ImageUtils.loadTextureCube = function(B, e, b, L) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const M = new CubeTextureLoader();
  M.setCrossOrigin(this.crossOrigin);
  const D = M.load(B, b, void 0, L);
  return e && (D.mapping = e), D;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
function CanvasRenderer() {
  console.error("THREE.CanvasRenderer has been removed");
}
function JSONLoader() {
  console.error("THREE.JSONLoader has been removed.");
}
const SceneUtils = {
  createMultiMaterialObject: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  },
  detach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  },
  attach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  }
};
function LensFlare() {
  console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: REVISION
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = REVISION);
const THREE$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping,
  AddEquation,
  AddOperation,
  AdditiveAnimationBlendMode,
  AdditiveBlending,
  AlphaFormat,
  AlwaysDepth,
  AlwaysStencilFunc,
  AmbientLight,
  AmbientLightProbe,
  AnimationClip,
  AnimationLoader,
  AnimationMixer,
  AnimationObjectGroup,
  AnimationUtils,
  ArcCurve,
  ArrayCamera,
  ArrowHelper,
  Audio: Audio$1,
  AudioAnalyser,
  AudioContext,
  AudioListener,
  AudioLoader,
  AxesHelper,
  AxisHelper,
  BackSide,
  BasicDepthPacking,
  BasicShadowMap,
  BinaryTextureLoader,
  Bone,
  BooleanKeyframeTrack,
  BoundingBoxHelper,
  Box2,
  Box3,
  Box3Helper,
  BoxBufferGeometry: BoxGeometry,
  BoxGeometry,
  BoxHelper,
  BufferAttribute,
  BufferGeometry,
  BufferGeometryLoader,
  ByteType,
  Cache,
  Camera: Camera$1,
  CameraHelper,
  CanvasRenderer,
  CanvasTexture,
  CatmullRomCurve3,
  CineonToneMapping,
  CircleBufferGeometry: CircleGeometry,
  CircleGeometry,
  ClampToEdgeWrapping,
  Clock,
  Color,
  ColorKeyframeTrack,
  CompressedTexture,
  CompressedTextureLoader,
  ConeBufferGeometry: ConeGeometry,
  ConeGeometry,
  CubeCamera,
  CubeReflectionMapping,
  CubeRefractionMapping,
  CubeTexture,
  CubeTextureLoader,
  CubeUVReflectionMapping,
  CubeUVRefractionMapping,
  CubicBezierCurve,
  CubicBezierCurve3,
  CubicInterpolant,
  CullFaceBack,
  CullFaceFront,
  CullFaceFrontBack,
  CullFaceNone,
  Curve,
  CurvePath,
  CustomBlending,
  CustomToneMapping,
  CylinderBufferGeometry: CylinderGeometry,
  CylinderGeometry,
  Cylindrical,
  DataTexture,
  DataTexture2DArray,
  DataTexture3D,
  DataTextureLoader,
  DataUtils,
  DecrementStencilOp,
  DecrementWrapStencilOp,
  DefaultLoadingManager,
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  DirectionalLight,
  DirectionalLightHelper,
  DiscreteInterpolant,
  DodecahedronBufferGeometry: DodecahedronGeometry,
  DodecahedronGeometry,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  DynamicBufferAttribute,
  DynamicCopyUsage,
  DynamicDrawUsage,
  DynamicReadUsage,
  EdgesGeometry,
  EdgesHelper,
  EllipseCurve,
  EqualDepth,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  Euler,
  EventDispatcher: EventDispatcher$1,
  ExtrudeBufferGeometry: ExtrudeGeometry,
  ExtrudeGeometry,
  FaceColors,
  FileLoader,
  FlatShading,
  Float16BufferAttribute,
  Float32Attribute,
  Float32BufferAttribute,
  Float64Attribute,
  Float64BufferAttribute,
  FloatType,
  Fog,
  FogExp2,
  Font,
  FontLoader,
  FrontSide,
  Frustum,
  GLBufferAttribute,
  GLSL1,
  GLSL3,
  GammaEncoding,
  GreaterDepth,
  GreaterEqualDepth,
  GreaterEqualStencilFunc,
  GreaterStencilFunc,
  GridHelper,
  Group,
  HalfFloatType,
  HemisphereLight,
  HemisphereLightHelper,
  HemisphereLightProbe,
  IcosahedronBufferGeometry: IcosahedronGeometry,
  IcosahedronGeometry,
  ImageBitmapLoader,
  ImageLoader,
  ImageUtils,
  ImmediateRenderObject,
  IncrementStencilOp,
  IncrementWrapStencilOp,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  InstancedMesh,
  Int16Attribute,
  Int16BufferAttribute,
  Int32Attribute,
  Int32BufferAttribute,
  Int8Attribute,
  Int8BufferAttribute,
  IntType,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  InterpolateSmooth,
  InvertStencilOp,
  JSONLoader,
  KeepStencilOp,
  KeyframeTrack,
  LOD,
  LatheBufferGeometry: LatheGeometry,
  LatheGeometry,
  Layers,
  LensFlare,
  LessDepth,
  LessEqualDepth,
  LessEqualStencilFunc,
  LessStencilFunc,
  Light,
  LightProbe,
  Line,
  Line3,
  LineBasicMaterial,
  LineCurve,
  LineCurve3,
  LineDashedMaterial,
  LineLoop,
  LinePieces,
  LineSegments,
  LineStrip,
  LinearEncoding,
  LinearFilter,
  LinearInterpolant,
  LinearMipMapLinearFilter,
  LinearMipMapNearestFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LinearToneMapping,
  Loader,
  LoaderUtils,
  LoadingManager,
  LogLuvEncoding,
  LoopOnce,
  LoopPingPong,
  LoopRepeat,
  LuminanceAlphaFormat,
  LuminanceFormat,
  MOUSE,
  Material,
  MaterialLoader,
  Math: MathUtils,
  MathUtils,
  Matrix3,
  Matrix4,
  MaxEquation,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshFaceMaterial,
  MeshLambertMaterial,
  MeshMatcapMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  MinEquation,
  MirroredRepeatWrapping,
  MixOperation,
  MultiMaterial,
  MultiplyBlending,
  MultiplyOperation,
  NearestFilter,
  NearestMipMapLinearFilter,
  NearestMipMapNearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NeverDepth,
  NeverStencilFunc,
  NoBlending,
  NoColors,
  NoToneMapping,
  NormalAnimationBlendMode,
  NormalBlending,
  NotEqualDepth,
  NotEqualStencilFunc,
  NumberKeyframeTrack,
  Object3D,
  ObjectLoader,
  ObjectSpaceNormalMap,
  OctahedronBufferGeometry: OctahedronGeometry,
  OctahedronGeometry,
  OneFactor,
  OneMinusDstAlphaFactor,
  OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor,
  OrthographicCamera,
  PCFShadowMap,
  PCFSoftShadowMap,
  PMREMGenerator,
  ParametricBufferGeometry: ParametricGeometry,
  ParametricGeometry,
  Particle,
  ParticleBasicMaterial,
  ParticleSystem,
  ParticleSystemMaterial,
  Path,
  PerspectiveCamera,
  Plane,
  PlaneBufferGeometry: PlaneGeometry,
  PlaneGeometry,
  PlaneHelper,
  PointCloud,
  PointCloudMaterial,
  PointLight,
  PointLightHelper,
  Points,
  PointsMaterial,
  PolarGridHelper,
  PolyhedronBufferGeometry: PolyhedronGeometry,
  PolyhedronGeometry,
  PositionalAudio,
  PropertyBinding,
  PropertyMixer,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  Quaternion,
  QuaternionKeyframeTrack,
  QuaternionLinearInterpolant,
  REVISION,
  RGBADepthPacking,
  RGBAFormat,
  RGBAIntegerFormat,
  RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format,
  RGBDEncoding,
  RGBEEncoding,
  RGBEFormat,
  RGBFormat,
  RGBIntegerFormat,
  RGBM16Encoding,
  RGBM7Encoding,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGFormat,
  RGIntegerFormat,
  RawShaderMaterial,
  Ray,
  Raycaster: Raycaster$1,
  RectAreaLight,
  RedFormat,
  RedIntegerFormat,
  ReinhardToneMapping,
  RepeatWrapping,
  ReplaceStencilOp,
  ReverseSubtractEquation,
  RingBufferGeometry: RingGeometry,
  RingGeometry,
  SRGB8_ALPHA8_ASTC_10x10_Format,
  SRGB8_ALPHA8_ASTC_10x5_Format,
  SRGB8_ALPHA8_ASTC_10x6_Format,
  SRGB8_ALPHA8_ASTC_10x8_Format,
  SRGB8_ALPHA8_ASTC_12x10_Format,
  SRGB8_ALPHA8_ASTC_12x12_Format,
  SRGB8_ALPHA8_ASTC_4x4_Format,
  SRGB8_ALPHA8_ASTC_5x4_Format,
  SRGB8_ALPHA8_ASTC_5x5_Format,
  SRGB8_ALPHA8_ASTC_6x5_Format,
  SRGB8_ALPHA8_ASTC_6x6_Format,
  SRGB8_ALPHA8_ASTC_8x5_Format,
  SRGB8_ALPHA8_ASTC_8x6_Format,
  SRGB8_ALPHA8_ASTC_8x8_Format,
  Scene: Scene$1,
  SceneUtils,
  ShaderChunk,
  ShaderLib,
  ShaderMaterial,
  ShadowMaterial,
  Shape: Shape$1,
  ShapeBufferGeometry: ShapeGeometry,
  ShapeGeometry,
  ShapePath,
  ShapeUtils,
  ShortType,
  Skeleton,
  SkeletonHelper,
  SkinnedMesh,
  SmoothShading,
  Sphere,
  SphereBufferGeometry: SphereGeometry,
  SphereGeometry,
  Spherical,
  SphericalHarmonics3,
  SplineCurve,
  SpotLight,
  SpotLightHelper,
  Sprite,
  SpriteMaterial,
  SrcAlphaFactor,
  SrcAlphaSaturateFactor,
  SrcColorFactor,
  StaticCopyUsage,
  StaticDrawUsage,
  StaticReadUsage,
  StereoCamera,
  StreamCopyUsage,
  StreamDrawUsage,
  StreamReadUsage,
  StringKeyframeTrack,
  SubtractEquation,
  SubtractiveBlending,
  TOUCH,
  TangentSpaceNormalMap,
  TetrahedronBufferGeometry: TetrahedronGeometry,
  TetrahedronGeometry,
  TextBufferGeometry: TextGeometry,
  TextGeometry,
  Texture,
  TextureLoader,
  TorusBufferGeometry: TorusGeometry,
  TorusGeometry,
  TorusKnotBufferGeometry: TorusKnotGeometry,
  TorusKnotGeometry,
  Triangle,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  TrianglesDrawMode,
  TubeBufferGeometry: TubeGeometry,
  TubeGeometry,
  UVMapping,
  Uint16Attribute,
  Uint16BufferAttribute,
  Uint32Attribute,
  Uint32BufferAttribute,
  Uint8Attribute,
  Uint8BufferAttribute,
  Uint8ClampedAttribute,
  Uint8ClampedBufferAttribute,
  Uniform,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedInt248Type,
  UnsignedIntType,
  UnsignedShort4444Type,
  UnsignedShort5551Type,
  UnsignedShort565Type,
  UnsignedShortType,
  VSMShadowMap,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  Vertex,
  VertexColors,
  VideoTexture,
  WebGL1Renderer,
  WebGLCubeRenderTarget,
  WebGLMultipleRenderTargets,
  WebGLMultisampleRenderTarget,
  WebGLRenderTarget,
  WebGLRenderTargetCube,
  WebGLRenderer: WebGLRenderer$1,
  WebGLUtils,
  WireframeGeometry,
  WireframeHelper,
  WrapAroundEnding,
  XHRLoader,
  ZeroCurvatureEnding,
  ZeroFactor,
  ZeroSlopeEnding,
  ZeroStencilOp,
  sRGBEncoding
}, Symbol.toStringTag, { value: "Module" }));
function getName(B) {
  return B.name;
}
function queryKey(B) {
  for (var e = [], b = 0; b < B.length; b++) {
    var L = B[b];
    if (typeof L == "object") {
      var M = L.operator === "not" ? "!" : L.operator;
      e.push(M + getName(L.Component));
    } else
      e.push(getName(L));
  }
  return e.sort().join("-");
}
const hasWindow = typeof window < "u", now$2 = hasWindow && typeof window.performance < "u" ? performance.now.bind(performance) : Date.now.bind(Date);
class SystemManager {
  constructor(e) {
    this._systems = [], this._executeSystems = [], this.world = e, this.lastExecutedSystem = null;
  }
  registerSystem(e, b) {
    if (!e.isSystem)
      throw new Error(
        `System '${e.name}' does not extend 'System' class`
      );
    if (this.getSystem(e) !== void 0)
      return console.warn(`System '${e.getName()}' already registered.`), this;
    var L = new e(this.world, b);
    return L.init && L.init(b), L.order = this._systems.length, this._systems.push(L), L.execute && (this._executeSystems.push(L), this.sortSystems()), this;
  }
  unregisterSystem(e) {
    let b = this.getSystem(e);
    return b === void 0 ? (console.warn(
      `Can unregister system '${e.getName()}'. It doesn't exist.`
    ), this) : (this._systems.splice(this._systems.indexOf(b), 1), b.execute && this._executeSystems.splice(this._executeSystems.indexOf(b), 1), this);
  }
  sortSystems() {
    this._executeSystems.sort((e, b) => e.priority - b.priority || e.order - b.order);
  }
  getSystem(e) {
    return this._systems.find((b) => b instanceof e);
  }
  getSystems() {
    return this._systems;
  }
  removeSystem(e) {
    var b = this._systems.indexOf(e);
    ~b && this._systems.splice(b, 1);
  }
  executeSystem(e, b, L) {
    if (e.initialized && e.canExecute()) {
      let M = now$2();
      e.execute(b, L), e.executeTime = now$2() - M, this.lastExecutedSystem = e, e.clearEvents();
    }
  }
  stop() {
    this._executeSystems.forEach((e) => e.stop());
  }
  execute(e, b, L) {
    this._executeSystems.forEach(
      (M) => (L || M.enabled) && this.executeSystem(M, e, b)
    );
  }
  stats() {
    for (var e = {
      numSystems: this._systems.length,
      systems: {}
    }, b = 0; b < this._systems.length; b++) {
      var L = this._systems[b], M = e.systems[L.getName()] = {
        queries: {},
        executeTime: L.executeTime
      };
      for (var D in L.ctx)
        M.queries[D] = L.ctx[D].stats();
    }
    return e;
  }
}
class ObjectPool {
  // @todo Add initial size
  constructor(e, b) {
    this.freeList = [], this.count = 0, this.T = e, this.isObjectPool = !0, typeof b < "u" && this.expand(b);
  }
  acquire() {
    this.freeList.length <= 0 && this.expand(Math.round(this.count * 0.2) + 1);
    var e = this.freeList.pop();
    return e;
  }
  release(e) {
    e.reset(), this.freeList.push(e);
  }
  expand(e) {
    for (var b = 0; b < e; b++) {
      var L = new this.T();
      L._pool = this, this.freeList.push(L);
    }
    this.count += e;
  }
  totalSize() {
    return this.count;
  }
  totalFree() {
    return this.freeList.length;
  }
  totalUsed() {
    return this.count - this.freeList.length;
  }
}
class EventDispatcher {
  constructor() {
    this._listeners = {}, this.stats = {
      fired: 0,
      handled: 0
    };
  }
  /**
   * Add an event listener
   * @param {String} eventName Name of the event to listen
   * @param {Function} listener Callback to trigger when the event is fired
   */
  addEventListener(e, b) {
    let L = this._listeners;
    L[e] === void 0 && (L[e] = []), L[e].indexOf(b) === -1 && L[e].push(b);
  }
  /**
   * Check if an event listener is already added to the list of listeners
   * @param {String} eventName Name of the event to check
   * @param {Function} listener Callback for the specified event
   */
  hasEventListener(e, b) {
    return this._listeners[e] !== void 0 && this._listeners[e].indexOf(b) !== -1;
  }
  /**
   * Remove an event listener
   * @param {String} eventName Name of the event to remove
   * @param {Function} listener Callback for the specified event
   */
  removeEventListener(e, b) {
    var L = this._listeners[e];
    if (L !== void 0) {
      var M = L.indexOf(b);
      M !== -1 && L.splice(M, 1);
    }
  }
  /**
   * Dispatch an event
   * @param {String} eventName Name of the event to dispatch
   * @param {Entity} entity (Optional) Entity to emit
   * @param {Component} component
   */
  dispatchEvent(e, b, L) {
    this.stats.fired++;
    var M = this._listeners[e];
    if (M !== void 0)
      for (var D = M.slice(0), I = 0; I < D.length; I++)
        D[I].call(this, b, L);
  }
  /**
   * Reset stats counters
   */
  resetCounters() {
    this.stats.fired = this.stats.handled = 0;
  }
}
class Query {
  /**
   * @param {Array(Component)} Components List of types of components to query
   */
  constructor(e, b) {
    if (this.Components = [], this.NotComponents = [], e.forEach((D) => {
      typeof D == "object" ? this.NotComponents.push(D.Component) : this.Components.push(D);
    }), this.Components.length === 0)
      throw new Error("Can't create a query without components");
    this.entities = [], this.eventDispatcher = new EventDispatcher(), this.reactive = !1, this.key = queryKey(e);
    for (var L = 0; L < b._entities.length; L++) {
      var M = b._entities[L];
      this.match(M) && (M.queries.push(this), this.entities.push(M));
    }
  }
  /**
   * Add entity to this query
   * @param {Entity} entity
   */
  addEntity(e) {
    e.queries.push(this), this.entities.push(e), this.eventDispatcher.dispatchEvent(Query.prototype.ENTITY_ADDED, e);
  }
  /**
   * Remove entity from this query
   * @param {Entity} entity
   */
  removeEntity(e) {
    let b = this.entities.indexOf(e);
    ~b && (this.entities.splice(b, 1), b = e.queries.indexOf(this), e.queries.splice(b, 1), this.eventDispatcher.dispatchEvent(
      Query.prototype.ENTITY_REMOVED,
      e
    ));
  }
  match(e) {
    return e.hasAllComponents(this.Components) && !e.hasAnyComponents(this.NotComponents);
  }
  toJSON() {
    return {
      key: this.key,
      reactive: this.reactive,
      components: {
        included: this.Components.map((e) => e.name),
        not: this.NotComponents.map((e) => e.name)
      },
      numEntities: this.entities.length
    };
  }
  /**
   * Return stats for this query
   */
  stats() {
    return {
      numComponents: this.Components.length,
      numEntities: this.entities.length
    };
  }
}
Query.prototype.ENTITY_ADDED = "Query#ENTITY_ADDED";
Query.prototype.ENTITY_REMOVED = "Query#ENTITY_REMOVED";
Query.prototype.COMPONENT_CHANGED = "Query#COMPONENT_CHANGED";
class QueryManager {
  constructor(e) {
    this._world = e, this._queries = {};
  }
  onEntityRemoved(e) {
    for (var b in this._queries) {
      var L = this._queries[b];
      e.queries.indexOf(L) !== -1 && L.removeEntity(e);
    }
  }
  /**
   * Callback when a component is added to an entity
   * @param {Entity} entity Entity that just got the new component
   * @param {Component} Component Component added to the entity
   */
  onEntityComponentAdded(e, b) {
    for (var L in this._queries) {
      var M = this._queries[L];
      if (~M.NotComponents.indexOf(b) && ~M.entities.indexOf(e)) {
        M.removeEntity(e);
        continue;
      }
      !~M.Components.indexOf(b) || !M.match(e) || ~M.entities.indexOf(e) || M.addEntity(e);
    }
  }
  /**
   * Callback when a component is removed from an entity
   * @param {Entity} entity Entity to remove the component from
   * @param {Component} Component Component to remove from the entity
   */
  onEntityComponentRemoved(e, b) {
    for (var L in this._queries) {
      var M = this._queries[L];
      if (~M.NotComponents.indexOf(b) && !~M.entities.indexOf(e) && M.match(e)) {
        M.addEntity(e);
        continue;
      }
      if (~M.Components.indexOf(b) && ~M.entities.indexOf(e) && !M.match(e)) {
        M.removeEntity(e);
        continue;
      }
    }
  }
  /**
   * Get a query for the specified components
   * @param {Component} Components Components that the query should have
   */
  getQuery(e) {
    var b = queryKey(e), L = this._queries[b];
    return L || (this._queries[b] = L = new Query(e, this._world)), L;
  }
  /**
   * Return some stats from this class
   */
  stats() {
    var e = {};
    for (var b in this._queries)
      e[b] = this._queries[b].stats();
    return e;
  }
}
let Component$1 = class {
  constructor(e) {
    if (e !== !1) {
      const b = this.constructor.schema;
      for (const L in b)
        if (e && e.hasOwnProperty(L))
          this[L] = e[L];
        else {
          const M = b[L];
          if (M.hasOwnProperty("default"))
            this[L] = M.type.clone(M.default);
          else {
            const D = M.type;
            this[L] = D.clone(D.default);
          }
        }
    }
    this._pool = null;
  }
  copy(e) {
    const b = this.constructor.schema;
    for (const L in b) {
      const M = b[L];
      e.hasOwnProperty(L) && (this[L] = M.type.copy(e[L], this[L]));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  reset() {
    const e = this.constructor.schema;
    for (const b in e) {
      const L = e[b];
      if (L.hasOwnProperty("default"))
        this[b] = L.type.copy(L.default, this[b]);
      else {
        const M = L.type;
        this[b] = M.copy(M.default, this[b]);
      }
    }
  }
  dispose() {
    this._pool && this._pool.release(this);
  }
  getName() {
    return this.constructor.getName();
  }
};
Component$1.schema = {};
Component$1.isComponent = !0;
Component$1.getName = function() {
  return this.displayName || this.name;
};
class SystemStateComponent extends Component$1 {
}
SystemStateComponent.isSystemStateComponent = !0;
class EntityPool extends ObjectPool {
  constructor(e, b, L) {
    super(b, void 0), this.entityManager = e, typeof L < "u" && this.expand(L);
  }
  expand(e) {
    for (var b = 0; b < e; b++) {
      var L = new this.T(this.entityManager);
      L._pool = this, this.freeList.push(L);
    }
    this.count += e;
  }
}
class EntityManager {
  constructor(e) {
    this.world = e, this.componentsManager = e.componentsManager, this._entities = [], this._nextEntityId = 0, this._entitiesByNames = {}, this._queryManager = new QueryManager(this), this.eventDispatcher = new EventDispatcher(), this._entityPool = new EntityPool(
      this,
      this.world.options.entityClass,
      this.world.options.entityPoolSize
    ), this.entitiesWithComponentsToRemove = [], this.entitiesToRemove = [], this.deferredRemovalEnabled = !0;
  }
  getEntityByName(e) {
    return this._entitiesByNames[e];
  }
  /**
   * Create a new entity
   */
  createEntity(e) {
    var b = this._entityPool.acquire();
    return b.alive = !0, b.name = e || "", e && (this._entitiesByNames[e] ? console.warn(`Entity name '${e}' already exist`) : this._entitiesByNames[e] = b), this._entities.push(b), this.eventDispatcher.dispatchEvent(ENTITY_CREATED, b), b;
  }
  // COMPONENTS
  /**
   * Add a component to an entity
   * @param {Entity} entity Entity where the component will be added
   * @param {Component} Component Component to be added to the entity
   * @param {Object} values Optional values to replace the default attributes
   */
  entityAddComponent(e, b, L) {
    if (typeof b._typeId > "u" && !this.world.componentsManager._ComponentsMap[b._typeId])
      throw new Error(
        `Attempted to add unregistered component "${b.getName()}"`
      );
    if (~e._ComponentTypes.indexOf(b)) {
      console.warn(
        "Component type already exists on entity.",
        e,
        b.getName()
      );
      return;
    }
    e._ComponentTypes.push(b), b.__proto__ === SystemStateComponent && e.numStateComponents++;
    var M = this.world.componentsManager.getComponentsPool(
      b
    ), D = M ? M.acquire() : new b(L);
    M && L && D.copy(L), e._components[b._typeId] = D, this._queryManager.onEntityComponentAdded(e, b), this.world.componentsManager.componentAddedToEntity(b), this.eventDispatcher.dispatchEvent(COMPONENT_ADDED, e, b);
  }
  /**
   * Remove a component from an entity
   * @param {Entity} entity Entity which will get removed the component
   * @param {*} Component Component to remove from the entity
   * @param {Bool} immediately If you want to remove the component immediately instead of deferred (Default is false)
   */
  entityRemoveComponent(e, b, L) {
    var M = e._ComponentTypes.indexOf(b);
    ~M && (this.eventDispatcher.dispatchEvent(COMPONENT_REMOVE, e, b), L ? this._entityRemoveComponentSync(e, b, M) : (e._ComponentTypesToRemove.length === 0 && this.entitiesWithComponentsToRemove.push(e), e._ComponentTypes.splice(M, 1), e._ComponentTypesToRemove.push(b), e._componentsToRemove[b._typeId] = e._components[b._typeId], delete e._components[b._typeId]), this._queryManager.onEntityComponentRemoved(e, b), b.__proto__ === SystemStateComponent && (e.numStateComponents--, e.numStateComponents === 0 && !e.alive && e.remove()));
  }
  _entityRemoveComponentSync(e, b, L) {
    e._ComponentTypes.splice(L, 1);
    var M = e._components[b._typeId];
    delete e._components[b._typeId], M.dispose(), this.world.componentsManager.componentRemovedFromEntity(b);
  }
  /**
   * Remove all the components from an entity
   * @param {Entity} entity Entity from which the components will be removed
   */
  entityRemoveAllComponents(e, b) {
    let L = e._ComponentTypes;
    for (let M = L.length - 1; M >= 0; M--)
      L[M].__proto__ !== SystemStateComponent && this.entityRemoveComponent(e, L[M], b);
  }
  /**
   * Remove the entity from this manager. It will clear also its components
   * @param {Entity} entity Entity to remove from the manager
   * @param {Bool} immediately If you want to remove the component immediately instead of deferred (Default is false)
   */
  removeEntity(e, b) {
    var L = this._entities.indexOf(e);
    if (!~L) throw new Error("Tried to remove entity not in list");
    e.alive = !1, e.numStateComponents === 0 && (this.eventDispatcher.dispatchEvent(ENTITY_REMOVED, e), this._queryManager.onEntityRemoved(e), b === !0 ? this._releaseEntity(e, L) : this.entitiesToRemove.push(e)), this.entityRemoveAllComponents(e, b);
  }
  _releaseEntity(e, b) {
    this._entities.splice(b, 1), this._entitiesByNames[e.name] && delete this._entitiesByNames[e.name], e._pool.release(e);
  }
  /**
   * Remove all entities from this manager
   */
  removeAllEntities() {
    for (var e = this._entities.length - 1; e >= 0; e--)
      this.removeEntity(this._entities[e]);
  }
  processDeferredRemoval() {
    if (this.deferredRemovalEnabled) {
      for (let b = 0; b < this.entitiesToRemove.length; b++) {
        let L = this.entitiesToRemove[b], M = this._entities.indexOf(L);
        this._releaseEntity(L, M);
      }
      this.entitiesToRemove.length = 0;
      for (let b = 0; b < this.entitiesWithComponentsToRemove.length; b++) {
        let L = this.entitiesWithComponentsToRemove[b];
        for (; L._ComponentTypesToRemove.length > 0; ) {
          let M = L._ComponentTypesToRemove.pop();
          var e = L._componentsToRemove[M._typeId];
          delete L._componentsToRemove[M._typeId], e.dispose(), this.world.componentsManager.componentRemovedFromEntity(M);
        }
      }
      this.entitiesWithComponentsToRemove.length = 0;
    }
  }
  /**
   * Get a query based on a list of components
   * @param {Array(Component)} Components List of components that will form the query
   */
  queryComponents(e) {
    return this._queryManager.getQuery(e);
  }
  // EXTRAS
  /**
   * Return number of entities
   */
  count() {
    return this._entities.length;
  }
  /**
   * Return some stats
   */
  stats() {
    var e = {
      numEntities: this._entities.length,
      numQueries: Object.keys(this._queryManager._queries).length,
      queries: this._queryManager.stats(),
      numComponentPool: Object.keys(this.componentsManager._componentPool).length,
      componentPool: {},
      eventDispatcher: this.eventDispatcher.stats
    };
    for (var b in this.componentsManager._componentPool) {
      var L = this.componentsManager._componentPool[b];
      e.componentPool[b] = {
        used: L.totalUsed(),
        size: L.count
      };
    }
    return e;
  }
}
const ENTITY_CREATED = "EntityManager#ENTITY_CREATE", ENTITY_REMOVED = "EntityManager#ENTITY_REMOVED", COMPONENT_ADDED = "EntityManager#COMPONENT_ADDED", COMPONENT_REMOVE = "EntityManager#COMPONENT_REMOVE";
class ComponentManager {
  constructor() {
    this.Components = [], this._ComponentsMap = {}, this._componentPool = {}, this.numComponents = {}, this.nextComponentId = 0;
  }
  registerComponent(e, b) {
    if (this.Components.indexOf(e) !== -1) {
      console.warn(
        `Component type: '${e.getName()}' already registered.`
      );
      return;
    }
    const L = e.schema;
    if (!L)
      throw new Error(
        `Component "${e.getName()}" has no schema property.`
      );
    for (const M in L)
      if (!L[M].type)
        throw new Error(
          `Invalid schema for component "${e.getName()}". Missing type for "${M}" property.`
        );
    e._typeId = this.nextComponentId++, this.Components.push(e), this._ComponentsMap[e._typeId] = e, this.numComponents[e._typeId] = 0, b === void 0 ? b = new ObjectPool(e) : b === !1 && (b = void 0), this._componentPool[e._typeId] = b;
  }
  componentAddedToEntity(e) {
    this.numComponents[e._typeId]++;
  }
  componentRemovedFromEntity(e) {
    this.numComponents[e._typeId]--;
  }
  getComponentsPool(e) {
    return this._componentPool[e._typeId];
  }
}
const Version = "0.3.1";
class Entity {
  constructor(e) {
    this._entityManager = e || null, this.id = e._nextEntityId++, this._ComponentTypes = [], this._components = {}, this._componentsToRemove = {}, this.queries = [], this._ComponentTypesToRemove = [], this.alive = !1, this.numStateComponents = 0;
  }
  // COMPONENTS
  getComponent(e, b) {
    var L = this._components[e._typeId];
    return !L && b === !0 && (L = this._componentsToRemove[e._typeId]), L;
  }
  getRemovedComponent(e) {
    return this._componentsToRemove[e._typeId];
  }
  getComponents() {
    return this._components;
  }
  getComponentsToRemove() {
    return this._componentsToRemove;
  }
  getComponentTypes() {
    return this._ComponentTypes;
  }
  getMutableComponent(e) {
    for (var b = this._components[e._typeId], L = 0; L < this.queries.length; L++) {
      var M = this.queries[L];
      M.reactive && M.Components.indexOf(e) !== -1 && M.eventDispatcher.dispatchEvent(
        Query.prototype.COMPONENT_CHANGED,
        this,
        b
      );
    }
    return b;
  }
  addComponent(e, b) {
    return this._entityManager.entityAddComponent(this, e, b), this;
  }
  removeComponent(e, b) {
    return this._entityManager.entityRemoveComponent(this, e, b), this;
  }
  hasComponent(e, b) {
    return !!~this._ComponentTypes.indexOf(e) || b === !0 && this.hasRemovedComponent(e);
  }
  hasRemovedComponent(e) {
    return !!~this._ComponentTypesToRemove.indexOf(e);
  }
  hasAllComponents(e) {
    for (var b = 0; b < e.length; b++)
      if (!this.hasComponent(e[b])) return !1;
    return !0;
  }
  hasAnyComponents(e) {
    for (var b = 0; b < e.length; b++)
      if (this.hasComponent(e[b])) return !0;
    return !1;
  }
  removeAllComponents(e) {
    return this._entityManager.entityRemoveAllComponents(this, e);
  }
  copy(e) {
    for (var b in e._components) {
      var L = e._components[b];
      this.addComponent(L.constructor);
      var M = this.getComponent(L.constructor);
      M.copy(L);
    }
    return this;
  }
  clone() {
    return new Entity(this._entityManager).copy(this);
  }
  reset() {
    this.id = this._entityManager._nextEntityId++, this._ComponentTypes.length = 0, this.queries.length = 0;
    for (var e in this._components)
      delete this._components[e];
  }
  remove(e) {
    return this._entityManager.removeEntity(this, e);
  }
}
const DEFAULT_OPTIONS = {
  entityPoolSize: 0,
  entityClass: Entity
};
class World {
  constructor(e = {}) {
    if (this.options = Object.assign({}, DEFAULT_OPTIONS, e), this.componentsManager = new ComponentManager(this), this.entityManager = new EntityManager(this), this.systemManager = new SystemManager(this), this.enabled = !0, this.eventQueues = {}, hasWindow && typeof CustomEvent < "u") {
      var b = new CustomEvent("ecsy-world-created", {
        detail: { world: this, version: Version }
      });
      window.dispatchEvent(b);
    }
    this.lastTime = now$2();
  }
  registerComponent(e, b) {
    return this.componentsManager.registerComponent(e, b), this;
  }
  registerSystem(e, b) {
    return this.systemManager.registerSystem(e, b), this;
  }
  unregisterSystem(e) {
    return this.systemManager.unregisterSystem(e), this;
  }
  getSystem(e) {
    return this.systemManager.getSystem(e);
  }
  getSystems() {
    return this.systemManager.getSystems();
  }
  execute(e, b) {
    e || (b = now$2(), e = b - this.lastTime, this.lastTime = b), this.enabled && (this.systemManager.execute(e, b), this.entityManager.processDeferredRemoval());
  }
  stop() {
    this.enabled = !1;
  }
  play() {
    this.enabled = !0;
  }
  createEntity(e) {
    return this.entityManager.createEntity(e);
  }
  stats() {
    var e = {
      entities: this.entityManager.stats(),
      system: this.systemManager.stats()
    };
    console.log(JSON.stringify(e, null, 2));
  }
}
class System {
  canExecute() {
    if (this._mandatoryQueries.length === 0) return !0;
    for (let b = 0; b < this._mandatoryQueries.length; b++) {
      var e = this._mandatoryQueries[b];
      if (e.entities.length === 0)
        return !1;
    }
    return !0;
  }
  getName() {
    return this.constructor.getName();
  }
  constructor(e, b) {
    if (this.world = e, this.enabled = !0, this._queries = {}, this.queries = {}, this.priority = 0, this.executeTime = 0, b && b.priority && (this.priority = b.priority), this._mandatoryQueries = [], this.initialized = !0, this.constructor.queries)
      for (var L in this.constructor.queries) {
        var M = this.constructor.queries[L], D = M.components;
        if (!D || D.length === 0)
          throw new Error("'components' attribute can't be empty in a query");
        var I = this.world.entityManager.queryComponents(D);
        this._queries[L] = I, M.mandatory === !0 && this._mandatoryQueries.push(I), this.queries[L] = {
          results: I.entities
        };
        var F = ["added", "removed", "changed"];
        const N = {
          added: Query.prototype.ENTITY_ADDED,
          removed: Query.prototype.ENTITY_REMOVED,
          changed: Query.prototype.COMPONENT_CHANGED
          // Query.prototype.ENTITY_CHANGED
        };
        M.listen && F.forEach((U) => {
          if (this.execute || console.warn(
            `System '${this.getName()}' has defined listen events (${F.join(
              ", "
            )}) for query '${L}' but it does not implement the 'execute' method.`
          ), M.listen[U]) {
            let G = M.listen[U];
            if (U === "changed") {
              if (I.reactive = !0, G === !0) {
                let V = this.queries[L][U] = [];
                I.eventDispatcher.addEventListener(
                  Query.prototype.COMPONENT_CHANGED,
                  (z) => {
                    V.indexOf(z) === -1 && V.push(z);
                  }
                );
              } else if (Array.isArray(G)) {
                let V = this.queries[L][U] = [];
                I.eventDispatcher.addEventListener(
                  Query.prototype.COMPONENT_CHANGED,
                  (z, k) => {
                    G.indexOf(k.constructor) !== -1 && V.indexOf(z) === -1 && V.push(z);
                  }
                );
              }
            } else {
              let V = this.queries[L][U] = [];
              I.eventDispatcher.addEventListener(
                N[U],
                (z) => {
                  V.indexOf(z) === -1 && V.push(z);
                }
              );
            }
          }
        });
      }
  }
  stop() {
    this.executeTime = 0, this.enabled = !1;
  }
  play() {
    this.enabled = !0;
  }
  // @question rename to clear queues?
  clearEvents() {
    for (let b in this.queries) {
      var e = this.queries[b];
      if (e.added && (e.added.length = 0), e.removed && (e.removed.length = 0), e.changed)
        if (Array.isArray(e.changed))
          e.changed.length = 0;
        else
          for (let L in e.changed)
            e.changed[L].length = 0;
    }
  }
  toJSON() {
    var e = {
      name: this.getName(),
      enabled: this.enabled,
      executeTime: this.executeTime,
      priority: this.priority,
      queries: {}
    };
    if (this.constructor.queries) {
      var b = this.constructor.queries;
      for (let L in b) {
        let M = this.queries[L], D = b[L], I = e.queries[L] = {
          key: this._queries[L].key
        };
        I.mandatory = D.mandatory === !0, I.reactive = D.listen && (D.listen.added === !0 || D.listen.removed === !0 || D.listen.changed === !0 || Array.isArray(D.listen.changed)), I.reactive && (I.listen = {}, ["added", "removed", "changed"].forEach((N) => {
          M[N] && (I.listen[N] = {
            entities: M[N].length
          });
        }));
      }
    }
    return e;
  }
}
System.isSystem = !0;
System.getName = function() {
  return this.displayName || this.name;
};
function Not(B) {
  return {
    operator: "not",
    Component: B
  };
}
class TagComponent extends Component$1 {
  constructor() {
    super(!1);
  }
}
TagComponent.isTagComponent = !0;
const copyValue = (B) => B, cloneValue = (B) => B, copyArray = (B, e) => {
  if (!B)
    return B;
  if (!e)
    return B.slice();
  e.length = 0;
  for (let b = 0; b < B.length; b++)
    e.push(B[b]);
  return e;
}, cloneArray = (B) => B && B.slice(), copyJSON = (B) => JSON.parse(JSON.stringify(B)), cloneJSON = (B) => JSON.parse(JSON.stringify(B)), copyCopyable = (B, e) => B && (e ? e.copy(B) : B.clone()), cloneClonable = (B) => B && B.clone();
function createType(B) {
  var e = ["name", "default", "copy", "clone"], b = e.filter((L) => !B.hasOwnProperty(L));
  if (b.length > 0)
    throw new Error(
      `createType expects a type definition with the following properties: ${b.join(
        ", "
      )}`
    );
  return B.isType = !0, B;
}
const Types = {
  Number: createType({
    name: "Number",
    default: 0,
    copy: copyValue,
    clone: cloneValue
  }),
  Boolean: createType({
    name: "Boolean",
    default: !1,
    copy: copyValue,
    clone: cloneValue
  }),
  String: createType({
    name: "String",
    default: "",
    copy: copyValue,
    clone: cloneValue
  }),
  Array: createType({
    name: "Array",
    default: [],
    copy: copyArray,
    clone: cloneArray
  }),
  Ref: createType({
    name: "Ref",
    default: void 0,
    copy: copyValue,
    clone: cloneValue
  }),
  JSON: createType({
    name: "JSON",
    default: null,
    copy: copyJSON,
    clone: cloneJSON
  })
};
function generateId(B) {
  for (var e = "", b = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", L = b.length, M = 0; M < B; M++)
    e += b.charAt(Math.floor(Math.random() * L));
  return e;
}
function injectScript(B, e) {
  var b = document.createElement("script");
  b.src = B, b.onload = e, (document.head || document.documentElement).appendChild(b);
}
function hookConsoleAndErrors(B) {
  var e = ["error", "warning", "log"];
  e.forEach((b) => {
    if (typeof console[b] == "function") {
      var L = console[b].bind(console);
      console[b] = (...M) => (B.send({
        method: "console",
        type: b,
        args: JSON.stringify(M)
      }), L.apply(null, M));
    }
  }), window.addEventListener("error", (b) => {
    B.send({
      method: "error",
      error: JSON.stringify({
        message: b.error.message,
        stack: b.error.stack
      })
    });
  });
}
function includeRemoteIdHTML(B) {
  let e = document.createElement("div");
  return e.style.cssText = `
    align-items: center;
    background-color: #333;
    color: #aaa;
    display:flex;
    font-family: Arial;
    font-size: 1.1em;
    height: 40px;
    justify-content: center;
    left: 0;
    opacity: 0.9;
    position: absolute;
    right: 0;
    text-align: center;
    top: 0;
  `, e.innerHTML = `Open ECSY devtools to connect to this page using the code:&nbsp;<b style="color: #fff">${B}</b>&nbsp;<button onClick="generateNewCode()">Generate new code</button>`, document.body.appendChild(e), e;
}
function enableRemoteDevtools(remoteId) {
  if (!hasWindow) {
    console.warn("Remote devtools not available outside the browser");
    return;
  }
  window.generateNewCode = () => {
    window.localStorage.clear(), remoteId = generateId(6), window.localStorage.setItem("ecsyRemoteId", remoteId), window.location.reload(!1);
  }, remoteId = remoteId || window.localStorage.getItem("ecsyRemoteId"), remoteId || (remoteId = generateId(6), window.localStorage.setItem("ecsyRemoteId", remoteId));
  let infoDiv = includeRemoteIdHTML(remoteId);
  window.__ECSY_REMOTE_DEVTOOLS_INJECTED = !0, window.__ECSY_REMOTE_DEVTOOLS = {};
  let Version = "", worldsBeforeLoading = [], onWorldCreated = (B) => {
    var e = B.detail.world;
    Version = B.detail.version, worldsBeforeLoading.push(e);
  };
  window.addEventListener("ecsy-world-created", onWorldCreated);
  let onLoaded = () => {
    var peer = new Peer(remoteId);
    peer.on("open", () => {
      peer.on("connection", (connection) => {
        window.__ECSY_REMOTE_DEVTOOLS.connection = connection, connection.on("open", function() {
          infoDiv.innerHTML = "Connected", connection.on("data", function(data) {
            if (data.type === "init") {
              var script = document.createElement("script");
              script.setAttribute("type", "text/javascript"), script.onload = () => {
                script.parentNode.removeChild(script), window.removeEventListener(
                  "ecsy-world-created",
                  onWorldCreated
                ), worldsBeforeLoading.forEach((B) => {
                  var e = new CustomEvent("ecsy-world-created", {
                    detail: { world: B, version: Version }
                  });
                  window.dispatchEvent(e);
                });
              }, script.innerHTML = data.script, (document.head || document.documentElement).appendChild(script), script.onload(), hookConsoleAndErrors(connection);
            } else if (data.type === "executeScript") {
              let value = eval(data.script);
              data.returnEval && connection.send({
                method: "evalReturn",
                value
              });
            }
          });
        });
      });
    });
  };
  injectScript(
    "https://cdn.jsdelivr.net/npm/peerjs@0.3.20/dist/peer.min.js",
    onLoaded
  );
}
hasWindow && new URLSearchParams(window.location.search).has("enable-remote-devtools") && enableRemoteDevtools();
class Object3DComponent extends Component$1 {
}
Object3DComponent.schema = {
  value: { default: null, type: Types.Ref }
};
class ECSYThreeEntity extends Entity {
  addObject3DComponent(e, b) {
    return e.entity = this, this.addComponent(Object3DComponent, { value: e }), this._entityManager.world.object3DInflator.inflate(this, e), b && b.hasComponent(Object3DComponent) && b.getObject3D().add(e), this;
  }
  removeObject3DComponent(e = !0) {
    const b = this.getComponent(Object3DComponent, !0).value;
    e && b.parent && b.parent.remove(b), this.removeComponent(Object3DComponent), this._entityManager.world.object3DInflator.deflate(this, b), b.entity = null;
  }
  remove(e) {
    if (this.hasComponent(Object3DComponent)) {
      const b = this.getObject3D();
      b.traverse((L) => {
        L.entity && this._entityManager.removeEntity(L.entity, e), L.entity = null;
      }), b.parent && b.parent.remove(b);
    }
    this._entityManager.removeEntity(this, e);
  }
  getObject3D() {
    return this.getComponent(Object3DComponent).value;
  }
}
class SceneTagComponent extends TagComponent {
}
class CameraTagComponent extends TagComponent {
}
class MeshTagComponent extends TagComponent {
}
const defaultObject3DInflator = {
  inflate: (B, e) => {
    e.isMesh ? B.addComponent(MeshTagComponent) : e.isScene ? B.addComponent(SceneTagComponent) : e.isCamera && B.addComponent(CameraTagComponent);
  },
  deflate: (B, e) => {
    e.isMesh ? B.removeComponent(MeshTagComponent) : e.isScene ? B.removeComponent(SceneTagComponent) : e.isCamera && B.removeComponent(CameraTagComponent);
  }
};
class ECSYThreeWorld extends World {
  constructor(e) {
    super(Object.assign({}, { entityClass: ECSYThreeEntity }, e)), this.object3DInflator = defaultObject3DInflator;
  }
}
const Vector3Type = createType({
  name: "Vector3",
  default: new Vector3(),
  copy: copyCopyable,
  clone: cloneClonable
}), ThreeTypes = {
  Vector3Type
};
class Active extends TagComponent {
}
class Animation extends Component$1 {
}
Animation.schema = {
  animations: { default: [], type: Types.Array },
  duration: { default: -1, type: Types.Number }
};
class Camera extends Component$1 {
}
Camera.schema = {
  fov: { default: 45, type: Types.Number },
  aspect: { default: 1, type: Types.Number },
  near: { default: 0.1, type: Types.Number },
  far: { default: 1e3, type: Types.Number },
  layers: { default: 0, type: Types.Number },
  handleResize: { default: !0, type: Types.Boolean }
};
class CameraRig extends Component$1 {
}
CameraRig.schema = {
  leftHand: { default: null, type: Types.Ref },
  rightHand: { default: null, type: Types.Ref },
  camera: { default: null, type: Types.Ref }
};
class Colliding extends Component$1 {
}
Colliding.schema = {
  collidingWith: { default: [], type: Types.Array },
  collidingFrame: { default: 0, type: Types.Number }
};
class CollisionStart extends TagComponent {
}
class CollisionStop extends TagComponent {
}
class Draggable extends Component$1 {
}
Draggable.schema = {
  value: { default: !1, type: Types.Boolean }
};
class Dragging extends TagComponent {
}
class Geometry extends Component$1 {
}
Geometry.schema = {
  primitive: { default: "box", type: Types.String },
  width: { default: 0, type: Types.Number },
  height: { default: 0, type: Types.Number },
  depth: { default: 0, type: Types.Number }
};
let GLTFLoader$1 = class extends Component$1 {
};
GLTFLoader$1.schema = {
  url: { default: "", type: Types.String },
  receiveShadow: { default: !1, type: Types.Boolean },
  castShadow: { default: !1, type: Types.Boolean },
  envMapOverride: { default: null, type: Types.Ref },
  append: { default: !0, type: Types.Boolean },
  onLoaded: { default: null, type: Types.Ref },
  parent: { default: null, type: Types.Ref }
};
class GLTFModel extends Component$1 {
}
GLTFModel.schema = {
  value: { default: null, type: Types.Ref }
};
class InputState extends Component$1 {
}
InputState.schema = {
  vrcontrollers: { default: /* @__PURE__ */ new Map(), type: Types.Ref },
  keyboard: { default: {}, type: Types.Ref },
  mouse: { default: {}, type: Types.Ref },
  gamepads: { default: {}, type: Types.Ref }
};
class Parent extends Component$1 {
}
Parent.schema = {
  value: { default: null, type: Types.Ref }
};
class ParentObject3D extends Component$1 {
}
ParentObject3D.schema = {
  value: { default: null, type: Types.Ref }
};
class Play extends TagComponent {
}
class Position extends Component$1 {
}
Position.schema = {
  value: { default: new Vector3(), type: Vector3Type }
};
class RenderPass extends Component$1 {
}
RenderPass.schema = {
  scene: { default: null, type: Types.Ref },
  camera: { default: null, type: Types.Ref }
};
class RigidBody extends Component$1 {
}
RigidBody.schema = {
  object: { default: null, type: Types.Ref },
  weight: { default: 0, type: Types.Number },
  restitution: { default: 1, type: Types.Number },
  friction: { default: 1, type: Types.Number },
  linearDamping: { default: 0, type: Types.Number },
  angularDamping: { default: 0, type: Types.Number },
  linearVelocity: { default: { x: 0, y: 0, z: 0 }, type: Types.Ref }
};
class Rotation extends Component$1 {
}
Rotation.schema = {
  // @fixme
  rotation: { default: new Vector3(), type: Vector3Type }
};
class Scale extends Component$1 {
}
Scale.schema = {
  // @fixme
  value: { default: new Vector3(), type: Vector3Type }
};
class Scene extends Component$1 {
}
Scene.schema = {
  value: { default: null, type: Types.Ref }
};
class Shape extends Component$1 {
}
Shape.schema = {
  primitive: { default: "", type: Types.String },
  width: { default: 0, type: Types.Number },
  height: { default: 0, type: Types.Number },
  depth: { default: 0, type: Types.Number },
  radius: { default: 0, type: Types.Number }
};
class SkyBox extends Component$1 {
}
SkyBox.schema = {
  textureUrl: { default: null, type: Types.String },
  type: { default: 0, type: Types.Number }
};
class Sound extends Component$1 {
}
Sound.schema = {
  sound: { default: null, type: Types.Ref },
  url: { default: "", type: Types.String }
};
class Stop extends TagComponent {
}
let Text$1 = class extends Component$1 {
};
Text$1.schema = {
  text: { default: "", type: Types.String },
  textAlign: { default: "left", type: Types.String },
  // ['left', 'right', 'center']
  anchor: { default: "center", type: Types.String },
  // ['left', 'right', 'center', 'align']
  baseline: { default: "center", type: Types.String },
  // ['top', 'center', 'bottom']
  color: { default: "#FFF", type: Types.String },
  font: { default: "", type: Types.String },
  //"https://code.cdn.mozilla.net/fonts/ttf/ZillaSlab-SemiBold.ttf"
  fontSize: { default: 0.2, type: Types.Number },
  letterSpacing: { default: 0, type: Types.Number },
  lineHeight: { default: 0, type: Types.Number },
  maxWidth: { default: 1 / 0, type: Types.Number },
  overflowWrap: { default: "normal", type: Types.String },
  // ['normal', 'break-word']
  whiteSpace: { default: "normal", type: Types.String },
  // ['normal', 'nowrap']
  opacity: { default: 1, type: Types.Number }
};
class Transform extends Component$1 {
}
Transform.schema = {
  position: { default: new Vector3(), type: Vector3Type },
  rotation: { default: new Vector3(), type: Vector3Type }
};
class Visible extends Component$1 {
}
Visible.schema = {
  value: { default: !0, type: Types.Boolean }
};
class VRController extends Component$1 {
}
VRController.schema = {
  id: { default: 0, type: Types.Number },
  controller: { default: null, type: Types.Ref }
};
class VRControllerBasicBehaviour extends Component$1 {
}
VRControllerBasicBehaviour.schema = {
  select: { default: null, type: Types.Ref },
  selectstart: { default: null, type: Types.Ref },
  selectend: { default: null, type: Types.Ref },
  connected: { default: null, type: Types.Ref },
  disconnected: { default: null, type: Types.Ref },
  squeeze: { default: null, type: Types.Ref },
  squeezestart: { default: null, type: Types.Ref },
  squeezeend: { default: null, type: Types.Ref }
};
class WebGLRenderer extends Component$1 {
}
WebGLRenderer.schema = {
  vr: { default: !1, type: Types.Boolean },
  ar: { default: !1, type: Types.Boolean },
  antialias: { default: !0, type: Types.Boolean },
  handleResize: { default: !0, type: Types.Boolean },
  shadowMap: { default: !0, type: Types.Boolean },
  animationLoop: { default: null, type: Types.Ref }
};
class ControllerConnected extends TagComponent {
}
class OnObject3DAdded extends Component$1 {
}
OnObject3DAdded.schema = {
  callback: { default: null, type: Types.Ref }
};
class UpdateAspectOnResizeTag extends TagComponent {
}
class VRButton {
  static createButton(e, b) {
    b && console.error('THREE.VRButton: The "options" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.');
    const L = document.createElement("button");
    function M() {
      let N = null;
      async function U(V) {
        V.addEventListener("end", G), await e.xr.setSession(V), L.textContent = "EXIT VR", N = V;
      }
      function G() {
        N.removeEventListener("end", G), L.textContent = "ENTER VR", N = null;
      }
      L.style.display = "", L.style.cursor = "pointer", L.style.left = "calc(50% - 50px)", L.style.width = "100px", L.textContent = "ENTER VR", L.onmouseenter = function() {
        L.style.opacity = "1.0";
      }, L.onmouseleave = function() {
        L.style.opacity = "0.5";
      }, L.onclick = function() {
        if (N === null) {
          const V = { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"] };
          navigator.xr.requestSession("immersive-vr", V).then(U);
        } else
          N.end();
      };
    }
    function D() {
      L.style.display = "", L.style.cursor = "auto", L.style.left = "calc(50% - 75px)", L.style.width = "150px", L.onmouseenter = null, L.onmouseleave = null, L.onclick = null;
    }
    function I() {
      D(), L.textContent = "VR NOT SUPPORTED";
    }
    function F(N) {
      N.style.position = "absolute", N.style.bottom = "20px", N.style.padding = "12px 6px", N.style.border = "1px solid #fff", N.style.borderRadius = "4px", N.style.background = "rgba(0,0,0,0.1)", N.style.color = "#fff", N.style.font = "normal 13px sans-serif", N.style.textAlign = "center", N.style.opacity = "0.5", N.style.outline = "none", N.style.zIndex = "999";
    }
    if ("xr" in navigator)
      return L.id = "VRButton", L.style.display = "none", F(L), navigator.xr.isSessionSupported("immersive-vr").then(function(N) {
        N ? M() : I();
      }), L;
    {
      const N = document.createElement("a");
      return window.isSecureContext === !1 ? (N.href = document.location.href.replace(/^http:/, "https:"), N.innerHTML = "WEBXR NEEDS HTTPS") : (N.href = "https://immersiveweb.dev/", N.innerHTML = "WEBXR NOT AVAILABLE"), N.style.left = "calc(50% - 90px)", N.style.width = "180px", N.style.textDecoration = "none", F(N), N;
    }
  }
}
class ARButton {
  static createButton(e, b = {}) {
    const L = document.createElement("button");
    function M() {
      if (b.domOverlay === void 0) {
        var N = document.createElement("div");
        N.style.display = "none", document.body.appendChild(N);
        var U = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        U.setAttribute("width", 38), U.setAttribute("height", 38), U.style.position = "absolute", U.style.right = "20px", U.style.top = "20px", U.addEventListener("click", function() {
          V.end();
        }), N.appendChild(U);
        var G = document.createElementNS("http://www.w3.org/2000/svg", "path");
        G.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28"), G.setAttribute("stroke", "#fff"), G.setAttribute("stroke-width", 2), U.appendChild(G), b.optionalFeatures === void 0 && (b.optionalFeatures = []), b.optionalFeatures.push("dom-overlay"), b.domOverlay = { root: N };
      }
      let V = null;
      async function z(H) {
        H.addEventListener("end", k), e.xr.setReferenceSpaceType("local"), await e.xr.setSession(H), L.textContent = "STOP AR", b.domOverlay.root.style.display = "", V = H;
      }
      function k() {
        V.removeEventListener("end", k), L.textContent = "START AR", b.domOverlay.root.style.display = "none", V = null;
      }
      L.style.display = "", L.style.cursor = "pointer", L.style.left = "calc(50% - 50px)", L.style.width = "100px", L.textContent = "START AR", L.onmouseenter = function() {
        L.style.opacity = "1.0";
      }, L.onmouseleave = function() {
        L.style.opacity = "0.5";
      }, L.onclick = function() {
        V === null ? navigator.xr.requestSession("immersive-ar", b).then(z) : V.end();
      };
    }
    function D() {
      L.style.display = "", L.style.cursor = "auto", L.style.left = "calc(50% - 75px)", L.style.width = "150px", L.onmouseenter = null, L.onmouseleave = null, L.onclick = null;
    }
    function I() {
      D(), L.textContent = "AR NOT SUPPORTED";
    }
    function F(N) {
      N.style.position = "absolute", N.style.bottom = "20px", N.style.padding = "12px 6px", N.style.border = "1px solid #fff", N.style.borderRadius = "4px", N.style.background = "rgba(0,0,0,0.1)", N.style.color = "#fff", N.style.font = "normal 13px sans-serif", N.style.textAlign = "center", N.style.opacity = "0.5", N.style.outline = "none", N.style.zIndex = "999";
    }
    if ("xr" in navigator)
      return L.id = "ARButton", L.style.display = "none", F(L), navigator.xr.isSessionSupported("immersive-ar").then(function(N) {
        N ? M() : I();
      }).catch(I), L;
    {
      const N = document.createElement("a");
      return window.isSecureContext === !1 ? (N.href = document.location.href.replace(/^http:/, "https:"), N.innerHTML = "WEBXR NEEDS HTTPS") : (N.href = "https://immersiveweb.dev/", N.innerHTML = "WEBXR NOT AVAILABLE"), N.style.left = "calc(50% - 90px)", N.style.width = "180px", N.style.textDecoration = "none", F(N), N;
    }
  }
}
class WebGLRendererContext extends Component$1 {
}
WebGLRendererContext.schema = {
  value: { default: null, type: Types.Ref }
};
class WebGLRendererSystem extends System {
  init() {
    this.world.registerComponent(WebGLRendererContext), window.addEventListener(
      "resize",
      () => {
        this.queries.renderers.results.forEach((e) => {
          var b = e.getMutableComponent(WebGLRenderer);
          b.width = window.innerWidth, b.height = window.innerHeight;
        });
      },
      !1
    );
  }
  execute() {
    this.queries.renderers.results.forEach((b) => {
      var L = b.getComponent(WebGLRendererContext).value;
      this.queries.renderPasses.results.forEach((M) => {
        var D = M.getComponent(RenderPass), I = D.scene.getObject3D();
        this.queries.activeCameras.results.forEach((F) => {
          var N = F.getObject3D();
          L.render(I, N);
        });
      });
    }), this.queries.uninitializedRenderers.results.forEach((b) => {
      var L = b.getComponent(WebGLRenderer), M = new WebGLRenderer$1({
        antialias: L.antialias
      });
      L.animationLoop && M.setAnimationLoop(L.animationLoop), M.setPixelRatio(window.devicePixelRatio), L.handleResize && M.setSize(window.innerWidth, window.innerHeight), M.shadowMap.enabled = L.shadowMap, document.body.appendChild(M.domElement), (L.vr || L.ar) && (M.xr.enabled = !0, L.vr && document.body.appendChild(VRButton.createButton(M)), L.ar && document.body.appendChild(ARButton.createButton(M))), b.addComponent(WebGLRendererContext, { value: M });
    }), this.queries.renderers.changed.forEach((b) => {
      var L = b.getComponent(WebGLRenderer), M = b.getComponent(WebGLRendererContext).value;
      (L.width !== M.width || L.height !== M.height) && M.setSize(L.width, L.height);
    });
  }
}
WebGLRendererSystem.queries = {
  uninitializedRenderers: {
    components: [WebGLRenderer, Not(WebGLRendererContext)]
  },
  renderers: {
    components: [WebGLRenderer, WebGLRendererContext],
    listen: {
      changed: [WebGLRenderer]
    }
  },
  renderPasses: {
    components: [RenderPass]
  },
  activeCameras: {
    components: [CameraTagComponent, Active],
    listen: {
      added: !0
    }
  }
};
class TransformSystem extends System {
  execute() {
    let e = this.queries.parent.added;
    for (var b = 0; b < e.length; b++) {
      var L = e[b];
      if (!L.alive)
        return;
      var M = L.getComponent(Parent).value;
      if (M.hasComponent(Object3DComponent)) {
        var D = M.getObject3D(), I = L.getObject3D();
        D.add(I);
      }
    }
    this.queries.parentObject3D.added.forEach((G) => {
      var V = G.getComponent(ParentObject3D).value, z = G.getObject3D();
      V.add(z);
    });
    var F = this.queries.transforms;
    for (let G = 0; G < F.added.length; G++) {
      let V = F.added[G], z = V.getComponent(Transform), k = V.getObject3D();
      k.position.copy(z.position), k.rotation.set(
        z.rotation.x,
        z.rotation.y,
        z.rotation.z
      );
    }
    for (let G = 0; G < F.changed.length; G++) {
      let V = F.changed[G];
      if (!V.alive)
        continue;
      let z = V.getComponent(Transform), k = V.getObject3D();
      k.position.copy(z.position), k.rotation.set(
        z.rotation.x,
        z.rotation.y,
        z.rotation.z
      );
    }
    let N = this.queries.positions;
    for (let G = 0; G < N.added.length; G++) {
      let V = N.added[G], z = V.getComponent(Position).value, k = V.getObject3D();
      k.position.copy(z), V.getComponent(Position).value = k.position;
    }
    let U = this.queries.scales;
    for (let G = 0; G < U.added.length; G++) {
      let V = U.added[G], z = V.getComponent(Scale).value;
      V.getObject3D().scale.copy(z);
    }
    for (let G = 0; G < U.changed.length; G++) {
      let V = U.changed[G], z = V.getComponent(Scale).value;
      V.getObject3D().scale.copy(z);
    }
  }
}
TransformSystem.queries = {
  parentObject3D: {
    components: [ParentObject3D, Object3DComponent],
    listen: {
      added: !0
    }
  },
  parent: {
    components: [Parent, Object3DComponent],
    listen: {
      added: !0
    }
  },
  transforms: {
    components: [Object3DComponent, Transform],
    listen: {
      added: !0,
      changed: [Transform]
    }
  },
  positions: {
    components: [Object3DComponent, Position],
    listen: {
      added: !0,
      changed: [Position]
    }
  },
  scales: {
    components: [Object3DComponent, Scale],
    listen: {
      added: !0,
      changed: [Scale]
    }
  }
};
class UpdateAspectOnResizeSystem extends System {
  init() {
    this.aspect = window.innerWidth / window.innerHeight, window.addEventListener(
      "resize",
      () => {
        this.aspect = window.innerWidth / window.innerHeight, console.log("resize", this.aspect);
      },
      !1
    );
  }
  execute() {
    let e = this.queries.cameras.results;
    for (let b = 0; b < e.length; b++) {
      let L = e[b].getObject3D();
      L.aspect !== this.aspect && (L.aspect = this.aspect, L.updateProjectionMatrix());
    }
  }
}
UpdateAspectOnResizeSystem.queries = {
  cameras: {
    components: [CameraTagComponent, UpdateAspectOnResizeTag, Object3DComponent]
  }
};
class OnObject3DAddedSystem extends System {
  execute() {
    const e = this.queries.entities.added;
    for (let b = 0; b < e.length; b++) {
      const L = e[b];
      L.getComponent(OnObject3DAdded).callback(L.getObject3D());
    }
  }
}
OnObject3DAddedSystem.queries = {
  entities: {
    components: [OnObject3DAdded, Object3DComponent],
    listen: {
      added: !0
    }
  }
};
function initialize(B = new ECSYThreeWorld(), e) {
  if (!(B instanceof ECSYThreeWorld))
    throw new Error(
      "The provided 'world' paremeter is not an instance of 'ECSYThreeWorld'"
    );
  if (B.registerSystem(UpdateAspectOnResizeSystem).registerSystem(TransformSystem).registerSystem(OnObject3DAddedSystem).registerSystem(WebGLRendererSystem), B.registerComponent(OnObject3DAdded).registerComponent(WebGLRenderer).registerComponent(Scene).registerComponent(Active).registerComponent(CameraRig).registerComponent(Parent).registerComponent(Object3DComponent).registerComponent(RenderPass).registerComponent(Camera).registerComponent(SceneTagComponent).registerComponent(CameraTagComponent).registerComponent(MeshTagComponent).registerComponent(UpdateAspectOnResizeTag), e = Object.assign({}, {
    vr: !1,
    defaults: !0
  }, e), !e.defaults)
    return { world: B };
  let L = e.animationLoop;
  if (!L) {
    const U = new Clock();
    L = () => {
      B.execute(U.getDelta(), U.elapsedTime);
    };
  }
  let M = B.createEntity().addComponent(Scene).addObject3DComponent(new Scene$1()), D = B.createEntity().addComponent(WebGLRenderer, {
    ar: e.ar,
    vr: e.vr,
    animationLoop: L
  });
  var I = null, F = null;
  e.ar || e.vr ? F = B.createEntity().addComponent(CameraRig).addComponent(Parent, { value: M }).addComponent(Active) : I = B.createEntity().addComponent(Camera).addComponent(UpdateAspectOnResizeTag).addObject3DComponent(
    new PerspectiveCamera(
      90,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    ),
    M
  ).addComponent(Active);
  let N = B.createEntity().addComponent(RenderPass, {
    scene: M,
    camera: I
  });
  return {
    world: B,
    entities: {
      scene: M,
      camera: I,
      cameraRig: F,
      renderer: D,
      renderPass: N
    }
  };
}
class GeometrySystem extends System {
  execute() {
    this.queries.entities.removed.forEach((e) => {
      var b = e.getRemovedComponent(Object3DComponent).value, L = e.getComponent(Parent, !0).value;
      L.getObject3D().remove(b);
    }), this.queries.entities.added.forEach((e) => {
      var b = e.getComponent(Geometry), L;
      switch (b.primitive) {
        case "torus":
          L = new TorusGeometry(
            b.radius,
            b.tube,
            b.radialSegments,
            b.tubularSegments
          );
          break;
        case "sphere":
          L = new IcosahedronGeometry(b.radius, 1);
          break;
        case "box":
          L = new BoxGeometry(
            b.width,
            b.height,
            b.depth
          );
          break;
      }
      var M = b.primitive === "torus" ? 10066176 : Math.random() * 16777215, D = new MeshLambertMaterial({
        color: M
      }), I = new Mesh(L, D);
      if (I.castShadow = !0, I.receiveShadow = !0, e.hasComponent(Transform)) {
        var F = e.getComponent(Transform);
        I.position.copy(F.position), F.rotation && I.rotation.set(
          F.rotation.x,
          F.rotation.y,
          F.rotation.z
        );
      }
      e.addComponent(Object3DComponent, { value: I });
    });
  }
}
GeometrySystem.queries = {
  entities: {
    components: [Geometry],
    // @todo Transform: As optional, how to define it?
    listen: {
      added: !0,
      removed: !0
    }
  }
};
class GLTFLoader extends Loader {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(b) {
      return new GLTFMaterialsClearcoatExtension(b);
    }), this.register(function(b) {
      return new GLTFTextureBasisUExtension(b);
    }), this.register(function(b) {
      return new GLTFTextureWebPExtension(b);
    }), this.register(function(b) {
      return new GLTFMaterialsTransmissionExtension(b);
    }), this.register(function(b) {
      return new GLTFLightsExtension(b);
    }), this.register(function(b) {
      return new GLTFMeshoptCompression(b);
    });
  }
  load(e, b, L, M) {
    const D = this;
    let I;
    this.resourcePath !== "" ? I = this.resourcePath : this.path !== "" ? I = this.path : I = LoaderUtils.extractUrlBase(e), this.manager.itemStart(e);
    const F = function(U) {
      M ? M(U) : console.error(U), D.manager.itemError(e), D.manager.itemEnd(e);
    }, N = new FileLoader(this.manager);
    N.setPath(this.path), N.setResponseType("arraybuffer"), N.setRequestHeader(this.requestHeader), N.setWithCredentials(this.withCredentials), N.load(e, function(U) {
      try {
        D.parse(U, I, function(G) {
          b(G), D.manager.itemEnd(e);
        }, F);
      } catch (G) {
        F(G);
      }
    }, L, F);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, b, L, M) {
    let D;
    const I = {}, F = {};
    if (typeof e == "string")
      D = e;
    else if (LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === BINARY_EXTENSION_HEADER_MAGIC) {
      try {
        I[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(e);
      } catch (V) {
        M && M(V);
        return;
      }
      D = I[EXTENSIONS.KHR_BINARY_GLTF].content;
    } else
      D = LoaderUtils.decodeText(new Uint8Array(e));
    const N = JSON.parse(D);
    if (N.asset === void 0 || N.asset.version[0] < 2) {
      M && M(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const U = new GLTFParser(N, {
      path: b || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    U.fileLoader.setRequestHeader(this.requestHeader);
    for (let G = 0; G < this.pluginCallbacks.length; G++) {
      const V = this.pluginCallbacks[G](U);
      F[V.name] = V, I[V.name] = !0;
    }
    if (N.extensionsUsed)
      for (let G = 0; G < N.extensionsUsed.length; ++G) {
        const V = N.extensionsUsed[G], z = N.extensionsRequired || [];
        switch (V) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            I[V] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            I[V] = new GLTFMaterialsPbrSpecularGlossinessExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            I[V] = new GLTFDracoMeshCompressionExtension(N, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            I[V] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            I[V] = new GLTFMeshQuantizationExtension();
            break;
          default:
            z.indexOf(V) >= 0 && F[V] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + V + '".');
        }
      }
    U.setExtensions(I), U.setPlugins(F), U.parse(L, M);
  }
}
function GLTFRegistry() {
  let B = {};
  return {
    get: function(e) {
      return B[e];
    },
    add: function(e, b) {
      B[e] = b;
    },
    remove: function(e) {
      delete B[e];
    },
    removeAll: function() {
      B = {};
    }
  };
}
const EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
class GLTFLightsExtension {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, b = this.parser.json.nodes || [];
    for (let L = 0, M = b.length; L < M; L++) {
      const D = b[L];
      D.extensions && D.extensions[this.name] && D.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, D.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const b = this.parser, L = "light:" + e;
    let M = b.cache.get(L);
    if (M) return M;
    const D = b.json, N = ((D.extensions && D.extensions[this.name] || {}).lights || [])[e];
    let U;
    const G = new Color(16777215);
    N.color !== void 0 && G.fromArray(N.color);
    const V = N.range !== void 0 ? N.range : 0;
    switch (N.type) {
      case "directional":
        U = new DirectionalLight(G), U.target.position.set(0, 0, -1), U.add(U.target);
        break;
      case "point":
        U = new PointLight(G), U.distance = V;
        break;
      case "spot":
        U = new SpotLight(G), U.distance = V, N.spot = N.spot || {}, N.spot.innerConeAngle = N.spot.innerConeAngle !== void 0 ? N.spot.innerConeAngle : 0, N.spot.outerConeAngle = N.spot.outerConeAngle !== void 0 ? N.spot.outerConeAngle : Math.PI / 4, U.angle = N.spot.outerConeAngle, U.penumbra = 1 - N.spot.innerConeAngle / N.spot.outerConeAngle, U.target.position.set(0, 0, -1), U.add(U.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + N.type);
    }
    return U.position.set(0, 0, 0), U.decay = 2, N.intensity !== void 0 && (U.intensity = N.intensity), U.name = b.createUniqueName(N.name || "light_" + e), M = Promise.resolve(U), b.cache.add(L, M), M;
  }
  createNodeAttachment(e) {
    const b = this, L = this.parser, D = L.json.nodes[e], F = (D.extensions && D.extensions[this.name] || {}).light;
    return F === void 0 ? null : this._loadLight(F).then(function(N) {
      return L._getNodeRef(b.cache, F, N);
    });
  }
}
class GLTFMaterialsUnlitExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(e, b, L) {
    const M = [];
    e.color = new Color(1, 1, 1), e.opacity = 1;
    const D = b.pbrMetallicRoughness;
    if (D) {
      if (Array.isArray(D.baseColorFactor)) {
        const I = D.baseColorFactor;
        e.color.fromArray(I), e.opacity = I[3];
      }
      D.baseColorTexture !== void 0 && M.push(L.assignTexture(e, "map", D.baseColorTexture));
    }
    return Promise.all(M);
  }
}
class GLTFMaterialsClearcoatExtension {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const L = this.parser.json.materials[e];
    return !L.extensions || !L.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, b) {
    const L = this.parser, M = L.json.materials[e];
    if (!M.extensions || !M.extensions[this.name])
      return Promise.resolve();
    const D = [], I = M.extensions[this.name];
    if (I.clearcoatFactor !== void 0 && (b.clearcoat = I.clearcoatFactor), I.clearcoatTexture !== void 0 && D.push(L.assignTexture(b, "clearcoatMap", I.clearcoatTexture)), I.clearcoatRoughnessFactor !== void 0 && (b.clearcoatRoughness = I.clearcoatRoughnessFactor), I.clearcoatRoughnessTexture !== void 0 && D.push(L.assignTexture(b, "clearcoatRoughnessMap", I.clearcoatRoughnessTexture)), I.clearcoatNormalTexture !== void 0 && (D.push(L.assignTexture(b, "clearcoatNormalMap", I.clearcoatNormalTexture)), I.clearcoatNormalTexture.scale !== void 0)) {
      const F = I.clearcoatNormalTexture.scale;
      b.clearcoatNormalScale = new Vector2(F, -F);
    }
    return Promise.all(D);
  }
}
class GLTFMaterialsTransmissionExtension {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const L = this.parser.json.materials[e];
    return !L.extensions || !L.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, b) {
    const L = this.parser, M = L.json.materials[e];
    if (!M.extensions || !M.extensions[this.name])
      return Promise.resolve();
    const D = [], I = M.extensions[this.name];
    return I.transmissionFactor !== void 0 && (b.transmission = I.transmissionFactor), I.transmissionTexture !== void 0 && D.push(L.assignTexture(b, "transmissionMap", I.transmissionTexture)), Promise.all(D);
  }
}
class GLTFTextureBasisUExtension {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const b = this.parser, L = b.json, M = L.textures[e];
    if (!M.extensions || !M.extensions[this.name])
      return null;
    const D = M.extensions[this.name], I = L.images[D.source], F = b.options.ktx2Loader;
    if (!F) {
      if (L.extensionsRequired && L.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return b.loadTextureImage(e, I, F);
  }
}
class GLTFTextureWebPExtension {
  constructor(e) {
    this.parser = e, this.name = EXTENSIONS.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const b = this.name, L = this.parser, M = L.json, D = M.textures[e];
    if (!D.extensions || !D.extensions[b])
      return null;
    const I = D.extensions[b], F = M.images[I.source];
    let N = L.textureLoader;
    if (F.uri) {
      const U = L.options.manager.getHandler(F.uri);
      U !== null && (N = U);
    }
    return this.detectSupport().then(function(U) {
      if (U) return L.loadTextureImage(e, F, N);
      if (M.extensionsRequired && M.extensionsRequired.indexOf(b) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return L.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const b = new Image();
      b.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", b.onload = b.onerror = function() {
        e(b.height === 1);
      };
    })), this.isSupported;
  }
}
class GLTFMeshoptCompression {
  constructor(e) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const b = this.parser.json, L = b.bufferViews[e];
    if (L.extensions && L.extensions[this.name]) {
      const M = L.extensions[this.name], D = this.parser.getDependency("buffer", M.buffer), I = this.parser.options.meshoptDecoder;
      if (!I || !I.supported) {
        if (b.extensionsRequired && b.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return Promise.all([D, I.ready]).then(function(F) {
        const N = M.byteOffset || 0, U = M.byteLength || 0, G = M.count, V = M.byteStride, z = new ArrayBuffer(G * V), k = new Uint8Array(F[0], N, U);
        return I.decodeGltfBuffer(new Uint8Array(z), G, V, k, M.mode, M.filter), z;
      });
    } else
      return null;
  }
}
const BINARY_EXTENSION_HEADER_MAGIC = "glTF", BINARY_EXTENSION_HEADER_LENGTH = 12, BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
class GLTFBinaryExtension {
  constructor(e) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const b = new DataView(e, 0, BINARY_EXTENSION_HEADER_LENGTH);
    if (this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))),
      version: b.getUint32(4, !0),
      length: b.getUint32(8, !0)
    }, this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const L = this.header.length - BINARY_EXTENSION_HEADER_LENGTH, M = new DataView(e, BINARY_EXTENSION_HEADER_LENGTH);
    let D = 0;
    for (; D < L; ) {
      const I = M.getUint32(D, !0);
      D += 4;
      const F = M.getUint32(D, !0);
      if (D += 4, F === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const N = new Uint8Array(e, BINARY_EXTENSION_HEADER_LENGTH + D, I);
        this.content = LoaderUtils.decodeText(N);
      } else if (F === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const N = BINARY_EXTENSION_HEADER_LENGTH + D;
        this.body = e.slice(N, N + I);
      }
      D += I;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class GLTFDracoMeshCompressionExtension {
  constructor(e, b) {
    if (!b)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = b, this.dracoLoader.preload();
  }
  decodePrimitive(e, b) {
    const L = this.json, M = this.dracoLoader, D = e.extensions[this.name].bufferView, I = e.extensions[this.name].attributes, F = {}, N = {}, U = {};
    for (const G in I) {
      const V = ATTRIBUTES[G] || G.toLowerCase();
      F[V] = I[G];
    }
    for (const G in e.attributes) {
      const V = ATTRIBUTES[G] || G.toLowerCase();
      if (I[G] !== void 0) {
        const z = L.accessors[e.attributes[G]], k = WEBGL_COMPONENT_TYPES[z.componentType];
        U[V] = k, N[V] = z.normalized === !0;
      }
    }
    return b.getDependency("bufferView", D).then(function(G) {
      return new Promise(function(V) {
        M.decodeDracoFile(G, function(z) {
          for (const k in z.attributes) {
            const H = z.attributes[k], W = N[k];
            W !== void 0 && (H.normalized = W);
          }
          V(z);
        }, F, U);
      });
    });
  }
}
class GLTFTextureTransformExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, b) {
    return b.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), b.offset === void 0 && b.rotation === void 0 && b.scale === void 0 || (e = e.clone(), b.offset !== void 0 && e.offset.fromArray(b.offset), b.rotation !== void 0 && (e.rotation = b.rotation), b.scale !== void 0 && e.repeat.fromArray(b.scale), e.needsUpdate = !0), e;
  }
}
class GLTFMeshStandardSGMaterial extends MeshStandardMaterial {
  constructor(e) {
    super(), this.isGLTFSpecularGlossinessMaterial = !0;
    const b = [
      "#ifdef USE_SPECULARMAP",
      "	uniform sampler2D specularMap;",
      "#endif"
    ].join(`
`), L = [
      "#ifdef USE_GLOSSINESSMAP",
      "	uniform sampler2D glossinessMap;",
      "#endif"
    ].join(`
`), M = [
      "vec3 specularFactor = specular;",
      "#ifdef USE_SPECULARMAP",
      "	vec4 texelSpecular = texture2D( specularMap, vUv );",
      "	texelSpecular = sRGBToLinear( texelSpecular );",
      "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	specularFactor *= texelSpecular.rgb;",
      "#endif"
    ].join(`
`), D = [
      "float glossinessFactor = glossiness;",
      "#ifdef USE_GLOSSINESSMAP",
      "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
      "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	glossinessFactor *= texelGlossiness.a;",
      "#endif"
    ].join(`
`), I = [
      "PhysicalMaterial material;",
      "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
      "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
      "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
      "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
      "material.specularRoughness += geometryRoughness;",
      "material.specularRoughness = min( material.specularRoughness, 1.0 );",
      "material.specularColor = specularFactor;"
    ].join(`
`), F = {
      specular: { value: new Color().setHex(16777215) },
      glossiness: { value: 1 },
      specularMap: { value: null },
      glossinessMap: { value: null }
    };
    this._extraUniforms = F, this.onBeforeCompile = function(N) {
      for (const U in F)
        N.uniforms[U] = F[U];
      N.fragmentShader = N.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", b).replace("#include <metalnessmap_pars_fragment>", L).replace("#include <roughnessmap_fragment>", M).replace("#include <metalnessmap_fragment>", D).replace("#include <lights_physical_fragment>", I);
    }, Object.defineProperties(this, {
      specular: {
        get: function() {
          return F.specular.value;
        },
        set: function(N) {
          F.specular.value = N;
        }
      },
      specularMap: {
        get: function() {
          return F.specularMap.value;
        },
        set: function(N) {
          F.specularMap.value = N, N ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP;
        }
      },
      glossiness: {
        get: function() {
          return F.glossiness.value;
        },
        set: function(N) {
          F.glossiness.value = N;
        }
      },
      glossinessMap: {
        get: function() {
          return F.glossinessMap.value;
        },
        set: function(N) {
          F.glossinessMap.value = N, N ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
        }
      }
    }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
  }
}
class GLTFMaterialsPbrSpecularGlossinessExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = [
      "color",
      "map",
      "lightMap",
      "lightMapIntensity",
      "aoMap",
      "aoMapIntensity",
      "emissive",
      "emissiveIntensity",
      "emissiveMap",
      "bumpMap",
      "bumpScale",
      "normalMap",
      "normalMapType",
      "displacementMap",
      "displacementScale",
      "displacementBias",
      "specularMap",
      "specular",
      "glossinessMap",
      "glossiness",
      "alphaMap",
      "envMap",
      "envMapIntensity",
      "refractionRatio"
    ];
  }
  getMaterialType() {
    return GLTFMeshStandardSGMaterial;
  }
  extendParams(e, b, L) {
    const M = b.extensions[this.name];
    e.color = new Color(1, 1, 1), e.opacity = 1;
    const D = [];
    if (Array.isArray(M.diffuseFactor)) {
      const I = M.diffuseFactor;
      e.color.fromArray(I), e.opacity = I[3];
    }
    if (M.diffuseTexture !== void 0 && D.push(L.assignTexture(e, "map", M.diffuseTexture)), e.emissive = new Color(0, 0, 0), e.glossiness = M.glossinessFactor !== void 0 ? M.glossinessFactor : 1, e.specular = new Color(1, 1, 1), Array.isArray(M.specularFactor) && e.specular.fromArray(M.specularFactor), M.specularGlossinessTexture !== void 0) {
      const I = M.specularGlossinessTexture;
      D.push(L.assignTexture(e, "glossinessMap", I)), D.push(L.assignTexture(e, "specularMap", I));
    }
    return Promise.all(D);
  }
  createMaterial(e) {
    const b = new GLTFMeshStandardSGMaterial(e);
    return b.fog = !0, b.color = e.color, b.map = e.map === void 0 ? null : e.map, b.lightMap = null, b.lightMapIntensity = 1, b.aoMap = e.aoMap === void 0 ? null : e.aoMap, b.aoMapIntensity = 1, b.emissive = e.emissive, b.emissiveIntensity = 1, b.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap, b.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap, b.bumpScale = 1, b.normalMap = e.normalMap === void 0 ? null : e.normalMap, b.normalMapType = TangentSpaceNormalMap, e.normalScale && (b.normalScale = e.normalScale), b.displacementMap = null, b.displacementScale = 1, b.displacementBias = 0, b.specularMap = e.specularMap === void 0 ? null : e.specularMap, b.specular = e.specular, b.glossinessMap = e.glossinessMap === void 0 ? null : e.glossinessMap, b.glossiness = e.glossiness, b.alphaMap = null, b.envMap = e.envMap === void 0 ? null : e.envMap, b.envMapIntensity = 1, b.refractionRatio = 0.98, b;
  }
}
class GLTFMeshQuantizationExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
}
class GLTFCubicSplineInterpolant extends Interpolant {
  constructor(e, b, L, M) {
    super(e, b, L, M);
  }
  copySampleValue_(e) {
    const b = this.resultBuffer, L = this.sampleValues, M = this.valueSize, D = e * M * 3 + M;
    for (let I = 0; I !== M; I++)
      b[I] = L[D + I];
    return b;
  }
}
GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.interpolate_ = function(B, e, b, L) {
  const M = this.resultBuffer, D = this.sampleValues, I = this.valueSize, F = I * 2, N = I * 3, U = L - e, G = (b - e) / U, V = G * G, z = V * G, k = B * N, H = k - N, W = -2 * z + 3 * V, $ = z - V, j = 1 - W, q = $ - V + G;
  for (let Y = 0; Y !== I; Y++) {
    const J = D[H + Y + I], K = D[H + Y + F] * U, X = D[k + Y + I], Z = D[k + Y] * U;
    M[Y] = j * J + q * K + W * X + $ * Z;
  }
  return M;
};
const WEBGL_CONSTANTS = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
}, WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
}, WEBGL_TYPE_SIZES = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv2",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
}, ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function resolveURL(B, e) {
  return typeof B != "string" || B === "" ? "" : (/^https?:\/\//i.test(e) && /^\//.test(B) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(B) || /^data:.*,.*$/i.test(B) || /^blob:.*$/i.test(B) ? B : e + B);
}
function createDefaultMaterial(B) {
  return B.DefaultMaterial === void 0 && (B.DefaultMaterial = new MeshStandardMaterial({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: FrontSide
  })), B.DefaultMaterial;
}
function addUnknownExtensionsToUserData(B, e, b) {
  for (const L in b.extensions)
    B[L] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[L] = b.extensions[L]);
}
function assignExtrasToUserData(B, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(B.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function addMorphTargets(B, e, b) {
  let L = !1, M = !1;
  for (let F = 0, N = e.length; F < N; F++) {
    const U = e[F];
    if (U.POSITION !== void 0 && (L = !0), U.NORMAL !== void 0 && (M = !0), L && M) break;
  }
  if (!L && !M) return Promise.resolve(B);
  const D = [], I = [];
  for (let F = 0, N = e.length; F < N; F++) {
    const U = e[F];
    if (L) {
      const G = U.POSITION !== void 0 ? b.getDependency("accessor", U.POSITION) : B.attributes.position;
      D.push(G);
    }
    if (M) {
      const G = U.NORMAL !== void 0 ? b.getDependency("accessor", U.NORMAL) : B.attributes.normal;
      I.push(G);
    }
  }
  return Promise.all([
    Promise.all(D),
    Promise.all(I)
  ]).then(function(F) {
    const N = F[0], U = F[1];
    return L && (B.morphAttributes.position = N), M && (B.morphAttributes.normal = U), B.morphTargetsRelative = !0, B;
  });
}
function updateMorphTargets(B, e) {
  if (B.updateMorphTargets(), e.weights !== void 0)
    for (let b = 0, L = e.weights.length; b < L; b++)
      B.morphTargetInfluences[b] = e.weights[b];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const b = e.extras.targetNames;
    if (B.morphTargetInfluences.length === b.length) {
      B.morphTargetDictionary = {};
      for (let L = 0, M = b.length; L < M; L++)
        B.morphTargetDictionary[b[L]] = L;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function createPrimitiveKey(B) {
  const e = B.extensions && B.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  let b;
  return e ? b = "draco:" + e.bufferView + ":" + e.indices + ":" + createAttributesKey(e.attributes) : b = B.indices + ":" + createAttributesKey(B.attributes) + ":" + B.mode, b;
}
function createAttributesKey(B) {
  let e = "";
  const b = Object.keys(B).sort();
  for (let L = 0, M = b.length; L < M; L++)
    e += b[L] + ":" + B[b[L]] + ";";
  return e;
}
function getNormalizedComponentScale(B) {
  switch (B) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
class GLTFParser {
  constructor(e = {}, b = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = b, this.cache = new GLTFRegistry(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.textureCache = {}, this.nodeNamesUsed = {}, typeof createImageBitmap < "u" && /Firefox/.test(navigator.userAgent) === !1 ? this.textureLoader = new ImageBitmapLoader(this.options.manager) : this.textureLoader = new TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, b) {
    const L = this, M = this.json, D = this.extensions;
    this.cache.removeAll(), this._invokeAll(function(I) {
      return I._markDefs && I._markDefs();
    }), Promise.all(this._invokeAll(function(I) {
      return I.beforeRoot && I.beforeRoot();
    })).then(function() {
      return Promise.all([
        L.getDependencies("scene"),
        L.getDependencies("animation"),
        L.getDependencies("camera")
      ]);
    }).then(function(I) {
      const F = {
        scene: I[0][M.scene || 0],
        scenes: I[0],
        animations: I[1],
        cameras: I[2],
        asset: M.asset,
        parser: L,
        userData: {}
      };
      addUnknownExtensionsToUserData(D, F, M), assignExtrasToUserData(F, M), Promise.all(L._invokeAll(function(N) {
        return N.afterRoot && N.afterRoot(F);
      })).then(function() {
        e(F);
      });
    }).catch(b);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], b = this.json.skins || [], L = this.json.meshes || [];
    for (let M = 0, D = b.length; M < D; M++) {
      const I = b[M].joints;
      for (let F = 0, N = I.length; F < N; F++)
        e[I[F]].isBone = !0;
    }
    for (let M = 0, D = e.length; M < D; M++) {
      const I = e[M];
      I.mesh !== void 0 && (this._addNodeRef(this.meshCache, I.mesh), I.skin !== void 0 && (L[I.mesh].isSkinnedMesh = !0)), I.camera !== void 0 && this._addNodeRef(this.cameraCache, I.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, b) {
    b !== void 0 && (e.refs[b] === void 0 && (e.refs[b] = e.uses[b] = 0), e.refs[b]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, b, L) {
    if (e.refs[b] <= 1) return L;
    const M = L.clone();
    return M.name += "_instance_" + e.uses[b]++, M;
  }
  _invokeOne(e) {
    const b = Object.values(this.plugins);
    b.push(this);
    for (let L = 0; L < b.length; L++) {
      const M = e(b[L]);
      if (M) return M;
    }
    return null;
  }
  _invokeAll(e) {
    const b = Object.values(this.plugins);
    b.unshift(this);
    const L = [];
    for (let M = 0; M < b.length; M++) {
      const D = e(b[M]);
      D && L.push(D);
    }
    return L;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, b) {
    const L = e + ":" + b;
    let M = this.cache.get(L);
    if (!M) {
      switch (e) {
        case "scene":
          M = this.loadScene(b);
          break;
        case "node":
          M = this.loadNode(b);
          break;
        case "mesh":
          M = this._invokeOne(function(D) {
            return D.loadMesh && D.loadMesh(b);
          });
          break;
        case "accessor":
          M = this.loadAccessor(b);
          break;
        case "bufferView":
          M = this._invokeOne(function(D) {
            return D.loadBufferView && D.loadBufferView(b);
          });
          break;
        case "buffer":
          M = this.loadBuffer(b);
          break;
        case "material":
          M = this._invokeOne(function(D) {
            return D.loadMaterial && D.loadMaterial(b);
          });
          break;
        case "texture":
          M = this._invokeOne(function(D) {
            return D.loadTexture && D.loadTexture(b);
          });
          break;
        case "skin":
          M = this.loadSkin(b);
          break;
        case "animation":
          M = this.loadAnimation(b);
          break;
        case "camera":
          M = this.loadCamera(b);
          break;
        default:
          throw new Error("Unknown type: " + e);
      }
      this.cache.add(L, M);
    }
    return M;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let b = this.cache.get(e);
    if (!b) {
      const L = this, M = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      b = Promise.all(M.map(function(D, I) {
        return L.getDependency(e, I);
      })), this.cache.add(e, b);
    }
    return b;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const b = this.json.buffers[e], L = this.fileLoader;
    if (b.type && b.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + b.type + " buffer type is not supported.");
    if (b.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    const M = this.options;
    return new Promise(function(D, I) {
      L.load(resolveURL(b.uri, M.path), D, void 0, function() {
        I(new Error('THREE.GLTFLoader: Failed to load buffer "' + b.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const b = this.json.bufferViews[e];
    return this.getDependency("buffer", b.buffer).then(function(L) {
      const M = b.byteLength || 0, D = b.byteOffset || 0;
      return L.slice(D, D + M);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const b = this, L = this.json, M = this.json.accessors[e];
    if (M.bufferView === void 0 && M.sparse === void 0)
      return Promise.resolve(null);
    const D = [];
    return M.bufferView !== void 0 ? D.push(this.getDependency("bufferView", M.bufferView)) : D.push(null), M.sparse !== void 0 && (D.push(this.getDependency("bufferView", M.sparse.indices.bufferView)), D.push(this.getDependency("bufferView", M.sparse.values.bufferView))), Promise.all(D).then(function(I) {
      const F = I[0], N = WEBGL_TYPE_SIZES[M.type], U = WEBGL_COMPONENT_TYPES[M.componentType], G = U.BYTES_PER_ELEMENT, V = G * N, z = M.byteOffset || 0, k = M.bufferView !== void 0 ? L.bufferViews[M.bufferView].byteStride : void 0, H = M.normalized === !0;
      let W, $;
      if (k && k !== V) {
        const j = Math.floor(z / k), q = "InterleavedBuffer:" + M.bufferView + ":" + M.componentType + ":" + j + ":" + M.count;
        let Y = b.cache.get(q);
        Y || (W = new U(F, j * k, M.count * k / G), Y = new InterleavedBuffer(W, k / G), b.cache.add(q, Y)), $ = new InterleavedBufferAttribute(Y, N, z % k / G, H);
      } else
        F === null ? W = new U(M.count * N) : W = new U(F, z, M.count * N), $ = new BufferAttribute(W, N, H);
      if (M.sparse !== void 0) {
        const j = WEBGL_TYPE_SIZES.SCALAR, q = WEBGL_COMPONENT_TYPES[M.sparse.indices.componentType], Y = M.sparse.indices.byteOffset || 0, J = M.sparse.values.byteOffset || 0, K = new q(I[1], Y, M.sparse.count * j), X = new U(I[2], J, M.sparse.count * N);
        F !== null && ($ = new BufferAttribute($.array.slice(), $.itemSize, $.normalized));
        for (let Z = 0, Q = K.length; Z < Q; Z++) {
          const ne = K[Z];
          if ($.setX(ne, X[Z * N]), N >= 2 && $.setY(ne, X[Z * N + 1]), N >= 3 && $.setZ(ne, X[Z * N + 2]), N >= 4 && $.setW(ne, X[Z * N + 3]), N >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return $;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture>}
   */
  loadTexture(e) {
    const b = this.json, L = this.options, M = b.textures[e], D = b.images[M.source];
    let I = this.textureLoader;
    if (D.uri) {
      const F = L.manager.getHandler(D.uri);
      F !== null && (I = F);
    }
    return this.loadTextureImage(e, D, I);
  }
  loadTextureImage(e, b, L) {
    const M = this, D = this.json, I = this.options, F = D.textures[e], N = (b.uri || b.bufferView) + ":" + F.sampler;
    if (this.textureCache[N])
      return this.textureCache[N];
    const U = self.URL || self.webkitURL;
    let G = b.uri || "", V = !1, z = !0;
    const k = G.search(/\.jpe?g($|\?)/i) > 0 || G.search(/^data\:image\/jpeg/) === 0;
    if ((b.mimeType === "image/jpeg" || k) && (z = !1), b.bufferView !== void 0)
      G = M.getDependency("bufferView", b.bufferView).then(function(W) {
        if (b.mimeType === "image/png") {
          const j = new DataView(W, 25, 1).getUint8(0, !1);
          z = j === 6 || j === 4 || j === 3;
        }
        V = !0;
        const $ = new Blob([W], { type: b.mimeType });
        return G = U.createObjectURL($), G;
      });
    else if (b.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const H = Promise.resolve(G).then(function(W) {
      return new Promise(function($, j) {
        let q = $;
        L.isImageBitmapLoader === !0 && (q = function(Y) {
          const J = new Texture(Y);
          J.needsUpdate = !0, $(J);
        }), L.load(resolveURL(W, I.path), q, void 0, j);
      });
    }).then(function(W) {
      V === !0 && U.revokeObjectURL(G), W.flipY = !1, F.name && (W.name = F.name), z || (W.format = RGBFormat);
      const j = (D.samplers || {})[F.sampler] || {};
      return W.magFilter = WEBGL_FILTERS[j.magFilter] || LinearFilter, W.minFilter = WEBGL_FILTERS[j.minFilter] || LinearMipmapLinearFilter, W.wrapS = WEBGL_WRAPPINGS[j.wrapS] || RepeatWrapping, W.wrapT = WEBGL_WRAPPINGS[j.wrapT] || RepeatWrapping, M.associations.set(W, {
        type: "textures",
        index: e
      }), W;
    }).catch(function() {
      return console.error("THREE.GLTFLoader: Couldn't load texture", G), null;
    });
    return this.textureCache[N] = H, H;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise}
   */
  assignTexture(e, b, L) {
    const M = this;
    return this.getDependency("texture", L.index).then(function(D) {
      if (L.texCoord !== void 0 && L.texCoord != 0 && !(b === "aoMap" && L.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + L.texCoord + " for texture " + b + " not yet supported."), M.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const I = L.extensions !== void 0 ? L.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (I) {
          const F = M.associations.get(D);
          D = M.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(D, I), M.associations.set(D, F);
        }
      }
      e[b] = D;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const b = e.geometry;
    let L = e.material;
    const M = b.attributes.tangent !== void 0, D = b.attributes.color !== void 0, I = b.attributes.normal === void 0, F = Object.keys(b.morphAttributes).length > 0, N = F && b.morphAttributes.normal !== void 0;
    if (e.isPoints) {
      const U = "PointsMaterial:" + L.uuid;
      let G = this.cache.get(U);
      G || (G = new PointsMaterial(), Material.prototype.copy.call(G, L), G.color.copy(L.color), G.map = L.map, G.sizeAttenuation = !1, this.cache.add(U, G)), L = G;
    } else if (e.isLine) {
      const U = "LineBasicMaterial:" + L.uuid;
      let G = this.cache.get(U);
      G || (G = new LineBasicMaterial(), Material.prototype.copy.call(G, L), G.color.copy(L.color), this.cache.add(U, G)), L = G;
    }
    if (M || D || I || F) {
      let U = "ClonedMaterial:" + L.uuid + ":";
      L.isGLTFSpecularGlossinessMaterial && (U += "specular-glossiness:"), M && (U += "vertex-tangents:"), D && (U += "vertex-colors:"), I && (U += "flat-shading:"), F && (U += "morph-targets:"), N && (U += "morph-normals:");
      let G = this.cache.get(U);
      G || (G = L.clone(), D && (G.vertexColors = !0), I && (G.flatShading = !0), F && (G.morphTargets = !0), N && (G.morphNormals = !0), M && (G.vertexTangents = !0, G.normalScale && (G.normalScale.y *= -1), G.clearcoatNormalScale && (G.clearcoatNormalScale.y *= -1)), this.cache.add(U, G), this.associations.set(G, this.associations.get(L))), L = G;
    }
    L.aoMap && b.attributes.uv2 === void 0 && b.attributes.uv !== void 0 && b.setAttribute("uv2", b.attributes.uv), e.material = L;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const b = this, L = this.json, M = this.extensions, D = L.materials[e];
    let I;
    const F = {}, N = D.extensions || {}, U = [];
    if (N[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const V = M[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      I = V.getMaterialType(), U.push(V.extendParams(F, D, b));
    } else if (N[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const V = M[EXTENSIONS.KHR_MATERIALS_UNLIT];
      I = V.getMaterialType(), U.push(V.extendParams(F, D, b));
    } else {
      const V = D.pbrMetallicRoughness || {};
      if (F.color = new Color(1, 1, 1), F.opacity = 1, Array.isArray(V.baseColorFactor)) {
        const z = V.baseColorFactor;
        F.color.fromArray(z), F.opacity = z[3];
      }
      V.baseColorTexture !== void 0 && U.push(b.assignTexture(F, "map", V.baseColorTexture)), F.metalness = V.metallicFactor !== void 0 ? V.metallicFactor : 1, F.roughness = V.roughnessFactor !== void 0 ? V.roughnessFactor : 1, V.metallicRoughnessTexture !== void 0 && (U.push(b.assignTexture(F, "metalnessMap", V.metallicRoughnessTexture)), U.push(b.assignTexture(F, "roughnessMap", V.metallicRoughnessTexture))), I = this._invokeOne(function(z) {
        return z.getMaterialType && z.getMaterialType(e);
      }), U.push(Promise.all(this._invokeAll(function(z) {
        return z.extendMaterialParams && z.extendMaterialParams(e, F);
      })));
    }
    D.doubleSided === !0 && (F.side = DoubleSide);
    const G = D.alphaMode || ALPHA_MODES.OPAQUE;
    return G === ALPHA_MODES.BLEND ? (F.transparent = !0, F.depthWrite = !1) : (F.transparent = !1, G === ALPHA_MODES.MASK && (F.alphaTest = D.alphaCutoff !== void 0 ? D.alphaCutoff : 0.5)), D.normalTexture !== void 0 && I !== MeshBasicMaterial && (U.push(b.assignTexture(F, "normalMap", D.normalTexture)), F.normalScale = new Vector2(1, -1), D.normalTexture.scale !== void 0 && F.normalScale.set(D.normalTexture.scale, -D.normalTexture.scale)), D.occlusionTexture !== void 0 && I !== MeshBasicMaterial && (U.push(b.assignTexture(F, "aoMap", D.occlusionTexture)), D.occlusionTexture.strength !== void 0 && (F.aoMapIntensity = D.occlusionTexture.strength)), D.emissiveFactor !== void 0 && I !== MeshBasicMaterial && (F.emissive = new Color().fromArray(D.emissiveFactor)), D.emissiveTexture !== void 0 && I !== MeshBasicMaterial && U.push(b.assignTexture(F, "emissiveMap", D.emissiveTexture)), Promise.all(U).then(function() {
      let V;
      return I === GLTFMeshStandardSGMaterial ? V = M[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(F) : V = new I(F), D.name && (V.name = D.name), V.map && (V.map.encoding = sRGBEncoding), V.emissiveMap && (V.emissiveMap.encoding = sRGBEncoding), assignExtrasToUserData(V, D), b.associations.set(V, { type: "materials", index: e }), D.extensions && addUnknownExtensionsToUserData(M, V, D), V;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const b = PropertyBinding.sanitizeNodeName(e || "");
    let L = b;
    for (let M = 1; this.nodeNamesUsed[L]; ++M)
      L = b + "_" + M;
    return this.nodeNamesUsed[L] = !0, L;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const b = this, L = this.extensions, M = this.primitiveCache;
    function D(F) {
      return L[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(F, b).then(function(N) {
        return addPrimitiveAttributes(N, F, b);
      });
    }
    const I = [];
    for (let F = 0, N = e.length; F < N; F++) {
      const U = e[F], G = createPrimitiveKey(U), V = M[G];
      if (V)
        I.push(V.promise);
      else {
        let z;
        U.extensions && U.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] ? z = D(U) : z = addPrimitiveAttributes(new BufferGeometry(), U, b), M[G] = { primitive: U, promise: z }, I.push(z);
      }
    }
    return Promise.all(I);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const b = this, L = this.json, M = this.extensions, D = L.meshes[e], I = D.primitives, F = [];
    for (let N = 0, U = I.length; N < U; N++) {
      const G = I[N].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", I[N].material);
      F.push(G);
    }
    return F.push(b.loadGeometries(I)), Promise.all(F).then(function(N) {
      const U = N.slice(0, N.length - 1), G = N[N.length - 1], V = [];
      for (let k = 0, H = G.length; k < H; k++) {
        const W = G[k], $ = I[k];
        let j;
        const q = U[k];
        if ($.mode === WEBGL_CONSTANTS.TRIANGLES || $.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || $.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || $.mode === void 0)
          j = D.isSkinnedMesh === !0 ? new SkinnedMesh(W, q) : new Mesh(W, q), j.isSkinnedMesh === !0 && !j.geometry.attributes.skinWeight.normalized && j.normalizeSkinWeights(), $.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ? j.geometry = toTrianglesDrawMode(j.geometry, TriangleStripDrawMode) : $.mode === WEBGL_CONSTANTS.TRIANGLE_FAN && (j.geometry = toTrianglesDrawMode(j.geometry, TriangleFanDrawMode));
        else if ($.mode === WEBGL_CONSTANTS.LINES)
          j = new LineSegments(W, q);
        else if ($.mode === WEBGL_CONSTANTS.LINE_STRIP)
          j = new Line(W, q);
        else if ($.mode === WEBGL_CONSTANTS.LINE_LOOP)
          j = new LineLoop(W, q);
        else if ($.mode === WEBGL_CONSTANTS.POINTS)
          j = new Points(W, q);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + $.mode);
        Object.keys(j.geometry.morphAttributes).length > 0 && updateMorphTargets(j, D), j.name = b.createUniqueName(D.name || "mesh_" + e), assignExtrasToUserData(j, D), $.extensions && addUnknownExtensionsToUserData(M, j, $), b.assignFinalMaterial(j), V.push(j);
      }
      if (V.length === 1)
        return V[0];
      const z = new Group();
      for (let k = 0, H = V.length; k < H; k++)
        z.add(V[k]);
      return z;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let b;
    const L = this.json.cameras[e], M = L[L.type];
    if (!M) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return L.type === "perspective" ? b = new PerspectiveCamera(MathUtils.radToDeg(M.yfov), M.aspectRatio || 1, M.znear || 1, M.zfar || 2e6) : L.type === "orthographic" && (b = new OrthographicCamera(-M.xmag, M.xmag, M.ymag, -M.ymag, M.znear, M.zfar)), L.name && (b.name = this.createUniqueName(L.name)), assignExtrasToUserData(b, L), Promise.resolve(b);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Object>}
   */
  loadSkin(e) {
    const b = this.json.skins[e], L = { joints: b.joints };
    return b.inverseBindMatrices === void 0 ? Promise.resolve(L) : this.getDependency("accessor", b.inverseBindMatrices).then(function(M) {
      return L.inverseBindMatrices = M, L;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const L = this.json.animations[e], M = [], D = [], I = [], F = [], N = [];
    for (let U = 0, G = L.channels.length; U < G; U++) {
      const V = L.channels[U], z = L.samplers[V.sampler], k = V.target, H = k.node !== void 0 ? k.node : k.id, W = L.parameters !== void 0 ? L.parameters[z.input] : z.input, $ = L.parameters !== void 0 ? L.parameters[z.output] : z.output;
      M.push(this.getDependency("node", H)), D.push(this.getDependency("accessor", W)), I.push(this.getDependency("accessor", $)), F.push(z), N.push(k);
    }
    return Promise.all([
      Promise.all(M),
      Promise.all(D),
      Promise.all(I),
      Promise.all(F),
      Promise.all(N)
    ]).then(function(U) {
      const G = U[0], V = U[1], z = U[2], k = U[3], H = U[4], W = [];
      for (let j = 0, q = G.length; j < q; j++) {
        const Y = G[j], J = V[j], K = z[j], X = k[j], Z = H[j];
        if (Y === void 0) continue;
        Y.updateMatrix(), Y.matrixAutoUpdate = !0;
        let Q;
        switch (PATH_PROPERTIES[Z.path]) {
          case PATH_PROPERTIES.weights:
            Q = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES.rotation:
            Q = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            Q = VectorKeyframeTrack;
            break;
        }
        const ne = Y.name ? Y.name : Y.uuid, le = X.interpolation !== void 0 ? INTERPOLATION[X.interpolation] : InterpolateLinear, pe = [];
        PATH_PROPERTIES[Z.path] === PATH_PROPERTIES.weights ? Y.traverse(function(oe) {
          oe.isMesh === !0 && oe.morphTargetInfluences && pe.push(oe.name ? oe.name : oe.uuid);
        }) : pe.push(ne);
        let ue = K.array;
        if (K.normalized) {
          const oe = getNormalizedComponentScale(ue.constructor), ae = new Float32Array(ue.length);
          for (let se = 0, ie = ue.length; se < ie; se++)
            ae[se] = ue[se] * oe;
          ue = ae;
        }
        for (let oe = 0, ae = pe.length; oe < ae; oe++) {
          const se = new Q(
            pe[oe] + "." + PATH_PROPERTIES[Z.path],
            J.array,
            ue,
            le
          );
          X.interpolation === "CUBICSPLINE" && (se.createInterpolant = function(ye) {
            return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, ye);
          }, se.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), W.push(se);
        }
      }
      const $ = L.name ? L.name : "animation_" + e;
      return new AnimationClip($, void 0, W);
    });
  }
  createNodeMesh(e) {
    const b = this.json, L = this, M = b.nodes[e];
    return M.mesh === void 0 ? null : L.getDependency("mesh", M.mesh).then(function(D) {
      const I = L._getNodeRef(L.meshCache, M.mesh, D);
      return M.weights !== void 0 && I.traverse(function(F) {
        if (F.isMesh)
          for (let N = 0, U = M.weights.length; N < U; N++)
            F.morphTargetInfluences[N] = M.weights[N];
      }), I;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const b = this.json, L = this.extensions, M = this, D = b.nodes[e], I = D.name ? M.createUniqueName(D.name) : "";
    return function() {
      const F = [], N = M._invokeOne(function(U) {
        return U.createNodeMesh && U.createNodeMesh(e);
      });
      return N && F.push(N), D.camera !== void 0 && F.push(M.getDependency("camera", D.camera).then(function(U) {
        return M._getNodeRef(M.cameraCache, D.camera, U);
      })), M._invokeAll(function(U) {
        return U.createNodeAttachment && U.createNodeAttachment(e);
      }).forEach(function(U) {
        F.push(U);
      }), Promise.all(F);
    }().then(function(F) {
      let N;
      if (D.isBone === !0 ? N = new Bone() : F.length > 1 ? N = new Group() : F.length === 1 ? N = F[0] : N = new Object3D(), N !== F[0])
        for (let U = 0, G = F.length; U < G; U++)
          N.add(F[U]);
      if (D.name && (N.userData.name = D.name, N.name = I), assignExtrasToUserData(N, D), D.extensions && addUnknownExtensionsToUserData(L, N, D), D.matrix !== void 0) {
        const U = new Matrix4();
        U.fromArray(D.matrix), N.applyMatrix4(U);
      } else
        D.translation !== void 0 && N.position.fromArray(D.translation), D.rotation !== void 0 && N.quaternion.fromArray(D.rotation), D.scale !== void 0 && N.scale.fromArray(D.scale);
      return M.associations.set(N, { type: "nodes", index: e }), N;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const b = this.json, L = this.extensions, M = this.json.scenes[e], D = this, I = new Group();
    M.name && (I.name = D.createUniqueName(M.name)), assignExtrasToUserData(I, M), M.extensions && addUnknownExtensionsToUserData(L, I, M);
    const F = M.nodes || [], N = [];
    for (let U = 0, G = F.length; U < G; U++)
      N.push(buildNodeHierachy(F[U], I, b, D));
    return Promise.all(N).then(function() {
      return I;
    });
  }
}
function buildNodeHierachy(B, e, b, L) {
  const M = b.nodes[B];
  return L.getDependency("node", B).then(function(D) {
    if (M.skin === void 0) return D;
    let I;
    return L.getDependency("skin", M.skin).then(function(F) {
      I = F;
      const N = [];
      for (let U = 0, G = I.joints.length; U < G; U++)
        N.push(L.getDependency("node", I.joints[U]));
      return Promise.all(N);
    }).then(function(F) {
      return D.traverse(function(N) {
        if (!N.isMesh) return;
        const U = [], G = [];
        for (let V = 0, z = F.length; V < z; V++) {
          const k = F[V];
          if (k) {
            U.push(k);
            const H = new Matrix4();
            I.inverseBindMatrices !== void 0 && H.fromArray(I.inverseBindMatrices.array, V * 16), G.push(H);
          } else
            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', I.joints[V]);
        }
        N.bind(new Skeleton(U, G), N.matrixWorld);
      }), D;
    });
  }).then(function(D) {
    e.add(D);
    const I = [];
    if (M.children) {
      const F = M.children;
      for (let N = 0, U = F.length; N < U; N++) {
        const G = F[N];
        I.push(buildNodeHierachy(G, D, b, L));
      }
    }
    return Promise.all(I);
  });
}
function computeBounds(B, e, b) {
  const L = e.attributes, M = new Box3();
  if (L.POSITION !== void 0) {
    const F = b.json.accessors[L.POSITION], N = F.min, U = F.max;
    if (N !== void 0 && U !== void 0) {
      if (M.set(
        new Vector3(N[0], N[1], N[2]),
        new Vector3(U[0], U[1], U[2])
      ), F.normalized) {
        const G = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[F.componentType]);
        M.min.multiplyScalar(G), M.max.multiplyScalar(G);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const D = e.targets;
  if (D !== void 0) {
    const F = new Vector3(), N = new Vector3();
    for (let U = 0, G = D.length; U < G; U++) {
      const V = D[U];
      if (V.POSITION !== void 0) {
        const z = b.json.accessors[V.POSITION], k = z.min, H = z.max;
        if (k !== void 0 && H !== void 0) {
          if (N.setX(Math.max(Math.abs(k[0]), Math.abs(H[0]))), N.setY(Math.max(Math.abs(k[1]), Math.abs(H[1]))), N.setZ(Math.max(Math.abs(k[2]), Math.abs(H[2]))), z.normalized) {
            const W = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[z.componentType]);
            N.multiplyScalar(W);
          }
          F.max(N);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    M.expandByVector(F);
  }
  B.boundingBox = M;
  const I = new Sphere();
  M.getCenter(I.center), I.radius = M.min.distanceTo(M.max) / 2, B.boundingSphere = I;
}
function addPrimitiveAttributes(B, e, b) {
  const L = e.attributes, M = [];
  function D(I, F) {
    return b.getDependency("accessor", I).then(function(N) {
      B.setAttribute(F, N);
    });
  }
  for (const I in L) {
    const F = ATTRIBUTES[I] || I.toLowerCase();
    F in B.attributes || M.push(D(L[I], F));
  }
  if (e.indices !== void 0 && !B.index) {
    const I = b.getDependency("accessor", e.indices).then(function(F) {
      B.setIndex(F);
    });
    M.push(I);
  }
  return assignExtrasToUserData(B, e), computeBounds(B, e, b), Promise.all(M).then(function() {
    return e.targets !== void 0 ? addMorphTargets(B, e.targets, b) : B;
  });
}
function toTrianglesDrawMode(B, e) {
  let b = B.getIndex();
  if (b === null) {
    const I = [], F = B.getAttribute("position");
    if (F !== void 0) {
      for (let N = 0; N < F.count; N++)
        I.push(N);
      B.setIndex(I), b = B.getIndex();
    } else
      return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), B;
  }
  const L = b.count - 2, M = [];
  if (e === TriangleFanDrawMode)
    for (let I = 1; I <= L; I++)
      M.push(b.getX(0)), M.push(b.getX(I)), M.push(b.getX(I + 1));
  else
    for (let I = 0; I < L; I++)
      I % 2 === 0 ? (M.push(b.getX(I)), M.push(b.getX(I + 1)), M.push(b.getX(I + 2))) : (M.push(b.getX(I + 2)), M.push(b.getX(I + 1)), M.push(b.getX(I)));
  M.length / 3 !== L && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
  const D = B.clone();
  return D.setIndex(M), D;
}
var loader = new GLTFLoader();
class GLTFLoaderState extends SystemStateComponent {
}
class GLTFLoaderSystem extends System {
  init() {
    this.world.registerComponent(GLTFLoaderState).registerComponent(GLTFModel), this.loaded = [];
  }
  execute() {
    const e = this.queries.toLoad.results;
    for (; e.length; ) {
      const L = e[0];
      L.addComponent(GLTFLoaderState), loader.load(
        L.getComponent(GLTFLoader$1).url,
        (M) => this.loaded.push([L, M])
      );
    }
    for (let L = 0; L < this.loaded.length; L++) {
      const [M, D] = this.loaded[L], I = M.getComponent(GLTFLoader$1);
      D.scene.traverse(function(F) {
        F.isMesh && (F.receiveShadow = I.receiveShadow, F.castShadow = I.castShadow, I.envMapOverride && (F.material.envMap = I.envMapOverride));
      }), M.hasComponent(Object3DComponent) ? I.append && M.getObject3D().add(D.scene) : M.addComponent(GLTFModel, { value: D }).addObject3DComponent(D.scene, I.parent), I.onLoaded && I.onLoaded(D.scene, D);
    }
    this.loaded.length = 0;
    const b = this.queries.toUnload.results;
    for (; b.length; ) {
      const L = b[0];
      L.removeComponent(GLTFLoaderState), L.removeObject3DComponent();
    }
  }
}
GLTFLoaderSystem.queries = {
  toLoad: {
    components: [GLTFLoader$1, Not(GLTFLoaderState)]
  },
  toUnload: {
    components: [GLTFLoaderState, Not(GLTFLoader$1)]
  }
};
class SkyBoxSystem extends System {
  execute() {
    let e = this.queries.entities.results;
    for (let b = 0; b < e.length; b++) {
      let L = e[b], M = L.getComponent(SkyBox), D = new Group(), I = new BoxGeometry(100, 100, 100);
      if (I.scale(1, 1, -1), M.type === "cubemap-stereo") {
        let F = getTexturesFromAtlasFile(M.textureUrl, 12), N = [];
        for (let z = 0; z < 6; z++)
          N.push(new MeshBasicMaterial({ map: F[z] }));
        let U = new Mesh(I, N);
        U.layers.set(1), D.add(U);
        let G = [];
        for (let z = 6; z < 12; z++)
          G.push(new MeshBasicMaterial({ map: F[z] }));
        let V = new Mesh(I, G);
        V.layers.set(2), D.add(V), L.addObject3DComponent(D, !1);
      } else
        console.warn("Unknown skybox type: ", M.type);
    }
  }
}
function getTexturesFromAtlasFile(B, e) {
  let b = [];
  for (let M = 0; M < e; M++)
    b[M] = new Texture();
  return new ImageLoader().load(B, function(M) {
    let D, I, F = M.height;
    for (let N = 0; N < b.length; N++)
      D = document.createElement("canvas"), I = D.getContext("2d"), D.height = F, D.width = F, I.drawImage(
        M,
        F * N,
        0,
        F,
        F,
        0,
        0,
        F,
        F
      ), b[N].image = D, b[N].needsUpdate = !0;
  }), b;
}
SkyBoxSystem.queries = {
  entities: {
    components: [SkyBox, Not(Object3DComponent)]
  }
};
class VisibilitySystem extends System {
  processVisibility(e) {
    e.forEach((b) => {
      b.getObject3D().visible = b.getComponent(Visible).value;
    });
  }
  execute() {
    this.processVisibility(this.queries.entities.added), this.processVisibility(this.queries.entities.changed);
  }
}
VisibilitySystem.queries = {
  entities: {
    components: [Visible, Object3DComponent],
    listen: {
      added: !0,
      changed: [Visible]
    }
  }
};
function workerBootstrap() {
  var B = /* @__PURE__ */ Object.create(null);
  function e(M, D) {
    var I = M.id, F = M.name, N = M.dependencies;
    N === void 0 && (N = []);
    var U = M.init;
    U === void 0 && (U = function() {
    });
    var G = M.getTransferables;
    if (G === void 0 && (G = null), !B[I])
      try {
        N = N.map(function(z) {
          return z && z.isWorkerModule && (e(z, function(k) {
            if (k instanceof Error)
              throw k;
          }), z = B[z.id].value), z;
        }), U = L("<" + F + ">.init", U), G && (G = L("<" + F + ">.getTransferables", G));
        var V = null;
        typeof U == "function" ? V = U.apply(void 0, N) : console.error("worker module init function failed to rehydrate"), B[I] = {
          id: I,
          value: V,
          getTransferables: G
        }, D(V);
      } catch (z) {
        z && z.noLog || console.error(z), D(z);
      }
  }
  function b(M, D) {
    var I, F = M.id, N = M.args;
    (!B[F] || typeof B[F].value != "function") && D(new Error("Worker module " + F + ": not found or its 'init' did not return a function"));
    try {
      var U = (I = B[F]).value.apply(I, N);
      U && typeof U.then == "function" ? U.then(G, function(V) {
        return D(V instanceof Error ? V : new Error("" + V));
      }) : G(U);
    } catch (V) {
      D(V);
    }
    function G(V) {
      try {
        var z = B[F].getTransferables && B[F].getTransferables(V);
        (!z || !Array.isArray(z) || !z.length) && (z = void 0), D(V, z);
      } catch (k) {
        console.error(k), D(k);
      }
    }
  }
  function L(M, D) {
    var I = void 0;
    self.troikaDefine = function(N) {
      return I = N;
    };
    var F = URL.createObjectURL(
      new Blob(
        ["/** " + M.replace(/\*/g, "") + ` **/

troikaDefine(
` + D + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(F);
    } catch (N) {
      console.error(N);
    }
    return URL.revokeObjectURL(F), delete self.troikaDefine, I;
  }
  self.addEventListener("message", function(M) {
    var D = M.data, I = D.messageId, F = D.action, N = D.data;
    try {
      F === "registerModule" && e(N, function(U) {
        U instanceof Error ? postMessage({
          messageId: I,
          success: !1,
          error: U.message
        }) : postMessage({
          messageId: I,
          success: !0,
          result: { isCallable: typeof U == "function" }
        });
      }), F === "callModule" && b(N, function(U, G) {
        U instanceof Error ? postMessage({
          messageId: I,
          success: !1,
          error: U.message
        }) : postMessage({
          messageId: I,
          success: !0,
          result: U
        }, G || void 0);
      });
    } catch (U) {
      postMessage({
        messageId: I,
        success: !1,
        error: U.stack
      });
    }
  });
}
function defineMainThreadModule(B) {
  var e = function() {
    for (var b = [], L = arguments.length; L--; ) b[L] = arguments[L];
    return e._getInitResult().then(function(M) {
      if (typeof M == "function")
        return M.apply(void 0, b);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var b = B.dependencies, L = B.init;
    b = Array.isArray(b) ? b.map(
      function(D) {
        return D && D._getInitResult ? D._getInitResult() : D;
      }
    ) : [];
    var M = Promise.all(b).then(function(D) {
      return L.apply(null, D);
    });
    return e._getInitResult = function() {
      return M;
    }, M;
  }, e;
}
var supportsWorkers = function() {
  var B = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), B = !0;
    } catch (b) {
      typeof process < "u" && process.env.NODE_ENV === "test" || console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + b.message + "]"
      );
    }
  return supportsWorkers = function() {
    return B;
  }, B;
}, _workerModuleId = 0, _messageId = 0, _allowInitAsString = !1, workers = /* @__PURE__ */ Object.create(null), registeredModules = /* @__PURE__ */ Object.create(null), openRequests = /* @__PURE__ */ Object.create(null);
function defineWorkerModule(B) {
  if ((!B || typeof B.init != "function") && !_allowInitAsString)
    throw new Error("requires `options.init` function");
  var e = B.dependencies, b = B.init, L = B.getTransferables, M = B.workerId;
  if (!supportsWorkers())
    return defineMainThreadModule(B);
  M == null && (M = "#default");
  var D = "workerModule" + ++_workerModuleId, I = B.name || D, F = null;
  e = e && e.map(function(U) {
    return typeof U == "function" && !U.workerModuleData && (_allowInitAsString = !0, U = defineWorkerModule({
      workerId: M,
      name: "<" + I + "> function dependency: " + U.name,
      init: `function(){return (
` + stringifyFunction(U) + `
)}`
    }), _allowInitAsString = !1), U && U.workerModuleData && (U = U.workerModuleData), U;
  });
  function N() {
    for (var U = [], G = arguments.length; G--; ) U[G] = arguments[G];
    if (!F) {
      F = callWorker(M, "registerModule", N.workerModuleData);
      var V = function() {
        F = null, registeredModules[M].delete(V);
      };
      (registeredModules[M] || (registeredModules[M] = /* @__PURE__ */ new Set())).add(V);
    }
    return F.then(function(z) {
      var k = z.isCallable;
      if (k)
        return callWorker(M, "callModule", { id: D, args: U });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return N.workerModuleData = {
    isWorkerModule: !0,
    id: D,
    name: I,
    dependencies: e,
    init: stringifyFunction(b),
    getTransferables: L && stringifyFunction(L)
  }, N;
}
function terminateWorker(B) {
  registeredModules[B] && registeredModules[B].forEach(function(e) {
    e();
  }), workers[B] && (workers[B].terminate(), delete workers[B]);
}
function stringifyFunction(B) {
  var e = B.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function getWorker(B) {
  var e = workers[B];
  if (!e) {
    var b = stringifyFunction(workerBootstrap);
    e = workers[B] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + B.replace(/\*/g, "") + ` **/

;(` + b + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(L) {
      var M = L.data, D = M.messageId, I = openRequests[D];
      if (!I)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete openRequests[D], I(M);
    };
  }
  return e;
}
function callWorker(B, e, b) {
  return new Promise(function(L, M) {
    var D = ++_messageId;
    openRequests[D] = function(I) {
      I.success ? L(I.result) : M(new Error("Error in worker " + e + " call: " + I.error));
    }, getWorker(B).postMessage({
      messageId: D,
      action: e,
      data: b
    });
  });
}
function SDFGenerator() {
  var B = function(e) {
    function b(de, ve, ce, ge, _e, Me, xe, fe) {
      var Re = 1 - xe;
      fe.x = Re * Re * de + 2 * Re * xe * ce + xe * xe * _e, fe.y = Re * Re * ve + 2 * Re * xe * ge + xe * xe * Me;
    }
    function L(de, ve, ce, ge, _e, Me, xe, fe, Re, Pe) {
      var Ue = 1 - Re;
      Pe.x = Ue * Ue * Ue * de + 3 * Ue * Ue * Re * ce + 3 * Ue * Re * Re * _e + Re * Re * Re * xe, Pe.y = Ue * Ue * Ue * ve + 3 * Ue * Ue * Re * ge + 3 * Ue * Re * Re * Me + Re * Re * Re * fe;
    }
    function M(de, ve) {
      for (var ce = /([MLQCZ])([^MLQCZ]*)/g, ge, _e, Me, xe, fe; ge = ce.exec(de); ) {
        var Re = ge[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(Pe) {
          return parseFloat(Pe);
        });
        switch (ge[1]) {
          case "M":
            xe = _e = Re[0], fe = Me = Re[1];
            break;
          case "L":
            (Re[0] !== xe || Re[1] !== fe) && ve("L", xe, fe, xe = Re[0], fe = Re[1]);
            break;
          case "Q": {
            ve("Q", xe, fe, xe = Re[2], fe = Re[3], Re[0], Re[1]);
            break;
          }
          case "C": {
            ve("C", xe, fe, xe = Re[4], fe = Re[5], Re[0], Re[1], Re[2], Re[3]);
            break;
          }
          case "Z":
            (xe !== _e || fe !== Me) && ve("L", xe, fe, _e, Me);
            break;
        }
      }
    }
    function D(de, ve, ce) {
      ce === void 0 && (ce = 16);
      var ge = { x: 0, y: 0 };
      M(de, function(_e, Me, xe, fe, Re, Pe, Ue, Ve, Oe) {
        switch (_e) {
          case "L":
            ve(Me, xe, fe, Re);
            break;
          case "Q": {
            for (var me = Me, Ie = xe, Be = 1; Be < ce; Be++)
              b(
                Me,
                xe,
                Pe,
                Ue,
                fe,
                Re,
                Be / (ce - 1),
                ge
              ), ve(me, Ie, ge.x, ge.y), me = ge.x, Ie = ge.y;
            break;
          }
          case "C": {
            for (var Ne = Me, Fe = xe, te = 1; te < ce; te++)
              L(
                Me,
                xe,
                Pe,
                Ue,
                Ve,
                Oe,
                fe,
                Re,
                te / (ce - 1),
                ge
              ), ve(Ne, Fe, ge.x, ge.y), Ne = ge.x, Fe = ge.y;
            break;
          }
        }
      });
    }
    var I = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", F = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", N = /* @__PURE__ */ new WeakMap(), U = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function G(de, ve) {
      var ce = de.getContext ? de.getContext("webgl", U) : de, ge = N.get(ce);
      if (!ge) {
        let Ue = function(Ne) {
          var Fe = Me[Ne];
          if (!Fe && (Fe = Me[Ne] = ce.getExtension(Ne), !Fe))
            throw new Error(Ne + " not supported");
          return Fe;
        }, Ve = function(Ne, Fe) {
          var te = ce.createShader(Fe);
          return ce.shaderSource(te, Ne), ce.compileShader(te), te;
        }, Oe = function(Ne, Fe, te, ee) {
          if (!xe[Ne]) {
            var Se = {}, Ee = {}, be = ce.createProgram();
            ce.attachShader(be, Ve(Fe, ce.VERTEX_SHADER)), ce.attachShader(be, Ve(te, ce.FRAGMENT_SHADER)), ce.linkProgram(be), xe[Ne] = {
              program: be,
              transaction: function(Ge) {
                ce.useProgram(be), Ge({
                  setUniform: function(ke, $e) {
                    for (var he = [], Le = arguments.length - 2; Le-- > 0; ) he[Le] = arguments[Le + 2];
                    var Te = Ee[$e] || (Ee[$e] = ce.getUniformLocation(be, $e));
                    ce["uniform" + ke].apply(ce, [Te].concat(he));
                  },
                  setAttribute: function(ke, $e, he, Le, Te) {
                    var je = Se[ke];
                    je || (je = Se[ke] = {
                      buf: ce.createBuffer(),
                      // TODO should we destroy our buffers?
                      loc: ce.getAttribLocation(be, ke),
                      data: null
                    }), ce.bindBuffer(ce.ARRAY_BUFFER, je.buf), ce.vertexAttribPointer(je.loc, $e, ce.FLOAT, !1, 0, 0), ce.enableVertexAttribArray(je.loc), _e ? ce.vertexAttribDivisor(je.loc, Le) : Ue("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(je.loc, Le), Te !== je.data && (ce.bufferData(ce.ARRAY_BUFFER, Te, he), je.data = Te);
                  }
                });
              }
            };
          }
          xe[Ne].transaction(ee);
        }, me = function(Ne, Fe) {
          Re++;
          try {
            ce.activeTexture(ce.TEXTURE0 + Re);
            var te = fe[Ne];
            te || (te = fe[Ne] = ce.createTexture(), ce.bindTexture(ce.TEXTURE_2D, te), ce.texParameteri(ce.TEXTURE_2D, ce.TEXTURE_MIN_FILTER, ce.NEAREST), ce.texParameteri(ce.TEXTURE_2D, ce.TEXTURE_MAG_FILTER, ce.NEAREST)), ce.bindTexture(ce.TEXTURE_2D, te), Fe(te, Re);
          } finally {
            Re--;
          }
        }, Ie = function(Ne, Fe, te) {
          var ee = ce.createFramebuffer();
          Pe.push(ee), ce.bindFramebuffer(ce.FRAMEBUFFER, ee), ce.activeTexture(ce.TEXTURE0 + Fe), ce.bindTexture(ce.TEXTURE_2D, Ne), ce.framebufferTexture2D(ce.FRAMEBUFFER, ce.COLOR_ATTACHMENT0, ce.TEXTURE_2D, Ne, 0);
          try {
            te(ee);
          } finally {
            ce.deleteFramebuffer(ee), ce.bindFramebuffer(ce.FRAMEBUFFER, Pe[--Pe.length - 1] || null);
          }
        }, Be = function() {
          Me = {}, xe = {}, fe = {}, Re = -1, Pe.length = 0;
        };
        var _e = typeof WebGL2RenderingContext < "u" && ce instanceof WebGL2RenderingContext, Me = {}, xe = {}, fe = {}, Re = -1, Pe = [];
        ce.canvas.addEventListener("webglcontextlost", function(Ne) {
          Be(), Ne.preventDefault();
        }, !1), N.set(ce, ge = {
          gl: ce,
          isWebGL2: _e,
          getExtension: Ue,
          withProgram: Oe,
          withTexture: me,
          withTextureFramebuffer: Ie,
          handleContextLoss: Be
        });
      }
      ve(ge);
    }
    function V(de, ve, ce, ge, _e, Me, xe, fe) {
      xe === void 0 && (xe = 15), fe === void 0 && (fe = null), G(de, function(Re) {
        var Pe = Re.gl, Ue = Re.withProgram, Ve = Re.withTexture;
        Ve("copy", function(Oe, me) {
          Pe.texImage2D(Pe.TEXTURE_2D, 0, Pe.RGBA, _e, Me, 0, Pe.RGBA, Pe.UNSIGNED_BYTE, ve), Ue("copy", I, F, function(Ie) {
            var Be = Ie.setUniform, Ne = Ie.setAttribute;
            Ne("aUV", 2, Pe.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), Be("1i", "image", me), Pe.bindFramebuffer(Pe.FRAMEBUFFER, fe || null), Pe.disable(Pe.BLEND), Pe.colorMask(xe & 8, xe & 4, xe & 2, xe & 1), Pe.viewport(ce, ge, _e, Me), Pe.scissor(ce, ge, _e, Me), Pe.drawArrays(Pe.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function z(de, ve, ce) {
      var ge = de.width, _e = de.height;
      G(de, function(Me) {
        var xe = Me.gl, fe = new Uint8Array(ge * _e * 4);
        xe.readPixels(0, 0, ge, _e, xe.RGBA, xe.UNSIGNED_BYTE, fe), de.width = ve, de.height = ce, V(xe, fe, 0, 0, ge, _e);
      });
    }
    var k = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: G,
      renderImageData: V,
      resizeWebGLCanvasWithoutClearing: z
    });
    function H(de, ve, ce, ge, _e, Me) {
      Me === void 0 && (Me = 1);
      var xe = new Uint8Array(de * ve), fe = ge[2] - ge[0], Re = ge[3] - ge[1], Pe = [];
      D(ce, function(Ne, Fe, te, ee) {
        Pe.push({
          x1: Ne,
          y1: Fe,
          x2: te,
          y2: ee,
          minX: Math.min(Ne, te),
          minY: Math.min(Fe, ee),
          maxX: Math.max(Ne, te),
          maxY: Math.max(Fe, ee)
        });
      }), Pe.sort(function(Ne, Fe) {
        return Ne.maxX - Fe.maxX;
      });
      for (var Ue = 0; Ue < de; Ue++)
        for (var Ve = 0; Ve < ve; Ve++) {
          var Oe = Ie(
            ge[0] + fe * (Ue + 0.5) / de,
            ge[1] + Re * (Ve + 0.5) / ve
          ), me = Math.pow(1 - Math.abs(Oe) / _e, Me) / 2;
          Oe < 0 && (me = 1 - me), me = Math.max(0, Math.min(255, Math.round(me * 255))), xe[Ve * de + Ue] = me;
        }
      return xe;
      function Ie(Ne, Fe) {
        for (var te = 1 / 0, ee = 1 / 0, Se = Pe.length; Se--; ) {
          var Ee = Pe[Se];
          if (Ee.maxX + ee <= Ne)
            break;
          if (Ne + ee > Ee.minX && Fe - ee < Ee.maxY && Fe + ee > Ee.minY) {
            var be = j(Ne, Fe, Ee.x1, Ee.y1, Ee.x2, Ee.y2);
            be < te && (te = be, ee = Math.sqrt(te));
          }
        }
        return Be(Ne, Fe) && (ee = -ee), ee;
      }
      function Be(Ne, Fe) {
        for (var te = 0, ee = Pe.length; ee--; ) {
          var Se = Pe[ee];
          if (Se.maxX <= Ne)
            break;
          var Ee = Se.y1 > Fe != Se.y2 > Fe && Ne < (Se.x2 - Se.x1) * (Fe - Se.y1) / (Se.y2 - Se.y1) + Se.x1;
          Ee && (te += Se.y1 < Se.y2 ? 1 : -1);
        }
        return te !== 0;
      }
    }
    function W(de, ve, ce, ge, _e, Me, xe, fe, Re, Pe) {
      Me === void 0 && (Me = 1), fe === void 0 && (fe = 0), Re === void 0 && (Re = 0), Pe === void 0 && (Pe = 0), $(de, ve, ce, ge, _e, Me, xe, null, fe, Re, Pe);
    }
    function $(de, ve, ce, ge, _e, Me, xe, fe, Re, Pe, Ue) {
      Me === void 0 && (Me = 1), Re === void 0 && (Re = 0), Pe === void 0 && (Pe = 0), Ue === void 0 && (Ue = 0);
      for (var Ve = H(de, ve, ce, ge, _e, Me), Oe = new Uint8Array(Ve.length * 4), me = 0; me < Ve.length; me++)
        Oe[me * 4 + Ue] = Ve[me];
      V(xe, Oe, Re, Pe, de, ve, 1 << 3 - Ue, fe);
    }
    function j(de, ve, ce, ge, _e, Me) {
      var xe = _e - ce, fe = Me - ge, Re = xe * xe + fe * fe, Pe = Re ? Math.max(0, Math.min(1, ((de - ce) * xe + (ve - ge) * fe) / Re)) : 0, Ue = de - (ce + Pe * xe), Ve = ve - (ge + Pe * fe);
      return Ue * Ue + Ve * Ve;
    }
    var q = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: H,
      generateIntoCanvas: W,
      generateIntoFramebuffer: $
    }), Y = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", J = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", K = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", X = new Float32Array([0, 0, 2, 0, 0, 2]), Z = null, Q = !1, ne = {}, le = /* @__PURE__ */ new WeakMap();
    function pe(de) {
      if (!Q && !se(de))
        throw new Error("WebGL generation not supported");
    }
    function ue(de, ve, ce, ge, _e, Me, xe) {
      if (Me === void 0 && (Me = 1), xe === void 0 && (xe = null), !xe && (xe = Z, !xe)) {
        var fe = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!fe)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        xe = Z = fe.getContext("webgl", { depth: !1 });
      }
      pe(xe);
      var Re = new Uint8Array(de * ve * 4);
      G(xe, function(Oe) {
        var me = Oe.gl, Ie = Oe.withTexture, Be = Oe.withTextureFramebuffer;
        Ie("readable", function(Ne, Fe) {
          me.texImage2D(me.TEXTURE_2D, 0, me.RGBA, de, ve, 0, me.RGBA, me.UNSIGNED_BYTE, null), Be(Ne, Fe, function(te) {
            ae(
              de,
              ve,
              ce,
              ge,
              _e,
              Me,
              me,
              te,
              0,
              0,
              0
              // red channel
            ), me.readPixels(0, 0, de, ve, me.RGBA, me.UNSIGNED_BYTE, Re);
          });
        });
      });
      for (var Pe = new Uint8Array(de * ve), Ue = 0, Ve = 0; Ue < Re.length; Ue += 4)
        Pe[Ve++] = Re[Ue];
      return Pe;
    }
    function oe(de, ve, ce, ge, _e, Me, xe, fe, Re, Pe) {
      Me === void 0 && (Me = 1), fe === void 0 && (fe = 0), Re === void 0 && (Re = 0), Pe === void 0 && (Pe = 0), ae(de, ve, ce, ge, _e, Me, xe, null, fe, Re, Pe);
    }
    function ae(de, ve, ce, ge, _e, Me, xe, fe, Re, Pe, Ue) {
      Me === void 0 && (Me = 1), Re === void 0 && (Re = 0), Pe === void 0 && (Pe = 0), Ue === void 0 && (Ue = 0), pe(xe);
      var Ve = [];
      D(ce, function(Oe, me, Ie, Be) {
        Ve.push(Oe, me, Ie, Be);
      }), Ve = new Float32Array(Ve), G(xe, function(Oe) {
        var me = Oe.gl, Ie = Oe.isWebGL2, Be = Oe.getExtension, Ne = Oe.withProgram, Fe = Oe.withTexture, te = Oe.withTextureFramebuffer, ee = Oe.handleContextLoss;
        if (Fe("rawDistances", function(Se, Ee) {
          (de !== Se._lastWidth || ve !== Se._lastHeight) && me.texImage2D(
            me.TEXTURE_2D,
            0,
            me.RGBA,
            Se._lastWidth = de,
            Se._lastHeight = ve,
            0,
            me.RGBA,
            me.UNSIGNED_BYTE,
            null
          ), Ne("main", Y, J, function(be) {
            var ze = be.setAttribute, Ge = be.setUniform, He = !Ie && Be("ANGLE_instanced_arrays"), ke = !Ie && Be("EXT_blend_minmax");
            ze("aUV", 2, me.STATIC_DRAW, 0, X), ze("aLineSegment", 4, me.DYNAMIC_DRAW, 1, Ve), Ge.apply(void 0, ["4f", "uGlyphBounds"].concat(ge)), Ge("1f", "uMaxDistance", _e), Ge("1f", "uExponent", Me), te(Se, Ee, function($e) {
              me.enable(me.BLEND), me.colorMask(!0, !0, !0, !0), me.viewport(0, 0, de, ve), me.scissor(0, 0, de, ve), me.blendFunc(me.ONE, me.ONE), me.blendEquationSeparate(me.FUNC_ADD, Ie ? me.MAX : ke.MAX_EXT), me.clear(me.COLOR_BUFFER_BIT), Ie ? me.drawArraysInstanced(me.TRIANGLES, 0, 3, Ve.length / 4) : He.drawArraysInstancedANGLE(me.TRIANGLES, 0, 3, Ve.length / 4);
            });
          }), Ne("post", I, K, function(be) {
            be.setAttribute("aUV", 2, me.STATIC_DRAW, 0, X), be.setUniform("1i", "tex", Ee), me.bindFramebuffer(me.FRAMEBUFFER, fe), me.disable(me.BLEND), me.colorMask(Ue === 0, Ue === 1, Ue === 2, Ue === 3), me.viewport(Re, Pe, de, ve), me.scissor(Re, Pe, de, ve), me.drawArrays(me.TRIANGLES, 0, 3);
          });
        }), me.isContextLost())
          throw ee(), new Error("webgl context lost");
      });
    }
    function se(de) {
      var ve = !de || de === Z ? ne : de.canvas || de, ce = le.get(ve);
      if (ce === void 0) {
        Q = !0;
        var ge = null;
        try {
          var _e = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], Me = ue(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            de
          );
          ce = Me && _e.length === Me.length && Me.every(function(xe, fe) {
            return xe === _e[fe];
          }), ce || (ge = "bad trial run results", console.info(_e, Me));
        } catch (xe) {
          ce = !1, ge = xe.message;
        }
        ge && console.warn("WebGL SDF generation not supported:", ge), Q = !1, le.set(ve, ce);
      }
      return ce;
    }
    var ie = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: ue,
      generateIntoCanvas: oe,
      generateIntoFramebuffer: ae,
      isSupported: se
    });
    function ye(de, ve, ce, ge, _e, Me) {
      _e === void 0 && (_e = Math.max(ge[2] - ge[0], ge[3] - ge[1]) / 2), Me === void 0 && (Me = 1);
      try {
        return ue.apply(ie, arguments);
      } catch (xe) {
        return console.info("WebGL SDF generation failed, falling back to JS", xe), H.apply(q, arguments);
      }
    }
    function Ce(de, ve, ce, ge, _e, Me, xe, fe, Re, Pe) {
      _e === void 0 && (_e = Math.max(ge[2] - ge[0], ge[3] - ge[1]) / 2), Me === void 0 && (Me = 1), fe === void 0 && (fe = 0), Re === void 0 && (Re = 0), Pe === void 0 && (Pe = 0);
      try {
        return oe.apply(ie, arguments);
      } catch (Ue) {
        return console.info("WebGL SDF generation failed, falling back to JS", Ue), W.apply(q, arguments);
      }
    }
    return e.forEachPathCommand = M, e.generate = ye, e.generateIntoCanvas = Ce, e.javascript = q, e.pathToLineSegments = D, e.webgl = ie, e.webglUtils = k, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return B;
}
function bidiFactory() {
  var B = function(e) {
    var b = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, L = {}, M = {};
    L.L = 1, M[1] = "L", Object.keys(b).forEach(function(ee, Se) {
      L[ee] = 1 << Se + 1, M[L[ee]] = ee;
    }), Object.freeze(L);
    var D = L.LRI | L.RLI | L.FSI, I = L.L | L.R | L.AL, F = L.B | L.S | L.WS | L.ON | L.FSI | L.LRI | L.RLI | L.PDI, N = L.BN | L.RLE | L.LRE | L.RLO | L.LRO | L.PDF, U = L.S | L.WS | L.B | D | L.PDI | N, G = null;
    function V() {
      if (!G) {
        G = /* @__PURE__ */ new Map();
        var ee = function(Ee) {
          if (b.hasOwnProperty(Ee)) {
            var be = 0;
            b[Ee].split(",").forEach(function(ze) {
              var Ge = ze.split("+"), He = Ge[0], ke = Ge[1];
              He = parseInt(He, 36), ke = ke ? parseInt(ke, 36) : 0, G.set(be += He, L[Ee]);
              for (var $e = 0; $e < ke; $e++)
                G.set(++be, L[Ee]);
            });
          }
        };
        for (var Se in b) ee(Se);
      }
    }
    function z(ee) {
      return V(), G.get(ee.codePointAt(0)) || L.L;
    }
    function k(ee) {
      return M[z(ee)];
    }
    var H = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function W(ee, Se) {
      var Ee = 36, be = 0, ze = /* @__PURE__ */ new Map(), Ge = Se && /* @__PURE__ */ new Map(), He;
      return ee.split(",").forEach(function ke($e) {
        if ($e.indexOf("+") !== -1)
          for (var he = +$e; he--; )
            ke(He);
        else {
          He = $e;
          var Le = $e.split(">"), Te = Le[0], je = Le[1];
          Te = String.fromCodePoint(be += parseInt(Te, Ee)), je = String.fromCodePoint(be += parseInt(je, Ee)), ze.set(Te, je), Se && Ge.set(je, Te);
        }
      }), { map: ze, reverseMap: Ge };
    }
    var $, j, q;
    function Y() {
      if (!$) {
        var ee = W(H.pairs, !0), Se = ee.map, Ee = ee.reverseMap;
        $ = Se, j = Ee, q = W(H.canonical, !1).map;
      }
    }
    function J(ee) {
      return Y(), $.get(ee) || null;
    }
    function K(ee) {
      return Y(), j.get(ee) || null;
    }
    function X(ee) {
      return Y(), q.get(ee) || null;
    }
    var Z = L.L, Q = L.R, ne = L.EN, le = L.ES, pe = L.ET, ue = L.AN, oe = L.CS, ae = L.B, se = L.S, ie = L.ON, ye = L.BN, Ce = L.NSM, de = L.AL, ve = L.LRO, ce = L.RLO, ge = L.LRE, _e = L.RLE, Me = L.PDF, xe = L.LRI, fe = L.RLI, Re = L.FSI, Pe = L.PDI;
    function Ue(ee, Se) {
      for (var Ee = 125, be = new Uint32Array(ee.length), ze = 0; ze < ee.length; ze++)
        be[ze] = z(ee[ze]);
      var Ge = /* @__PURE__ */ new Map();
      function He(At, Dt) {
        var Ct = be[At];
        be[At] = Dt, Ge.set(Ct, Ge.get(Ct) - 1), Ct & F && Ge.set(F, Ge.get(F) - 1), Ge.set(Dt, (Ge.get(Dt) || 0) + 1), Dt & F && Ge.set(F, (Ge.get(F) || 0) + 1);
      }
      for (var ke = new Uint8Array(ee.length), $e = /* @__PURE__ */ new Map(), he = [], Le = null, Te = 0; Te < ee.length; Te++)
        Le || he.push(Le = {
          start: Te,
          end: ee.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: Se === "rtl" ? 1 : Se === "ltr" ? 0 : Hn(Te, !1)
        }), be[Te] & ae && (Le.end = Te, Le = null);
      for (var je = _e | ge | ce | ve | D | Pe | Me | ae, We = function(At) {
        return At + (At & 1 ? 1 : 2);
      }, rt = function(At) {
        return At + (At & 1 ? 2 : 1);
      }, Qe = 0; Qe < he.length; Qe++) {
        Le = he[Qe];
        var et = [{
          _level: Le.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }], Ye = void 0, st = 0, ut = 0, vt = 0;
        Ge.clear();
        for (var mt = Le.start; mt <= Le.end; mt++) {
          var tt = be[mt];
          if (Ye = et[et.length - 1], Ge.set(tt, (Ge.get(tt) || 0) + 1), tt & F && Ge.set(F, (Ge.get(F) || 0) + 1), tt & je)
            if (tt & (_e | ge)) {
              ke[mt] = Ye._level;
              var dt = (tt === _e ? rt : We)(Ye._level);
              dt <= Ee && !st && !ut ? et.push({
                _level: dt,
                _override: 0,
                _isolate: 0
              }) : st || ut++;
            } else if (tt & (ce | ve)) {
              ke[mt] = Ye._level;
              var Tt = (tt === ce ? rt : We)(Ye._level);
              Tt <= Ee && !st && !ut ? et.push({
                _level: Tt,
                _override: tt & ce ? Q : Z,
                _isolate: 0
              }) : st || ut++;
            } else if (tt & D) {
              tt & Re && (tt = Hn(mt + 1, !0) === 1 ? fe : xe), ke[mt] = Ye._level, Ye._override && He(mt, Ye._override);
              var ft = (tt === fe ? rt : We)(Ye._level);
              ft <= Ee && st === 0 && ut === 0 ? (vt++, et.push({
                _level: ft,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: mt
              })) : st++;
            } else if (tt & Pe) {
              if (st > 0)
                st--;
              else if (vt > 0) {
                for (ut = 0; !et[et.length - 1]._isolate; )
                  et.pop();
                var lt = et[et.length - 1]._isolInitIndex;
                lt != null && ($e.set(lt, mt), $e.set(mt, lt)), et.pop(), vt--;
              }
              Ye = et[et.length - 1], ke[mt] = Ye._level, Ye._override && He(mt, Ye._override);
            } else tt & Me ? (st === 0 && (ut > 0 ? ut-- : !Ye._isolate && et.length > 1 && (et.pop(), Ye = et[et.length - 1])), ke[mt] = Ye._level) : tt & ae && (ke[mt] = Le.level);
          else
            ke[mt] = Ye._level, Ye._override && tt !== ye && He(mt, Ye._override);
        }
        for (var _t = [], gt = null, ot = Le.start; ot <= Le.end; ot++) {
          var yt = be[ot];
          if (!(yt & N)) {
            var St = ke[ot], Mt = yt & D, xt = yt === Pe;
            gt && St === gt._level ? (gt._end = ot, gt._endsWithIsolInit = Mt) : _t.push(gt = {
              _start: ot,
              _end: ot,
              _level: St,
              _startsWithPDI: xt,
              _endsWithIsolInit: Mt
            });
          }
        }
        for (var re = [], Ae = 0; Ae < _t.length; Ae++) {
          var we = _t[Ae];
          if (!we._startsWithPDI || we._startsWithPDI && !$e.has(we._start)) {
            for (var De = [gt = we], qe = void 0; gt && gt._endsWithIsolInit && (qe = $e.get(gt._end)) != null; )
              for (var nt = Ae + 1; nt < _t.length; nt++)
                if (_t[nt]._start === qe) {
                  De.push(gt = _t[nt]);
                  break;
                }
            for (var Je = [], Xe = 0; Xe < De.length; Xe++)
              for (var at = De[Xe], Ke = at._start; Ke <= at._end; Ke++)
                Je.push(Ke);
            for (var ct = ke[Je[0]], it = Le.level, ht = Je[0] - 1; ht >= 0; ht--)
              if (!(be[ht] & N)) {
                it = ke[ht];
                break;
              }
            var Et = Je[Je.length - 1], wt = ke[Et], It = Le.level;
            if (!(be[Et] & D)) {
              for (var pt = Et + 1; pt <= Le.end; pt++)
                if (!(be[pt] & N)) {
                  It = ke[pt];
                  break;
                }
            }
            re.push({
              _seqIndices: Je,
              _sosType: Math.max(it, ct) % 2 ? Q : Z,
              _eosType: Math.max(It, wt) % 2 ? Q : Z
            });
          }
        }
        for (var Rt = 0; Rt < re.length; Rt++) {
          var bt = re[Rt], Ze = bt._seqIndices, Bt = bt._sosType, Ut = bt._eosType, Gt = ke[Ze[0]] & 1 ? Q : Z;
          if (Ge.get(Ce))
            for (var Kt = 0; Kt < Ze.length; Kt++) {
              var En = Ze[Kt];
              if (be[En] & Ce) {
                for (var un = Bt, Qt = Kt - 1; Qt >= 0; Qt--)
                  if (!(be[Ze[Qt]] & N)) {
                    un = be[Ze[Qt]];
                    break;
                  }
                He(En, un & (D | Pe) ? ie : un);
              }
            }
          if (Ge.get(ne))
            for (var en = 0; en < Ze.length; en++) {
              var An = Ze[en];
              if (be[An] & ne)
                for (var tn = en - 1; tn >= -1; tn--) {
                  var Cn = tn === -1 ? Bt : be[Ze[tn]];
                  if (Cn & I) {
                    Cn === de && He(An, ue);
                    break;
                  }
                }
            }
          if (Ge.get(de))
            for (var hn = 0; hn < Ze.length; hn++) {
              var Ln = Ze[hn];
              be[Ln] & de && He(Ln, Q);
            }
          if (Ge.get(le) || Ge.get(oe))
            for (var Ht = 1; Ht < Ze.length - 1; Ht++) {
              var dn = Ze[Ht];
              if (be[dn] & (le | oe)) {
                for (var Vt = 0, fn = 0, pn = Ht - 1; pn >= 0 && (Vt = be[Ze[pn]], !!(Vt & N)); pn--)
                  ;
                for (var mn = Ht + 1; mn < Ze.length && (fn = be[Ze[mn]], !!(fn & N)); mn++)
                  ;
                Vt === fn && (be[dn] === le ? Vt === ne : Vt & (ne | ue)) && He(dn, Vt);
              }
            }
          if (Ge.get(ne))
            for (var Ft = 0; Ft < Ze.length; Ft++) {
              var qn = Ze[Ft];
              if (be[qn] & ne) {
                for (var nn = Ft - 1; nn >= 0 && be[Ze[nn]] & (pe | N); nn--)
                  He(Ze[nn], ne);
                for (Ft++; Ft < Ze.length && be[Ze[Ft]] & (pe | N | ne); Ft++)
                  be[Ze[Ft]] !== ne && He(Ze[Ft], ne);
              }
            }
          if (Ge.get(pe) || Ge.get(le) || Ge.get(oe))
            for (var Wt = 0; Wt < Ze.length; Wt++) {
              var Rn = Ze[Wt];
              if (be[Rn] & (pe | le | oe)) {
                He(Rn, ie);
                for (var rn = Wt - 1; rn >= 0 && be[Ze[rn]] & N; rn--)
                  He(Ze[rn], ie);
                for (var on = Wt + 1; on < Ze.length && be[Ze[on]] & N; on++)
                  He(Ze[on], ie);
              }
            }
          if (Ge.get(ne))
            for (var gn = 0, Pn = Bt; gn < Ze.length; gn++) {
              var Dn = Ze[gn], yn = be[Dn];
              yn & ne ? Pn === Z && He(Dn, Z) : yn & I && (Pn = yn);
            }
          if (Ge.get(F)) {
            var qt = Q | ne | ue, In = qt | Z, sn = [];
            {
              for (var zt = [], kt = 0; kt < Ze.length; kt++)
                if (be[Ze[kt]] & F) {
                  var jt = ee[Ze[kt]], Bn = void 0;
                  if (J(jt) !== null)
                    if (zt.length < 63)
                      zt.push({ char: jt, seqIndex: kt });
                    else
                      break;
                  else if ((Bn = K(jt)) !== null)
                    for (var $t = zt.length - 1; $t >= 0; $t--) {
                      var vn = zt[$t].char;
                      if (vn === Bn || vn === K(X(jt)) || J(X(vn)) === jt) {
                        sn.push([zt[$t].seqIndex, kt]), zt.length = $t;
                        break;
                      }
                    }
                }
              sn.sort(function(At, Dt) {
                return At[0] - Dt[0];
              });
            }
            for (var _n = 0; _n < sn.length; _n++) {
              for (var Fn = sn[_n], an = Fn[0], xn = Fn[1], Nn = !1, Pt = 0, bn = an + 1; bn < xn; bn++) {
                var On = Ze[bn];
                if (be[On] & In) {
                  Nn = !0;
                  var Un = be[On] & qt ? Q : Z;
                  if (Un === Gt) {
                    Pt = Un;
                    break;
                  }
                }
              }
              if (Nn && !Pt) {
                Pt = Bt;
                for (var Sn = an - 1; Sn >= 0; Sn--) {
                  var Gn = Ze[Sn];
                  if (be[Gn] & In) {
                    var Vn = be[Gn] & qt ? Q : Z;
                    Vn !== Gt ? Pt = Vn : Pt = Gt;
                    break;
                  }
                }
              }
              if (Pt) {
                if (be[Ze[an]] = be[Ze[xn]] = Pt, Pt !== Gt) {
                  for (var Xt = an + 1; Xt < Ze.length; Xt++)
                    if (!(be[Ze[Xt]] & N)) {
                      z(ee[Ze[Xt]]) & Ce && (be[Ze[Xt]] = Pt);
                      break;
                    }
                }
                if (Pt !== Gt) {
                  for (var Yt = xn + 1; Yt < Ze.length; Yt++)
                    if (!(be[Ze[Yt]] & N)) {
                      z(ee[Ze[Yt]]) & Ce && (be[Ze[Yt]] = Pt);
                      break;
                    }
                }
              }
            }
            for (var Nt = 0; Nt < Ze.length; Nt++)
              if (be[Ze[Nt]] & F) {
                for (var zn = Nt, Mn = Nt, wn = Bt, Jt = Nt - 1; Jt >= 0; Jt--)
                  if (be[Ze[Jt]] & N)
                    zn = Jt;
                  else {
                    wn = be[Ze[Jt]] & qt ? Q : Z;
                    break;
                  }
                for (var kn = Ut, Zt = Nt + 1; Zt < Ze.length; Zt++)
                  if (be[Ze[Zt]] & (F | N))
                    Mn = Zt;
                  else {
                    kn = be[Ze[Zt]] & qt ? Q : Z;
                    break;
                  }
                for (var Tn = zn; Tn <= Mn; Tn++)
                  be[Ze[Tn]] = wn === kn ? wn : Gt;
                Nt = Mn;
              }
          }
        }
        for (var Lt = Le.start; Lt <= Le.end; Lt++) {
          var jn = ke[Lt], ln = be[Lt];
          if (jn & 1 ? ln & (Z | ne | ue) && ke[Lt]++ : ln & Q ? ke[Lt]++ : ln & (ue | ne) && (ke[Lt] += 2), ln & N && (ke[Lt] = Lt === 0 ? Le.level : ke[Lt - 1]), Lt === Le.end || z(ee[Lt]) & (se | ae))
            for (var cn = Lt; cn >= 0 && z(ee[cn]) & U; cn--)
              ke[cn] = Le.level;
        }
      }
      return {
        levels: ke,
        paragraphs: he
      };
      function Hn(At, Dt) {
        for (var Ct = At; Ct < ee.length; Ct++) {
          var Ot = be[Ct];
          if (Ot & (Q | de))
            return 1;
          if (Ot & (ae | Z) || Dt && Ot === Pe)
            return 0;
          if (Ot & D) {
            var Wn = $n(Ct);
            Ct = Wn === -1 ? ee.length : Wn;
          }
        }
        return 0;
      }
      function $n(At) {
        for (var Dt = 1, Ct = At + 1; Ct < ee.length; Ct++) {
          var Ot = be[Ct];
          if (Ot & ae)
            break;
          if (Ot & Pe) {
            if (--Dt === 0)
              return Ct;
          } else Ot & D && Dt++;
        }
        return -1;
      }
    }
    var Ve = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", Oe;
    function me() {
      if (!Oe) {
        var ee = W(Ve, !0), Se = ee.map, Ee = ee.reverseMap;
        Ee.forEach(function(be, ze) {
          Se.set(ze, be);
        }), Oe = Se;
      }
    }
    function Ie(ee) {
      return me(), Oe.get(ee) || null;
    }
    function Be(ee, Se, Ee, be) {
      var ze = ee.length;
      Ee = Math.max(0, Ee == null ? 0 : +Ee), be = Math.min(ze - 1, be == null ? ze - 1 : +be);
      for (var Ge = /* @__PURE__ */ new Map(), He = Ee; He <= be; He++)
        if (Se[He] & 1) {
          var ke = Ie(ee[He]);
          ke !== null && Ge.set(He, ke);
        }
      return Ge;
    }
    function Ne(ee, Se, Ee, be) {
      var ze = ee.length;
      Ee = Math.max(0, Ee == null ? 0 : +Ee), be = Math.min(ze - 1, be == null ? ze - 1 : +be);
      var Ge = [];
      return Se.paragraphs.forEach(function(He) {
        var ke = Math.max(Ee, He.start), $e = Math.min(be, He.end);
        if (ke < $e) {
          for (var he = Se.levels.slice(ke, $e + 1), Le = $e; Le >= ke && z(ee[Le]) & U; Le--)
            he[Le] = He.level;
          for (var Te = He.level, je = 1 / 0, We = 0; We < he.length; We++) {
            var rt = he[We];
            rt > Te && (Te = rt), rt < je && (je = rt | 1);
          }
          for (var Qe = Te; Qe >= je; Qe--)
            for (var et = 0; et < he.length; et++)
              if (he[et] >= Qe) {
                for (var Ye = et; et + 1 < he.length && he[et + 1] >= Qe; )
                  et++;
                et > Ye && Ge.push([Ye + ke, et + ke]);
              }
        }
      }), Ge;
    }
    function Fe(ee, Se, Ee, be) {
      var ze = te(ee, Se, Ee, be), Ge = [].concat(ee);
      return ze.forEach(function(He, ke) {
        Ge[ke] = (Se.levels[He] & 1 ? Ie(ee[He]) : null) || ee[He];
      }), Ge.join("");
    }
    function te(ee, Se, Ee, be) {
      for (var ze = Ne(ee, Se, Ee, be), Ge = [], He = 0; He < ee.length; He++)
        Ge[He] = He;
      return ze.forEach(function(ke) {
        for (var $e = ke[0], he = ke[1], Le = Ge.slice($e, he + 1), Te = Le.length; Te--; )
          Ge[he - Te] = Le[Te];
      }), Ge;
    }
    return e.closingToOpeningBracket = K, e.getBidiCharType = z, e.getBidiCharTypeName = k, e.getCanonicalBracket = X, e.getEmbeddingLevels = Ue, e.getMirroredCharacter = Ie, e.getMirroredCharactersMap = Be, e.getReorderSegments = Ne, e.getReorderedIndices = te, e.getReorderedString = Fe, e.openingToClosingBracket = J, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return B;
}
const voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function expandShaderIncludes(B) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function b(L, M) {
    let D = ShaderChunk[M];
    return D ? expandShaderIncludes(D) : L;
  }
  return B.replace(e, b);
}
const _lut = [];
for (let B = 0; B < 256; B++)
  _lut[B] = (B < 16 ? "0" : "") + B.toString(16);
function generateUUID() {
  const B = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, b = Math.random() * 4294967295 | 0, L = Math.random() * 4294967295 | 0;
  return (_lut[B & 255] + _lut[B >> 8 & 255] + _lut[B >> 16 & 255] + _lut[B >> 24 & 255] + "-" + _lut[e & 255] + _lut[e >> 8 & 255] + "-" + _lut[e >> 16 & 15 | 64] + _lut[e >> 24 & 255] + "-" + _lut[b & 63 | 128] + _lut[b >> 8 & 255] + "-" + _lut[b >> 16 & 255] + _lut[b >> 24 & 255] + _lut[L & 255] + _lut[L >> 8 & 255] + _lut[L >> 16 & 255] + _lut[L >> 24 & 255]).toUpperCase();
}
const assign$1 = Object.assign || function() {
  let B = arguments[0];
  for (let e = 1, b = arguments.length; e < b; e++) {
    let L = arguments[e];
    if (L)
      for (let M in L)
        Object.prototype.hasOwnProperty.call(L, M) && (B[M] = L[M]);
  }
  return B;
}, epoch = Date.now(), CONSTRUCTOR_CACHE = /* @__PURE__ */ new WeakMap(), SHADER_UPGRADE_CACHE = /* @__PURE__ */ new Map();
let materialInstanceId = 1e10;
function createDerivedMaterial(B, e) {
  const b = getKeyForOptions(e);
  let L = CONSTRUCTOR_CACHE.get(B);
  if (L || CONSTRUCTOR_CACHE.set(B, L = /* @__PURE__ */ Object.create(null)), L[b])
    return new L[b]();
  const M = `_onBeforeCompile${b}`, D = function(U, G) {
    B.onBeforeCompile.call(this, U, G);
    const V = this.customProgramCacheKey() + "|" + U.vertexShader + "|" + U.fragmentShader;
    let z = SHADER_UPGRADE_CACHE[V];
    if (!z) {
      const k = upgradeShaders(this, U, e, b);
      z = SHADER_UPGRADE_CACHE[V] = k;
    }
    U.vertexShader = z.vertexShader, U.fragmentShader = z.fragmentShader, assign$1(U.uniforms, this.uniforms), e.timeUniform && (U.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - epoch;
      }
    }), this[M] && this[M](U);
  }, I = function() {
    return F(e.chained ? B : B.clone());
  }, F = function(U) {
    const G = Object.create(U, N);
    return Object.defineProperty(G, "baseMaterial", { value: B }), Object.defineProperty(G, "id", { value: materialInstanceId++ }), G.uuid = generateUUID(), G.uniforms = assign$1({}, U.uniforms, e.uniforms), G.defines = assign$1({}, U.defines, e.defines), G.defines[`TROIKA_DERIVED_MATERIAL_${b}`] = "", G.extensions = assign$1({}, U.extensions, e.extensions), G._listeners = void 0, G;
  }, N = {
    constructor: { value: I },
    isDerivedMaterial: { value: !0 },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return B.customProgramCacheKey() + "|" + b;
      }
    },
    onBeforeCompile: {
      get() {
        return D;
      },
      set(U) {
        this[M] = U;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(U) {
        return B.copy.call(this, U), !B.isShaderMaterial && !B.isDerivedMaterial && (assign$1(this.extensions, U.extensions), assign$1(this.defines, U.defines), assign$1(this.uniforms, UniformsUtils.clone(U.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const U = new B.constructor();
        return F(U).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let U = this._depthMaterial;
        return U || (U = this._depthMaterial = createDerivedMaterial(
          B.isDerivedMaterial ? B.getDepthMaterial() : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
          e
        ), U.defines.IS_DEPTH_MATERIAL = "", U.uniforms = this.uniforms), U;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let U = this._distanceMaterial;
        return U || (U = this._distanceMaterial = createDerivedMaterial(
          B.isDerivedMaterial ? B.getDistanceMaterial() : new MeshDistanceMaterial(),
          e
        ), U.defines.IS_DISTANCE_MATERIAL = "", U.uniforms = this.uniforms), U;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: U, _distanceMaterial: G } = this;
        U && U.dispose(), G && G.dispose(), B.dispose.call(this);
      }
    }
  };
  return L[b] = I, new I();
}
function upgradeShaders(B, { vertexShader: e, fragmentShader: b }, L, M) {
  let {
    vertexDefs: D,
    vertexMainIntro: I,
    vertexMainOutro: F,
    vertexTransform: N,
    fragmentDefs: U,
    fragmentMainIntro: G,
    fragmentMainOutro: V,
    fragmentColorTransform: z,
    customRewriter: k,
    timeUniform: H
  } = L;
  if (D = D || "", I = I || "", F = F || "", U = U || "", G = G || "", V = V || "", (N || k) && (e = expandShaderIncludes(e)), (z || k) && (b = b.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), b = expandShaderIncludes(b)), k) {
    let W = k({ vertexShader: e, fragmentShader: b });
    e = W.vertexShader, b = W.fragmentShader;
  }
  if (z) {
    let W = [];
    b = b.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      ($) => (W.push($), "")
    ), V = `${z}
${W.join(`
`)}
${V}`;
  }
  if (H) {
    const W = `
uniform float ${H};
`;
    D = W + D, U = W + U;
  }
  return N && (e = `vec3 troika_position_${M};
vec3 troika_normal_${M};
vec2 troika_uv_${M};
${e}
`, D = `${D}
void troikaVertexTransform${M}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${N}
}
`, I = `
troika_position_${M} = vec3(position);
troika_normal_${M} = vec3(normal);
troika_uv_${M} = vec2(uv);
troikaVertexTransform${M}(troika_position_${M}, troika_normal_${M}, troika_uv_${M});
${I}
`, e = e.replace(/\b(position|normal|uv)\b/g, (W, $, j, q) => /\battribute\s+vec[23]\s+$/.test(q.substr(0, j)) ? $ : `troika_${$}_${M}`), B.map && B.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${M}`))), e = injectIntoShaderCode(e, M, D, I, F), b = injectIntoShaderCode(b, M, U, G, V), {
    vertexShader: e,
    fragmentShader: b
  };
}
function injectIntoShaderCode(B, e, b, L, M) {
  return (L || M || b) && (B = B.replace(
    voidMainRegExp,
    `
${b}
void troikaOrigMain${e}() {`
  ), B += `
void main() {
  ${L}
  troikaOrigMain${e}();
  ${M}
}`), B;
}
function optionsJsonReplacer(B, e) {
  return B === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let _idCtr = 0;
const optionsHashesToIds = /* @__PURE__ */ new Map();
function getKeyForOptions(B) {
  const e = JSON.stringify(B, optionsJsonReplacer);
  let b = optionsHashesToIds.get(e);
  return b == null && optionsHashesToIds.set(e, b = ++_idCtr), b;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function typrFactory() {
  return typeof window > "u" && (self.window = self), function(B) {
    var e = { parse: function(M) {
      var D = e._bin, I = new Uint8Array(M);
      if (D.readASCII(I, 0, 4) == "ttcf") {
        var F = 4;
        D.readUshort(I, F), F += 2, D.readUshort(I, F), F += 2;
        var N = D.readUint(I, F);
        F += 4;
        for (var U = [], G = 0; G < N; G++) {
          var V = D.readUint(I, F);
          F += 4, U.push(e._readFont(I, V));
        }
        return U;
      }
      return [e._readFont(I, 0)];
    }, _readFont: function(M, D) {
      var I = e._bin, F = D;
      I.readFixed(M, D), D += 4;
      var N = I.readUshort(M, D);
      D += 2, I.readUshort(M, D), D += 2, I.readUshort(M, D), D += 2, I.readUshort(M, D), D += 2;
      for (var U = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], G = { _data: M, _offset: F }, V = {}, z = 0; z < N; z++) {
        var k = I.readASCII(M, D, 4);
        D += 4, I.readUint(M, D), D += 4;
        var H = I.readUint(M, D);
        D += 4;
        var W = I.readUint(M, D);
        D += 4, V[k] = { offset: H, length: W };
      }
      for (z = 0; z < U.length; z++) {
        var $ = U[z];
        V[$] && (G[$.trim()] = e[$.trim()].parse(M, V[$].offset, V[$].length, G));
      }
      return G;
    }, _tabOffset: function(M, D, I) {
      for (var F = e._bin, N = F.readUshort(M, I + 4), U = I + 12, G = 0; G < N; G++) {
        var V = F.readASCII(M, U, 4);
        U += 4, F.readUint(M, U), U += 4;
        var z = F.readUint(M, U);
        if (U += 4, F.readUint(M, U), U += 4, V == D) return z;
      }
      return 0;
    } };
    e._bin = { readFixed: function(M, D) {
      return (M[D] << 8 | M[D + 1]) + (M[D + 2] << 8 | M[D + 3]) / 65540;
    }, readF2dot14: function(M, D) {
      return e._bin.readShort(M, D) / 16384;
    }, readInt: function(M, D) {
      return e._bin._view(M).getInt32(D);
    }, readInt8: function(M, D) {
      return e._bin._view(M).getInt8(D);
    }, readShort: function(M, D) {
      return e._bin._view(M).getInt16(D);
    }, readUshort: function(M, D) {
      return e._bin._view(M).getUint16(D);
    }, readUshorts: function(M, D, I) {
      for (var F = [], N = 0; N < I; N++) F.push(e._bin.readUshort(M, D + 2 * N));
      return F;
    }, readUint: function(M, D) {
      return e._bin._view(M).getUint32(D);
    }, readUint64: function(M, D) {
      return 4294967296 * e._bin.readUint(M, D) + e._bin.readUint(M, D + 4);
    }, readASCII: function(M, D, I) {
      for (var F = "", N = 0; N < I; N++) F += String.fromCharCode(M[D + N]);
      return F;
    }, readUnicode: function(M, D, I) {
      for (var F = "", N = 0; N < I; N++) {
        var U = M[D++] << 8 | M[D++];
        F += String.fromCharCode(U);
      }
      return F;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(M, D, I) {
      var F = e._bin._tdec;
      return F && D == 0 && I == M.length ? F.decode(M) : e._bin.readASCII(M, D, I);
    }, readBytes: function(M, D, I) {
      for (var F = [], N = 0; N < I; N++) F.push(M[D + N]);
      return F;
    }, readASCIIArray: function(M, D, I) {
      for (var F = [], N = 0; N < I; N++) F.push(String.fromCharCode(M[D + N]));
      return F;
    }, _view: function(M) {
      return M._dataView || (M._dataView = M.buffer ? new DataView(M.buffer, M.byteOffset, M.byteLength) : new DataView(new Uint8Array(M).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(M, D, I, F, N) {
      var U = e._bin, G = {}, V = D;
      U.readFixed(M, D), D += 4;
      var z = U.readUshort(M, D);
      D += 2;
      var k = U.readUshort(M, D);
      D += 2;
      var H = U.readUshort(M, D);
      return D += 2, G.scriptList = e._lctf.readScriptList(M, V + z), G.featureList = e._lctf.readFeatureList(M, V + k), G.lookupList = e._lctf.readLookupList(M, V + H, N), G;
    }, e._lctf.readLookupList = function(M, D, I) {
      var F = e._bin, N = D, U = [], G = F.readUshort(M, D);
      D += 2;
      for (var V = 0; V < G; V++) {
        var z = F.readUshort(M, D);
        D += 2;
        var k = e._lctf.readLookupTable(M, N + z, I);
        U.push(k);
      }
      return U;
    }, e._lctf.readLookupTable = function(M, D, I) {
      var F = e._bin, N = D, U = { tabs: [] };
      U.ltype = F.readUshort(M, D), D += 2, U.flag = F.readUshort(M, D), D += 2;
      var G = F.readUshort(M, D);
      D += 2;
      for (var V = U.ltype, z = 0; z < G; z++) {
        var k = F.readUshort(M, D);
        D += 2;
        var H = I(M, V, N + k, U);
        U.tabs.push(H);
      }
      return U;
    }, e._lctf.numOfOnes = function(M) {
      for (var D = 0, I = 0; I < 32; I++) M >>> I & 1 && D++;
      return D;
    }, e._lctf.readClassDef = function(M, D) {
      var I = e._bin, F = [], N = I.readUshort(M, D);
      if (D += 2, N == 1) {
        var U = I.readUshort(M, D);
        D += 2;
        var G = I.readUshort(M, D);
        D += 2;
        for (var V = 0; V < G; V++) F.push(U + V), F.push(U + V), F.push(I.readUshort(M, D)), D += 2;
      }
      if (N == 2) {
        var z = I.readUshort(M, D);
        for (D += 2, V = 0; V < z; V++) F.push(I.readUshort(M, D)), D += 2, F.push(I.readUshort(M, D)), D += 2, F.push(I.readUshort(M, D)), D += 2;
      }
      return F;
    }, e._lctf.getInterval = function(M, D) {
      for (var I = 0; I < M.length; I += 3) {
        var F = M[I], N = M[I + 1];
        if (M[I + 2], F <= D && D <= N) return I;
      }
      return -1;
    }, e._lctf.readCoverage = function(M, D) {
      var I = e._bin, F = {};
      F.fmt = I.readUshort(M, D), D += 2;
      var N = I.readUshort(M, D);
      return D += 2, F.fmt == 1 && (F.tab = I.readUshorts(M, D, N)), F.fmt == 2 && (F.tab = I.readUshorts(M, D, 3 * N)), F;
    }, e._lctf.coverageIndex = function(M, D) {
      var I = M.tab;
      if (M.fmt == 1) return I.indexOf(D);
      if (M.fmt == 2) {
        var F = e._lctf.getInterval(I, D);
        if (F != -1) return I[F + 2] + (D - I[F]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(M, D) {
      var I = e._bin, F = D, N = [], U = I.readUshort(M, D);
      D += 2;
      for (var G = 0; G < U; G++) {
        var V = I.readASCII(M, D, 4);
        D += 4;
        var z = I.readUshort(M, D);
        D += 2;
        var k = e._lctf.readFeatureTable(M, F + z);
        k.tag = V.trim(), N.push(k);
      }
      return N;
    }, e._lctf.readFeatureTable = function(M, D) {
      var I = e._bin, F = D, N = {}, U = I.readUshort(M, D);
      D += 2, U > 0 && (N.featureParams = F + U);
      var G = I.readUshort(M, D);
      D += 2, N.tab = [];
      for (var V = 0; V < G; V++) N.tab.push(I.readUshort(M, D + 2 * V));
      return N;
    }, e._lctf.readScriptList = function(M, D) {
      var I = e._bin, F = D, N = {}, U = I.readUshort(M, D);
      D += 2;
      for (var G = 0; G < U; G++) {
        var V = I.readASCII(M, D, 4);
        D += 4;
        var z = I.readUshort(M, D);
        D += 2, N[V.trim()] = e._lctf.readScriptTable(M, F + z);
      }
      return N;
    }, e._lctf.readScriptTable = function(M, D) {
      var I = e._bin, F = D, N = {}, U = I.readUshort(M, D);
      D += 2, U > 0 && (N.default = e._lctf.readLangSysTable(M, F + U));
      var G = I.readUshort(M, D);
      D += 2;
      for (var V = 0; V < G; V++) {
        var z = I.readASCII(M, D, 4);
        D += 4;
        var k = I.readUshort(M, D);
        D += 2, N[z.trim()] = e._lctf.readLangSysTable(M, F + k);
      }
      return N;
    }, e._lctf.readLangSysTable = function(M, D) {
      var I = e._bin, F = {};
      I.readUshort(M, D), D += 2, F.reqFeature = I.readUshort(M, D), D += 2;
      var N = I.readUshort(M, D);
      return D += 2, F.features = I.readUshorts(M, D, N), F;
    }, e.CFF = {}, e.CFF.parse = function(M, D, I) {
      var F = e._bin;
      (M = new Uint8Array(M.buffer, D, I))[D = 0], M[++D], M[++D], M[++D], D++;
      var N = [];
      D = e.CFF.readIndex(M, D, N);
      for (var U = [], G = 0; G < N.length - 1; G++) U.push(F.readASCII(M, D + N[G], N[G + 1] - N[G]));
      D += N[N.length - 1];
      var V = [];
      D = e.CFF.readIndex(M, D, V);
      var z = [];
      for (G = 0; G < V.length - 1; G++) z.push(e.CFF.readDict(M, D + V[G], D + V[G + 1]));
      D += V[V.length - 1];
      var k = z[0], H = [];
      D = e.CFF.readIndex(M, D, H);
      var W = [];
      for (G = 0; G < H.length - 1; G++) W.push(F.readASCII(M, D + H[G], H[G + 1] - H[G]));
      if (D += H[H.length - 1], e.CFF.readSubrs(M, D, k), k.CharStrings) {
        D = k.CharStrings, H = [], D = e.CFF.readIndex(M, D, H);
        var $ = [];
        for (G = 0; G < H.length - 1; G++) $.push(F.readBytes(M, D + H[G], H[G + 1] - H[G]));
        k.CharStrings = $;
      }
      if (k.ROS) {
        D = k.FDArray;
        var j = [];
        for (D = e.CFF.readIndex(M, D, j), k.FDArray = [], G = 0; G < j.length - 1; G++) {
          var q = e.CFF.readDict(M, D + j[G], D + j[G + 1]);
          e.CFF._readFDict(M, q, W), k.FDArray.push(q);
        }
        D += j[j.length - 1], D = k.FDSelect, k.FDSelect = [];
        var Y = M[D];
        if (D++, Y != 3) throw Y;
        var J = F.readUshort(M, D);
        for (D += 2, G = 0; G < J + 1; G++) k.FDSelect.push(F.readUshort(M, D), M[D + 2]), D += 3;
      }
      return k.Encoding && (k.Encoding = e.CFF.readEncoding(M, k.Encoding, k.CharStrings.length)), k.charset && (k.charset = e.CFF.readCharset(M, k.charset, k.CharStrings.length)), e.CFF._readFDict(M, k, W), k;
    }, e.CFF._readFDict = function(M, D, I) {
      var F;
      for (var N in D.Private && (F = D.Private[1], D.Private = e.CFF.readDict(M, F, F + D.Private[0]), D.Private.Subrs && e.CFF.readSubrs(M, F + D.Private.Subrs, D.Private)), D) ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(N) != -1 && (D[N] = I[D[N] - 426 + 35]);
    }, e.CFF.readSubrs = function(M, D, I) {
      var F = e._bin, N = [];
      D = e.CFF.readIndex(M, D, N);
      var U, G = N.length;
      U = G < 1240 ? 107 : G < 33900 ? 1131 : 32768, I.Bias = U, I.Subrs = [];
      for (var V = 0; V < N.length - 1; V++) I.Subrs.push(F.readBytes(M, D + N[V], N[V + 1] - N[V]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(M, D) {
      for (var I = 0; I < M.charset.length; I++) if (M.charset[I] == D) return I;
      return -1;
    }, e.CFF.glyphBySE = function(M, D) {
      return D < 0 || D > 255 ? -1 : e.CFF.glyphByUnicode(M, e.CFF.tableSE[D]);
    }, e.CFF.readEncoding = function(M, D, I) {
      e._bin;
      var F = [".notdef"], N = M[D];
      if (D++, N != 0) throw "error: unknown encoding format: " + N;
      var U = M[D];
      D++;
      for (var G = 0; G < U; G++) F.push(M[D + G]);
      return F;
    }, e.CFF.readCharset = function(M, D, I) {
      var F = e._bin, N = [".notdef"], U = M[D];
      if (D++, U == 0) for (var G = 0; G < I; G++) {
        var V = F.readUshort(M, D);
        D += 2, N.push(V);
      }
      else {
        if (U != 1 && U != 2) throw "error: format: " + U;
        for (; N.length < I; ) {
          V = F.readUshort(M, D), D += 2;
          var z = 0;
          for (U == 1 ? (z = M[D], D++) : (z = F.readUshort(M, D), D += 2), G = 0; G <= z; G++) N.push(V), V++;
        }
      }
      return N;
    }, e.CFF.readIndex = function(M, D, I) {
      var F = e._bin, N = F.readUshort(M, D) + 1, U = M[D += 2];
      if (D++, U == 1) for (var G = 0; G < N; G++) I.push(M[D + G]);
      else if (U == 2) for (G = 0; G < N; G++) I.push(F.readUshort(M, D + 2 * G));
      else if (U == 3) for (G = 0; G < N; G++) I.push(16777215 & F.readUint(M, D + 3 * G - 1));
      else if (N != 1) throw "unsupported offset size: " + U + ", count: " + N;
      return (D += N * U) - 1;
    }, e.CFF.getCharString = function(M, D, I) {
      var F = e._bin, N = M[D], U = M[D + 1];
      M[D + 2], M[D + 3], M[D + 4];
      var G = 1, V = null, z = null;
      N <= 20 && (V = N, G = 1), N == 12 && (V = 100 * N + U, G = 2), 21 <= N && N <= 27 && (V = N, G = 1), N == 28 && (z = F.readShort(M, D + 1), G = 3), 29 <= N && N <= 31 && (V = N, G = 1), 32 <= N && N <= 246 && (z = N - 139, G = 1), 247 <= N && N <= 250 && (z = 256 * (N - 247) + U + 108, G = 2), 251 <= N && N <= 254 && (z = 256 * -(N - 251) - U - 108, G = 2), N == 255 && (z = F.readInt(M, D + 1) / 65535, G = 5), I.val = z ?? "o" + V, I.size = G;
    }, e.CFF.readCharString = function(M, D, I) {
      for (var F = D + I, N = e._bin, U = []; D < F; ) {
        var G = M[D], V = M[D + 1];
        M[D + 2], M[D + 3], M[D + 4];
        var z = 1, k = null, H = null;
        G <= 20 && (k = G, z = 1), G == 12 && (k = 100 * G + V, z = 2), G != 19 && G != 20 || (k = G, z = 2), 21 <= G && G <= 27 && (k = G, z = 1), G == 28 && (H = N.readShort(M, D + 1), z = 3), 29 <= G && G <= 31 && (k = G, z = 1), 32 <= G && G <= 246 && (H = G - 139, z = 1), 247 <= G && G <= 250 && (H = 256 * (G - 247) + V + 108, z = 2), 251 <= G && G <= 254 && (H = 256 * -(G - 251) - V - 108, z = 2), G == 255 && (H = N.readInt(M, D + 1) / 65535, z = 5), U.push(H ?? "o" + k), D += z;
      }
      return U;
    }, e.CFF.readDict = function(M, D, I) {
      for (var F = e._bin, N = {}, U = []; D < I; ) {
        var G = M[D], V = M[D + 1];
        M[D + 2], M[D + 3], M[D + 4];
        var z = 1, k = null, H = null;
        if (G == 28 && (H = F.readShort(M, D + 1), z = 3), G == 29 && (H = F.readInt(M, D + 1), z = 5), 32 <= G && G <= 246 && (H = G - 139, z = 1), 247 <= G && G <= 250 && (H = 256 * (G - 247) + V + 108, z = 2), 251 <= G && G <= 254 && (H = 256 * -(G - 251) - V - 108, z = 2), G == 255) throw H = F.readInt(M, D + 1) / 65535, z = 5, "unknown number";
        if (G == 30) {
          var W = [];
          for (z = 1; ; ) {
            var $ = M[D + z];
            z++;
            var j = $ >> 4, q = 15 & $;
            if (j != 15 && W.push(j), q != 15 && W.push(q), q == 15) break;
          }
          for (var Y = "", J = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], K = 0; K < W.length; K++) Y += J[W[K]];
          H = parseFloat(Y);
        }
        G <= 21 && (k = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][G], z = 1, G == 12 && (k = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][V], z = 2)), k != null ? (N[k] = U.length == 1 ? U[0] : U, U = []) : U.push(H), D += z;
      }
      return N;
    }, e.cmap = {}, e.cmap.parse = function(M, D, I) {
      M = new Uint8Array(M.buffer, D, I), D = 0;
      var F = e._bin, N = {};
      F.readUshort(M, D), D += 2;
      var U = F.readUshort(M, D);
      D += 2;
      var G = [];
      N.tables = [];
      for (var V = 0; V < U; V++) {
        var z = F.readUshort(M, D);
        D += 2;
        var k = F.readUshort(M, D);
        D += 2;
        var H = F.readUint(M, D);
        D += 4;
        var W = "p" + z + "e" + k, $ = G.indexOf(H);
        if ($ == -1) {
          var j;
          $ = N.tables.length, G.push(H);
          var q = F.readUshort(M, H);
          q == 0 ? j = e.cmap.parse0(M, H) : q == 4 ? j = e.cmap.parse4(M, H) : q == 6 ? j = e.cmap.parse6(M, H) : q == 12 ? j = e.cmap.parse12(M, H) : console.debug("unknown format: " + q, z, k, H), N.tables.push(j);
        }
        if (N[W] != null) throw "multiple tables for one platform+encoding";
        N[W] = $;
      }
      return N;
    }, e.cmap.parse0 = function(M, D) {
      var I = e._bin, F = {};
      F.format = I.readUshort(M, D), D += 2;
      var N = I.readUshort(M, D);
      D += 2, I.readUshort(M, D), D += 2, F.map = [];
      for (var U = 0; U < N - 6; U++) F.map.push(M[D + U]);
      return F;
    }, e.cmap.parse4 = function(M, D) {
      var I = e._bin, F = D, N = {};
      N.format = I.readUshort(M, D), D += 2;
      var U = I.readUshort(M, D);
      D += 2, I.readUshort(M, D), D += 2;
      var G = I.readUshort(M, D);
      D += 2;
      var V = G / 2;
      N.searchRange = I.readUshort(M, D), D += 2, N.entrySelector = I.readUshort(M, D), D += 2, N.rangeShift = I.readUshort(M, D), D += 2, N.endCount = I.readUshorts(M, D, V), D += 2 * V, D += 2, N.startCount = I.readUshorts(M, D, V), D += 2 * V, N.idDelta = [];
      for (var z = 0; z < V; z++) N.idDelta.push(I.readShort(M, D)), D += 2;
      for (N.idRangeOffset = I.readUshorts(M, D, V), D += 2 * V, N.glyphIdArray = []; D < F + U; ) N.glyphIdArray.push(I.readUshort(M, D)), D += 2;
      return N;
    }, e.cmap.parse6 = function(M, D) {
      var I = e._bin, F = {};
      F.format = I.readUshort(M, D), D += 2, I.readUshort(M, D), D += 2, I.readUshort(M, D), D += 2, F.firstCode = I.readUshort(M, D), D += 2;
      var N = I.readUshort(M, D);
      D += 2, F.glyphIdArray = [];
      for (var U = 0; U < N; U++) F.glyphIdArray.push(I.readUshort(M, D)), D += 2;
      return F;
    }, e.cmap.parse12 = function(M, D) {
      var I = e._bin, F = {};
      F.format = I.readUshort(M, D), D += 2, D += 2, I.readUint(M, D), D += 4, I.readUint(M, D), D += 4;
      var N = I.readUint(M, D);
      D += 4, F.groups = [];
      for (var U = 0; U < N; U++) {
        var G = D + 12 * U, V = I.readUint(M, G + 0), z = I.readUint(M, G + 4), k = I.readUint(M, G + 8);
        F.groups.push([V, z, k]);
      }
      return F;
    }, e.glyf = {}, e.glyf.parse = function(M, D, I, F) {
      for (var N = [], U = 0; U < F.maxp.numGlyphs; U++) N.push(null);
      return N;
    }, e.glyf._parseGlyf = function(M, D) {
      var I = e._bin, F = M._data, N = e._tabOffset(F, "glyf", M._offset) + M.loca[D];
      if (M.loca[D] == M.loca[D + 1]) return null;
      var U = {};
      if (U.noc = I.readShort(F, N), N += 2, U.xMin = I.readShort(F, N), N += 2, U.yMin = I.readShort(F, N), N += 2, U.xMax = I.readShort(F, N), N += 2, U.yMax = I.readShort(F, N), N += 2, U.xMin >= U.xMax || U.yMin >= U.yMax) return null;
      if (U.noc > 0) {
        U.endPts = [];
        for (var G = 0; G < U.noc; G++) U.endPts.push(I.readUshort(F, N)), N += 2;
        var V = I.readUshort(F, N);
        if (N += 2, F.length - N < V) return null;
        U.instructions = I.readBytes(F, N, V), N += V;
        var z = U.endPts[U.noc - 1] + 1;
        for (U.flags = [], G = 0; G < z; G++) {
          var k = F[N];
          if (N++, U.flags.push(k), (8 & k) != 0) {
            var H = F[N];
            N++;
            for (var W = 0; W < H; W++) U.flags.push(k), G++;
          }
        }
        for (U.xs = [], G = 0; G < z; G++) {
          var $ = (2 & U.flags[G]) != 0, j = (16 & U.flags[G]) != 0;
          $ ? (U.xs.push(j ? F[N] : -F[N]), N++) : j ? U.xs.push(0) : (U.xs.push(I.readShort(F, N)), N += 2);
        }
        for (U.ys = [], G = 0; G < z; G++)
          $ = (4 & U.flags[G]) != 0, j = (32 & U.flags[G]) != 0, $ ? (U.ys.push(j ? F[N] : -F[N]), N++) : j ? U.ys.push(0) : (U.ys.push(I.readShort(F, N)), N += 2);
        var q = 0, Y = 0;
        for (G = 0; G < z; G++) q += U.xs[G], Y += U.ys[G], U.xs[G] = q, U.ys[G] = Y;
      } else {
        var J;
        U.parts = [];
        do {
          J = I.readUshort(F, N), N += 2;
          var K = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (U.parts.push(K), K.glyphIndex = I.readUshort(F, N), N += 2, 1 & J) {
            var X = I.readShort(F, N);
            N += 2;
            var Z = I.readShort(F, N);
            N += 2;
          } else
            X = I.readInt8(F, N), N++, Z = I.readInt8(F, N), N++;
          2 & J ? (K.m.tx = X, K.m.ty = Z) : (K.p1 = X, K.p2 = Z), 8 & J ? (K.m.a = K.m.d = I.readF2dot14(F, N), N += 2) : 64 & J ? (K.m.a = I.readF2dot14(F, N), N += 2, K.m.d = I.readF2dot14(F, N), N += 2) : 128 & J && (K.m.a = I.readF2dot14(F, N), N += 2, K.m.b = I.readF2dot14(F, N), N += 2, K.m.c = I.readF2dot14(F, N), N += 2, K.m.d = I.readF2dot14(F, N), N += 2);
        } while (32 & J);
        if (256 & J) {
          var Q = I.readUshort(F, N);
          for (N += 2, U.instr = [], G = 0; G < Q; G++) U.instr.push(F[N]), N++;
        }
      }
      return U;
    }, e.GDEF = {}, e.GDEF.parse = function(M, D, I, F) {
      var N = D;
      D += 4;
      var U = e._bin.readUshort(M, D);
      return { glyphClassDef: U === 0 ? null : e._lctf.readClassDef(M, N + U) };
    }, e.GPOS = {}, e.GPOS.parse = function(M, D, I, F) {
      return e._lctf.parse(M, D, I, F, e.GPOS.subt);
    }, e.GPOS.subt = function(M, D, I, F) {
      var N = e._bin, U = I, G = {};
      if (G.fmt = N.readUshort(M, I), I += 2, D == 1 || D == 2 || D == 3 || D == 7 || D == 8 && G.fmt <= 2) {
        var V = N.readUshort(M, I);
        I += 2, G.coverage = e._lctf.readCoverage(M, V + U);
      }
      if (D == 1 && G.fmt == 1) {
        var z = N.readUshort(M, I);
        I += 2, z != 0 && (G.pos = e.GPOS.readValueRecord(M, I, z));
      } else if (D == 2 && G.fmt >= 1 && G.fmt <= 2) {
        z = N.readUshort(M, I), I += 2;
        var k = N.readUshort(M, I);
        I += 2;
        var H = e._lctf.numOfOnes(z), W = e._lctf.numOfOnes(k);
        if (G.fmt == 1) {
          G.pairsets = [];
          var $ = N.readUshort(M, I);
          I += 2;
          for (var j = 0; j < $; j++) {
            var q = U + N.readUshort(M, I);
            I += 2;
            var Y = N.readUshort(M, q);
            q += 2;
            for (var J = [], K = 0; K < Y; K++) {
              var X = N.readUshort(M, q);
              q += 2, z != 0 && (ue = e.GPOS.readValueRecord(M, q, z), q += 2 * H), k != 0 && (oe = e.GPOS.readValueRecord(M, q, k), q += 2 * W), J.push({ gid2: X, val1: ue, val2: oe });
            }
            G.pairsets.push(J);
          }
        }
        if (G.fmt == 2) {
          var Z = N.readUshort(M, I);
          I += 2;
          var Q = N.readUshort(M, I);
          I += 2;
          var ne = N.readUshort(M, I);
          I += 2;
          var le = N.readUshort(M, I);
          for (I += 2, G.classDef1 = e._lctf.readClassDef(M, U + Z), G.classDef2 = e._lctf.readClassDef(M, U + Q), G.matrix = [], j = 0; j < ne; j++) {
            var pe = [];
            for (K = 0; K < le; K++) {
              var ue = null, oe = null;
              z != 0 && (ue = e.GPOS.readValueRecord(M, I, z), I += 2 * H), k != 0 && (oe = e.GPOS.readValueRecord(M, I, k), I += 2 * W), pe.push({ val1: ue, val2: oe });
            }
            G.matrix.push(pe);
          }
        }
      } else if (D == 4 && G.fmt == 1) G.markCoverage = e._lctf.readCoverage(M, N.readUshort(M, I) + U), G.baseCoverage = e._lctf.readCoverage(M, N.readUshort(M, I + 2) + U), G.markClassCount = N.readUshort(M, I + 4), G.markArray = e.GPOS.readMarkArray(M, N.readUshort(M, I + 6) + U), G.baseArray = e.GPOS.readBaseArray(M, N.readUshort(M, I + 8) + U, G.markClassCount);
      else if (D == 6 && G.fmt == 1) G.mark1Coverage = e._lctf.readCoverage(M, N.readUshort(M, I) + U), G.mark2Coverage = e._lctf.readCoverage(M, N.readUshort(M, I + 2) + U), G.markClassCount = N.readUshort(M, I + 4), G.mark1Array = e.GPOS.readMarkArray(M, N.readUshort(M, I + 6) + U), G.mark2Array = e.GPOS.readBaseArray(M, N.readUshort(M, I + 8) + U, G.markClassCount);
      else {
        if (D == 9 && G.fmt == 1) {
          var ae = N.readUshort(M, I);
          I += 2;
          var se = N.readUint(M, I);
          if (I += 4, F.ltype == 9) F.ltype = ae;
          else if (F.ltype != ae) throw "invalid extension substitution";
          return e.GPOS.subt(M, F.ltype, U + se);
        }
        console.debug("unsupported GPOS table LookupType", D, "format", G.fmt);
      }
      return G;
    }, e.GPOS.readValueRecord = function(M, D, I) {
      var F = e._bin, N = [];
      return N.push(1 & I ? F.readShort(M, D) : 0), D += 1 & I ? 2 : 0, N.push(2 & I ? F.readShort(M, D) : 0), D += 2 & I ? 2 : 0, N.push(4 & I ? F.readShort(M, D) : 0), D += 4 & I ? 2 : 0, N.push(8 & I ? F.readShort(M, D) : 0), D += 8 & I ? 2 : 0, N;
    }, e.GPOS.readBaseArray = function(M, D, I) {
      var F = e._bin, N = [], U = D, G = F.readUshort(M, D);
      D += 2;
      for (var V = 0; V < G; V++) {
        for (var z = [], k = 0; k < I; k++) z.push(e.GPOS.readAnchorRecord(M, U + F.readUshort(M, D))), D += 2;
        N.push(z);
      }
      return N;
    }, e.GPOS.readMarkArray = function(M, D) {
      var I = e._bin, F = [], N = D, U = I.readUshort(M, D);
      D += 2;
      for (var G = 0; G < U; G++) {
        var V = e.GPOS.readAnchorRecord(M, I.readUshort(M, D + 2) + N);
        V.markClass = I.readUshort(M, D), F.push(V), D += 4;
      }
      return F;
    }, e.GPOS.readAnchorRecord = function(M, D) {
      var I = e._bin, F = {};
      return F.fmt = I.readUshort(M, D), F.x = I.readShort(M, D + 2), F.y = I.readShort(M, D + 4), F;
    }, e.GSUB = {}, e.GSUB.parse = function(M, D, I, F) {
      return e._lctf.parse(M, D, I, F, e.GSUB.subt);
    }, e.GSUB.subt = function(M, D, I, F) {
      var N = e._bin, U = I, G = {};
      if (G.fmt = N.readUshort(M, I), I += 2, D != 1 && D != 2 && D != 4 && D != 5 && D != 6) return null;
      if (D == 1 || D == 2 || D == 4 || D == 5 && G.fmt <= 2 || D == 6 && G.fmt <= 2) {
        var V = N.readUshort(M, I);
        I += 2, G.coverage = e._lctf.readCoverage(M, U + V);
      }
      if (D == 1 && G.fmt >= 1 && G.fmt <= 2) {
        if (G.fmt == 1) G.delta = N.readShort(M, I), I += 2;
        else if (G.fmt == 2) {
          var z = N.readUshort(M, I);
          I += 2, G.newg = N.readUshorts(M, I, z), I += 2 * G.newg.length;
        }
      } else if (D == 2 && G.fmt == 1) {
        z = N.readUshort(M, I), I += 2, G.seqs = [];
        for (var k = 0; k < z; k++) {
          var H = N.readUshort(M, I) + U;
          I += 2;
          var W = N.readUshort(M, H);
          G.seqs.push(N.readUshorts(M, H + 2, W));
        }
      } else if (D == 4)
        for (G.vals = [], z = N.readUshort(M, I), I += 2, k = 0; k < z; k++) {
          var $ = N.readUshort(M, I);
          I += 2, G.vals.push(e.GSUB.readLigatureSet(M, U + $));
        }
      else if (D == 5 && G.fmt == 2) {
        if (G.fmt == 2) {
          var j = N.readUshort(M, I);
          I += 2, G.cDef = e._lctf.readClassDef(M, U + j), G.scset = [];
          var q = N.readUshort(M, I);
          for (I += 2, k = 0; k < q; k++) {
            var Y = N.readUshort(M, I);
            I += 2, G.scset.push(Y == 0 ? null : e.GSUB.readSubClassSet(M, U + Y));
          }
        }
      } else if (D == 6 && G.fmt == 3) {
        if (G.fmt == 3) {
          for (k = 0; k < 3; k++) {
            z = N.readUshort(M, I), I += 2;
            for (var J = [], K = 0; K < z; K++) J.push(e._lctf.readCoverage(M, U + N.readUshort(M, I + 2 * K)));
            I += 2 * z, k == 0 && (G.backCvg = J), k == 1 && (G.inptCvg = J), k == 2 && (G.ahedCvg = J);
          }
          z = N.readUshort(M, I), I += 2, G.lookupRec = e.GSUB.readSubstLookupRecords(M, I, z);
        }
      } else {
        if (D == 7 && G.fmt == 1) {
          var X = N.readUshort(M, I);
          I += 2;
          var Z = N.readUint(M, I);
          if (I += 4, F.ltype == 9) F.ltype = X;
          else if (F.ltype != X) throw "invalid extension substitution";
          return e.GSUB.subt(M, F.ltype, U + Z);
        }
        console.debug("unsupported GSUB table LookupType", D, "format", G.fmt);
      }
      return G;
    }, e.GSUB.readSubClassSet = function(M, D) {
      var I = e._bin.readUshort, F = D, N = [], U = I(M, D);
      D += 2;
      for (var G = 0; G < U; G++) {
        var V = I(M, D);
        D += 2, N.push(e.GSUB.readSubClassRule(M, F + V));
      }
      return N;
    }, e.GSUB.readSubClassRule = function(M, D) {
      var I = e._bin.readUshort, F = {}, N = I(M, D), U = I(M, D += 2);
      D += 2, F.input = [];
      for (var G = 0; G < N - 1; G++) F.input.push(I(M, D)), D += 2;
      return F.substLookupRecords = e.GSUB.readSubstLookupRecords(M, D, U), F;
    }, e.GSUB.readSubstLookupRecords = function(M, D, I) {
      for (var F = e._bin.readUshort, N = [], U = 0; U < I; U++) N.push(F(M, D), F(M, D + 2)), D += 4;
      return N;
    }, e.GSUB.readChainSubClassSet = function(M, D) {
      var I = e._bin, F = D, N = [], U = I.readUshort(M, D);
      D += 2;
      for (var G = 0; G < U; G++) {
        var V = I.readUshort(M, D);
        D += 2, N.push(e.GSUB.readChainSubClassRule(M, F + V));
      }
      return N;
    }, e.GSUB.readChainSubClassRule = function(M, D) {
      for (var I = e._bin, F = {}, N = ["backtrack", "input", "lookahead"], U = 0; U < N.length; U++) {
        var G = I.readUshort(M, D);
        D += 2, U == 1 && G--, F[N[U]] = I.readUshorts(M, D, G), D += 2 * F[N[U]].length;
      }
      return G = I.readUshort(M, D), D += 2, F.subst = I.readUshorts(M, D, 2 * G), D += 2 * F.subst.length, F;
    }, e.GSUB.readLigatureSet = function(M, D) {
      var I = e._bin, F = D, N = [], U = I.readUshort(M, D);
      D += 2;
      for (var G = 0; G < U; G++) {
        var V = I.readUshort(M, D);
        D += 2, N.push(e.GSUB.readLigature(M, F + V));
      }
      return N;
    }, e.GSUB.readLigature = function(M, D) {
      var I = e._bin, F = { chain: [] };
      F.nglyph = I.readUshort(M, D), D += 2;
      var N = I.readUshort(M, D);
      D += 2;
      for (var U = 0; U < N - 1; U++) F.chain.push(I.readUshort(M, D)), D += 2;
      return F;
    }, e.head = {}, e.head.parse = function(M, D, I) {
      var F = e._bin, N = {};
      return F.readFixed(M, D), D += 4, N.fontRevision = F.readFixed(M, D), D += 4, F.readUint(M, D), D += 4, F.readUint(M, D), D += 4, N.flags = F.readUshort(M, D), D += 2, N.unitsPerEm = F.readUshort(M, D), D += 2, N.created = F.readUint64(M, D), D += 8, N.modified = F.readUint64(M, D), D += 8, N.xMin = F.readShort(M, D), D += 2, N.yMin = F.readShort(M, D), D += 2, N.xMax = F.readShort(M, D), D += 2, N.yMax = F.readShort(M, D), D += 2, N.macStyle = F.readUshort(M, D), D += 2, N.lowestRecPPEM = F.readUshort(M, D), D += 2, N.fontDirectionHint = F.readShort(M, D), D += 2, N.indexToLocFormat = F.readShort(M, D), D += 2, N.glyphDataFormat = F.readShort(M, D), D += 2, N;
    }, e.hhea = {}, e.hhea.parse = function(M, D, I) {
      var F = e._bin, N = {};
      return F.readFixed(M, D), D += 4, N.ascender = F.readShort(M, D), D += 2, N.descender = F.readShort(M, D), D += 2, N.lineGap = F.readShort(M, D), D += 2, N.advanceWidthMax = F.readUshort(M, D), D += 2, N.minLeftSideBearing = F.readShort(M, D), D += 2, N.minRightSideBearing = F.readShort(M, D), D += 2, N.xMaxExtent = F.readShort(M, D), D += 2, N.caretSlopeRise = F.readShort(M, D), D += 2, N.caretSlopeRun = F.readShort(M, D), D += 2, N.caretOffset = F.readShort(M, D), D += 2, D += 8, N.metricDataFormat = F.readShort(M, D), D += 2, N.numberOfHMetrics = F.readUshort(M, D), D += 2, N;
    }, e.hmtx = {}, e.hmtx.parse = function(M, D, I, F) {
      for (var N = e._bin, U = { aWidth: [], lsBearing: [] }, G = 0, V = 0, z = 0; z < F.maxp.numGlyphs; z++) z < F.hhea.numberOfHMetrics && (G = N.readUshort(M, D), D += 2, V = N.readShort(M, D), D += 2), U.aWidth.push(G), U.lsBearing.push(V);
      return U;
    }, e.kern = {}, e.kern.parse = function(M, D, I, F) {
      var N = e._bin, U = N.readUshort(M, D);
      if (D += 2, U == 1) return e.kern.parseV1(M, D - 2, I, F);
      var G = N.readUshort(M, D);
      D += 2;
      for (var V = { glyph1: [], rval: [] }, z = 0; z < G; z++) {
        D += 2, I = N.readUshort(M, D), D += 2;
        var k = N.readUshort(M, D);
        D += 2;
        var H = k >>> 8;
        if ((H &= 15) != 0) throw "unknown kern table format: " + H;
        D = e.kern.readFormat0(M, D, V);
      }
      return V;
    }, e.kern.parseV1 = function(M, D, I, F) {
      var N = e._bin;
      N.readFixed(M, D), D += 4;
      var U = N.readUint(M, D);
      D += 4;
      for (var G = { glyph1: [], rval: [] }, V = 0; V < U; V++) {
        N.readUint(M, D), D += 4;
        var z = N.readUshort(M, D);
        D += 2, N.readUshort(M, D), D += 2;
        var k = z >>> 8;
        if ((k &= 15) != 0) throw "unknown kern table format: " + k;
        D = e.kern.readFormat0(M, D, G);
      }
      return G;
    }, e.kern.readFormat0 = function(M, D, I) {
      var F = e._bin, N = -1, U = F.readUshort(M, D);
      D += 2, F.readUshort(M, D), D += 2, F.readUshort(M, D), D += 2, F.readUshort(M, D), D += 2;
      for (var G = 0; G < U; G++) {
        var V = F.readUshort(M, D);
        D += 2;
        var z = F.readUshort(M, D);
        D += 2;
        var k = F.readShort(M, D);
        D += 2, V != N && (I.glyph1.push(V), I.rval.push({ glyph2: [], vals: [] }));
        var H = I.rval[I.rval.length - 1];
        H.glyph2.push(z), H.vals.push(k), N = V;
      }
      return D;
    }, e.loca = {}, e.loca.parse = function(M, D, I, F) {
      var N = e._bin, U = [], G = F.head.indexToLocFormat, V = F.maxp.numGlyphs + 1;
      if (G == 0) for (var z = 0; z < V; z++) U.push(N.readUshort(M, D + (z << 1)) << 1);
      if (G == 1) for (z = 0; z < V; z++) U.push(N.readUint(M, D + (z << 2)));
      return U;
    }, e.maxp = {}, e.maxp.parse = function(M, D, I) {
      var F = e._bin, N = {}, U = F.readUint(M, D);
      return D += 4, N.numGlyphs = F.readUshort(M, D), D += 2, U == 65536 && (N.maxPoints = F.readUshort(M, D), D += 2, N.maxContours = F.readUshort(M, D), D += 2, N.maxCompositePoints = F.readUshort(M, D), D += 2, N.maxCompositeContours = F.readUshort(M, D), D += 2, N.maxZones = F.readUshort(M, D), D += 2, N.maxTwilightPoints = F.readUshort(M, D), D += 2, N.maxStorage = F.readUshort(M, D), D += 2, N.maxFunctionDefs = F.readUshort(M, D), D += 2, N.maxInstructionDefs = F.readUshort(M, D), D += 2, N.maxStackElements = F.readUshort(M, D), D += 2, N.maxSizeOfInstructions = F.readUshort(M, D), D += 2, N.maxComponentElements = F.readUshort(M, D), D += 2, N.maxComponentDepth = F.readUshort(M, D), D += 2), N;
    }, e.name = {}, e.name.parse = function(M, D, I) {
      var F = e._bin, N = {};
      F.readUshort(M, D), D += 2;
      var U = F.readUshort(M, D);
      D += 2, F.readUshort(M, D);
      for (var G, V = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], z = D += 2, k = 0; k < U; k++) {
        var H = F.readUshort(M, D);
        D += 2;
        var W = F.readUshort(M, D);
        D += 2;
        var $ = F.readUshort(M, D);
        D += 2;
        var j = F.readUshort(M, D);
        D += 2;
        var q = F.readUshort(M, D);
        D += 2;
        var Y = F.readUshort(M, D);
        D += 2;
        var J, K = V[j], X = z + 12 * U + Y;
        if (H == 0) J = F.readUnicode(M, X, q / 2);
        else if (H == 3 && W == 0) J = F.readUnicode(M, X, q / 2);
        else if (W == 0) J = F.readASCII(M, X, q);
        else if (W == 1) J = F.readUnicode(M, X, q / 2);
        else if (W == 3) J = F.readUnicode(M, X, q / 2);
        else {
          if (H != 1) throw "unknown encoding " + W + ", platformID: " + H;
          J = F.readASCII(M, X, q), console.debug("reading unknown MAC encoding " + W + " as ASCII");
        }
        var Z = "p" + H + "," + $.toString(16);
        N[Z] == null && (N[Z] = {}), N[Z][K !== void 0 ? K : j] = J, N[Z]._lang = $;
      }
      for (var Q in N) if (N[Q].postScriptName != null && N[Q]._lang == 1033) return N[Q];
      for (var Q in N) if (N[Q].postScriptName != null && N[Q]._lang == 0) return N[Q];
      for (var Q in N) if (N[Q].postScriptName != null && N[Q]._lang == 3084) return N[Q];
      for (var Q in N) if (N[Q].postScriptName != null) return N[Q];
      for (var Q in N) {
        G = Q;
        break;
      }
      return console.debug("returning name table with languageID " + N[G]._lang), N[G];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(M, D, I) {
      var F = e._bin.readUshort(M, D);
      D += 2;
      var N = {};
      if (F == 0) e["OS/2"].version0(M, D, N);
      else if (F == 1) e["OS/2"].version1(M, D, N);
      else if (F == 2 || F == 3 || F == 4) e["OS/2"].version2(M, D, N);
      else {
        if (F != 5) throw "unknown OS/2 table version: " + F;
        e["OS/2"].version5(M, D, N);
      }
      return N;
    }, e["OS/2"].version0 = function(M, D, I) {
      var F = e._bin;
      return I.xAvgCharWidth = F.readShort(M, D), D += 2, I.usWeightClass = F.readUshort(M, D), D += 2, I.usWidthClass = F.readUshort(M, D), D += 2, I.fsType = F.readUshort(M, D), D += 2, I.ySubscriptXSize = F.readShort(M, D), D += 2, I.ySubscriptYSize = F.readShort(M, D), D += 2, I.ySubscriptXOffset = F.readShort(M, D), D += 2, I.ySubscriptYOffset = F.readShort(M, D), D += 2, I.ySuperscriptXSize = F.readShort(M, D), D += 2, I.ySuperscriptYSize = F.readShort(M, D), D += 2, I.ySuperscriptXOffset = F.readShort(M, D), D += 2, I.ySuperscriptYOffset = F.readShort(M, D), D += 2, I.yStrikeoutSize = F.readShort(M, D), D += 2, I.yStrikeoutPosition = F.readShort(M, D), D += 2, I.sFamilyClass = F.readShort(M, D), D += 2, I.panose = F.readBytes(M, D, 10), D += 10, I.ulUnicodeRange1 = F.readUint(M, D), D += 4, I.ulUnicodeRange2 = F.readUint(M, D), D += 4, I.ulUnicodeRange3 = F.readUint(M, D), D += 4, I.ulUnicodeRange4 = F.readUint(M, D), D += 4, I.achVendID = [F.readInt8(M, D), F.readInt8(M, D + 1), F.readInt8(M, D + 2), F.readInt8(M, D + 3)], D += 4, I.fsSelection = F.readUshort(M, D), D += 2, I.usFirstCharIndex = F.readUshort(M, D), D += 2, I.usLastCharIndex = F.readUshort(M, D), D += 2, I.sTypoAscender = F.readShort(M, D), D += 2, I.sTypoDescender = F.readShort(M, D), D += 2, I.sTypoLineGap = F.readShort(M, D), D += 2, I.usWinAscent = F.readUshort(M, D), D += 2, I.usWinDescent = F.readUshort(M, D), D += 2;
    }, e["OS/2"].version1 = function(M, D, I) {
      var F = e._bin;
      return D = e["OS/2"].version0(M, D, I), I.ulCodePageRange1 = F.readUint(M, D), D += 4, I.ulCodePageRange2 = F.readUint(M, D), D += 4;
    }, e["OS/2"].version2 = function(M, D, I) {
      var F = e._bin;
      return D = e["OS/2"].version1(M, D, I), I.sxHeight = F.readShort(M, D), D += 2, I.sCapHeight = F.readShort(M, D), D += 2, I.usDefault = F.readUshort(M, D), D += 2, I.usBreak = F.readUshort(M, D), D += 2, I.usMaxContext = F.readUshort(M, D), D += 2;
    }, e["OS/2"].version5 = function(M, D, I) {
      var F = e._bin;
      return D = e["OS/2"].version2(M, D, I), I.usLowerOpticalPointSize = F.readUshort(M, D), D += 2, I.usUpperOpticalPointSize = F.readUshort(M, D), D += 2;
    }, e.post = {}, e.post.parse = function(M, D, I) {
      var F = e._bin, N = {};
      return N.version = F.readFixed(M, D), D += 4, N.italicAngle = F.readFixed(M, D), D += 4, N.underlinePosition = F.readShort(M, D), D += 2, N.underlineThickness = F.readShort(M, D), D += 2, N;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(M, D) {
      var I = M.cmap, F = -1;
      if (I.p0e4 != null ? F = I.p0e4 : I.p3e1 != null ? F = I.p3e1 : I.p1e0 != null ? F = I.p1e0 : I.p0e3 != null && (F = I.p0e3), F == -1) throw "no familiar platform and encoding!";
      var N = I.tables[F];
      if (N.format == 0) return D >= N.map.length ? 0 : N.map[D];
      if (N.format == 4) {
        for (var U = -1, G = 0; G < N.endCount.length; G++) if (D <= N.endCount[G]) {
          U = G;
          break;
        }
        return U == -1 || N.startCount[U] > D ? 0 : 65535 & (N.idRangeOffset[U] != 0 ? N.glyphIdArray[D - N.startCount[U] + (N.idRangeOffset[U] >> 1) - (N.idRangeOffset.length - U)] : D + N.idDelta[U]);
      }
      if (N.format == 12) {
        if (D > N.groups[N.groups.length - 1][1]) return 0;
        for (G = 0; G < N.groups.length; G++) {
          var V = N.groups[G];
          if (V[0] <= D && D <= V[1]) return V[2] + (D - V[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + N.format;
    }, e.U.glyphToPath = function(M, D) {
      var I = { cmds: [], crds: [] };
      if (M.SVG && M.SVG.entries[D]) {
        var F = M.SVG.entries[D];
        return F == null ? I : (typeof F == "string" && (F = e.SVG.toPath(F), M.SVG.entries[D] = F), F);
      }
      if (M.CFF) {
        var N = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: M.CFF.Private ? M.CFF.Private.defaultWidthX : 0, open: !1 }, U = M.CFF, G = M.CFF.Private;
        if (U.ROS) {
          for (var V = 0; U.FDSelect[V + 2] <= D; ) V += 2;
          G = U.FDArray[U.FDSelect[V + 1]].Private;
        }
        e.U._drawCFF(M.CFF.CharStrings[D], N, U, G, I);
      } else M.glyf && e.U._drawGlyf(D, M, I);
      return I;
    }, e.U._drawGlyf = function(M, D, I) {
      var F = D.glyf[M];
      F == null && (F = D.glyf[M] = e.glyf._parseGlyf(D, M)), F != null && (F.noc > -1 ? e.U._simpleGlyph(F, I) : e.U._compoGlyph(F, D, I));
    }, e.U._simpleGlyph = function(M, D) {
      for (var I = 0; I < M.noc; I++) {
        for (var F = I == 0 ? 0 : M.endPts[I - 1] + 1, N = M.endPts[I], U = F; U <= N; U++) {
          var G = U == F ? N : U - 1, V = U == N ? F : U + 1, z = 1 & M.flags[U], k = 1 & M.flags[G], H = 1 & M.flags[V], W = M.xs[U], $ = M.ys[U];
          if (U == F) if (z) {
            if (!k) {
              e.U.P.moveTo(D, W, $);
              continue;
            }
            e.U.P.moveTo(D, M.xs[G], M.ys[G]);
          } else k ? e.U.P.moveTo(D, M.xs[G], M.ys[G]) : e.U.P.moveTo(D, (M.xs[G] + W) / 2, (M.ys[G] + $) / 2);
          z ? k && e.U.P.lineTo(D, W, $) : H ? e.U.P.qcurveTo(D, W, $, M.xs[V], M.ys[V]) : e.U.P.qcurveTo(D, W, $, (W + M.xs[V]) / 2, ($ + M.ys[V]) / 2);
        }
        e.U.P.closePath(D);
      }
    }, e.U._compoGlyph = function(M, D, I) {
      for (var F = 0; F < M.parts.length; F++) {
        var N = { cmds: [], crds: [] }, U = M.parts[F];
        e.U._drawGlyf(U.glyphIndex, D, N);
        for (var G = U.m, V = 0; V < N.crds.length; V += 2) {
          var z = N.crds[V], k = N.crds[V + 1];
          I.crds.push(z * G.a + k * G.b + G.tx), I.crds.push(z * G.c + k * G.d + G.ty);
        }
        for (V = 0; V < N.cmds.length; V++) I.cmds.push(N.cmds[V]);
      }
    }, e.U._getGlyphClass = function(M, D) {
      var I = e._lctf.getInterval(D, M);
      return I == -1 ? 0 : D[I + 2];
    }, e.U._applySubs = function(M, D, I, F) {
      for (var N = M.length - D - 1, U = 0; U < I.tabs.length; U++) if (I.tabs[U] != null) {
        var G, V = I.tabs[U];
        if (!V.coverage || (G = e._lctf.coverageIndex(V.coverage, M[D])) != -1) {
          if (I.ltype == 1) M[D], V.fmt == 1 ? M[D] = M[D] + V.delta : M[D] = V.newg[G];
          else if (I.ltype == 4) for (var z = V.vals[G], k = 0; k < z.length; k++) {
            var H = z[k], W = H.chain.length;
            if (!(W > N)) {
              for (var $ = !0, j = 0, q = 0; q < W; q++) {
                for (; M[D + j + (1 + q)] == -1; ) j++;
                H.chain[q] != M[D + j + (1 + q)] && ($ = !1);
              }
              if ($) {
                for (M[D] = H.nglyph, q = 0; q < W + j; q++) M[D + q + 1] = -1;
                break;
              }
            }
          }
          else if (I.ltype == 5 && V.fmt == 2) for (var Y = e._lctf.getInterval(V.cDef, M[D]), J = V.cDef[Y + 2], K = V.scset[J], X = 0; X < K.length; X++) {
            var Z = K[X], Q = Z.input;
            if (!(Q.length > N)) {
              for ($ = !0, q = 0; q < Q.length; q++) {
                var ne = e._lctf.getInterval(V.cDef, M[D + 1 + q]);
                if (Y == -1 && V.cDef[ne + 2] != Q[q]) {
                  $ = !1;
                  break;
                }
              }
              if ($) {
                var le = Z.substLookupRecords;
                for (k = 0; k < le.length; k += 2) le[k], le[k + 1];
              }
            }
          }
          else if (I.ltype == 6 && V.fmt == 3) {
            if (!e.U._glsCovered(M, V.backCvg, D - V.backCvg.length) || !e.U._glsCovered(M, V.inptCvg, D) || !e.U._glsCovered(M, V.ahedCvg, D + V.inptCvg.length)) continue;
            var pe = V.lookupRec;
            for (X = 0; X < pe.length; X += 2) {
              Y = pe[X];
              var ue = F[pe[X + 1]];
              e.U._applySubs(M, D + Y, ue, F);
            }
          }
        }
      }
    }, e.U._glsCovered = function(M, D, I) {
      for (var F = 0; F < D.length; F++)
        if (e._lctf.coverageIndex(D[F], M[I + F]) == -1) return !1;
      return !0;
    }, e.U.glyphsToPath = function(M, D, I) {
      for (var F = { cmds: [], crds: [] }, N = 0, U = 0; U < D.length; U++) {
        var G = D[U];
        if (G != -1) {
          for (var V = U < D.length - 1 && D[U + 1] != -1 ? D[U + 1] : 0, z = e.U.glyphToPath(M, G), k = 0; k < z.crds.length; k += 2) F.crds.push(z.crds[k] + N), F.crds.push(z.crds[k + 1]);
          for (I && F.cmds.push(I), k = 0; k < z.cmds.length; k++) F.cmds.push(z.cmds[k]);
          I && F.cmds.push("X"), N += M.hmtx.aWidth[G], U < D.length - 1 && (N += e.U.getPairAdjustment(M, G, V));
        }
      }
      return F;
    }, e.U.P = {}, e.U.P.moveTo = function(M, D, I) {
      M.cmds.push("M"), M.crds.push(D, I);
    }, e.U.P.lineTo = function(M, D, I) {
      M.cmds.push("L"), M.crds.push(D, I);
    }, e.U.P.curveTo = function(M, D, I, F, N, U, G) {
      M.cmds.push("C"), M.crds.push(D, I, F, N, U, G);
    }, e.U.P.qcurveTo = function(M, D, I, F, N) {
      M.cmds.push("Q"), M.crds.push(D, I, F, N);
    }, e.U.P.closePath = function(M) {
      M.cmds.push("Z");
    }, e.U._drawCFF = function(M, D, I, F, N) {
      for (var U = D.stack, G = D.nStems, V = D.haveWidth, z = D.width, k = D.open, H = 0, W = D.x, $ = D.y, j = 0, q = 0, Y = 0, J = 0, K = 0, X = 0, Z = 0, Q = 0, ne = 0, le = 0, pe = { val: 0, size: 0 }; H < M.length; ) {
        e.CFF.getCharString(M, H, pe);
        var ue = pe.val;
        if (H += pe.size, ue == "o1" || ue == "o18") U.length % 2 != 0 && !V && (z = U.shift() + F.nominalWidthX), G += U.length >> 1, U.length = 0, V = !0;
        else if (ue == "o3" || ue == "o23")
          U.length % 2 != 0 && !V && (z = U.shift() + F.nominalWidthX), G += U.length >> 1, U.length = 0, V = !0;
        else if (ue == "o4") U.length > 1 && !V && (z = U.shift() + F.nominalWidthX, V = !0), k && e.U.P.closePath(N), $ += U.pop(), e.U.P.moveTo(N, W, $), k = !0;
        else if (ue == "o5") for (; U.length > 0; ) W += U.shift(), $ += U.shift(), e.U.P.lineTo(N, W, $);
        else if (ue == "o6" || ue == "o7") for (var oe = U.length, ae = ue == "o6", se = 0; se < oe; se++) {
          var ie = U.shift();
          ae ? W += ie : $ += ie, ae = !ae, e.U.P.lineTo(N, W, $);
        }
        else if (ue == "o8" || ue == "o24") {
          oe = U.length;
          for (var ye = 0; ye + 6 <= oe; ) j = W + U.shift(), q = $ + U.shift(), Y = j + U.shift(), J = q + U.shift(), W = Y + U.shift(), $ = J + U.shift(), e.U.P.curveTo(N, j, q, Y, J, W, $), ye += 6;
          ue == "o24" && (W += U.shift(), $ += U.shift(), e.U.P.lineTo(N, W, $));
        } else {
          if (ue == "o11") break;
          if (ue == "o1234" || ue == "o1235" || ue == "o1236" || ue == "o1237") ue == "o1234" && (q = $, Y = (j = W + U.shift()) + U.shift(), le = J = q + U.shift(), X = J, Q = $, W = (Z = (K = (ne = Y + U.shift()) + U.shift()) + U.shift()) + U.shift(), e.U.P.curveTo(N, j, q, Y, J, ne, le), e.U.P.curveTo(N, K, X, Z, Q, W, $)), ue == "o1235" && (j = W + U.shift(), q = $ + U.shift(), Y = j + U.shift(), J = q + U.shift(), ne = Y + U.shift(), le = J + U.shift(), K = ne + U.shift(), X = le + U.shift(), Z = K + U.shift(), Q = X + U.shift(), W = Z + U.shift(), $ = Q + U.shift(), U.shift(), e.U.P.curveTo(N, j, q, Y, J, ne, le), e.U.P.curveTo(N, K, X, Z, Q, W, $)), ue == "o1236" && (j = W + U.shift(), q = $ + U.shift(), Y = j + U.shift(), le = J = q + U.shift(), X = J, Z = (K = (ne = Y + U.shift()) + U.shift()) + U.shift(), Q = X + U.shift(), W = Z + U.shift(), e.U.P.curveTo(N, j, q, Y, J, ne, le), e.U.P.curveTo(N, K, X, Z, Q, W, $)), ue == "o1237" && (j = W + U.shift(), q = $ + U.shift(), Y = j + U.shift(), J = q + U.shift(), ne = Y + U.shift(), le = J + U.shift(), K = ne + U.shift(), X = le + U.shift(), Z = K + U.shift(), Q = X + U.shift(), Math.abs(Z - W) > Math.abs(Q - $) ? W = Z + U.shift() : $ = Q + U.shift(), e.U.P.curveTo(N, j, q, Y, J, ne, le), e.U.P.curveTo(N, K, X, Z, Q, W, $));
          else if (ue == "o14") {
            if (U.length > 0 && !V && (z = U.shift() + I.nominalWidthX, V = !0), U.length == 4) {
              var Ce = U.shift(), de = U.shift(), ve = U.shift(), ce = U.shift(), ge = e.CFF.glyphBySE(I, ve), _e = e.CFF.glyphBySE(I, ce);
              e.U._drawCFF(I.CharStrings[ge], D, I, F, N), D.x = Ce, D.y = de, e.U._drawCFF(I.CharStrings[_e], D, I, F, N);
            }
            k && (e.U.P.closePath(N), k = !1);
          } else if (ue == "o19" || ue == "o20")
            U.length % 2 != 0 && !V && (z = U.shift() + F.nominalWidthX), G += U.length >> 1, U.length = 0, V = !0, H += G + 7 >> 3;
          else if (ue == "o21") U.length > 2 && !V && (z = U.shift() + F.nominalWidthX, V = !0), $ += U.pop(), W += U.pop(), k && e.U.P.closePath(N), e.U.P.moveTo(N, W, $), k = !0;
          else if (ue == "o22") U.length > 1 && !V && (z = U.shift() + F.nominalWidthX, V = !0), W += U.pop(), k && e.U.P.closePath(N), e.U.P.moveTo(N, W, $), k = !0;
          else if (ue == "o25") {
            for (; U.length > 6; ) W += U.shift(), $ += U.shift(), e.U.P.lineTo(N, W, $);
            j = W + U.shift(), q = $ + U.shift(), Y = j + U.shift(), J = q + U.shift(), W = Y + U.shift(), $ = J + U.shift(), e.U.P.curveTo(N, j, q, Y, J, W, $);
          } else if (ue == "o26") for (U.length % 2 && (W += U.shift()); U.length > 0; ) j = W, q = $ + U.shift(), W = Y = j + U.shift(), $ = (J = q + U.shift()) + U.shift(), e.U.P.curveTo(N, j, q, Y, J, W, $);
          else if (ue == "o27") for (U.length % 2 && ($ += U.shift()); U.length > 0; ) q = $, Y = (j = W + U.shift()) + U.shift(), J = q + U.shift(), W = Y + U.shift(), $ = J, e.U.P.curveTo(N, j, q, Y, J, W, $);
          else if (ue == "o10" || ue == "o29") {
            var Me = ue == "o10" ? F : I;
            if (U.length == 0) console.debug("error: empty stack");
            else {
              var xe = U.pop(), fe = Me.Subrs[xe + Me.Bias];
              D.x = W, D.y = $, D.nStems = G, D.haveWidth = V, D.width = z, D.open = k, e.U._drawCFF(fe, D, I, F, N), W = D.x, $ = D.y, G = D.nStems, V = D.haveWidth, z = D.width, k = D.open;
            }
          } else if (ue == "o30" || ue == "o31") {
            var Re = U.length, Pe = (ye = 0, ue == "o31");
            for (ye += Re - (oe = -3 & Re); ye < oe; ) Pe ? (q = $, Y = (j = W + U.shift()) + U.shift(), $ = (J = q + U.shift()) + U.shift(), oe - ye == 5 ? (W = Y + U.shift(), ye++) : W = Y, Pe = !1) : (j = W, q = $ + U.shift(), Y = j + U.shift(), J = q + U.shift(), W = Y + U.shift(), oe - ye == 5 ? ($ = J + U.shift(), ye++) : $ = J, Pe = !0), e.U.P.curveTo(N, j, q, Y, J, W, $), ye += 4;
          } else {
            if ((ue + "").charAt(0) == "o") throw console.debug("Unknown operation: " + ue, M), ue;
            U.push(ue);
          }
        }
      }
      D.x = W, D.y = $, D.nStems = G, D.haveWidth = V, D.width = z, D.open = k;
    };
    var b = e, L = { Typr: b };
    return B.Typr = b, B.default = L, Object.defineProperty(B, "__esModule", { value: !0 }), B;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function woff2otfFactory() {
  return function(B) {
    var e = Uint8Array, b = Uint16Array, L = Uint32Array, M = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), D = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), I = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), F = function(ue, oe) {
      for (var ae = new b(31), se = 0; se < 31; ++se) ae[se] = oe += 1 << ue[se - 1];
      var ie = new L(ae[30]);
      for (se = 1; se < 30; ++se) for (var ye = ae[se]; ye < ae[se + 1]; ++ye) ie[ye] = ye - ae[se] << 5 | se;
      return [ae, ie];
    }, N = F(M, 2), U = N[0], G = N[1];
    U[28] = 258, G[258] = 28;
    for (var V = F(D, 0)[0], z = new b(32768), k = 0; k < 32768; ++k) {
      var H = (43690 & k) >>> 1 | (21845 & k) << 1;
      H = (61680 & (H = (52428 & H) >>> 2 | (13107 & H) << 2)) >>> 4 | (3855 & H) << 4, z[k] = ((65280 & H) >>> 8 | (255 & H) << 8) >>> 1;
    }
    var W = function(ue, oe, ae) {
      for (var se = ue.length, ie = 0, ye = new b(oe); ie < se; ++ie) ++ye[ue[ie] - 1];
      var Ce, de = new b(oe);
      for (ie = 0; ie < oe; ++ie) de[ie] = de[ie - 1] + ye[ie - 1] << 1;
      {
        Ce = new b(1 << oe);
        var ve = 15 - oe;
        for (ie = 0; ie < se; ++ie) if (ue[ie]) for (var ce = ie << 4 | ue[ie], ge = oe - ue[ie], _e = de[ue[ie] - 1]++ << ge, Me = _e | (1 << ge) - 1; _e <= Me; ++_e) Ce[z[_e] >>> ve] = ce;
      }
      return Ce;
    }, $ = new e(288);
    for (k = 0; k < 144; ++k) $[k] = 8;
    for (k = 144; k < 256; ++k) $[k] = 9;
    for (k = 256; k < 280; ++k) $[k] = 7;
    for (k = 280; k < 288; ++k) $[k] = 8;
    var j = new e(32);
    for (k = 0; k < 32; ++k) j[k] = 5;
    var q = W($, 9), Y = W(j, 5), J = function(ue) {
      for (var oe = ue[0], ae = 1; ae < ue.length; ++ae) ue[ae] > oe && (oe = ue[ae]);
      return oe;
    }, K = function(ue, oe, ae) {
      var se = oe / 8 | 0;
      return (ue[se] | ue[se + 1] << 8) >> (7 & oe) & ae;
    }, X = function(ue, oe) {
      var ae = oe / 8 | 0;
      return (ue[ae] | ue[ae + 1] << 8 | ue[ae + 2] << 16) >> (7 & oe);
    }, Z = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], Q = function(ue, oe, ae) {
      var se = new Error(oe || Z[ue]);
      if (se.code = ue, Error.captureStackTrace && Error.captureStackTrace(se, Q), !ae) throw se;
      return se;
    }, ne = function(ue, oe, ae) {
      var se = ue.length;
      if (!se || ae && !ae.l && se < 5) return oe || new e(0);
      var ie = !oe || ae, ye = !ae || ae.i;
      ae || (ae = {}), oe || (oe = new e(3 * se));
      var Ce, de = function(Ye) {
        var st = oe.length;
        if (Ye > st) {
          var ut = new e(Math.max(2 * st, Ye));
          ut.set(oe), oe = ut;
        }
      }, ve = ae.f || 0, ce = ae.p || 0, ge = ae.b || 0, _e = ae.l, Me = ae.d, xe = ae.m, fe = ae.n, Re = 8 * se;
      do {
        if (!_e) {
          ae.f = ve = K(ue, ce, 1);
          var Pe = K(ue, ce + 1, 3);
          if (ce += 3, !Pe) {
            var Ue = ue[(Ee = ((Ce = ce) / 8 | 0) + (7 & Ce && 1) + 4) - 4] | ue[Ee - 3] << 8, Ve = Ee + Ue;
            if (Ve > se) {
              ye && Q(0);
              break;
            }
            ie && de(ge + Ue), oe.set(ue.subarray(Ee, Ve), ge), ae.b = ge += Ue, ae.p = ce = 8 * Ve;
            continue;
          }
          if (Pe == 1) _e = q, Me = Y, xe = 9, fe = 5;
          else if (Pe == 2) {
            var Oe = K(ue, ce, 31) + 257, me = K(ue, ce + 10, 15) + 4, Ie = Oe + K(ue, ce + 5, 31) + 1;
            ce += 14;
            for (var Be = new e(Ie), Ne = new e(19), Fe = 0; Fe < me; ++Fe) Ne[I[Fe]] = K(ue, ce + 3 * Fe, 7);
            ce += 3 * me;
            var te = J(Ne), ee = (1 << te) - 1, Se = W(Ne, te);
            for (Fe = 0; Fe < Ie; ) {
              var Ee, be = Se[K(ue, ce, ee)];
              if (ce += 15 & be, (Ee = be >>> 4) < 16) Be[Fe++] = Ee;
              else {
                var ze = 0, Ge = 0;
                for (Ee == 16 ? (Ge = 3 + K(ue, ce, 3), ce += 2, ze = Be[Fe - 1]) : Ee == 17 ? (Ge = 3 + K(ue, ce, 7), ce += 3) : Ee == 18 && (Ge = 11 + K(ue, ce, 127), ce += 7); Ge--; ) Be[Fe++] = ze;
              }
            }
            var He = Be.subarray(0, Oe), ke = Be.subarray(Oe);
            xe = J(He), fe = J(ke), _e = W(He, xe), Me = W(ke, fe);
          } else Q(1);
          if (ce > Re) {
            ye && Q(0);
            break;
          }
        }
        ie && de(ge + 131072);
        for (var $e = (1 << xe) - 1, he = (1 << fe) - 1, Le = ce; ; Le = ce) {
          var Te = (ze = _e[X(ue, ce) & $e]) >>> 4;
          if ((ce += 15 & ze) > Re) {
            ye && Q(0);
            break;
          }
          if (ze || Q(2), Te < 256) oe[ge++] = Te;
          else {
            if (Te == 256) {
              Le = ce, _e = null;
              break;
            }
            var je = Te - 254;
            if (Te > 264) {
              var We = M[Fe = Te - 257];
              je = K(ue, ce, (1 << We) - 1) + U[Fe], ce += We;
            }
            var rt = Me[X(ue, ce) & he], Qe = rt >>> 4;
            if (rt || Q(3), ce += 15 & rt, ke = V[Qe], Qe > 3 && (We = D[Qe], ke += X(ue, ce) & (1 << We) - 1, ce += We), ce > Re) {
              ye && Q(0);
              break;
            }
            ie && de(ge + 131072);
            for (var et = ge + je; ge < et; ge += 4) oe[ge] = oe[ge - ke], oe[ge + 1] = oe[ge + 1 - ke], oe[ge + 2] = oe[ge + 2 - ke], oe[ge + 3] = oe[ge + 3 - ke];
            ge = et;
          }
        }
        ae.l = _e, ae.p = Le, ae.b = ge, _e && (ve = 1, ae.m = xe, ae.d = Me, ae.n = fe);
      } while (!ve);
      return ge == oe.length ? oe : function(Ye, st, ut) {
        (ut == null || ut > Ye.length) && (ut = Ye.length);
        var vt = new (Ye instanceof b ? b : Ye instanceof L ? L : e)(ut - st);
        return vt.set(Ye.subarray(st, ut)), vt;
      }(oe, 0, ge);
    }, le = new e(0), pe = typeof TextDecoder < "u" && new TextDecoder();
    try {
      pe.decode(le, { stream: !0 });
    } catch {
    }
    return B.convert_streams = function(ue) {
      var oe = new DataView(ue), ae = 0;
      function se() {
        var Oe = oe.getUint16(ae);
        return ae += 2, Oe;
      }
      function ie() {
        var Oe = oe.getUint32(ae);
        return ae += 4, Oe;
      }
      function ye(Oe) {
        Ue.setUint16(Ve, Oe), Ve += 2;
      }
      function Ce(Oe) {
        Ue.setUint32(Ve, Oe), Ve += 4;
      }
      for (var de = { signature: ie(), flavor: ie(), length: ie(), numTables: se(), reserved: se(), totalSfntSize: ie(), majorVersion: se(), minorVersion: se(), metaOffset: ie(), metaLength: ie(), metaOrigLength: ie(), privOffset: ie(), privLength: ie() }, ve = 0; Math.pow(2, ve) <= de.numTables; ) ve++;
      ve--;
      for (var ce = 16 * Math.pow(2, ve), ge = 16 * de.numTables - ce, _e = 12, Me = [], xe = 0; xe < de.numTables; xe++) Me.push({ tag: ie(), offset: ie(), compLength: ie(), origLength: ie(), origChecksum: ie() }), _e += 16;
      var fe, Re = new Uint8Array(12 + 16 * Me.length + Me.reduce(function(Oe, me) {
        return Oe + me.origLength + 4;
      }, 0)), Pe = Re.buffer, Ue = new DataView(Pe), Ve = 0;
      return Ce(de.flavor), ye(de.numTables), ye(ce), ye(ve), ye(ge), Me.forEach(function(Oe) {
        Ce(Oe.tag), Ce(Oe.origChecksum), Ce(_e), Ce(Oe.origLength), Oe.outOffset = _e, (_e += Oe.origLength) % 4 != 0 && (_e += 4 - _e % 4);
      }), Me.forEach(function(Oe) {
        var me, Ie = ue.slice(Oe.offset, Oe.offset + Oe.compLength);
        if (Oe.compLength != Oe.origLength) {
          var Be = new Uint8Array(Oe.origLength);
          me = new Uint8Array(Ie, 2), ne(me, Be);
        } else Be = new Uint8Array(Ie);
        Re.set(Be, Oe.outOffset);
        var Ne = 0;
        (_e = Oe.outOffset + Oe.origLength) % 4 != 0 && (Ne = 4 - _e % 4), Re.set(new Uint8Array(Ne).buffer, Oe.outOffset + Oe.origLength), fe = _e + Ne;
      }), Pe.slice(0, fe);
    }, Object.defineProperty(B, "__esModule", { value: !0 }), B;
  }({}).convert_streams;
}
function parserFactory(B, e) {
  const b = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, L = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, M = 1, D = 2, I = 4, F = 8, N = 16, U = 32;
  let G;
  function V(Z) {
    if (!G) {
      const Q = {
        R: D,
        L: M,
        D: I,
        C: N,
        U,
        T: F
      };
      G = /* @__PURE__ */ new Map();
      for (let ne in L) {
        let le = 0;
        L[ne].split(",").forEach((pe) => {
          let [ue, oe] = pe.split("+");
          ue = parseInt(ue, 36), oe = oe ? parseInt(oe, 36) : 0, G.set(le += ue, Q[ne]);
          for (let ae = oe; ae--; )
            G.set(++le, Q[ne]);
        });
      }
    }
    return G.get(Z) || U;
  }
  const z = 1, k = 2, H = 3, W = 4, $ = [null, "isol", "init", "fina", "medi"];
  function j(Z) {
    const Q = new Uint8Array(Z.length);
    let ne = U, le = z, pe = -1;
    for (let ue = 0; ue < Z.length; ue++) {
      const oe = Z.codePointAt(ue);
      let ae = V(oe) | 0, se = z;
      ae & F || (ne & (M | I | N) ? ae & (D | I | N) ? (se = H, (le === z || le === H) && Q[pe]++) : ae & (M | U) && (le === k || le === W) && Q[pe]-- : ne & (D | U) && (le === k || le === W) && Q[pe]--, le = Q[ue] = se, ne = ae, pe = ue, oe > 65535 && ue++);
    }
    return Q;
  }
  function q(Z, Q) {
    const ne = [];
    for (let pe = 0; pe < Q.length; pe++) {
      const ue = Q.codePointAt(pe);
      ue > 65535 && pe++, ne.push(B.U.codeToGlyph(Z, ue));
    }
    const le = Z.GSUB;
    if (le) {
      const { lookupList: pe, featureList: ue } = le;
      let oe;
      const ae = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/, se = [];
      ue.forEach((ie) => {
        if (ae.test(ie.tag))
          for (let ye = 0; ye < ie.tab.length; ye++) {
            if (se[ie.tab[ye]]) continue;
            se[ie.tab[ye]] = !0;
            const Ce = pe[ie.tab[ye]], de = /^(isol|init|fina|medi)$/.test(ie.tag);
            de && !oe && (oe = j(Q));
            for (let ve = 0; ve < ne.length; ve++)
              (!oe || !de || $[oe[ve]] === ie.tag) && B.U._applySubs(ne, ve, Ce, pe);
          }
      });
    }
    return ne;
  }
  function Y(Z, Q) {
    const ne = new Int16Array(Q.length * 3);
    let le = 0;
    for (; le < Q.length; le++) {
      const ae = Q[le];
      if (ae === -1) continue;
      ne[le * 3 + 2] = Z.hmtx.aWidth[ae];
      const se = Z.GPOS;
      if (se) {
        const ie = se.lookupList;
        for (let ye = 0; ye < ie.length; ye++) {
          const Ce = ie[ye];
          for (let de = 0; de < Ce.tabs.length; de++) {
            const ve = Ce.tabs[de];
            if (Ce.ltype === 1) {
              if (B._lctf.coverageIndex(ve.coverage, ae) !== -1 && ve.pos) {
                oe(ve.pos, le);
                break;
              }
            } else if (Ce.ltype === 2) {
              let ce = null, ge = pe();
              if (ge !== -1) {
                const _e = B._lctf.coverageIndex(ve.coverage, Q[ge]);
                if (_e !== -1) {
                  if (ve.fmt === 1) {
                    const Me = ve.pairsets[_e];
                    for (let xe = 0; xe < Me.length; xe++)
                      Me[xe].gid2 === ae && (ce = Me[xe]);
                  } else if (ve.fmt === 2) {
                    const Me = B.U._getGlyphClass(Q[ge], ve.classDef1), xe = B.U._getGlyphClass(ae, ve.classDef2);
                    ce = ve.matrix[Me][xe];
                  }
                  if (ce) {
                    ce.val1 && oe(ce.val1, ge), ce.val2 && oe(ce.val2, le);
                    break;
                  }
                }
              }
            } else if (Ce.ltype === 4) {
              const ce = B._lctf.coverageIndex(ve.markCoverage, ae);
              if (ce !== -1) {
                const ge = pe(ue), _e = ge === -1 ? -1 : B._lctf.coverageIndex(ve.baseCoverage, Q[ge]);
                if (_e !== -1) {
                  const Me = ve.markArray[ce], xe = ve.baseArray[_e][Me.markClass];
                  ne[le * 3] = xe.x - Me.x + ne[ge * 3] - ne[ge * 3 + 2], ne[le * 3 + 1] = xe.y - Me.y + ne[ge * 3 + 1];
                  break;
                }
              }
            } else if (Ce.ltype === 6) {
              const ce = B._lctf.coverageIndex(ve.mark1Coverage, ae);
              if (ce !== -1) {
                const ge = pe();
                if (ge !== -1) {
                  const _e = Q[ge];
                  if (J(Z, _e) === 3) {
                    const Me = B._lctf.coverageIndex(ve.mark2Coverage, _e);
                    if (Me !== -1) {
                      const xe = ve.mark1Array[ce], fe = ve.mark2Array[Me][xe.markClass];
                      ne[le * 3] = fe.x - xe.x + ne[ge * 3] - ne[ge * 3 + 2], ne[le * 3 + 1] = fe.y - xe.y + ne[ge * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (Z.kern && !Z.cff) {
        const ie = pe();
        if (ie !== -1) {
          const ye = Z.kern.glyph1.indexOf(Q[ie]);
          if (ye !== -1) {
            const Ce = Z.kern.rval[ye].glyph2.indexOf(ae);
            Ce !== -1 && (ne[ie * 3 + 2] += Z.kern.rval[ye].vals[Ce]);
          }
        }
      }
    }
    return ne;
    function pe(ae) {
      for (let se = le - 1; se >= 0; se--)
        if (Q[se] !== -1 && (!ae || ae(Q[se])))
          return se;
      return -1;
    }
    function ue(ae) {
      return J(Z, ae) === 1;
    }
    function oe(ae, se) {
      for (let ie = 0; ie < 3; ie++)
        ne[se * 3 + ie] += ae[ie] || 0;
    }
  }
  function J(Z, Q) {
    const ne = Z.GDEF && Z.GDEF.glyphClassDef;
    return ne ? B.U._getGlyphClass(Q, ne) : 0;
  }
  function K(...Z) {
    for (let Q = 0; Q < Z.length; Q++)
      if (typeof Z[Q] == "number")
        return Z[Q];
  }
  function X(Z) {
    const Q = /* @__PURE__ */ Object.create(null), ne = Z["OS/2"], le = Z.hhea, pe = Z.head.unitsPerEm, ue = K(ne && ne.sTypoAscender, le && le.ascender, pe), oe = {
      unitsPerEm: pe,
      ascender: ue,
      descender: K(ne && ne.sTypoDescender, le && le.descender, 0),
      capHeight: K(ne && ne.sCapHeight, ue),
      xHeight: K(ne && ne.sxHeight, ue),
      lineGap: K(ne && ne.sTypoLineGap, le && le.lineGap),
      supportsCodePoint(ae) {
        return B.U.codeToGlyph(Z, ae) > 0;
      },
      forEachGlyph(ae, se, ie, ye) {
        let Ce = 0;
        const de = 1 / oe.unitsPerEm * se, ve = q(Z, ae);
        let ce = 0;
        const ge = Y(Z, ve);
        return ve.forEach((_e, Me) => {
          if (_e !== -1) {
            let xe = Q[_e];
            if (!xe) {
              const { cmds: fe, crds: Re } = B.U.glyphToPath(Z, _e);
              let Pe = "", Ue = 0;
              for (let Be = 0, Ne = fe.length; Be < Ne; Be++) {
                const Fe = b[fe[Be]];
                Pe += fe[Be];
                for (let te = 1; te <= Fe; te++)
                  Pe += (te > 1 ? "," : "") + Re[Ue++];
              }
              let Ve, Oe, me, Ie;
              if (Re.length) {
                Ve = Oe = 1 / 0, me = Ie = -1 / 0;
                for (let Be = 0, Ne = Re.length; Be < Ne; Be += 2) {
                  let Fe = Re[Be], te = Re[Be + 1];
                  Fe < Ve && (Ve = Fe), te < Oe && (Oe = te), Fe > me && (me = Fe), te > Ie && (Ie = te);
                }
              } else
                Ve = me = Oe = Ie = 0;
              xe = Q[_e] = {
                index: _e,
                advanceWidth: Z.hmtx.aWidth[_e],
                xMin: Ve,
                yMin: Oe,
                xMax: me,
                yMax: Ie,
                path: Pe
              };
            }
            ye.call(
              null,
              xe,
              Ce + ge[Me * 3] * de,
              ge[Me * 3 + 1] * de,
              ce
            ), Ce += ge[Me * 3 + 2] * de, ie && (Ce += ie * se);
          }
          ce += ae.codePointAt(ce) > 65535 ? 2 : 1;
        }), Ce;
      }
    };
    return oe;
  }
  return function(Q) {
    const ne = new Uint8Array(Q, 0, 4), le = B._bin.readASCII(ne, 0, 4);
    if (le === "wOFF")
      Q = e(Q);
    else if (le === "wOF2")
      throw new Error("woff2 fonts not supported");
    return X(B.parse(Q)[0]);
  };
}
const workerModule = /* @__PURE__ */ defineWorkerModule({
  name: "Typr Font Parser",
  dependencies: [typrFactory, woff2otfFactory, parserFactory],
  init(B, e, b) {
    const L = B(), M = e();
    return b(L, M);
  }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function unicodeFontResolverClientFactory() {
  return function(B) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(Y) {
      var J = Y >> 5;
      this.buckets.set(J, (this.buckets.get(J) || 0) | 1 << (31 & Y));
    }, e.prototype.has = function(Y) {
      var J = this.buckets.get(Y >> 5);
      return J !== void 0 && (J & 1 << (31 & Y)) != 0;
    }, e.prototype.serialize = function() {
      var Y = [];
      return this.buckets.forEach(function(J, K) {
        Y.push((+K).toString(36) + ":" + J.toString(36));
      }), Y.join(",");
    }, e.prototype.deserialize = function(Y) {
      var J = this;
      this.buckets.clear(), Y.split(",").forEach(function(K) {
        var X = K.split(":");
        J.buckets.set(parseInt(X[0], 36), parseInt(X[1], 36));
      });
    };
    var b = Math.pow(2, 8), L = b - 1, M = ~L;
    function D(Y) {
      var J = function(X) {
        return X & M;
      }(Y).toString(16), K = function(X) {
        return (X & M) + b - 1;
      }(Y).toString(16);
      return "codepoint-index/plane" + (Y >> 16) + "/" + J + "-" + K + ".json";
    }
    function I(Y, J) {
      var K = Y & L, X = J.codePointAt(K / 6 | 0);
      return ((X = (X || 48) - 48) & 1 << K % 6) != 0;
    }
    function F(Y, J) {
      var K;
      (K = Y, K.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(X) {
        return X.split("-").map(function(Z) {
          return parseInt(Z.trim(), 16);
        });
      })).forEach(function(X) {
        var Z = X[0], Q = X[1];
        Q === void 0 && (Q = Z), J(Z, Q);
      });
    }
    function N(Y, J) {
      F(Y, function(K, X) {
        for (var Z = K; Z <= X; Z++) J(Z);
      });
    }
    var U = {}, G = {}, V = /* @__PURE__ */ new WeakMap(), z = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function k(Y) {
      var J = V.get(Y);
      return J || (J = new e(), N(Y.ranges, function(K) {
        return J.add(K);
      }), V.set(Y, J)), J;
    }
    var H, W = /* @__PURE__ */ new Map();
    function $(Y, J, K) {
      return Y[J] ? J : Y[K] ? K : function(X) {
        for (var Z in X) return Z;
      }(Y);
    }
    function j(Y, J) {
      var K = J;
      if (!Y.includes(K)) {
        K = 1 / 0;
        for (var X = 0; X < Y.length; X++) Math.abs(Y[X] - J) < Math.abs(K - J) && (K = Y[X]);
      }
      return K;
    }
    function q(Y) {
      return H || (H = /* @__PURE__ */ new Set(), N("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(J) {
        H.add(J);
      })), H.has(Y);
    }
    return B.CodePointSet = e, B.clearCache = function() {
      U = {}, G = {};
    }, B.getFontsForString = function(Y, J) {
      J === void 0 && (J = {});
      var K, X = J.lang;
      X === void 0 && (X = new RegExp("\\p{Script=Hangul}", "u").test(K = Y) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(K) ? "ja" : "en");
      var Z = J.category;
      Z === void 0 && (Z = "sans-serif");
      var Q = J.style;
      Q === void 0 && (Q = "normal");
      var ne = J.weight;
      ne === void 0 && (ne = 400);
      var le = (J.dataUrl || z).replace(/\/$/g, ""), pe = /* @__PURE__ */ new Map(), ue = new Uint8Array(Y.length), oe = {}, ae = {}, se = new Array(Y.length), ie = /* @__PURE__ */ new Map(), ye = !1;
      function Ce(ce) {
        var ge = W.get(ce);
        return ge || (ge = fetch(le + "/" + ce).then(function(_e) {
          if (!_e.ok) throw new Error(_e.statusText);
          return _e.json().then(function(Me) {
            if (!Array.isArray(Me) || Me[0] !== 1) throw new Error("Incorrect schema version; need 1, got " + Me[0]);
            return Me[1];
          });
        }).catch(function(_e) {
          if (le !== z) return ye || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + le + '", trying default CDN. ' + _e.message), ye = !0), le = z, W.delete(ce), Ce(ce);
          throw _e;
        }), W.set(ce, ge)), ge;
      }
      for (var de = function(ce) {
        var ge = Y.codePointAt(ce), _e = D(ge);
        se[ce] = _e, U[_e] || ie.has(_e) || ie.set(_e, Ce(_e).then(function(Me) {
          U[_e] = Me;
        })), ge > 65535 && (ce++, ve = ce);
      }, ve = 0; ve < Y.length; ve++) de(ve);
      return Promise.all(ie.values()).then(function() {
        ie.clear();
        for (var ce = function(_e) {
          var Me = Y.codePointAt(_e), xe = null, fe = U[se[_e]], Re = void 0;
          for (var Pe in fe) {
            var Ue = ae[Pe];
            if (Ue === void 0 && (Ue = ae[Pe] = new RegExp(Pe).test(X || "en")), Ue) {
              for (var Ve in Re = Pe, fe[Pe]) if (I(Me, fe[Pe][Ve])) {
                xe = Ve;
                break;
              }
              break;
            }
          }
          if (!xe) {
            e: for (var Oe in fe) if (Oe !== Re) {
              for (var me in fe[Oe]) if (I(Me, fe[Oe][me])) {
                xe = me;
                break e;
              }
            }
          }
          xe || (console.debug("No font coverage for U+" + Me.toString(16)), xe = "latin"), se[_e] = xe, G[xe] || ie.has(xe) || ie.set(xe, Ce("font-meta/" + xe + ".json").then(function(Ie) {
            G[xe] = Ie;
          })), Me > 65535 && (_e++, ge = _e);
        }, ge = 0; ge < Y.length; ge++) ce(ge);
        return Promise.all(ie.values());
      }).then(function() {
        for (var ce, ge = null, _e = 0; _e < Y.length; _e++) {
          var Me = Y.codePointAt(_e);
          if (ge && (q(Me) || k(ge).has(Me))) ue[_e] = ue[_e - 1];
          else {
            ge = G[se[_e]];
            var xe = oe[ge.id];
            if (!xe) {
              var fe = ge.typeforms, Re = $(fe, Z, "sans-serif"), Pe = $(fe[Re], Q, "normal"), Ue = j((ce = fe[Re]) === null || ce === void 0 ? void 0 : ce[Pe], ne);
              xe = oe[ge.id] = le + "/font-files/" + ge.id + "/" + Re + "." + Pe + "." + Ue + ".woff";
            }
            var Ve = pe.get(xe);
            Ve == null && (Ve = pe.size, pe.set(xe, Ve)), ue[_e] = Ve;
          }
          Me > 65535 && (_e++, ue[_e] = ue[_e - 1]);
        }
        return { fontUrls: Array.from(pe.keys()), chars: ue };
      });
    }, Object.defineProperty(B, "__esModule", { value: !0 }), B;
  }({});
}
function createFontResolver(B, e) {
  const b = /* @__PURE__ */ Object.create(null), L = /* @__PURE__ */ Object.create(null);
  function M(I, F) {
    const N = (U) => {
      console.error(`Failure loading font ${I}`, U);
    };
    try {
      const U = new XMLHttpRequest();
      U.open("get", I, !0), U.responseType = "arraybuffer", U.onload = function() {
        if (U.status >= 400)
          N(new Error(U.statusText));
        else if (U.status > 0)
          try {
            const G = B(U.response);
            G.src = I, F(G);
          } catch (G) {
            N(G);
          }
      }, U.onerror = N, U.send();
    } catch (U) {
      N(U);
    }
  }
  function D(I, F) {
    let N = b[I];
    N ? F(N) : L[I] ? L[I].push(F) : (L[I] = [F], M(I, (U) => {
      U.src = I, b[I] = U, L[I].forEach((G) => G(U)), delete L[I];
    }));
  }
  return function(I, F, {
    lang: N,
    fonts: U = [],
    style: G = "normal",
    weight: V = "normal",
    unicodeFontsURL: z
  } = {}) {
    const k = new Uint8Array(I.length), H = [];
    I.length || q();
    const W = /* @__PURE__ */ new Map(), $ = [];
    if (G !== "italic" && (G = "normal"), typeof V != "number" && (V = V === "bold" ? 700 : 400), U && !Array.isArray(U) && (U = [U]), U = U.slice().filter((J) => !J.lang || J.lang.test(N)).reverse(), U.length) {
      let Z = 0;
      (function Q(ne = 0) {
        for (let le = ne, pe = I.length; le < pe; le++) {
          const ue = I.codePointAt(le);
          if (Z === 1 && H[k[le - 1]].supportsCodePoint(ue) || /\s/.test(I[le]))
            k[le] = k[le - 1], Z === 2 && ($[$.length - 1][1] = le);
          else
            for (let oe = k[le], ae = U.length; oe <= ae; oe++)
              if (oe === ae) {
                const se = Z === 2 ? $[$.length - 1] : $[$.length] = [le, le];
                se[1] = le, Z = 2;
              } else {
                k[le] = oe;
                const { src: se, unicodeRange: ie } = U[oe];
                if (!ie || Y(ue, ie)) {
                  const ye = b[se];
                  if (!ye) {
                    D(se, () => {
                      Q(le);
                    });
                    return;
                  }
                  if (ye.supportsCodePoint(ue)) {
                    let Ce = W.get(ye);
                    typeof Ce != "number" && (Ce = H.length, H.push(ye), W.set(ye, Ce)), k[le] = Ce, Z = 1;
                    break;
                  }
                }
              }
          ue > 65535 && le + 1 < pe && (k[le + 1] = k[le], le++, Z === 2 && ($[$.length - 1][1] = le));
        }
        j();
      })();
    } else
      $.push([0, I.length - 1]), j();
    function j() {
      if ($.length) {
        const J = $.map((K) => I.substring(K[0], K[1] + 1)).join(`
`);
        e.getFontsForString(J, {
          lang: N || void 0,
          style: G,
          weight: V,
          dataUrl: z
        }).then(({ fontUrls: K, chars: X }) => {
          const Z = H.length;
          let Q = 0;
          $.forEach((le) => {
            for (let pe = 0, ue = le[1] - le[0]; pe <= ue; pe++)
              k[le[0] + pe] = X[Q++] + Z;
            Q++;
          });
          let ne = 0;
          K.forEach((le, pe) => {
            D(le, (ue) => {
              H[pe + Z] = ue, ++ne === K.length && q();
            });
          });
        });
      } else
        q();
    }
    function q() {
      F({
        chars: k,
        fonts: H
      });
    }
    function Y(J, K) {
      for (let X = 0; X < K.length; X++) {
        const [Z, Q = Z] = K[X];
        if (Z <= J && J <= Q)
          return !0;
      }
      return !1;
    }
  };
}
const fontResolverWorkerModule = /* @__PURE__ */ defineWorkerModule({
  name: "FontResolver",
  dependencies: [
    createFontResolver,
    workerModule,
    unicodeFontResolverClientFactory
  ],
  init(B, e, b) {
    return B(e, b());
  }
});
function createTypesetter(B, e) {
  const L = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, M = "[^\\S\\u00A0]", D = new RegExp(`${M}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function I({ text: H, lang: W, fonts: $, style: j, weight: q, preResolvedFonts: Y, unicodeFontsURL: J }, K) {
    const X = ({ chars: Z, fonts: Q }) => {
      let ne, le;
      const pe = [];
      for (let ue = 0; ue < Z.length; ue++)
        Z[ue] !== le ? (le = Z[ue], pe.push(ne = { start: ue, end: ue, fontObj: Q[Z[ue]] })) : ne.end = ue;
      K(pe);
    };
    Y ? X(Y) : B(
      H,
      X,
      { lang: W, fonts: $, style: j, weight: q, unicodeFontsURL: J }
    );
  }
  function F({
    text: H = "",
    font: W,
    lang: $,
    sdfGlyphSize: j = 64,
    fontSize: q = 400,
    fontWeight: Y = 1,
    fontStyle: J = "normal",
    letterSpacing: K = 0,
    lineHeight: X = "normal",
    maxWidth: Z = 1 / 0,
    direction: Q,
    textAlign: ne = "left",
    textIndent: le = 0,
    whiteSpace: pe = "normal",
    overflowWrap: ue = "normal",
    anchorX: oe = 0,
    anchorY: ae = 0,
    metricsOnly: se = !1,
    unicodeFontsURL: ie,
    preResolvedFonts: ye = null,
    includeCaretPositions: Ce = !1,
    chunkedBoundsSize: de = 8192,
    colorRanges: ve = null
  }, ce) {
    const ge = V(), _e = { fontLoad: 0, typesetting: 0 };
    H.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), H = H.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), q = +q, K = +K, Z = +Z, X = X || "normal", le = +le, I({
      text: H,
      lang: $,
      style: J,
      weight: Y,
      fonts: typeof W == "string" ? [{ src: W }] : W,
      unicodeFontsURL: ie,
      preResolvedFonts: ye
    }, (Me) => {
      _e.fontLoad = V() - ge;
      const xe = isFinite(Z);
      let fe = null, Re = null, Pe = null, Ue = null, Ve = null, Oe = null, me = null, Ie = null, Be = 0, Ne = 0, Fe = pe !== "nowrap";
      const te = /* @__PURE__ */ new Map(), ee = V();
      let Se = le, Ee = 0, be = new z();
      const ze = [be];
      Me.forEach((he) => {
        const { fontObj: Le } = he, { ascender: Te, descender: je, unitsPerEm: We, lineGap: rt, capHeight: Qe, xHeight: et } = Le;
        let Ye = te.get(Le);
        if (!Ye) {
          const tt = q / We, dt = X === "normal" ? (Te - je + rt) * tt : X * q, Tt = (dt - (Te - je) * tt) / 2, ft = Math.min(dt, (Te - je) * tt), lt = (Te + je) / 2 * tt + ft / 2;
          Ye = {
            index: te.size,
            src: Le.src,
            fontObj: Le,
            fontSizeMult: tt,
            unitsPerEm: We,
            ascender: Te * tt,
            descender: je * tt,
            capHeight: Qe * tt,
            xHeight: et * tt,
            lineHeight: dt,
            baseline: -Tt - Te * tt,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: lt,
            caretBottom: lt - ft
          }, te.set(Le, Ye);
        }
        const { fontSizeMult: st } = Ye, ut = H.slice(he.start, he.end + 1);
        let vt, mt;
        Le.forEachGlyph(ut, q, K, (tt, dt, Tt, ft) => {
          dt += Ee, ft += he.start, vt = dt, mt = tt;
          const lt = H.charAt(ft), _t = tt.advanceWidth * st, gt = be.count;
          let ot;
          if ("isEmpty" in tt || (tt.isWhitespace = !!lt && new RegExp(M).test(lt), tt.canBreakAfter = !!lt && D.test(lt), tt.isEmpty = tt.xMin === tt.xMax || tt.yMin === tt.yMax || L.test(lt)), !tt.isWhitespace && !tt.isEmpty && Ne++, Fe && xe && !tt.isWhitespace && dt + _t + Se > Z && gt) {
            if (be.glyphAt(gt - 1).glyphObj.canBreakAfter)
              ot = new z(), Se = -dt;
            else
              for (let St = gt; St--; )
                if (St === 0 && ue === "break-word") {
                  ot = new z(), Se = -dt;
                  break;
                } else if (be.glyphAt(St).glyphObj.canBreakAfter) {
                  ot = be.splitAt(St + 1);
                  const Mt = ot.glyphAt(0).x;
                  Se -= Mt;
                  for (let xt = ot.count; xt--; )
                    ot.glyphAt(xt).x -= Mt;
                  break;
                }
            ot && (be.isSoftWrapped = !0, be = ot, ze.push(be), Be = Z);
          }
          let yt = be.glyphAt(be.count);
          yt.glyphObj = tt, yt.x = dt + Se, yt.y = Tt, yt.width = _t, yt.charIndex = ft, yt.fontData = Ye, lt === `
` && (be = new z(), ze.push(be), Se = -(dt + _t + K * q) + le);
        }), Ee = vt + mt.advanceWidth * st + K * q;
      });
      let Ge = 0;
      ze.forEach((he) => {
        let Le = !0;
        for (let Te = he.count; Te--; ) {
          const je = he.glyphAt(Te);
          Le && !je.glyphObj.isWhitespace && (he.width = je.x + je.width, he.width > Be && (Be = he.width), Le = !1);
          let { lineHeight: We, capHeight: rt, xHeight: Qe, baseline: et } = je.fontData;
          We > he.lineHeight && (he.lineHeight = We);
          const Ye = et - he.baseline;
          Ye < 0 && (he.baseline += Ye, he.cap += Ye, he.ex += Ye), he.cap = Math.max(he.cap, he.baseline + rt), he.ex = Math.max(he.ex, he.baseline + Qe);
        }
        he.baseline -= Ge, he.cap -= Ge, he.ex -= Ge, Ge += he.lineHeight;
      });
      let He = 0, ke = 0;
      if (oe && (typeof oe == "number" ? He = -oe : typeof oe == "string" && (He = -Be * (oe === "left" ? 0 : oe === "center" ? 0.5 : oe === "right" ? 1 : U(oe)))), ae && (typeof ae == "number" ? ke = -ae : typeof ae == "string" && (ke = ae === "top" ? 0 : ae === "top-baseline" ? -ze[0].baseline : ae === "top-cap" ? -ze[0].cap : ae === "top-ex" ? -ze[0].ex : ae === "middle" ? Ge / 2 : ae === "bottom" ? Ge : ae === "bottom-baseline" ? -ze[ze.length - 1].baseline : U(ae) * Ge)), !se) {
        const he = e.getEmbeddingLevels(H, Q);
        fe = new Uint16Array(Ne), Re = new Uint8Array(Ne), Pe = new Float32Array(Ne * 2), Ue = {}, me = [1 / 0, 1 / 0, -1 / 0, -1 / 0], Ie = [], Ce && (Oe = new Float32Array(H.length * 4)), ve && (Ve = new Uint8Array(Ne * 3));
        let Le = 0, Te = -1, je = -1, We, rt;
        if (ze.forEach((Qe, et) => {
          let { count: Ye, width: st } = Qe;
          if (Ye > 0) {
            let ut = 0;
            for (let ft = Ye; ft-- && Qe.glyphAt(ft).glyphObj.isWhitespace; )
              ut++;
            let vt = 0, mt = 0;
            if (ne === "center")
              vt = (Be - st) / 2;
            else if (ne === "right")
              vt = Be - st;
            else if (ne === "justify" && Qe.isSoftWrapped) {
              let ft = 0;
              for (let lt = Ye - ut; lt--; )
                Qe.glyphAt(lt).glyphObj.isWhitespace && ft++;
              mt = (Be - st) / ft;
            }
            if (mt || vt) {
              let ft = 0;
              for (let lt = 0; lt < Ye; lt++) {
                let _t = Qe.glyphAt(lt);
                const gt = _t.glyphObj;
                _t.x += vt + ft, mt !== 0 && gt.isWhitespace && lt < Ye - ut && (ft += mt, _t.width += mt);
              }
            }
            const tt = e.getReorderSegments(
              H,
              he,
              Qe.glyphAt(0).charIndex,
              Qe.glyphAt(Qe.count - 1).charIndex
            );
            for (let ft = 0; ft < tt.length; ft++) {
              const [lt, _t] = tt[ft];
              let gt = 1 / 0, ot = -1 / 0;
              for (let yt = 0; yt < Ye; yt++)
                if (Qe.glyphAt(yt).charIndex >= lt) {
                  let St = yt, Mt = yt;
                  for (; Mt < Ye; Mt++) {
                    let xt = Qe.glyphAt(Mt);
                    if (xt.charIndex > _t)
                      break;
                    Mt < Ye - ut && (gt = Math.min(gt, xt.x), ot = Math.max(ot, xt.x + xt.width));
                  }
                  for (let xt = St; xt < Mt; xt++) {
                    const re = Qe.glyphAt(xt);
                    re.x = ot - (re.x + re.width - gt);
                  }
                  break;
                }
            }
            let dt;
            const Tt = (ft) => dt = ft;
            for (let ft = 0; ft < Ye; ft++) {
              const lt = Qe.glyphAt(ft);
              dt = lt.glyphObj;
              const _t = dt.index, gt = he.levels[lt.charIndex] & 1;
              if (gt) {
                const ot = e.getMirroredCharacter(H[lt.charIndex]);
                ot && lt.fontData.fontObj.forEachGlyph(ot, 0, 0, Tt);
              }
              if (Ce) {
                const { charIndex: ot, fontData: yt } = lt, St = lt.x + He, Mt = lt.x + lt.width + He;
                Oe[ot * 4] = gt ? Mt : St, Oe[ot * 4 + 1] = gt ? St : Mt, Oe[ot * 4 + 2] = Qe.baseline + yt.caretBottom + ke, Oe[ot * 4 + 3] = Qe.baseline + yt.caretTop + ke;
                const xt = ot - Te;
                xt > 1 && G(Oe, Te, xt), Te = ot;
              }
              if (ve) {
                const { charIndex: ot } = lt;
                for (; ot > je; )
                  je++, ve.hasOwnProperty(je) && (rt = ve[je]);
              }
              if (!dt.isWhitespace && !dt.isEmpty) {
                const ot = Le++, { fontSizeMult: yt, src: St, index: Mt } = lt.fontData, xt = Ue[St] || (Ue[St] = {});
                xt[_t] || (xt[_t] = {
                  path: dt.path,
                  pathBounds: [dt.xMin, dt.yMin, dt.xMax, dt.yMax]
                });
                const re = lt.x + He, Ae = lt.y + Qe.baseline + ke;
                Pe[ot * 2] = re, Pe[ot * 2 + 1] = Ae;
                const we = re + dt.xMin * yt, De = Ae + dt.yMin * yt, qe = re + dt.xMax * yt, nt = Ae + dt.yMax * yt;
                we < me[0] && (me[0] = we), De < me[1] && (me[1] = De), qe > me[2] && (me[2] = qe), nt > me[3] && (me[3] = nt), ot % de === 0 && (We = { start: ot, end: ot, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, Ie.push(We)), We.end++;
                const Je = We.rect;
                if (we < Je[0] && (Je[0] = we), De < Je[1] && (Je[1] = De), qe > Je[2] && (Je[2] = qe), nt > Je[3] && (Je[3] = nt), fe[ot] = _t, Re[ot] = Mt, ve) {
                  const Xe = ot * 3;
                  Ve[Xe] = rt >> 16 & 255, Ve[Xe + 1] = rt >> 8 & 255, Ve[Xe + 2] = rt & 255;
                }
              }
            }
          }
        }), Oe) {
          const Qe = H.length - Te;
          Qe > 1 && G(Oe, Te, Qe);
        }
      }
      const $e = [];
      te.forEach(({ index: he, src: Le, unitsPerEm: Te, ascender: je, descender: We, lineHeight: rt, capHeight: Qe, xHeight: et }) => {
        $e[he] = { src: Le, unitsPerEm: Te, ascender: je, descender: We, lineHeight: rt, capHeight: Qe, xHeight: et };
      }), _e.typesetting = V() - ee, ce({
        glyphIds: fe,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: Re,
        //index into fontData for each glyph
        glyphPositions: Pe,
        //x,y of each glyph's origin in layout
        glyphData: Ue,
        //dict holding data about each glyph appearing in the text
        fontData: $e,
        //data about each font used in the text
        caretPositions: Oe,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: Ve,
        //color for each glyph, if color ranges supplied
        chunkedBounds: Ie,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: q,
        //calculated em height
        topBaseline: ke + ze[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          He,
          ke - Ge,
          He + Be,
          ke
        ],
        visibleBounds: me,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: _e
      });
    });
  }
  function N(H, W) {
    F({ ...H, metricsOnly: !0 }, ($) => {
      const [j, q, Y, J] = $.blockBounds;
      W({
        width: Y - j,
        height: J - q
      });
    });
  }
  function U(H) {
    let W = H.match(/^([\d.]+)%$/), $ = W ? parseFloat(W[1]) : NaN;
    return isNaN($) ? 0 : $ / 100;
  }
  function G(H, W, $) {
    const j = H[W * 4], q = H[W * 4 + 1], Y = H[W * 4 + 2], J = H[W * 4 + 3], K = (q - j) / $;
    for (let X = 0; X < $; X++) {
      const Z = (W + X) * 4;
      H[Z] = j + K * X, H[Z + 1] = j + K * (X + 1), H[Z + 2] = Y, H[Z + 3] = J;
    }
  }
  function V() {
    return (self.performance || Date).now();
  }
  function z() {
    this.data = [];
  }
  const k = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return z.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / k.length);
    },
    glyphAt(H) {
      let W = z.flyweight;
      return W.data = this.data, W.index = H, W;
    },
    splitAt(H) {
      let W = new z();
      return W.data = this.data.splice(H * k.length), W;
    }
  }, z.flyweight = k.reduce((H, W, $, j) => (Object.defineProperty(H, W, {
    get() {
      return this.data[this.index * k.length + $];
    },
    set(q) {
      this.data[this.index * k.length + $] = q;
    }
  }), H), { data: null, index: 0 }), {
    typeset: F,
    measure: N
  };
}
const now = () => (self.performance || Date).now(), mainThreadGenerator = /* @__PURE__ */ SDFGenerator();
let warned;
function generateSDF(B, e, b, L, M, D, I, F, N, U, G = !0) {
  return G ? generateSDF_GL(B, e, b, L, M, D, I, F, N, U).then(
    null,
    (V) => (warned || (console.warn("WebGL SDF generation failed, falling back to JS", V), warned = !0), generateSDF_JS_Worker(B, e, b, L, M, D, I, F, N, U))
  ) : generateSDF_JS_Worker(B, e, b, L, M, D, I, F, N, U);
}
const queue = [], chunkTimeBudget = 5;
let timer = 0;
function nextChunk() {
  const B = now();
  for (; queue.length && now() - B < chunkTimeBudget; )
    queue.shift()();
  timer = queue.length ? setTimeout(nextChunk, 0) : 0;
}
const generateSDF_GL = (...B) => new Promise((e, b) => {
  queue.push(() => {
    const L = now();
    try {
      mainThreadGenerator.webgl.generateIntoCanvas(...B), e({ timing: now() - L });
    } catch (M) {
      b(M);
    }
  }), timer || (timer = setTimeout(nextChunk, 0));
}), threadCount = 4, idleTimeout = 2e3, threads = {};
let callNum = 0;
function generateSDF_JS_Worker(B, e, b, L, M, D, I, F, N, U) {
  const G = "TroikaTextSDFGenerator_JS_" + callNum++ % threadCount;
  let V = threads[G];
  return V || (V = threads[G] = {
    workerModule: defineWorkerModule({
      name: G,
      workerId: G,
      dependencies: [
        SDFGenerator,
        now
      ],
      init(z, k) {
        const H = z().javascript.generate;
        return function(...W) {
          const $ = k();
          return {
            textureData: H(...W),
            timing: k() - $
          };
        };
      },
      getTransferables(z) {
        return [z.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), V.requests++, clearTimeout(V.idleTimer), V.workerModule(B, e, b, L, M, D).then(({ textureData: z, timing: k }) => {
    const H = now(), W = new Uint8Array(z.length * 4);
    for (let $ = 0; $ < z.length; $++)
      W[$ * 4 + U] = z[$];
    return mainThreadGenerator.webglUtils.renderImageData(I, W, F, N, B, e, 1 << 3 - U), k += now() - H, --V.requests === 0 && (V.idleTimer = setTimeout(() => {
      terminateWorker(G);
    }, idleTimeout)), { timing: k };
  });
}
function warmUpSDFCanvas(B) {
  B._warm || (mainThreadGenerator.webgl.isSupported(B), B._warm = !0);
}
const resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing, CONFIG = {
  defaultFontURL: null,
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, tempColor = /* @__PURE__ */ new Color();
function now$1() {
  return (self.performance || Date).now();
}
const atlases = /* @__PURE__ */ Object.create(null);
function getTextRenderInfo(B, e) {
  B = assign({}, B);
  const b = now$1(), { defaultFontURL: L } = CONFIG, M = [];
  if (L && M.push({ label: "default", src: toAbsoluteURL(L) }), B.font && M.push({ label: "user", src: toAbsoluteURL(B.font) }), B.font = M, B.text = "" + B.text, B.sdfGlyphSize = B.sdfGlyphSize || CONFIG.sdfGlyphSize, B.unicodeFontsURL = B.unicodeFontsURL || CONFIG.unicodeFontsURL, B.colorRanges != null) {
    let z = {};
    for (let k in B.colorRanges)
      if (B.colorRanges.hasOwnProperty(k)) {
        let H = B.colorRanges[k];
        typeof H != "number" && (H = tempColor.set(H).getHex()), z[k] = H;
      }
    B.colorRanges = z;
  }
  Object.freeze(B);
  const { textureWidth: D, sdfExponent: I } = CONFIG, { sdfGlyphSize: F } = B, N = D / F * 4;
  let U = atlases[F];
  if (!U) {
    const z = document.createElement("canvas");
    z.width = D, z.height = F * 256 / N, U = atlases[F] = {
      glyphCount: 0,
      sdfGlyphSize: F,
      sdfCanvas: z,
      sdfTexture: new Texture(
        z,
        void 0,
        void 0,
        void 0,
        LinearFilter,
        LinearFilter
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, U.sdfTexture.generateMipmaps = !1, initContextLossHandling(U);
  }
  const { sdfTexture: G, sdfCanvas: V } = U;
  typesetInWorker(B).then((z) => {
    const { glyphIds: k, glyphFontIndices: H, fontData: W, glyphPositions: $, fontSize: j, timings: q } = z, Y = [], J = new Float32Array(k.length * 4);
    let K = 0, X = 0;
    const Z = now$1(), Q = W.map((oe) => {
      let ae = U.glyphsByFont.get(oe.src);
      return ae || U.glyphsByFont.set(oe.src, ae = /* @__PURE__ */ new Map()), ae;
    });
    k.forEach((oe, ae) => {
      const se = H[ae], { src: ie, unitsPerEm: ye } = W[se];
      let Ce = Q[se].get(oe);
      if (!Ce) {
        const { path: _e, pathBounds: Me } = z.glyphData[ie][oe], xe = Math.max(Me[2] - Me[0], Me[3] - Me[1]) / F * (CONFIG.sdfMargin * F + 0.5), fe = U.glyphCount++, Re = [
          Me[0] - xe,
          Me[1] - xe,
          Me[2] + xe,
          Me[3] + xe
        ];
        Q[se].set(oe, Ce = { path: _e, atlasIndex: fe, sdfViewBox: Re }), Y.push(Ce);
      }
      const { sdfViewBox: de } = Ce, ve = $[X++], ce = $[X++], ge = j / ye;
      J[K++] = ve + de[0] * ge, J[K++] = ce + de[1] * ge, J[K++] = ve + de[2] * ge, J[K++] = ce + de[3] * ge, k[ae] = Ce.atlasIndex;
    }), q.quads = (q.quads || 0) + (now$1() - Z);
    const ne = now$1();
    q.sdf = {};
    const le = V.height, pe = Math.ceil(U.glyphCount / N), ue = Math.pow(2, Math.ceil(Math.log2(pe * F)));
    ue > le && (console.info(`Increasing SDF texture size ${le}->${ue}`), resizeWebGLCanvasWithoutClearing(V, D, ue), G.dispose()), Promise.all(Y.map(
      (oe) => generateGlyphSDF(oe, U, B.gpuAccelerateSDF).then(({ timing: ae }) => {
        q.sdf[oe.atlasIndex] = ae;
      })
    )).then(() => {
      Y.length && !U.contextLost && (safariPre15Workaround(U), G.needsUpdate = !0), q.sdfTotal = now$1() - ne, q.total = now$1() - b, e(Object.freeze({
        parameters: B,
        sdfTexture: G,
        sdfGlyphSize: F,
        sdfExponent: I,
        glyphBounds: J,
        glyphAtlasIndices: k,
        glyphColors: z.glyphColors,
        caretPositions: z.caretPositions,
        chunkedBounds: z.chunkedBounds,
        ascender: z.ascender,
        descender: z.descender,
        lineHeight: z.lineHeight,
        capHeight: z.capHeight,
        xHeight: z.xHeight,
        topBaseline: z.topBaseline,
        blockBounds: z.blockBounds,
        visibleBounds: z.visibleBounds,
        timings: z.timings
      }));
    });
  }), Promise.resolve().then(() => {
    U.contextLost || warmUpSDFCanvas(V);
  });
}
function generateGlyphSDF({ path: B, atlasIndex: e, sdfViewBox: b }, { sdfGlyphSize: L, sdfCanvas: M, contextLost: D }, I) {
  if (D)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: F, sdfExponent: N } = CONFIG, U = Math.max(b[2] - b[0], b[3] - b[1]), G = Math.floor(e / 4), V = G % (F / L) * L, z = Math.floor(G / (F / L)) * L, k = e % 4;
  return generateSDF(L, L, B, b, U, N, M, V, z, k, I);
}
function initContextLossHandling(B) {
  const e = B.sdfCanvas;
  e.addEventListener("webglcontextlost", (b) => {
    console.log("Context Lost", b), b.preventDefault(), B.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (b) => {
    console.log("Context Restored", b), B.contextLost = !1;
    const L = [];
    B.glyphsByFont.forEach((M) => {
      M.forEach((D) => {
        L.push(generateGlyphSDF(D, B, !0));
      });
    }), Promise.all(L).then(() => {
      safariPre15Workaround(B), B.sdfTexture.needsUpdate = !0;
    });
  });
}
function assign(B, e) {
  for (let b in e)
    e.hasOwnProperty(b) && (B[b] = e[b]);
  return B;
}
let linkEl;
function toAbsoluteURL(B) {
  return linkEl || (linkEl = typeof document > "u" ? {} : document.createElement("a")), linkEl.href = B, linkEl.href;
}
function safariPre15Workaround(B) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: b } = B, { width: L, height: M } = e, D = B.sdfCanvas.getContext("webgl");
    let I = b.image.data;
    (!I || I.length !== L * M * 4) && (I = new Uint8Array(L * M * 4), b.image = { width: L, height: M, data: I }, b.flipY = !1, b.isDataTexture = !0), D.readPixels(0, 0, L, M, D.RGBA, D.UNSIGNED_BYTE, I);
  }
}
const typesetterWorkerModule = /* @__PURE__ */ defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    createTypesetter,
    fontResolverWorkerModule,
    bidiFactory
  ],
  init(B, e, b) {
    return B(e, b());
  }
}), typesetInWorker = /* @__PURE__ */ defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    typesetterWorkerModule
  ],
  init(B) {
    return function(e) {
      return new Promise((b) => {
        B.typeset(e, b);
      });
    };
  },
  getTransferables(B) {
    const e = [];
    for (let b in B)
      B[b] && B[b].buffer && e.push(B[b].buffer);
    return e;
  }
}), templateGeometries = {};
function getTemplateGeometry(B) {
  let e = templateGeometries[B];
  if (!e) {
    const b = new PlaneGeometry(1, 1, B, B), L = b.clone(), M = b.attributes, D = L.attributes, I = new BufferGeometry(), F = M.uv.count;
    for (let N = 0; N < F; N++)
      D.position.array[N * 3] *= -1, D.normal.array[N * 3 + 2] *= -1;
    ["position", "normal", "uv"].forEach((N) => {
      I.setAttribute(
        N,
        new Float32BufferAttribute(
          [...M[N].array, ...D[N].array],
          M[N].itemSize
        )
      );
    }), I.setIndex([...b.index.array, ...L.index.array.map((N) => N + F)]), I.translate(0.5, 0.5, 0), e = templateGeometries[B] = I;
  }
  return e;
}
const glyphBoundsAttrName = "aTroikaGlyphBounds", glyphIndexAttrName = "aTroikaGlyphIndex", glyphColorAttrName = "aTroikaGlyphColor";
class GlyphsGeometry extends InstancedBufferGeometry {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new Sphere(), this.boundingBox = new Box3();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  // Since our base geometry contains triangles for both front and back sides, we can emulate
  // the "side" by restricting the draw range.
  setSide(e) {
    const b = this.getIndex().count;
    this.setDrawRange(e === BackSide ? b / 2 : 0, e === DoubleSide ? b : b / 2);
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let b = getTemplateGeometry(e);
      ["position", "normal", "uv"].forEach((L) => {
        this.attributes[L] = b.attributes[L].clone();
      }), this.setIndex(b.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, b, L, M, D) {
    updateBufferAttr(this, glyphBoundsAttrName, e, 4), updateBufferAttr(this, glyphIndexAttrName, b, 1), updateBufferAttr(this, glyphColorAttrName, D, 3), this._blockBounds = L, this._chunkedBounds = M, this.instanceCount = b.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: b, boundingBox: L } = this;
      if (b) {
        const { PI: M, floor: D, min: I, max: F, sin: N, cos: U } = Math, G = M / 2, V = M * 2, z = Math.abs(b), k = e[0] / z, H = e[2] / z, W = D((k + G) / V) !== D((H + G) / V) ? -z : I(N(k) * z, N(H) * z), $ = D((k - G) / V) !== D((H - G) / V) ? z : F(N(k) * z, N(H) * z), j = D((k + M) / V) !== D((H + M) / V) ? z * 2 : F(z - U(k) * z, z - U(H) * z);
        L.min.set(W, e[1], b < 0 ? -j : 0), L.max.set($, e[3], b < 0 ? 0 : j);
      } else
        L.min.set(e[0], e[1], 0), L.max.set(e[2], e[3], 0);
      L.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let b = this.getAttribute(glyphIndexAttrName).count, L = this._chunkedBounds;
    if (L)
      for (let M = L.length; M--; ) {
        b = L[M].end;
        let D = L[M].rect;
        if (D[1] < e.w && D[3] > e.y && D[0] < e.z && D[2] > e.x)
          break;
      }
    this.instanceCount = b;
  }
}
function updateBufferAttr(B, e, b, L) {
  const M = B.getAttribute(e);
  b ? M && M.array.length === b.length ? (M.array.set(b), M.needsUpdate = !0) : (B.setAttribute(e, new InstancedBufferAttribute(b, L)), delete B._maxInstanceCount, B.dispose()) : M && B.deleteAttribute(e);
}
const VERTEX_DEFS = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, VERTEX_TRANSFORM = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, FRAGMENT_DEFS = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, FRAGMENT_TRANSFORM = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function createTextDerivedMaterial(B) {
  const e = createDerivedMaterial(B, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Vector2() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Vector4(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Vector4(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Vector2() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Color() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Matrix3() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: VERTEX_DEFS,
    vertexTransform: VERTEX_TRANSFORM,
    fragmentDefs: FRAGMENT_DEFS,
    fragmentColorTransform: FRAGMENT_TRANSFORM,
    customRewriter({ vertexShader: b, fragmentShader: L }) {
      let M = /\buniform\s+vec3\s+diffuse\b/;
      return M.test(L) && (L = L.replace(M, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), M.test(b) || (b = b.replace(
        voidMainRegExp,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: b, fragmentShader: L };
    }
  });
  return e.transparent = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const defaultMaterial = /* @__PURE__ */ new MeshBasicMaterial({
  color: 16777215,
  side: DoubleSide,
  transparent: !0
}), defaultStrokeColor = 8421504, tempMat4 = /* @__PURE__ */ new Matrix4(), tempVec3a = /* @__PURE__ */ new Vector3(), tempVec3b = /* @__PURE__ */ new Vector3(), tempArray = [], origin = /* @__PURE__ */ new Vector3(), defaultOrient = "+x+y";
function first(B) {
  return Array.isArray(B) ? B[0] : B;
}
let getFlatRaycastMesh = () => {
  const B = new Mesh(
    new PlaneGeometry(1, 1),
    defaultMaterial
  );
  return getFlatRaycastMesh = () => B, B;
}, getCurvedRaycastMesh = () => {
  const B = new Mesh(
    new PlaneGeometry(1, 1, 32, 1),
    defaultMaterial
  );
  return getCurvedRaycastMesh = () => B, B;
};
const syncStartEvent = { type: "syncstart" }, syncCompleteEvent = { type: "synccomplete" }, SYNCABLE_PROPS = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], COPYABLE_PROPS = SYNCABLE_PROPS.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
class Text extends Mesh {
  constructor() {
    const e = new GlyphsGeometry();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = defaultStrokeColor, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = defaultOrient, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(syncStartEvent), getTextRenderInfo({
      text: this.text,
      font: this.font,
      lang: this.lang,
      fontSize: this.fontSize || 0.1,
      fontWeight: this.fontWeight || "normal",
      fontStyle: this.fontStyle || "normal",
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF,
      unicodeFontsURL: this.unicodeFontsURL
    }, (b) => {
      this._isSyncing = !1, this._textRenderInfo = b, this.geometry.updateGlyphs(
        b.glyphBounds,
        b.glyphAtlasIndices,
        b.blockBounds,
        b.chunkedBounds,
        b.glyphColors
      );
      const L = this._queuedSyncs;
      L && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        L.forEach((M) => M && M());
      })), this.dispatchEvent(syncCompleteEvent), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, b, L, M, D, I) {
    this.sync(), D.isTroikaTextMaterial && this._prepareForRender(D), D._hadOwnSide = D.hasOwnProperty("side"), this.geometry.setSide(D._actualSide = D.side), D.side = FrontSide;
  }
  onAfterRender(e, b, L, M, D, I) {
    D._hadOwnSide ? D.side = D._actualSide : delete D.side;
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const b = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());
    if ((!e || e.baseMaterial !== b) && (e = this._derivedMaterial = createTextDerivedMaterial(b), b.addEventListener("dispose", function L() {
      b.removeEventListener("dispose", L), e.dispose();
    })), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let L = e._outlineMtl;
      return L || (L = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), L.isTextOutlineMaterial = !0, L.depthWrite = !1, L.map = null, e.addEventListener("dispose", function M() {
        e.removeEventListener("dispose", M), L.dispose();
      })), [
        L,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return first(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return first(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const b = e.isTextOutlineMaterial, L = e.uniforms, M = this.textRenderInfo;
    if (M) {
      const { sdfTexture: F, blockBounds: N } = M;
      L.uTroikaSDFTexture.value = F, L.uTroikaSDFTextureSize.value.set(F.image.width, F.image.height), L.uTroikaSDFGlyphSize.value = M.sdfGlyphSize, L.uTroikaSDFExponent.value = M.sdfExponent, L.uTroikaTotalBounds.value.fromArray(N), L.uTroikaUseGlyphColors.value = !b && !!M.glyphColors;
      let U = 0, G = 0, V = 0, z, k, H, W = 0, $ = 0;
      if (b) {
        let { outlineWidth: q, outlineOffsetX: Y, outlineOffsetY: J, outlineBlur: K, outlineOpacity: X } = this;
        U = this._parsePercent(q) || 0, G = Math.max(0, this._parsePercent(K) || 0), z = X, W = this._parsePercent(Y) || 0, $ = this._parsePercent(J) || 0;
      } else
        V = Math.max(0, this._parsePercent(this.strokeWidth) || 0), V && (H = this.strokeColor, L.uTroikaStrokeColor.value.set(H ?? defaultStrokeColor), k = this.strokeOpacity, k == null && (k = 1)), z = this.fillOpacity;
      L.uTroikaDistanceOffset.value = U, L.uTroikaPositionOffset.value.set(W, $), L.uTroikaBlurRadius.value = G, L.uTroikaStrokeWidth.value = V, L.uTroikaStrokeOpacity.value = k, L.uTroikaFillOpacity.value = z ?? 1, L.uTroikaCurveRadius.value = this.curveRadius || 0;
      let j = this.clipRect;
      if (j && Array.isArray(j) && j.length === 4)
        L.uTroikaClipRect.value.fromArray(j);
      else {
        const q = (this.fontSize || 0.1) * 100;
        L.uTroikaClipRect.value.set(
          N[0] - q,
          N[1] - q,
          N[2] + q,
          N[3] + q
        );
      }
      this.geometry.applyClipRect(L.uTroikaClipRect.value);
    }
    L.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const D = b ? this.outlineColor || 0 : this.color;
    if (D == null)
      delete e.color;
    else {
      const F = e.hasOwnProperty("color") ? e.color : e.color = new Color();
      (D !== F._input || typeof D == "object") && F.set(F._input = D);
    }
    let I = this.orientation || defaultOrient;
    if (I !== e._orientation) {
      let F = L.uTroikaOrient.value;
      I = I.replace(/[^-+xyz]/g, "");
      let N = I !== defaultOrient && I.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (N) {
        let [, U, G, V, z] = N;
        tempVec3a.set(0, 0, 0)[G] = U === "-" ? 1 : -1, tempVec3b.set(0, 0, 0)[z] = V === "-" ? -1 : 1, tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b), F.setFromMatrix4(tempMat4);
      } else
        F.identity();
      e._orientation = I;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let b = e.match(/^(-?[\d.]+)%$/), L = b ? parseFloat(b[1]) : NaN;
      e = (isNaN(L) ? 0 : L / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, b = new Vector2()) {
    b.copy(e);
    const L = this.curveRadius;
    return L && (b.x = Math.atan2(e.x, Math.abs(L) - Math.abs(e.z)) * Math.abs(L)), b;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, b = new Vector2()) {
    return tempVec3a.copy(e), this.localPositionToTextCoords(this.worldToLocal(tempVec3a), b);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, b) {
    const { textRenderInfo: L, curveRadius: M } = this;
    if (L) {
      const D = L.blockBounds, I = M ? getCurvedRaycastMesh() : getFlatRaycastMesh(), F = I.geometry, { position: N, uv: U } = F.attributes;
      for (let G = 0; G < U.count; G++) {
        let V = D[0] + U.getX(G) * (D[2] - D[0]);
        const z = D[1] + U.getY(G) * (D[3] - D[1]);
        let k = 0;
        M && (k = M - Math.cos(V / M) * M, V = Math.sin(V / M) * M), N.setXYZ(G, V, z, k);
      }
      F.boundingSphere = this.geometry.boundingSphere, F.boundingBox = this.geometry.boundingBox, I.matrixWorld = this.matrixWorld, I.material.side = this.material.side, tempArray.length = 0, I.raycast(e, tempArray);
      for (let G = 0; G < tempArray.length; G++)
        tempArray[G].object = this, b.push(tempArray[G]);
    }
  }
  copy(e) {
    const b = this.geometry;
    return super.copy(e), this.geometry = b, COPYABLE_PROPS.forEach((L) => {
      this[L] = e[L];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
SYNCABLE_PROPS.forEach((B) => {
  const e = "_private_" + B;
  Object.defineProperty(Text.prototype, B, {
    get() {
      return this[e];
    },
    set(b) {
      b !== this[e] && (this[e] = b, this._needsSync = !0);
    }
  });
});
const baselineMapping = {
  top: "top",
  center: "middle",
  bottom: "bottom"
};
class SDFTextSystem extends System {
  updateText(e, b) {
    e.text = b.text, e.textAlign = b.textAlign, e.anchorX = b.anchor, e.anchorY = baselineMapping[b.baseline], e.color = b.color, e.font = b.font, e.fontSize = b.fontSize, e.letterSpacing = b.letterSpacing || 0, e.lineHeight = b.lineHeight || null, e.overflowWrap = b.overflowWrap, e.whiteSpace = b.whiteSpace, e.maxWidth = b.maxWidth, e.material.opacity = b.opacity, e.sync();
  }
  execute() {
    var e = this.queries.entities;
    e.added.forEach((b) => {
      var L = b.getComponent(Text$1);
      const M = new Text();
      M.name = "textMesh", M.anchorX = 0, M.anchorY = 0, M.renderOrder = 10, this.updateText(M, L), b.addComponent(Object3DComponent, { value: M });
    }), e.removed.forEach((b) => {
      var L = b.getObject3D(), M = L.getObjectByName("textMesh");
      M.dispose(), L.remove(M);
    }), e.changed.forEach((b) => {
      var L = b.getObject3D();
      if (L instanceof Text) {
        var M = b.getComponent(Text$1);
        this.updateText(L, M);
      }
    });
  }
}
SDFTextSystem.queries = {
  entities: {
    components: [Text$1],
    listen: {
      added: !0,
      removed: !0,
      changed: [Text$1]
    }
  }
};
const Constants = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
async function fetchJsonFile(B) {
  const e = await fetch(B);
  if (e.ok)
    return e.json();
  throw new Error(e.statusText);
}
async function fetchProfilesList(B) {
  if (!B)
    throw new Error("No basePath supplied");
  return await fetchJsonFile(`${B}/profilesList.json`);
}
async function fetchProfile(B, e, b = null, L = !0) {
  if (!B)
    throw new Error("No xrInputSource supplied");
  if (!e)
    throw new Error("No basePath supplied");
  const M = await fetchProfilesList(e);
  let D;
  if (B.profiles.some((N) => {
    const U = M[N];
    return U && (D = {
      profileId: N,
      profilePath: `${e}/${U.path}`,
      deprecated: !!U.deprecated
    }), !!D;
  }), !D) {
    if (!b)
      throw new Error("No matching profile name found");
    const N = M[b];
    if (!N)
      throw new Error(`No matching profile name found and default profile "${b}" missing.`);
    D = {
      profileId: b,
      profilePath: `${e}/${N.path}`,
      deprecated: !!N.deprecated
    };
  }
  const I = await fetchJsonFile(D.profilePath);
  let F;
  if (L) {
    let N;
    if (B.handedness === "any" ? N = I.layouts[Object.keys(I.layouts)[0]] : N = I.layouts[B.handedness], !N)
      throw new Error(
        `No matching handedness, ${B.handedness}, in profile ${D.profileId}`
      );
    N.assetPath && (F = D.profilePath.replace("profile.json", N.assetPath));
  }
  return { profile: I, assetPath: F };
}
const defaultComponentValues = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: Constants.ComponentState.DEFAULT
};
function normalizeAxes(B = 0, e = 0) {
  let b = B, L = e;
  if (Math.sqrt(B * B + e * e) > 1) {
    const I = Math.atan2(e, B);
    b = Math.cos(I), L = Math.sin(I);
  }
  return {
    normalizedXAxis: b * 0.5 + 0.5,
    normalizedYAxis: L * 0.5 + 0.5
  };
}
class VisualResponse {
  constructor(e) {
    this.componentProperty = e.componentProperty, this.states = e.states, this.valueNodeName = e.valueNodeName, this.valueNodeProperty = e.valueNodeProperty, this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM && (this.minNodeName = e.minNodeName, this.maxNodeName = e.maxNodeName), this.value = 0, this.updateFromComponent(defaultComponentValues);
  }
  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent({
    xAxis: e,
    yAxis: b,
    button: L,
    state: M
  }) {
    const { normalizedXAxis: D, normalizedYAxis: I } = normalizeAxes(e, b);
    switch (this.componentProperty) {
      case Constants.ComponentProperty.X_AXIS:
        this.value = this.states.includes(M) ? D : 0.5;
        break;
      case Constants.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(M) ? I : 0.5;
        break;
      case Constants.ComponentProperty.BUTTON:
        this.value = this.states.includes(M) ? L : 0;
        break;
      case Constants.ComponentProperty.STATE:
        this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY ? this.value = this.states.includes(M) : this.value = this.states.includes(M) ? 1 : 0;
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
}
class Component {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(e, b) {
    if (!e || !b || !b.visualResponses || !b.gamepadIndices || Object.keys(b.gamepadIndices).length === 0)
      throw new Error("Invalid arguments supplied");
    this.id = e, this.type = b.type, this.rootNodeName = b.rootNodeName, this.touchPointNodeName = b.touchPointNodeName, this.visualResponses = {}, Object.keys(b.visualResponses).forEach((L) => {
      const M = new VisualResponse(b.visualResponses[L]);
      this.visualResponses[L] = M;
    }), this.gamepadIndices = Object.assign({}, b.gamepadIndices), this.values = {
      state: Constants.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
    };
  }
  get data() {
    return { id: this.id, ...this.values };
  }
  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(e) {
    if (this.values.state = Constants.ComponentState.DEFAULT, this.gamepadIndices.button !== void 0 && e.buttons.length > this.gamepadIndices.button) {
      const b = e.buttons[this.gamepadIndices.button];
      this.values.button = b.value, this.values.button = this.values.button < 0 ? 0 : this.values.button, this.values.button = this.values.button > 1 ? 1 : this.values.button, b.pressed || this.values.button === 1 ? this.values.state = Constants.ComponentState.PRESSED : (b.touched || this.values.button > Constants.ButtonTouchThreshold) && (this.values.state = Constants.ComponentState.TOUCHED);
    }
    this.gamepadIndices.xAxis !== void 0 && e.axes.length > this.gamepadIndices.xAxis && (this.values.xAxis = e.axes[this.gamepadIndices.xAxis], this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis, this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis, this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold && (this.values.state = Constants.ComponentState.TOUCHED)), this.gamepadIndices.yAxis !== void 0 && e.axes.length > this.gamepadIndices.yAxis && (this.values.yAxis = e.axes[this.gamepadIndices.yAxis], this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis, this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis, this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold && (this.values.state = Constants.ComponentState.TOUCHED)), Object.values(this.visualResponses).forEach((b) => {
      b.updateFromComponent(this.values);
    });
  }
}
class MotionController {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(e, b, L) {
    if (!e)
      throw new Error("No xrInputSource supplied");
    if (!b)
      throw new Error("No profile supplied");
    this.xrInputSource = e, this.assetUrl = L, this.id = b.profileId, this.layoutDescription = b.layouts[e.handedness], this.components = {}, Object.keys(this.layoutDescription.components).forEach((M) => {
      const D = this.layoutDescription.components[M];
      this.components[M] = new Component(M, D);
    }), this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const e = [];
    return Object.values(this.components).forEach((b) => {
      e.push(b.data);
    }), e;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach((e) => {
      e.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
}
const DEFAULT_PROFILES_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles", DEFAULT_PROFILE = "generic-trigger";
class XRControllerModel extends Object3D {
  constructor() {
    super(), this.motionController = null, this.envMap = null;
  }
  setEnvironmentMap(e) {
    return this.envMap == e ? this : (this.envMap = e, this.traverse((b) => {
      b.isMesh && (b.material.envMap = this.envMap, b.material.needsUpdate = !0);
    }), this);
  }
  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.motionController && (this.motionController.updateFromGamepad(), Object.values(this.motionController.components).forEach((b) => {
      Object.values(b.visualResponses).forEach((L) => {
        const { valueNode: M, minNode: D, maxNode: I, value: F, valueNodeProperty: N } = L;
        M && (N === Constants.VisualResponseProperty.VISIBILITY ? M.visible = F : N === Constants.VisualResponseProperty.TRANSFORM && (M.quaternion.slerpQuaternions(
          D.quaternion,
          I.quaternion,
          F
        ), M.position.lerpVectors(
          D.position,
          I.position,
          F
        )));
      });
    }));
  }
}
function findNodes(B, e) {
  Object.values(B.components).forEach((b) => {
    const { type: L, touchPointNodeName: M, visualResponses: D } = b;
    if (L === Constants.ComponentType.TOUCHPAD)
      if (b.touchPointNode = e.getObjectByName(M), b.touchPointNode) {
        const I = new SphereGeometry(1e-3), F = new MeshBasicMaterial({ color: 255 }), N = new Mesh(I, F);
        b.touchPointNode.add(N);
      } else
        console.warn(`Could not find touch dot, ${b.touchPointNodeName}, in touchpad component ${b.id}`);
    Object.values(D).forEach((I) => {
      const { valueNodeName: F, minNodeName: N, maxNodeName: U, valueNodeProperty: G } = I;
      if (G === Constants.VisualResponseProperty.TRANSFORM) {
        if (I.minNode = e.getObjectByName(N), I.maxNode = e.getObjectByName(U), !I.minNode) {
          console.warn(`Could not find ${N} in the model`);
          return;
        }
        if (!I.maxNode) {
          console.warn(`Could not find ${U} in the model`);
          return;
        }
      }
      I.valueNode = e.getObjectByName(F), I.valueNode || console.warn(`Could not find ${F} in the model`);
    });
  });
}
function addAssetSceneToControllerModel(B, e) {
  findNodes(B.motionController, e), B.envMap && e.traverse((b) => {
    b.isMesh && (b.material.envMap = B.envMap, b.material.needsUpdate = !0);
  }), B.add(e);
}
class XRControllerModelFactory {
  constructor(e = null) {
    this.gltfLoader = e, this.path = DEFAULT_PROFILES_PATH, this._assetCache = {}, this.gltfLoader || (this.gltfLoader = new GLTFLoader());
  }
  createControllerModel(e) {
    const b = new XRControllerModel();
    let L = null;
    return e.addEventListener("connected", (M) => {
      const D = M.data;
      D.targetRayMode !== "tracked-pointer" || !D.gamepad || fetchProfile(D, this.path, DEFAULT_PROFILE).then(({ profile: I, assetPath: F }) => {
        b.motionController = new MotionController(
          D,
          I,
          F
        );
        const N = this._assetCache[b.motionController.assetUrl];
        if (N)
          L = N.scene.clone(), addAssetSceneToControllerModel(b, L);
        else {
          if (!this.gltfLoader)
            throw new Error("GLTFLoader not set.");
          this.gltfLoader.setPath(""), this.gltfLoader.load(
            b.motionController.assetUrl,
            (U) => {
              this._assetCache[b.motionController.assetUrl] = U, L = U.scene.clone(), addAssetSceneToControllerModel(b, L);
            },
            null,
            () => {
              throw new Error(`Asset ${b.motionController.assetUrl} missing or malformed.`);
            }
          );
        }
      }).catch((I) => {
        console.warn(I);
      });
    }), e.addEventListener("disconnected", () => {
      b.motionController = null, b.remove(L), L = null;
    }), b;
  }
}
var controllerModelFactory = new XRControllerModelFactory();
class VRControllerSystem extends System {
  init() {
    this.world.registerComponent(VRController).registerComponent(VRControllerBasicBehaviour).registerComponent(ControllerConnected);
  }
  execute() {
    let e = this.queries.rendererContext.results[0].getComponent(
      WebGLRendererContext
    ).value;
    this.queries.controllers.added.forEach((b) => {
      let L = b.getComponent(VRController).id;
      var M = e.xr.getController(L);
      M.name = "controller";
      var D = new Group();
      if (D.add(M), b.addComponent(Object3DComponent, { value: D }), M.addEventListener("connected", () => {
        b.addComponent(ControllerConnected);
      }), M.addEventListener("disconnected", () => {
        b.removeComponent(ControllerConnected);
      }), b.hasComponent(VRControllerBasicBehaviour)) {
        var I = b.getComponent(VRControllerBasicBehaviour);
        Object.keys(I).forEach((N) => {
          I[N] && M.addEventListener(N, I[N]);
        });
      }
      let F = e.xr.getControllerGrip(L);
      F.add(
        controllerModelFactory.createControllerModel(F)
      ), F.name = "model", D.add(F);
    });
  }
}
VRControllerSystem.queries = {
  controllers: {
    components: [VRController],
    listen: {
      added: !0
      //changed: [Visible]
    }
  },
  rendererContext: {
    components: [WebGLRendererContext],
    mandatory: !0
  }
};
class AnimationMixerComponent extends Component$1 {
}
AnimationMixerComponent.schema = {
  value: { default: 0, type: Types.Number }
};
class AnimationActionsComponent extends Component$1 {
}
AnimationActionsComponent.schema = {
  animations: { default: [], type: Types.Array },
  duration: { default: 0, type: Types.Number }
};
class AnimationSystem extends System {
  init() {
    this.world.registerComponent(AnimationMixerComponent).registerComponent(AnimationActionsComponent);
  }
  execute(e) {
    this.queries.entities.added.forEach((b) => {
      let L = b.getComponent(GLTFModel).value, M = new AnimationMixer(L.scene);
      b.addComponent(AnimationMixerComponent, {
        value: M
      });
      let D = [];
      L.animations.forEach((I) => {
        const F = M.clipAction(I, L.scene);
        F.loop = LoopOnce, D.push(F);
      }), b.addComponent(AnimationActionsComponent, {
        animations: D,
        duration: b.getComponent(Animation).duration
      });
    }), this.queries.mixers.results.forEach((b) => {
      b.getComponent(AnimationMixerComponent).value.update(e);
    }), this.queries.playClips.results.forEach((b) => {
      let L = b.getComponent(AnimationActionsComponent);
      L.animations.forEach((M) => {
        L.duration !== -1 && M.setDuration(L.duration), M.clampWhenFinished = !0, M.reset(), M.play();
      }), b.removeComponent(Play);
    }), this.queries.stopClips.results.forEach((b) => {
      b.getComponent(AnimationActionsComponent).animations.forEach((M) => {
        M.reset(), M.stop();
      }), b.removeComponent(Stop);
    });
  }
}
AnimationSystem.queries = {
  entities: {
    components: [Animation, GLTFModel],
    listen: {
      added: !0
    }
  },
  mixers: {
    components: [AnimationMixerComponent]
  },
  playClips: {
    components: [AnimationActionsComponent, Play]
  },
  stopClips: {
    components: [AnimationActionsComponent, Stop]
  }
};
class InputSystem extends System {
  init() {
    //!!!!!!!!!!!!!
    this.world.registerComponent(InputState);
    let e = this.world.createEntity().addComponent(InputState);
    this.inputStateComponent = e.getMutableComponent(InputState);
  }
  execute() {
    this.processVRControllers();
  }
  processVRControllers() {
    this.queries.vrcontrollers.added.forEach((e) => {
      e.addComponent(VRControllerBasicBehaviour, {
        selectstart: (b) => {
          let L = this.inputStateComponent.vrcontrollers.get(b.target);
          L.selected = !0, L.prevSelected = !1;
        },
        selectend: (b) => {
          let L = this.inputStateComponent.vrcontrollers.get(b.target);
          L.selected = !1, L.prevSelected = !0;
        },
        connected: (b) => {
          this.inputStateComponent.vrcontrollers.set(b.target, {});
        },
        disconnected: (b) => {
          this.inputStateComponent.vrcontrollers.delete(b.target);
        }
      });
    }), this.inputStateComponent.vrcontrollers.forEach((e) => {
      e.selectStart = e.selected && !e.prevSelected, e.selectEnd = !e.selected && e.prevSelected, e.prevSelected = e.selected;
    });
  }
}
InputSystem.queries = {
  vrcontrollers: {
    components: [VRController],
    listen: {
      added: !0
    }
  }
};
class PositionalAudioPolyphonic extends Object3D {
  constructor(e, b) {
    super(), this.listener = e, this.context = e.context, this.poolSize = b || 5;
    for (var L = 0; L < this.poolSize; L++)
      this.children.push(new PositionalAudio(e));
  }
  setBuffer(e) {
    this.children.forEach((b) => {
      b.setBuffer(e);
    });
  }
  play() {
    var e = !1;
    for (let b = 0; b < this.children.length; b++) {
      let L = this.children[b];
      if (!L.isPlaying && L.buffer && !e) {
        L.play(), L.isPaused = !1, e = !0;
        continue;
      }
    }
    if (!e) {
      console.warn(
        "All the sounds are playing. If you need to play more sounds simultaneously consider increasing the pool size"
      );
      return;
    }
  }
}
class SoundSystem extends System {
  init() {
    this.listener = new AudioListener();
  }
  execute() {
    this.queries.sounds.added.forEach((e) => {
      const b = e.getMutableComponent(Sound), L = new PositionalAudioPolyphonic(this.listener, 10);
      new AudioLoader().load(b.url, (D) => {
        L.setBuffer(D);
      }), b.sound = L;
    });
  }
}
SoundSystem.queries = {
  sounds: {
    components: [Sound],
    listen: {
      added: !0,
      removed: !0,
      changed: !0
      // [Sound]
    }
  }
};
class LevelItem extends Component$1 {
}
class Level extends Component$1 {
}
Level.schema = {
  value: { default: 0, type: Types.Number }
};
class FloorCollided extends TagComponent {
}
class Cleared extends TagComponent {
}
class Element extends Component$1 {
}
Element.schema = {
  value: { default: 0, type: Types.Number },
  type: { default: 0, type: Types.Number }
};
class Rotating extends Component$1 {
}
Rotating.schema = {
  speed: {
    default: new Vector3(0, 0, 0),
    type: ThreeTypes.Vector3Type
  }
};
class Dissolve extends Component$1 {
}
Dissolve.schema = {
  speed: { default: 1, type: Types.Number },
  value: { default: 1, type: Types.Number }
};
class GameState extends Component$1 {
}
GameState.schema = {
  playing: { default: !1, type: Types.Boolean },
  prevPlaying: { default: !1, type: Types.Boolean },
  levelFinished: { default: !1, type: Types.Boolean },
  numBallsFailed: { default: 0, type: Types.Number },
  numBallsTotal: { default: 0, type: Types.Number },
  levelStartTime: { default: 0, type: Types.Number },
  gameStartTime: { default: 0, type: Types.Number }
};
class BallGenerator extends Component$1 {
}
BallGenerator.schema = {
  position: { default: new Vector3(), type: ThreeTypes.Vector3Type },
  linearVelocity: { default: new Vector3(), type: ThreeTypes.Vector3Type }
};
class Ball extends Component$1 {
}
Ball.schema = {
  radius: { default: 0.4, type: Types.Number },
  position: { default: new Vector3(), type: ThreeTypes.Vector3Type },
  linearVelocity: { default: new Vector3(), type: ThreeTypes.Vector3Type }
};
class Target extends Component$1 {
}
Target.schema = {
  position: { default: new Vector3(), type: ThreeTypes.Vector3Type }
};
class UI extends TagComponent {
}
class Button extends Component$1 {
}
Button.schema = {
  text: { default: "", type: Types.String },
  onClick: { default: null, type: Types.Ref }
};
class RaycastReceiver extends Component$1 {
}
RaycastReceiver.schema = {
  hovering: { default: !1, type: Types.Boolean },
  selecting: { default: !1, type: Types.Boolean },
  onHover: { default: null, type: Types.Ref },
  onEnter: { default: null, type: Types.Ref },
  onLeave: { default: null, type: Types.Ref },
  onSelectStart: { default: null, type: Types.Ref },
  onSelect: { default: null, type: Types.Ref },
  onSelectEnd: { default: null, type: Types.Ref },
  layerMask: { default: 0, type: Types.Number }
};
class Raycaster extends Component$1 {
}
Raycaster.schema = {
  enabled: { default: !0, type: Types.Boolean },
  currentEntity: { default: null, type: Types.Ref },
  layerMask: { default: 0, type: Types.Number },
  value: { default: null, type: Types.Ref }
};
class Floor extends TagComponent {
}
class Ad extends TagComponent {
}
const Components = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Active,
  Ad,
  Animation,
  AnimationSystem,
  Ball,
  BallGenerator,
  Button,
  Camera,
  CameraRig,
  CameraTagComponent,
  Cleared,
  Colliding,
  CollisionStart,
  CollisionStop,
  ControllerConnected,
  Dissolve,
  Draggable,
  Dragging,
  ECSYThreeSystem: System,
  ECSYThreeWorld,
  Element,
  Floor,
  FloorCollided,
  GLTFLoader: GLTFLoader$1,
  GLTFLoaderSystem,
  GLTFModel,
  GameState,
  Geometry,
  GeometrySystem,
  InputState,
  InputSystem,
  Level,
  LevelItem,
  MeshTagComponent,
  Object3DComponent,
  OnObject3DAdded,
  OnObject3DAddedSystem,
  Parent,
  ParentObject3D,
  Play,
  Position,
  RaycastReceiver,
  Raycaster,
  RenderPass,
  RigidBody,
  Rotating,
  Rotation,
  SDFTextSystem,
  Scale,
  Scene,
  SceneTagComponent,
  Shape,
  SkyBox,
  SkyBoxSystem,
  Sound,
  SoundSystem,
  Stop,
  Target,
  Text: Text$1,
  ThreeTypes,
  Transform,
  TransformSystem,
  Types,
  UI,
  UpdateAspectOnResizeSystem,
  UpdateAspectOnResizeTag,
  VRController,
  VRControllerBasicBehaviour,
  VRControllerSystem,
  Vector3Type,
  VisibilitySystem,
  Visible,
  WebGLRenderer,
  WebGLRendererContext,
  WebGLRendererSystem,
  defaultObject3DInflator,
  initialize
}, Symbol.toStringTag, { value: "Module" })), environmentMap = new TextureLoader().load(
  "assets/textures/env.jpg"
);
environmentMap.mapping = EquirectangularReflectionMapping;
environmentMap.encoding = sRGBEncoding;
environmentMap.flipY = !1;
const UIMaterial = new MeshBasicMaterial({
  map: new TextureLoader().load("assets/textures/ui.png"),
  transparent: !0
});
UIMaterial.map.encoding = sRGBEncoding;
UIMaterial.map.flipY = !1;
var textures = {};
const textureURLs = [
  "metal.jpg",
  "rubber.png",
  "wood.png",
  "floor.png",
  "target.png",
  "cannon.jpg",
  "ball.png",
  "wood_spec.jpg",
  "cannon_spec.jpg",
  "metal_spec.jpg"
];
for (let B = 0; B < textureURLs.length; B++) {
  let e = new TextureLoader().load(`assets/textures/${textureURLs[B]}`);
  e.encoding = sRGBEncoding, e.flipY = !1, textures[textureURLs[B]] = e;
}
var worldPos = new Vector3();
class TargetSystem extends System {
  init() {
    this.world.registerComponent(Rotating).registerComponent(Cleared);
  }
  execute() {
    var e = this.queries.balls.results, b = this.queries.targets.results;
    for (let F = 0; F < b.length; F++) {
      var L = b[F], M = L.getObject3D();
      let N = M.children[0];
      N.getWorldPosition(worldPos), N.geometry.boundingSphere || N.geometry.computeBoundingSphere();
      let U = N.geometry.boundingSphere.radius;
      for (let G = 0; G < e.length; G++) {
        var D = e[G], I = D.getObject3D();
        I.geometry.boundingSphere || I.geometry.computeBoundingSphere();
        let z = I.geometry.boundingSphere.radius + U;
        I.position.distanceToSquared(worldPos) <= z * z && (D.removeComponent(Active), L.addComponent(Rotating, { speed: new Vector3(0, 30, 0) }), L.addComponent(Cleared));
      }
    }
  }
}
TargetSystem.queries = {
  targets: { components: [Target, Object3DComponent] },
  balls: { components: [Ball, Active, Object3DComponent] }
};
const METAL = 0, RUBBER = 1, WOOD = 2, STATIC = 3, levels = [
  // 1
  {
    targets: [{
      position: { x: 0.7, y: 1, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: -0.7, y: 1, z: 0 },
      linearVelocity: { x: 2, y: 2, z: 0 }
    }],
    elements: [
      {
        type: RUBBER,
        position: { x: 0, y: 1.1, z: 0 },
        rotation: { x: 0, y: 0, z: Math.PI / 2 }
      }
    ]
  },
  // 2
  {
    targets: [{
      position: { x: 0.7, y: 0.7, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: -0.6, y: 1.2, z: 0 },
      linearVelocity: { x: 0.6, y: 2.8, z: 0 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: -0.3, y: 0.5, z: 0 },
        rotation: { x: -0.1, y: 0, z: -0.2 }
      },
      {
        type: WOOD,
        position: { x: 0.1, y: 0.75, z: -0.2 },
        rotation: { x: -0.3, y: 0.1, z: 1.1 }
      }
    ]
  },
  // 3
  {
    targets: [{
      position: { x: 0.5, y: 1.4, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: -0.5, y: 1, z: 0 },
      linearVelocity: { x: 1, y: -2, z: 0 }
    }],
    elements: [
      {
        type: METAL,
        position: { x: -0.1, y: 1, z: 0 },
        rotation: { x: 0.2, y: 0.3, z: 0 }
      },
      {
        type: RUBBER,
        position: { x: 0.4, y: 0.95, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.2, y: 1.5, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.4, y: 0.8, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 4
  {
    targets: [{
      position: { x: 0.6, y: 1.2, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: -0.7, y: 1, z: 0 },
      linearVelocity: { x: 2, y: -1, z: 0 }
    }],
    elements: [
      {
        type: METAL,
        position: { x: -0.5, y: 0.8, z: 0 },
        rotation: { x: 1.4, y: 1.4, z: -1.5 }
      },
      {
        type: RUBBER,
        position: { x: 0.5, y: 0.5, z: 0 },
        rotation: { x: -1.4, y: 1.4, z: 1.1 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.3, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.5, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.2, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 5
  {
    targets: [{
      position: { x: 0.5, y: 0.65, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: 0.1, y: 1.4, z: 0 },
      linearVelocity: { x: -3, y: 0.5, z: 0 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: 0.1, y: 0.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: RUBBER,
        position: { x: 1, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.22, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.22, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.44, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 6
  {
    targets: [{
      position: { x: 0.6, y: 1.6, z: 0 },
      rotation: { x: Math.PI / 2, y: 0.3, z: 0 }
    }],
    generators: [{
      position: { x: -1.4, y: 1, z: 0 },
      linearVelocity: { x: 2, y: 3, z: 0 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: 0.4, y: 0.5, z: 0 },
        rotation: { x: 0.08, y: 0, z: 0.2 }
      },
      {
        type: RUBBER,
        position: { x: 0.6, y: 0.7, z: 0 },
        rotation: { x: 0.3, y: 0, z: -0.1 }
      },
      {
        type: RUBBER,
        position: { x: -0.5, y: 0.96, z: 0 },
        rotation: { x: 0.5, y: 0, z: 0.7 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.8, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.2, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 7
  {
    targets: [{
      position: { x: 0, y: 1, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: 0.8, y: 1.7, z: 0 },
      linearVelocity: { x: -0.4, y: 3, z: 0 }
    }],
    elements: [
      {
        type: METAL,
        position: { x: -0.7, y: 1.5, z: 0 },
        rotation: { x: 0.2, y: 0, z: -0.3 }
      },
      {
        type: WOOD,
        position: { x: 0.6, y: 0.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0.6 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: 0 },
        rotation: { x: 0.1, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.4, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.4, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.2, y: 1.2, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.2, y: 0.8, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.2, y: 1.2, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.2, y: 0.8, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 8
  {
    targets: [{
      position: { x: -0.7, y: 0.8, z: 0 },
      rotation: { x: -0.1, y: -1.5, z: 2.2 }
    }],
    generators: [{
      position: { x: -0.1, y: 1.58, z: 0 },
      linearVelocity: { x: 3, y: 1, z: 0 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: 0.7, y: 1.3, z: 0 },
        rotation: { x: 0.1, y: 0, z: -0.2 }
      },
      {
        type: RUBBER,
        position: { x: 0.5, y: 0.7, z: 0 },
        rotation: { x: 0.1, y: -0.4, z: 0.7 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.8, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.2, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.8, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.6, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.2, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.8, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.4, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.8, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.6, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.2, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.8, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.4, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 9
  {
    targets: [{
      position: { x: 0.8, y: 0.7, z: -0.7 },
      rotation: { x: 2.6, y: 0.9, z: 3 }
    }],
    generators: [{
      position: { x: -1, y: 1.4, z: -0.2 },
      linearVelocity: { x: 2, y: 2, z: 1.5 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: -0.3, y: 0.8, z: 0.1 },
        rotation: { x: -0.1, y: 0.3, z: -0.2 }
      },
      {
        type: METAL,
        position: { x: 0.4, y: 1.3, z: 0 },
        rotation: { x: 0, y: 0.6, z: 0.1 }
      },
      {
        type: WOOD,
        position: { x: 0, y: 0.9, z: 0 },
        rotation: { x: -0.1, y: -0.1, z: -0.2 }
      },
      {
        type: STATIC,
        position: { x: 0.3, y: 0.5, z: -0.4 },
        rotation: { x: -0.1, y: -0.4, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.6, y: 1, z: 0.1 },
        rotation: { x: 0, y: 0.5, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.3, y: 1, z: -0.4 },
        rotation: { x: -0.1, y: 0.1, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.1, y: 0.9, z: -0.6 },
        rotation: { x: -0.1, y: -0.3, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.3, y: 1.3, z: -0.3 },
        rotation: { x: 0.1, y: -0.5, z: 0.1 }
      },
      {
        type: STATIC,
        position: { x: 0.5, y: 0.9, z: 0 },
        rotation: { x: 0, y: -0.7, z: -0.1 }
      },
      {
        type: STATIC,
        position: { x: 0.5, y: 0.8, z: -0.5 },
        rotation: { x: 0, y: 0.3, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.3, y: 1.5, z: -0.2 },
        rotation: { x: 0.1, y: 0.1, z: -0.1 }
      }
    ]
  },
  // 10
  {
    targets: [{
      position: { x: 1.2, y: 0.8, z: 0 },
      rotation: { x: 0, y: 1.5, z: 0 }
    }],
    generators: [{
      position: { x: -1.2, y: 1.7, z: 0 },
      linearVelocity: { x: 0.4, y: 1, z: -1.5 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: -0.4, y: 1.5, z: -0.4 },
        rotation: { x: 0.3, y: 0.1, z: -0.5 }
      },
      {
        type: WOOD,
        position: { x: 0.1, y: 0.7, z: -0.4 },
        rotation: { x: -0.2, y: -0.2, z: 0.2 }
      },
      {
        type: RUBBER,
        position: { x: -0.3, y: 0.8, z: 0 },
        rotation: { x: -0.1, y: 0.4, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.3, y: 1.2, z: -0.4 },
        rotation: { x: 0.1, y: -0.1, z: -0.1 }
      },
      {
        type: STATIC,
        position: { x: 0.8, y: 1, z: -0.4 },
        rotation: { x: 0, y: -0.8, z: 0.1 }
      },
      {
        type: STATIC,
        position: { x: -0.5, y: 0.9, z: -0.2 },
        rotation: { x: -0.1, y: 0.4, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.6, y: 0.8, z: -0.1 },
        rotation: { x: 0, y: -0.8, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.1, y: 1, z: -0.8 },
        rotation: { x: 0, y: -0.4, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.3, y: 1, z: -0.4 },
        rotation: { x: 0, y: -0.5, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: -0.6 },
        rotation: { x: 0.2, y: -0.3, z: 0.1 }
      },
      {
        type: STATIC,
        position: { x: -0.6, y: 1.2, z: -0.2 },
        rotation: { x: 0.1, y: 0.4, z: -0.2 }
      },
      {
        type: STATIC,
        position: { x: 0.4, y: 1.2, z: 0.1 },
        rotation: { x: 0, y: -0.3, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.9, y: 1.5, z: -0.7 },
        rotation: { x: 0, y: 0.2, z: -0.1 }
      },
      {
        type: STATIC,
        position: { x: -0.5, y: 1.1, z: 0.2 },
        rotation: { x: 0.1, y: 0.8, z: -0.2 }
      },
      {
        type: STATIC,
        position: { x: -0.5, y: 1.2, z: -0.8 },
        rotation: { x: 0.1, y: -0.1, z: -0.1 }
      },
      {
        type: STATIC,
        position: { x: 0.7, y: 0.7, z: 0.3 },
        rotation: { x: 0.1, y: -1.1, z: 0.2 }
      }
    ]
  }
];
class GameStateSystem extends System {
  setVisibilityByName(e, b) {
    let L = this.world.entityManager.getEntityByName(e);
    L && (L.getMutableComponent(Visible).value = b);
  }
  finish() {
    this.stopGame(), this.setVisibilityByName("startbutton", !0), this.setVisibilityByName("finished", !0), this.setVisibilityByName("playingGroup", !1), this.world.getSystem(LevelManager).clearCurrentLevel(), this.world.entityManager.getEntityByName("singleton").getMutableComponent(Level).value = 1, this.queries.raycasters.results.forEach((L) => {
      L.getMutableComponent(Raycaster).layerMask = 4;
    });
    let e = this.world.entityManager.getEntityByName("panelInfo");
    e.addComponent(Play);
    let b = e.getObject3D().children[0];
    b.userData.oldPosition || (b.userData.oldPosition = new Vector3()), b.userData.oldPosition.copy(b.position), b.position.set(0, 1.6, -2), b.scale.set(3, 3, 3);
  }
  playGame() {
    let e = this.queries.gameState.results[0].getMutableComponent(
      GameState
    );
    if (e.playing)
      return;
    this.setVisibilityByName("help", !1), this.setVisibilityByName("startbutton", !1), this.setVisibilityByName("finished", !1), this.setVisibilityByName("zestyBanner", !1), this.setVisibilityByName("newsPanel", !1), this.setVisibilityByName("adText", !1), this.setVisibilityByName("newsText", !1), this.setVisibilityByName("futureUpdateText", !1), this.setVisibilityByName("playingGroup", !0), this.setVisibilityByName("panelInfo", !0), this.queries.raycasters.results.forEach((M) => {
      M.getMutableComponent(Raycaster).layerMask = 2;
    }), e.playing = !0, e.numBallsFailed = 0, e.numBallsTotal = 0, e.levelStartTime = performance.now(), e.gameStartTime = performance.now(), this.updateTexts(e), this.queries.ballGenerators.results.forEach((M) => {
      M.addComponent(Active);
    });
    let b = this.world.entityManager.getEntityByName("panelInfo");
    b.addComponent(Stop);
    let L = b.getComponent(Object3DComponent);
    L && (L = L.value.children[0], L.userData.oldPosition && L.position.copy(L.userData.oldPosition), L.scale.set(1, 1, 1)), this.world.getSystem(PhysicsSystem).play();
  }
  updateTexts(e) {
    let b = this.world.entityManager.getEntityByName("numberBalls");
    b && (b.getMutableComponent(
      Text$1
    ).text = `${e.numBallsFailed}/${e.numBallsTotal}`);
  }
  stopGame() {
    this.queries.gameState.results[0].getMutableComponent(
      GameState
    ).playing = !1;
  }
  isPlaying() {
    return this.queries.gameState.results[0].getMutableComponent(
      GameState
    ).playing;
  }
  execute() {
    var e = this.queries.gameState.results[0].getComponent(GameState);
    if (!e.playing)
      return;
    let b = performance.now() - e.levelStartTime, L = performance.now() - e.gameStartTime, M = this.world.entityManager.getEntityByName("singleton"), D = this.world.entityManager.getEntityByName("timer");
    D && (D.getMutableComponent(Text$1).text = new Date(b).toISOString().substr(14, 5));
    let I = this.world.entityManager.getEntityByName("timerTotal");
    I && (I.getMutableComponent(Text$1).text = new Date(L).toISOString().substr(14, 5)), this.queries.ballFloorCollided.added.forEach((F) => {
      e.numBallsFailed++, this.world.entityManager.getEntityByName("numberBalls").getMutableComponent(
        Text$1
      ).text = `${e.numBallsFailed}`;
      let N = M.getComponent(Level).value;
      this.queries.ballGenerators.results.forEach((U) => {
        U.addComponent(Play);
      }), setTimeout(() => {
        M.getComponent(Level).value === N && this.queries.ballGenerators.results.forEach((U) => {
          U.addComponent(Active);
        });
      }, 1900), setTimeout(() => {
        !F || !F.alive || M.getComponent(Level).value;
      }, 2e3), F.addComponent(Dissolve);
    }), this.queries.targetCleared.added.forEach((F) => {
      F.getComponent(Sound).sound.play(), setTimeout(() => {
        var N = M.getMutableComponent(Level);
        N.value === levels.length - 1 ? (N.value = 1, this.finish()) : (N.value++, e.levelStartTime = performance.now(), e.levelFinished = !1);
      }, 2e3), e.levelFinished = !0;
    });
  }
}
GameStateSystem.queries = {
  ballGenerators: { components: [BallGenerator] },
  gameState: {
    components: [GameState],
    listen: {
      changed: !0
    }
  },
  ballFloorCollided: {
    components: [Ball, FloorCollided],
    listen: {
      added: !0
    }
  },
  targetCleared: {
    components: [Target, Cleared],
    listen: {
      added: !0
    }
  },
  raycasters: {
    components: [Raycaster]
  }
};
const RADIUS = 0.03;
class BallGeneratorSystem extends System {
  execute() {
    this.queries.entities.added.forEach((e) => {
      let b = e.getComponent(Sound);
      b.sound && b.sound.play();
      var L = e.getComponent(BallGenerator), M = this.world.createEntity();
      M.addComponent(GLTFLoader$1, {
        url: "assets/models/ball.glb",
        onLoaded: (D) => {
          M.getMutableComponent(Object3DComponent).value = D.children[0], D.children[0].material = new THREE.MeshPhongMaterial({
            map: textures["ball.png"],
            envMap: environmentMap,
            reflectivity: 0.2
          });
        }
      }).addComponent(Transform, {
        position: L.position,
        rotation: { x: 0, y: 0, z: 0 }
      }).addComponent(Shape, {
        primitive: "sphere",
        radius: RADIUS
      }).addComponent(RigidBody, {
        weight: 10,
        restitution: 0.5,
        friction: 0.5,
        linearDamping: 0,
        angularDamping: 0,
        linearVelocity: L.linearVelocity
      }).addComponent(LevelItem).addComponent(Ball, {
        position: L.position,
        radius: RADIUS,
        linearVelocity: L.linearVelocity
      }).addComponent(Active).addComponent(Parent, {
        value: this.world.entityManager.getEntityByName("playingGroup")
      }), e.removeComponent(Active);
    });
  }
}
BallGeneratorSystem.queries = {
  entities: {
    components: [BallGenerator, Active],
    listen: {
      added: !0
    }
  }
};
class DissolveSystem extends System {
  execute(e) {
    var b = this.queries.entities.results;
    for (let I = 0; I < b.length; I++) {
      var L = b[I], M = L.getMutableComponent(Dissolve), D = L.getObject3D();
      D.material && (D.material.opacity = M.value, D.material.transparent = !0, M.value -= e * M.speed, M.value <= 0 && L.remove());
    }
  }
}
DissolveSystem.queries = {
  entities: {
    components: [Ball, Dissolve, Object3DComponent],
    listen: {
      added: !0
    }
  }
};
class RotatingSystem extends System {
  execute(e) {
    this.queries.entities.results.forEach((b) => {
      var L = b.getComponent(Rotating), M = b.getObject3D();
      M.rotation.x += L.speed.x * e, M.rotation.y += L.speed.y * e, M.rotation.z += L.speed.z * e;
    });
  }
}
RotatingSystem.queries = {
  entities: {
    components: [Object3DComponent, Rotating]
  }
};
const urlParams$2 = new URLSearchParams(window.location.search);
var editMode$1 = urlParams$2.has("edit");
const elementTypes = [
  {
    model: "metal",
    restitution: 1.7,
    draggable: !0,
    scale: 1,
    sound: "metal.ogg",
    material: new MeshPhongMaterial({
      map: textures["metal.jpg"],
      envMap: environmentMap,
      specularMap: textures["metal_spec.jpg"],
      shininess: 70,
      specular: new Color(8947848),
      reflectivity: 0.7
    })
  },
  {
    model: "rubber",
    restitution: 2.5,
    draggable: !0,
    scale: 1,
    sound: "rubber.ogg",
    material: new MeshPhongMaterial({
      map: textures["rubber.png"],
      envMap: environmentMap,
      shininess: 10,
      specular: new Color(400159),
      reflectivity: 0.1
    })
  },
  {
    model: "wood",
    restitution: 1,
    draggable: !0,
    scale: 1,
    sound: "wood.ogg",
    material: new MeshPhongMaterial({
      map: textures["wood.png"],
      envMap: environmentMap,
      specularMap: textures["wood_spec.jpg"],
      shininess: 20,
      specular: new Color(6710886),
      reflectivity: 0.5
    })
  },
  {
    model: "static",
    restitution: 0.05,
    draggable: editMode$1,
    scale: 0.2,
    sound: "",
    material: new MeshLambertMaterial({
      map: textures["floor.png"]
    })
  }
];
class ElementSystem extends System {
  execute() {
    var e = this.queries.entities.added;
    for (let L = 0; L < e.length; L++) {
      let M = e[L];
      var b = M.getComponent(Element);
      const D = elementTypes[b.type];
      M.addComponent(GLTFLoader$1, {
        url: "assets/models/" + D.model + ".glb",
        onLoaded: (I) => {
          let F = I.children[0], N = F.geometry;
          D.scale && (N.scale(D.scale, D.scale, D.scale), N.computeBoundingBox());
          let U = N.boundingBox.min, G = N.boundingBox.max, V = Math.abs(G.x - U.x), z = Math.abs(G.y - U.y), k = Math.abs(G.z - U.z);
          F.material = D.material.clone(), M.addComponent(Shape, {
            primitive: "box",
            width: V,
            height: z,
            depth: k
          }), M.addComponent(Sound, {
            url: "assets/sounds/" + D.sound
          });
        }
      }).addComponent(RigidBody, {
        weight: 0,
        restitution: D.restitution,
        friction: 0.5,
        linearDamping: 0,
        angularDamping: 0
      }), D.draggable && M.addComponent(Draggable);
    }
    this.queries.colliding.results.forEach((L) => {
      let M = L.getComponent(Colliding), D = L.hasComponent(Ball), I = D ? L : M.collidingWith[0], F = D ? M.collidingWith[0] : L;
      F.hasComponent(Floor) ? I.hasComponent(Active) && (F.getComponent(Sound).sound.play(), I.removeComponent(Active), I.addComponent(FloorCollided)) : F.hasComponent(Sound) && F.getComponent(Sound).sound.play();
    });
  }
}
ElementSystem.queries = {
  entities: {
    components: [Element],
    listen: {
      added: !0
    }
  },
  colliding: {
    components: [CollisionStart]
  }
};
class OutputSystem extends System {
  trimDecimals(e) {
    e.x = Math.floor(e.x * 10) / 10, e.y = Math.floor(e.y * 10) / 10, e.z = Math.floor(e.z * 10) / 10;
  }
  outputJSON() {
    var e = {
      targets: [],
      generators: [],
      elements: []
    };
    this.queries.elements.results.forEach((b) => {
      var L = {}, M = b.getComponent(Element);
      L.type = M.type;
      var D = b.getObject3D();
      L.position = JSON.parse(JSON.stringify(D.position)), L.rotation = {
        x: D.rotation._x,
        y: D.rotation._y,
        z: D.rotation._z
      }, this.trimDecimals(L.position), this.trimDecimals(L.rotation), e.elements.push(L);
    }), this.queries.targets.results.forEach((b) => {
      var L = {}, M = b.getObject3D();
      L.position = JSON.parse(JSON.stringify(M.position)), L.rotation = {
        x: M.rotation._x,
        y: M.rotation._y,
        z: M.rotation._z
      }, this.trimDecimals(L.position), this.trimDecimals(L.rotation), e.targets.push(L);
    }), this.queries.generators.results.forEach((b) => {
      var L = {}, M = b.getComponent(BallGenerator), D = b.getObject3D();
      L.position = JSON.parse(JSON.stringify(D.position)), L.linearVelocity = M.linearVelocity, this.trimDecimals(L.position), this.trimDecimals(L.linearVelocity), e.generators.push(L);
    }), console.log(JSON.stringify(e, null, 2));
  }
  execute() {
  }
}
OutputSystem.queries = {
  elements: { components: [Element] },
  targets: { components: [Target] },
  generators: { components: [BallGenerator] }
};
const urlParams$1 = new URLSearchParams(window.location.search);
var editMode = urlParams$1.has("edit");
class LevelManager extends System {
  execute() {
    this.queries.levels.added.forEach((e) => {
      this.initializeLevel(e.getComponent(Level).value);
    }), this.queries.levels.changed.forEach((e) => {
      this.initializeLevel(e.getComponent(Level).value);
    });
  }
  clearCurrentLevel() {
    for (var e = this.queries.levelItems.results, b = e.length - 1; b >= 0; b--)
      e[b].remove();
  }
  initializeLevel(e) {
    e > levels.length && (e = 0);
    let b = this.world.entityManager.getEntityByName("level");
    b && (b.getMutableComponent(Text$1).text = e);
    let L = this.world.entityManager.getEntityByName("levelGroup");
    this.clearCurrentLevel();
    var M = levels[e];
    let D = this.world.entityManager.getEntityByName("singleton");
    M.generators.forEach((I) => {
      let F = new Vector3().copy(I.linearVelocity).normalize(), N = this.world.createEntity().addComponent(BallGenerator, {
        position: I.position,
        linearVelocity: I.linearVelocity
      }).addComponent(GLTFLoader$1, {
        url: "assets/models/cannon.glb",
        onLoaded: (U, G) => {
          U.lookAt(F), U.getObjectByName(
            "cannon"
          ).material = new MeshPhongMaterial({
            map: textures["cannon.jpg"],
            envMap: environmentMap,
            reflectivity: 0.2,
            specularMap: textures["cannon_spec.jpg"],
            shininess: 50,
            specular: new Color(3355443)
          });
          var V = new MeshBasicMaterial({ color: 15188515 });
          U.getObjectByName("explosion").material = V, U.getObjectByName("sparks").material = V;
          let z = U.userData.mixer = new AnimationMixer(
            U
          );
          const k = AnimationClip.findByName(
            G.animations,
            "cannonAction"
          ), H = z.clipAction(k, U);
          U.userData.animationClip = H;
        }
      }).addComponent(Animation, { duration: 2.35 }).addComponent(Sound, { url: "assets/sounds/cannon.ogg" }).addComponent(Position, {
        value: new Vector3().copy(I.position)
      }).addComponent(LevelItem).addComponent(Parent, { value: L });
      editMode && N.addComponent(Draggable), D.getComponent(GameState).playing && setTimeout(() => {
        N.addComponent(Play), setTimeout(() => {
          N.addComponent(Active);
        }, 1900);
      }, 2e3);
    }), M.targets.forEach((I) => {
      let F = this.world.createEntity().addComponent(Target).addComponent(GLTFLoader$1, {
        url: "assets/models/target.glb",
        onLoaded: (N) => {
          N.children[0].material = new MeshPhongMaterial({
            map: textures["target.png"],
            envMap: environmentMap,
            reflectivity: 0.2
          });
        }
      }).addComponent(Transform, {
        position: I.position,
        rotation: I.rotation
      }).addComponent(LevelItem).addComponent(Parent, { value: L }).addComponent(Sound, { url: "assets/sounds/target.ogg" });
      editMode && F.addComponent(Draggable);
    }), M.elements.forEach((I) => {
      this.world.createEntity().addComponent(Element, { type: I.type }).addComponent(Transform, {
        position: I.position,
        rotation: I.rotation
      }).addComponent(LevelItem).addComponent(Parent, { value: L });
    });
  }
}
LevelManager.queries = {
  /* @todo singleton */
  levels: {
    components: [Level],
    listen: {
      added: !0,
      changed: !0
    }
  },
  levelItems: {
    components: [LevelItem]
  }
};
class CameraRigSystem extends System {
  init() {
    window.addEventListener("resize", this.onWindowResize.bind(this), !1);
  }
  execute() {
    this.queries.entities.added.forEach((e) => {
      var b = new Group();
      e.addComponent(Object3DComponent, { value: b }).addComponent(Position, { value: new Vector3(0, 0, 0.5) }), this.world.entityManager.queryComponents([
        Camera,
        Active
      ]).entities.forEach((M) => {
        M.removeComponent(Active);
      }), this.world.createEntity().addComponent(Position, {
        value: new Vector3(0, 1.6, -0.6)
      }).addObject3DComponent(
        new PerspectiveCamera(
          90,
          window.innerWidth / window.innerHeight,
          0.1,
          500
        ),
        e
      ).addComponent(UpdateAspectOnResizeTag).addComponent(Active), this.world.createEntity().addComponent(VRController, { id: 0 }).addComponent(Parent, { value: e }), this.world.createEntity().addComponent(VRController, { id: 1 }).addComponent(Parent, { value: e });
    });
  }
  onWindowResize() {
    this.queries.entities.results.forEach((e) => {
    });
  }
}
CameraRigSystem.queries = {
  entities: {
    components: [CameraRig],
    listen: {
      added: !0
    }
  }
};
var raycaster = new Raycaster$1(), tempMatrix = new Matrix4(), intersected = [];
function setEmisive(B, e, b) {
  B.traverse((L) => {
    L.material && L.material.emissive && (b ? L.material.emissive[b] = e : L.material.emissive.set(e));
  });
}
class VRControllerInteraction extends System {
  execute() {
    this.queries.dragging.results.forEach((e) => {
      this.reposition(e.getObject3D(), !0);
    }), this.queries.objects.added.forEach((e) => {
      let b = e.getObject3D().children[0];
      e.addComponent(RaycastReceiver, {
        layerMask: 2,
        onHover: (L, M) => {
          let I = M.getObject3D().getObjectByName("line");
          I.scale.z = L.distance;
        },
        onEnter: () => {
          setEmisive(b, 2245717);
        },
        onLeave: (L) => {
          let D = L.getObject3D().getObjectByName("line");
          D.scale.z = 10, setEmisive(b, 0);
        },
        onSelectStart: this.onSelectStart.bind(this)
      });
    }), this.world.getSystem(InputSystem).inputStateComponent.vrcontrollers.forEach((e, b) => {
      e.selectEnd && this.onSelectEnd(b);
    }), this.queries.controllers.added.forEach((e) => {
      e.addComponent(Raycaster, {
        value: raycaster,
        layerMask: 4
      });
      var b = new BufferGeometry().setFromPoints([
        new Vector3(0, 0, 0),
        new Vector3(0, 0, -1)
      ]), L = new Line(b);
      L.name = "line", L.scale.z = 5;
      let M = e.getObject3D().getObjectByName("controller");
      this.world.createEntity().addComponent(Object3DComponent, { value: L }).addComponent(ParentObject3D, { value: M });
    }), this.cleanIntersected();
  }
  onSelectStart(e, b) {
    var L = b;
    tempMatrix.getInverse(L.matrixWorld);
    var M = e.object.parent;
    M.matrix.premultiply(tempMatrix), M.matrix.decompose(M.position, M.quaternion, M.scale), setEmisive(M, 1, "b"), M.userData.previousParent = M.parent, L.add(M), M.children[0].material.transparent = !0, M.children[0].renderOrder = 20, M.children[0].material.opacity = 0.5, L.userData.selected = M, this.disablePhysics(M);
  }
  onSelectEnd(e) {
    if (e.userData.selected !== void 0) {
      var b = e.userData.selected;
      b.children[0].material.transparent = !1, b.userData.entity.removeComponent(Dragging), b.matrix.premultiply(e.matrixWorld), b.matrix.decompose(b.position, b.quaternion, b.scale), setEmisive(b, 0, "b"), b.userData.previousParent.add(b), e.userData.selected = void 0, this.reposition(b);
    }
  }
  disablePhysics(e) {
    const b = new Ammo.btTransform();
    b.setIdentity(), b.setOrigin(new Ammo.btVector3(0, -10, 0)), e.userData.body.setWorldTransform(b);
  }
  reposition(e, b) {
    if (e.userData.body)
      if (b) {
        var L = new Vector3(), M = new Vector3(), D = new Quaternion();
        e.updateWorldMatrix(!0), e.matrixWorld.decompose(L, D, M);
        var I = e.userData.body.getWorldTransform();
        I.setIdentity();
        const F = new Ammo.btTransform();
        F.setIdentity(), F.setOrigin(
          new Ammo.btVector3(L.x, L.y, L.z)
        ), F.setRotation(
          new Ammo.btQuaternion(
            D.x,
            D.y,
            D.z,
            D.w
          )
        ), e.userData.body.setWorldTransform(F);
      } else {
        const F = new Ammo.btTransform();
        F.setIdentity(), F.setOrigin(
          new Ammo.btVector3(
            e.position.x,
            e.position.y,
            e.position.z
          )
        ), F.setRotation(
          new Ammo.btQuaternion(
            e.quaternion.x,
            e.quaternion.y,
            e.quaternion.z,
            e.quaternion.w
          )
        ), e.userData.body.setWorldTransform(F);
      }
  }
  cleanIntersected() {
    for (; intersected.length; ) {
      var e = intersected.pop();
      e.material.emissive.r = 0;
    }
  }
}
VRControllerInteraction.queries = {
  controllers: {
    components: [VRController],
    listen: {
      added: !0
    }
  },
  objects: {
    components: [Draggable, Object3DComponent],
    listen: {
      added: !0
    }
  },
  dragging: { components: [Dragging] },
  rendererContext: {
    components: [WebGLRendererContext],
    mandatory: !0
  }
};
var quaternion = new Quaternion(), euler = new Euler();
class PhysicsSystem extends System {
  init() {
    this.epsilon = 1e-5, this.collisions = /* @__PURE__ */ new Map(), this.collisionKeys = [], this.frame = 0, this._physicsWorld = this._createWorld(), this._transform = new Ammo.btTransform(), this._quaternion = new Ammo.btQuaternion(0, 0, 0, 1), this.bodyToEntity = /* @__PURE__ */ new Map();
  }
  execute(e) {
    this.frame++, this.queries.entities.added.forEach((M) => {
      var D = M.getObject3D();
      const I = this._setupRigidBody(this._createRigidBody(M), M);
      I.setCcdMotionThreshold(0.01), I.setCcdSweptSphereRadius(0.01), I.Object3DComponent = D, D.userData.body = I, this._physicsWorld.addRigidBody(I);
    }), this._physicsWorld.stepSimulation(e, 4, 1 / 60), this.queries.collisionsStart.results.forEach((M) => {
      M.removeComponent(CollisionStart);
    });
    const b = this.dispatcher.getNumManifolds();
    for (let M = 0; M < b; M++) {
      const D = this.dispatcher.getManifoldByIndexInternal(M), I = D.getNumContacts(), F = Ammo.getPointer(D.getBody0()), N = Ammo.getPointer(D.getBody1());
      for (let U = 0; U < I; U++)
        if (D.getContactPoint(U).getDistance() <= this.epsilon) {
          let z = this.bodyToEntity.get(F), k = this.bodyToEntity.get(N);
          z.hasComponent(Colliding) || (z.addComponent(Colliding, { collidingFrame: this.frame }), z.addComponent(CollisionStart));
          let H = z.getMutableComponent(Colliding);
          H.collidingWith.indexOf(k) === -1 && H.collidingWith.push(k);
          break;
        }
    }
    const L = this.queries.entities.results;
    for (let M = 0, D = L.length; M < D; M++) {
      const I = L[M];
      if (I.getComponent(RigidBody).weight === 0) continue;
      const N = I.getObject3D(), U = N.userData.body;
      if (U.isActive() && U.getMotionState()) {
        const G = this._transform, V = this._quaternion;
        U.getMotionState().getWorldTransform(G);
        const z = G.getOrigin();
        G.getBasis().getRotation(V), N.position.set(z.x(), z.y(), z.z()), N.quaternion.set(V.x(), V.y(), V.z(), V.w());
        let k = I.getMutableComponent(Transform);
        k.position.copy(N.position), k.rotation.copy(N.rotation);
      }
    }
    this.queries.entities.removed.forEach((M) => {
      this._removeRigidBody(M);
    }), this.queries.collisionsStop.results.forEach((M) => {
      M.removeComponent(CollisionStop);
    }), this.queries.collisions.results.forEach((M) => {
      M.getComponent(Colliding).collidingFrame !== this.frame && (M.removeComponent(Colliding), M.addComponent(CollisionStop));
    });
  }
  _removeRigidBody(e) {
    var b = e.getRemovedComponent(Object3DComponent);
    if (b) {
      let M = b.value;
      var L = M.userData.body;
      this._physicsWorld.removeRigidBody(L), this.bodyToEntity.delete(Ammo.getPointer(L)), Ammo.destroy(L), delete M.userData.body;
    } else
      console.warn(">>>>>>>>>>>>>>> Not found");
  }
  _createWorld() {
    const e = new Ammo.btDefaultCollisionConfiguration();
    this.dispatcher = new Ammo.btCollisionDispatcher(e);
    const b = new Ammo.btDbvtBroadphase(), L = new Ammo.btSequentialImpulseConstraintSolver(), M = new Ammo.btDiscreteDynamicsWorld(
      this.dispatcher,
      b,
      L,
      e
    );
    return M.setGravity(new Ammo.btVector3(0, -9.8, 0)), M;
  }
  _createShape(e) {
    var b = e.getComponent(Shape);
    return b.primitive === "box" ? new Ammo.btBoxShape(
      new Ammo.btVector3(b.width / 2, b.height / 2, b.depth / 2)
    ) : b.primitive === "sphere" ? new Ammo.btSphereShape(b.radius) : new Ammo.btBoxShape(new Ammo.btVector3(1, 1, 1));
  }
  _createRigidBody(e) {
    const b = e.getComponent(RigidBody), L = e.getComponent(Transform), M = this._createShape(e), D = new Ammo.btVector3(0, 0, 0);
    M.calculateLocalInertia(b.weight, D);
    const I = new Ammo.btTransform();
    I.setIdentity(), I.setOrigin(
      new Ammo.btVector3(
        L.position.x,
        L.position.y,
        L.position.z
      )
    ), euler.set(L.rotation.x, L.rotation.y, L.rotation.z), quaternion.setFromEuler(euler), I.setRotation(
      new Ammo.btQuaternion(
        quaternion.x,
        quaternion.y,
        quaternion.z,
        quaternion.w
      )
    );
    const F = new Ammo.btDefaultMotionState(I), N = new Ammo.btRigidBodyConstructionInfo(
      b.weight,
      F,
      M,
      D
    );
    var U = new Ammo.btRigidBody(N);
    return this.bodyToEntity.set(Ammo.getPointer(U), e), U;
  }
  _setupRigidBody(e, b) {
    const L = b.getComponent(RigidBody), M = L.linearVelocity;
    return e.setRestitution(L.restitution), e.setFriction(L.friction), e.setDamping(L.linearDamping, L.angularDamping), e.setSleepingThresholds(0, 0), e.setLinearVelocity(
      new Ammo.btVector3(M.x, M.y, M.z)
    ), e;
  }
}
PhysicsSystem.queries = {
  entities: {
    components: [RigidBody, Shape, Object3DComponent],
    listen: {
      added: !0,
      removed: !0
    }
  },
  collisions: {
    components: [Colliding],
    listen: {
      added: !0
    }
  },
  collisionsStart: {
    components: [CollisionStart],
    listen: {
      added: !0
    }
  },
  collisionsStop: {
    components: [CollisionStop],
    listen: {
      added: !0
    }
  }
};
var version = "18.4.2", _Group = function() {
  this._tweens = {}, this._tweensAddedDuringUpdate = {};
};
_Group.prototype = {
  getAll: function() {
    return Object.keys(this._tweens).map((function(B) {
      return this._tweens[B];
    }).bind(this));
  },
  removeAll: function() {
    this._tweens = {};
  },
  add: function(B) {
    this._tweens[B.getId()] = B, this._tweensAddedDuringUpdate[B.getId()] = B;
  },
  remove: function(B) {
    delete this._tweens[B.getId()], delete this._tweensAddedDuringUpdate[B.getId()];
  },
  update: function(B, e) {
    var b = Object.keys(this._tweens);
    if (b.length === 0)
      return !1;
    for (B = B !== void 0 ? B : TWEEN.now(); b.length > 0; ) {
      this._tweensAddedDuringUpdate = {};
      for (var L = 0; L < b.length; L++) {
        var M = this._tweens[b[L]];
        M && M.update(B) === !1 && (M._isPlaying = !1, e || delete this._tweens[b[L]]);
      }
      b = Object.keys(this._tweensAddedDuringUpdate);
    }
    return !0;
  }
};
var TWEEN = new _Group();
TWEEN.Group = _Group;
TWEEN._nextId = 0;
TWEEN.nextId = function() {
  return TWEEN._nextId++;
};
typeof self > "u" && typeof process < "u" && process.hrtime ? TWEEN.now = function() {
  var B = process.hrtime();
  return B[0] * 1e3 + B[1] / 1e6;
} : typeof self < "u" && self.performance !== void 0 && self.performance.now !== void 0 ? TWEEN.now = self.performance.now.bind(self.performance) : Date.now !== void 0 ? TWEEN.now = Date.now : TWEEN.now = function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
TWEEN.Tween = function(B, e) {
  this._isPaused = !1, this._pauseStart = null, this._object = B, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._repeat = 0, this._repeatDelayTime = void 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = null, this._easingFunction = TWEEN.Easing.Linear.None, this._interpolationFunction = TWEEN.Interpolation.Linear, this._chainedTweens = [], this._onStartCallback = null, this._onStartCallbackFired = !1, this._onUpdateCallback = null, this._onRepeatCallback = null, this._onCompleteCallback = null, this._onStopCallback = null, this._group = e || TWEEN, this._id = TWEEN.nextId();
};
TWEEN.Tween.prototype = {
  getId: function() {
    return this._id;
  },
  isPlaying: function() {
    return this._isPlaying;
  },
  isPaused: function() {
    return this._isPaused;
  },
  to: function(B, e) {
    return this._valuesEnd = Object.create(B), e !== void 0 && (this._duration = e), this;
  },
  duration: function B(e) {
    return this._duration = e, this;
  },
  start: function(B) {
    this._group.add(this), this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._startTime = B !== void 0 ? typeof B == "string" ? TWEEN.now() + parseFloat(B) : B : TWEEN.now(), this._startTime += this._delayTime;
    for (var e in this._valuesEnd) {
      if (this._valuesEnd[e] instanceof Array) {
        if (this._valuesEnd[e].length === 0)
          continue;
        this._valuesEnd[e] = [this._object[e]].concat(this._valuesEnd[e]);
      }
      this._object[e] !== void 0 && (typeof this._valuesStart[e] > "u" && (this._valuesStart[e] = this._object[e]), this._valuesStart[e] instanceof Array || (this._valuesStart[e] *= 1), this._valuesStartRepeat[e] = this._valuesStart[e] || 0);
    }
    return this;
  },
  stop: function() {
    return this._isPlaying ? (this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback !== null && this._onStopCallback(this._object), this.stopChainedTweens(), this) : this;
  },
  end: function() {
    return this.update(1 / 0), this;
  },
  pause: function(B) {
    return this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = B === void 0 ? TWEEN.now() : B, this._group.remove(this), this);
  },
  resume: function(B) {
    return !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += (B === void 0 ? TWEEN.now() : B) - this._pauseStart, this._pauseStart = 0, this._group.add(this), this);
  },
  stopChainedTweens: function() {
    for (var B = 0, e = this._chainedTweens.length; B < e; B++)
      this._chainedTweens[B].stop();
  },
  group: function(B) {
    return this._group = B, this;
  },
  delay: function(B) {
    return this._delayTime = B, this;
  },
  repeat: function(B) {
    return this._repeat = B, this;
  },
  repeatDelay: function(B) {
    return this._repeatDelayTime = B, this;
  },
  yoyo: function(B) {
    return this._yoyo = B, this;
  },
  easing: function(B) {
    return this._easingFunction = B, this;
  },
  interpolation: function(B) {
    return this._interpolationFunction = B, this;
  },
  chain: function() {
    return this._chainedTweens = arguments, this;
  },
  onStart: function(B) {
    return this._onStartCallback = B, this;
  },
  onUpdate: function(B) {
    return this._onUpdateCallback = B, this;
  },
  onRepeat: function B(e) {
    return this._onRepeatCallback = e, this;
  },
  onComplete: function(B) {
    return this._onCompleteCallback = B, this;
  },
  onStop: function(B) {
    return this._onStopCallback = B, this;
  },
  update: function(B) {
    var e, b, L;
    if (B < this._startTime)
      return !0;
    this._onStartCallbackFired === !1 && (this._onStartCallback !== null && this._onStartCallback(this._object), this._onStartCallbackFired = !0), b = (B - this._startTime) / this._duration, b = this._duration === 0 || b > 1 ? 1 : b, L = this._easingFunction(b);
    for (e in this._valuesEnd)
      if (this._valuesStart[e] !== void 0) {
        var M = this._valuesStart[e] || 0, D = this._valuesEnd[e];
        D instanceof Array ? this._object[e] = this._interpolationFunction(D, L) : (typeof D == "string" && (D.charAt(0) === "+" || D.charAt(0) === "-" ? D = M + parseFloat(D) : D = parseFloat(D)), typeof D == "number" && (this._object[e] = M + (D - M) * L));
      }
    if (this._onUpdateCallback !== null && this._onUpdateCallback(this._object, b), b === 1)
      if (this._repeat > 0) {
        isFinite(this._repeat) && this._repeat--;
        for (e in this._valuesStartRepeat) {
          if (typeof this._valuesEnd[e] == "string" && (this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(this._valuesEnd[e])), this._yoyo) {
            var I = this._valuesStartRepeat[e];
            this._valuesStartRepeat[e] = this._valuesEnd[e], this._valuesEnd[e] = I;
          }
          this._valuesStart[e] = this._valuesStartRepeat[e];
        }
        return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = B + this._repeatDelayTime : this._startTime = B + this._delayTime, this._onRepeatCallback !== null && this._onRepeatCallback(this._object), !0;
      } else {
        this._onCompleteCallback !== null && this._onCompleteCallback(this._object);
        for (var F = 0, N = this._chainedTweens.length; F < N; F++)
          this._chainedTweens[F].start(this._startTime + this._duration);
        return !1;
      }
    return !0;
  }
};
TWEEN.Easing = {
  Linear: {
    None: function(B) {
      return B;
    }
  },
  Quadratic: {
    In: function(B) {
      return B * B;
    },
    Out: function(B) {
      return B * (2 - B);
    },
    InOut: function(B) {
      return (B *= 2) < 1 ? 0.5 * B * B : -0.5 * (--B * (B - 2) - 1);
    }
  },
  Cubic: {
    In: function(B) {
      return B * B * B;
    },
    Out: function(B) {
      return --B * B * B + 1;
    },
    InOut: function(B) {
      return (B *= 2) < 1 ? 0.5 * B * B * B : 0.5 * ((B -= 2) * B * B + 2);
    }
  },
  Quartic: {
    In: function(B) {
      return B * B * B * B;
    },
    Out: function(B) {
      return 1 - --B * B * B * B;
    },
    InOut: function(B) {
      return (B *= 2) < 1 ? 0.5 * B * B * B * B : -0.5 * ((B -= 2) * B * B * B - 2);
    }
  },
  Quintic: {
    In: function(B) {
      return B * B * B * B * B;
    },
    Out: function(B) {
      return --B * B * B * B * B + 1;
    },
    InOut: function(B) {
      return (B *= 2) < 1 ? 0.5 * B * B * B * B * B : 0.5 * ((B -= 2) * B * B * B * B + 2);
    }
  },
  Sinusoidal: {
    In: function(B) {
      return 1 - Math.cos(B * Math.PI / 2);
    },
    Out: function(B) {
      return Math.sin(B * Math.PI / 2);
    },
    InOut: function(B) {
      return 0.5 * (1 - Math.cos(Math.PI * B));
    }
  },
  Exponential: {
    In: function(B) {
      return B === 0 ? 0 : Math.pow(1024, B - 1);
    },
    Out: function(B) {
      return B === 1 ? 1 : 1 - Math.pow(2, -10 * B);
    },
    InOut: function(B) {
      return B === 0 ? 0 : B === 1 ? 1 : (B *= 2) < 1 ? 0.5 * Math.pow(1024, B - 1) : 0.5 * (-Math.pow(2, -10 * (B - 1)) + 2);
    }
  },
  Circular: {
    In: function(B) {
      return 1 - Math.sqrt(1 - B * B);
    },
    Out: function(B) {
      return Math.sqrt(1 - --B * B);
    },
    InOut: function(B) {
      return (B *= 2) < 1 ? -0.5 * (Math.sqrt(1 - B * B) - 1) : 0.5 * (Math.sqrt(1 - (B -= 2) * B) + 1);
    }
  },
  Elastic: {
    In: function(B) {
      return B === 0 ? 0 : B === 1 ? 1 : -Math.pow(2, 10 * (B - 1)) * Math.sin((B - 1.1) * 5 * Math.PI);
    },
    Out: function(B) {
      return B === 0 ? 0 : B === 1 ? 1 : Math.pow(2, -10 * B) * Math.sin((B - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(B) {
      return B === 0 ? 0 : B === 1 ? 1 : (B *= 2, B < 1 ? -0.5 * Math.pow(2, 10 * (B - 1)) * Math.sin((B - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (B - 1)) * Math.sin((B - 1.1) * 5 * Math.PI) + 1);
    }
  },
  Back: {
    In: function(B) {
      var e = 1.70158;
      return B * B * ((e + 1) * B - e);
    },
    Out: function(B) {
      var e = 1.70158;
      return --B * B * ((e + 1) * B + e) + 1;
    },
    InOut: function(B) {
      var e = 2.5949095;
      return (B *= 2) < 1 ? 0.5 * (B * B * ((e + 1) * B - e)) : 0.5 * ((B -= 2) * B * ((e + 1) * B + e) + 2);
    }
  },
  Bounce: {
    In: function(B) {
      return 1 - TWEEN.Easing.Bounce.Out(1 - B);
    },
    Out: function(B) {
      return B < 1 / 2.75 ? 7.5625 * B * B : B < 2 / 2.75 ? 7.5625 * (B -= 1.5 / 2.75) * B + 0.75 : B < 2.5 / 2.75 ? 7.5625 * (B -= 2.25 / 2.75) * B + 0.9375 : 7.5625 * (B -= 2.625 / 2.75) * B + 0.984375;
    },
    InOut: function(B) {
      return B < 0.5 ? TWEEN.Easing.Bounce.In(B * 2) * 0.5 : TWEEN.Easing.Bounce.Out(B * 2 - 1) * 0.5 + 0.5;
    }
  }
};
TWEEN.Interpolation = {
  Linear: function(B, e) {
    var b = B.length - 1, L = b * e, M = Math.floor(L), D = TWEEN.Interpolation.Utils.Linear;
    return e < 0 ? D(B[0], B[1], L) : e > 1 ? D(B[b], B[b - 1], b - L) : D(B[M], B[M + 1 > b ? b : M + 1], L - M);
  },
  Bezier: function(B, e) {
    for (var b = 0, L = B.length - 1, M = Math.pow, D = TWEEN.Interpolation.Utils.Bernstein, I = 0; I <= L; I++)
      b += M(1 - e, L - I) * M(e, I) * B[I] * D(L, I);
    return b;
  },
  CatmullRom: function(B, e) {
    var b = B.length - 1, L = b * e, M = Math.floor(L), D = TWEEN.Interpolation.Utils.CatmullRom;
    return B[0] === B[b] ? (e < 0 && (M = Math.floor(L = b * (1 + e))), D(B[(M - 1 + b) % b], B[M], B[(M + 1) % b], B[(M + 2) % b], L - M)) : e < 0 ? B[0] - (D(B[0], B[0], B[1], B[1], -L) - B[0]) : e > 1 ? B[b] - (D(B[b], B[b], B[b - 1], B[b - 1], L - b) - B[b]) : D(B[M ? M - 1 : 0], B[M], B[b < M + 1 ? b : M + 1], B[b < M + 2 ? b : M + 2], L - M);
  },
  Utils: {
    Linear: function(B, e, b) {
      return (e - B) * b + B;
    },
    Bernstein: function(B, e) {
      var b = TWEEN.Interpolation.Utils.Factorial;
      return b(B) / b(e) / b(B - e);
    },
    Factorial: /* @__PURE__ */ function() {
      var B = [1];
      return function(e) {
        var b = 1;
        if (B[e])
          return B[e];
        for (var L = e; L > 1; L--)
          b *= L;
        return B[e] = b, b;
      };
    }(),
    CatmullRom: function(B, e, b, L, M) {
      var D = (b - B) * 0.5, I = (L - e) * 0.5, F = M * M, N = M * F;
      return (2 * e - 2 * b + D + I) * N + (-3 * e + 3 * b - 2 * D - I) * F + D * M + e;
    }
  }
};
TWEEN.version = version;
function setColor(B, e) {
  B.traverse((b) => {
    b.material && b.material.color.setRGB(e, e, e);
  });
}
class UISystem extends System {
  execute(e, b) {
    TWEEN.update();
    const L = this.queries.entities;
    for (let M = 0; M < L.results.length; M++)
      L.results[M].getComponent(UI);
    for (let M = 0; M < L.added.length; M++) {
      const D = L.added[M];
      D.getComponent(UI);
      const I = D.getComponent(Button);
      let F = this.world.createEntity(), N = new Group();
      D.addComponent(Object3DComponent, { value: N }), D.addComponent(RaycastReceiver, {
        layerMask: 4,
        onHover: () => {
        },
        onEnter: () => {
          let U = D.getObject3D();
          setColor(U, 1), new TWEEN.Tween(U.scale).to(
            {
              x: 1.1,
              y: 1.1,
              z: 1.1
            },
            500
          ).onUpdate(() => {
          }).easing(TWEEN.Easing.Quadratic.Out).start();
        },
        onLeave: () => {
          let U = D.getObject3D();
          setColor(U, 0.7), new TWEEN.Tween(U.scale).to(
            {
              x: 1,
              y: 1,
              z: 1
            },
            300
          ).onUpdate(() => {
          }).easing(TWEEN.Easing.Quadratic.Out).start();
        },
        onSelectStart: () => {
          let U = D.getObject3D();
          setColor(U, 1), setTimeout(() => {
            setColor(U, 0.7);
          }, 300), new TWEEN.Tween(U.scale).to(
            {
              x: 1.2,
              y: 1.2,
              z: 1.2
            },
            100
          ).repeat(1).yoyo(!0).easing(TWEEN.Easing.Quadratic.Out).start().onComplete(() => {
            I.onClick && I.onClick();
          }), D.hasComponent(Sound) && D.getComponent(Sound).sound.play();
        }
      }), F.addComponent(Text$1, {
        color: "#999",
        font: "assets/fonts/WetinCaroWant.ttf",
        fontSize: 0.09,
        anchor: "center",
        textAlign: "center",
        baseline: "center",
        maxWidth: 10,
        lineHeight: 0,
        text: I.text
      }).addComponent(Position, { value: new Vector3(0, 0, 0.01) }).addComponent(Parent, { value: D });
    }
  }
}
UISystem.queries = {
  entities: {
    components: [UI, Button],
    listen: {
      added: !0,
      removed: !0,
      changed: !0
      // [UI]
    }
  }
};
class RaycasterSystem extends System {
  init() {
    this.world.registerComponent(Raycaster);
  }
  execute() {
    let e = this.queries.inputState.results[0].getComponent(
      InputState
    );
    this.queries.raycasters.added.forEach((b) => {
      new Raycaster$1();
    }), this.queries.raycasters.results.forEach((b) => {
      let L = b.getComponent(Raycaster);
      if (!L.enabled)
        return;
      var M = this.queries.receivers.results.filter((z) => {
        var k = z.getComponent(RaycastReceiver).layerMask;
        return (k & L.layerMask) !== 0;
      }).map((z) => {
        var k = z.getObject3D();
        return k.traverse((H) => {
          H.userData.entity = z;
        }), k;
      });
      if (M.length === 0)
        return;
      let D = L.value;
      var I = new Matrix4(), F = b.getObject3D().getObjectByName("controller");
      I.identity().extractRotation(F.matrixWorld), D.ray.origin.setFromMatrixPosition(F.matrixWorld), D.ray.direction.set(0, 0, -1).applyMatrix4(I);
      let N = D.intersectObjects(M, !0), U = b.getObject3D(), G = U ? U.children[0] : null, V = e.vrcontrollers.get(
        G
      );
      if (N.length > 0) {
        let z = N[0].object.parent ? N[0] : N[1], k = z.object, H = k.userData.entity;
        for (; !H && k.parent; )
          k = k.parent, H = k.userData.entity;
        if (H) {
          const W = H.getComponent(RaycastReceiver);
          W && !W.hovering && (W.hovering = !0, W.onEnter(z, b)), W.onHover && W.onHover(z, b), V && V.selectStart && W.onSelectStart && W.onSelectStart(z, G), L.currentEntity = H;
        }
      } else if (L.currentEntity) {
        const z = L.currentEntity.getComponent(
          RaycastReceiver
        );
        z && z.hovering && (z.hovering = !1, z.onLeave && z.onLeave(b)), L.currentEntity = null;
      }
    });
  }
}
RaycasterSystem.queries = {
  raycasters: {
    components: [Raycaster],
    listen: {
      added: !0,
      removed: !0,
      changed: !0
      // [RaycasterReceiver]
    }
  },
  receivers: {
    components: [RaycastReceiver],
    listen: {
      added: !0,
      removed: !0,
      changed: !0
      // [RaycasterReceiver]
    }
  },
  inputState: {
    components: [InputState]
  }
};
const Systems = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BallGeneratorSystem,
  CameraRigSystem,
  DissolveSystem,
  ElementSystem,
  GameStateSystem,
  LevelManager,
  OutputSystem,
  PhysicsSystem,
  RaycasterSystem,
  RotatingSystem,
  TargetSystem,
  UISystem,
  VRControllerInteraction
}, Symbol.toStringTag, { value: "Module" }));
var t = { 957: (B, e, b) => {
  B.exports = b(475);
}, 404: (B, e, b) => {
  var L = b(952), M = b(366), D = b(48), I = b(134), F = b(587), N = b(648), U = b(238), G = b(780), V = b(57), z = b(879), k = b(860);
  B.exports = function(H) {
    return new Promise(function(W, $) {
      var j, q = H.data, Y = H.headers, J = H.responseType;
      function K() {
        H.cancelToken && H.cancelToken.unsubscribe(j), H.signal && H.signal.removeEventListener("abort", j);
      }
      L.isFormData(q) && L.isStandardBrowserEnv() && delete Y["Content-Type"];
      var X = new XMLHttpRequest();
      if (H.auth) {
        var Z = H.auth.username || "", Q = H.auth.password ? unescape(encodeURIComponent(H.auth.password)) : "";
        Y.Authorization = "Basic " + btoa(Z + ":" + Q);
      }
      var ne = F(H.baseURL, H.url);
      function le() {
        if (X) {
          var oe = "getAllResponseHeaders" in X ? N(X.getAllResponseHeaders()) : null, ae = { data: J && J !== "text" && J !== "json" ? X.response : X.responseText, status: X.status, statusText: X.statusText, headers: oe, config: H, request: X };
          M(function(se) {
            W(se), K();
          }, function(se) {
            $(se), K();
          }, ae), X = null;
        }
      }
      if (X.open(H.method.toUpperCase(), I(ne, H.params, H.paramsSerializer), !0), X.timeout = H.timeout, "onloadend" in X ? X.onloadend = le : X.onreadystatechange = function() {
        X && X.readyState === 4 && (X.status !== 0 || X.responseURL && X.responseURL.indexOf("file:") === 0) && setTimeout(le);
      }, X.onabort = function() {
        X && ($(new V("Request aborted", V.ECONNABORTED, H, X)), X = null);
      }, X.onerror = function() {
        $(new V("Network Error", V.ERR_NETWORK, H, X, X)), X = null;
      }, X.ontimeout = function() {
        var oe = H.timeout ? "timeout of " + H.timeout + "ms exceeded" : "timeout exceeded", ae = H.transitional || G;
        H.timeoutErrorMessage && (oe = H.timeoutErrorMessage), $(new V(oe, ae.clarifyTimeoutError ? V.ETIMEDOUT : V.ECONNABORTED, H, X)), X = null;
      }, L.isStandardBrowserEnv()) {
        var pe = (H.withCredentials || U(ne)) && H.xsrfCookieName ? D.read(H.xsrfCookieName) : void 0;
        pe && (Y[H.xsrfHeaderName] = pe);
      }
      "setRequestHeader" in X && L.forEach(Y, function(oe, ae) {
        q === void 0 && ae.toLowerCase() === "content-type" ? delete Y[ae] : X.setRequestHeader(ae, oe);
      }), L.isUndefined(H.withCredentials) || (X.withCredentials = !!H.withCredentials), J && J !== "json" && (X.responseType = H.responseType), typeof H.onDownloadProgress == "function" && X.addEventListener("progress", H.onDownloadProgress), typeof H.onUploadProgress == "function" && X.upload && X.upload.addEventListener("progress", H.onUploadProgress), (H.cancelToken || H.signal) && (j = function(oe) {
        X && ($(!oe || oe && oe.type ? new z() : oe), X.abort(), X = null);
      }, H.cancelToken && H.cancelToken.subscribe(j), H.signal && (H.signal.aborted ? j() : H.signal.addEventListener("abort", j))), q || (q = null);
      var ue = k(ne);
      ue && ["http", "https", "file"].indexOf(ue) === -1 ? $(new V("Unsupported protocol " + ue + ":", V.ERR_BAD_REQUEST, H)) : X.send(q);
    });
  };
}, 475: (B, e, b) => {
  var L = b(952), M = b(96), D = b(359), I = b(867), F = function N(U) {
    var G = new D(U), V = M(D.prototype.request, G);
    return L.extend(V, D.prototype, G), L.extend(V, G), V.create = function(z) {
      return N(I(U, z));
    }, V;
  }(b(432));
  F.Axios = D, F.CanceledError = b(879), F.CancelToken = b(723), F.isCancel = b(479), F.VERSION = b(925).version, F.toFormData = b(908), F.AxiosError = b(57), F.Cancel = F.CanceledError, F.all = function(N) {
    return Promise.all(N);
  }, F.spread = b(696), F.isAxiosError = b(975), B.exports = F, B.exports.default = F;
}, 723: (B, e, b) => {
  var L = b(879);
  function M(D) {
    if (typeof D != "function") throw new TypeError("executor must be a function.");
    var I;
    this.promise = new Promise(function(N) {
      I = N;
    });
    var F = this;
    this.promise.then(function(N) {
      if (F._listeners) {
        var U, G = F._listeners.length;
        for (U = 0; U < G; U++) F._listeners[U](N);
        F._listeners = null;
      }
    }), this.promise.then = function(N) {
      var U, G = new Promise(function(V) {
        F.subscribe(V), U = V;
      }).then(N);
      return G.cancel = function() {
        F.unsubscribe(U);
      }, G;
    }, D(function(N) {
      F.reason || (F.reason = new L(N), I(F.reason));
    });
  }
  M.prototype.throwIfRequested = function() {
    if (this.reason) throw this.reason;
  }, M.prototype.subscribe = function(D) {
    this.reason ? D(this.reason) : this._listeners ? this._listeners.push(D) : this._listeners = [D];
  }, M.prototype.unsubscribe = function(D) {
    if (this._listeners) {
      var I = this._listeners.indexOf(D);
      I !== -1 && this._listeners.splice(I, 1);
    }
  }, M.source = function() {
    var D;
    return { token: new M(function(I) {
      D = I;
    }), cancel: D };
  }, B.exports = M;
}, 879: (B, e, b) => {
  var L = b(57);
  function M(D) {
    L.call(this, D ?? "canceled", L.ERR_CANCELED), this.name = "CanceledError";
  }
  b(952).inherits(M, L, { __CANCEL__: !0 }), B.exports = M;
}, 479: (B) => {
  B.exports = function(e) {
    return !(!e || !e.__CANCEL__);
  };
}, 359: (B, e, b) => {
  var L = b(952), M = b(134), D = b(667), I = b(310), F = b(867), N = b(587), U = b(629), G = U.validators;
  function V(z) {
    this.defaults = z, this.interceptors = { request: new D(), response: new D() };
  }
  V.prototype.request = function(z, k) {
    typeof z == "string" ? (k = k || {}).url = z : k = z || {}, (k = F(this.defaults, k)).method ? k.method = k.method.toLowerCase() : this.defaults.method ? k.method = this.defaults.method.toLowerCase() : k.method = "get";
    var H = k.transitional;
    H !== void 0 && U.assertOptions(H, { silentJSONParsing: G.transitional(G.boolean), forcedJSONParsing: G.transitional(G.boolean), clarifyTimeoutError: G.transitional(G.boolean) }, !1);
    var W = [], $ = !0;
    this.interceptors.request.forEach(function(Z) {
      typeof Z.runWhen == "function" && Z.runWhen(k) === !1 || ($ = $ && Z.synchronous, W.unshift(Z.fulfilled, Z.rejected));
    });
    var j, q = [];
    if (this.interceptors.response.forEach(function(Z) {
      q.push(Z.fulfilled, Z.rejected);
    }), !$) {
      var Y = [I, void 0];
      for (Array.prototype.unshift.apply(Y, W), Y = Y.concat(q), j = Promise.resolve(k); Y.length; ) j = j.then(Y.shift(), Y.shift());
      return j;
    }
    for (var J = k; W.length; ) {
      var K = W.shift(), X = W.shift();
      try {
        J = K(J);
      } catch (Z) {
        X(Z);
        break;
      }
    }
    try {
      j = I(J);
    } catch (Z) {
      return Promise.reject(Z);
    }
    for (; q.length; ) j = j.then(q.shift(), q.shift());
    return j;
  }, V.prototype.getUri = function(z) {
    z = F(this.defaults, z);
    var k = N(z.baseURL, z.url);
    return M(k, z.params, z.paramsSerializer);
  }, L.forEach(["delete", "get", "head", "options"], function(z) {
    V.prototype[z] = function(k, H) {
      return this.request(F(H || {}, { method: z, url: k, data: (H || {}).data }));
    };
  }), L.forEach(["post", "put", "patch"], function(z) {
    function k(H) {
      return function(W, $, j) {
        return this.request(F(j || {}, { method: z, headers: H ? { "Content-Type": "multipart/form-data" } : {}, url: W, data: $ }));
      };
    }
    V.prototype[z] = k(), V.prototype[z + "Form"] = k(!0);
  }), B.exports = V;
}, 57: (B, e, b) => {
  var L = b(952);
  function M(F, N, U, G, V) {
    Error.call(this), this.message = F, this.name = "AxiosError", N && (this.code = N), U && (this.config = U), G && (this.request = G), V && (this.response = V);
  }
  L.inherits(M, Error, { toJSON: function() {
    return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code, status: this.response && this.response.status ? this.response.status : null };
  } });
  var D = M.prototype, I = {};
  ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED"].forEach(function(F) {
    I[F] = { value: F };
  }), Object.defineProperties(M, I), Object.defineProperty(D, "isAxiosError", { value: !0 }), M.from = function(F, N, U, G, V, z) {
    var k = Object.create(D);
    return L.toFlatObject(F, k, function(H) {
      return H !== Error.prototype;
    }), M.call(k, F.message, N, U, G, V), k.name = F.name, z && Object.assign(k, z), k;
  }, B.exports = M;
}, 667: (B, e, b) => {
  var L = b(952);
  function M() {
    this.handlers = [];
  }
  M.prototype.use = function(D, I, F) {
    return this.handlers.push({ fulfilled: D, rejected: I, synchronous: !!F && F.synchronous, runWhen: F ? F.runWhen : null }), this.handlers.length - 1;
  }, M.prototype.eject = function(D) {
    this.handlers[D] && (this.handlers[D] = null);
  }, M.prototype.forEach = function(D) {
    L.forEach(this.handlers, function(I) {
      I !== null && D(I);
    });
  }, B.exports = M;
}, 587: (B, e, b) => {
  var L = b(261), M = b(756);
  B.exports = function(D, I) {
    return D && !L(I) ? M(D, I) : I;
  };
}, 310: (B, e, b) => {
  var L = b(952), M = b(381), D = b(479), I = b(432), F = b(879);
  function N(U) {
    if (U.cancelToken && U.cancelToken.throwIfRequested(), U.signal && U.signal.aborted) throw new F();
  }
  B.exports = function(U) {
    return N(U), U.headers = U.headers || {}, U.data = M.call(U, U.data, U.headers, U.transformRequest), U.headers = L.merge(U.headers.common || {}, U.headers[U.method] || {}, U.headers), L.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(G) {
      delete U.headers[G];
    }), (U.adapter || I.adapter)(U).then(function(G) {
      return N(U), G.data = M.call(U, G.data, G.headers, U.transformResponse), G;
    }, function(G) {
      return D(G) || (N(U), G && G.response && (G.response.data = M.call(U, G.response.data, G.response.headers, U.transformResponse))), Promise.reject(G);
    });
  };
}, 867: (B, e, b) => {
  var L = b(952);
  B.exports = function(M, D) {
    D = D || {};
    var I = {};
    function F(k, H) {
      return L.isPlainObject(k) && L.isPlainObject(H) ? L.merge(k, H) : L.isPlainObject(H) ? L.merge({}, H) : L.isArray(H) ? H.slice() : H;
    }
    function N(k) {
      return L.isUndefined(D[k]) ? L.isUndefined(M[k]) ? void 0 : F(void 0, M[k]) : F(M[k], D[k]);
    }
    function U(k) {
      if (!L.isUndefined(D[k])) return F(void 0, D[k]);
    }
    function G(k) {
      return L.isUndefined(D[k]) ? L.isUndefined(M[k]) ? void 0 : F(void 0, M[k]) : F(void 0, D[k]);
    }
    function V(k) {
      return k in D ? F(M[k], D[k]) : k in M ? F(void 0, M[k]) : void 0;
    }
    var z = { url: U, method: U, data: U, baseURL: G, transformRequest: G, transformResponse: G, paramsSerializer: G, timeout: G, timeoutMessage: G, withCredentials: G, adapter: G, responseType: G, xsrfCookieName: G, xsrfHeaderName: G, onUploadProgress: G, onDownloadProgress: G, decompress: G, maxContentLength: G, maxBodyLength: G, beforeRedirect: G, transport: G, httpAgent: G, httpsAgent: G, cancelToken: G, socketPath: G, responseEncoding: G, validateStatus: V };
    return L.forEach(Object.keys(M).concat(Object.keys(D)), function(k) {
      var H = z[k] || N, W = H(k);
      L.isUndefined(W) && H !== V || (I[k] = W);
    }), I;
  };
}, 366: (B, e, b) => {
  var L = b(57);
  B.exports = function(M, D, I) {
    var F = I.config.validateStatus;
    I.status && F && !F(I.status) ? D(new L("Request failed with status code " + I.status, [L.ERR_BAD_REQUEST, L.ERR_BAD_RESPONSE][Math.floor(I.status / 100) - 4], I.config, I.request, I)) : M(I);
  };
}, 381: (B, e, b) => {
  var L = b(952), M = b(432);
  B.exports = function(D, I, F) {
    var N = this || M;
    return L.forEach(F, function(U) {
      D = U.call(N, D, I);
    }), D;
  };
}, 432: (B, e, b) => {
  var L = b(952), M = b(646), D = b(57), I = b(780), F = b(908), N = { "Content-Type": "application/x-www-form-urlencoded" };
  function U(z, k) {
    !L.isUndefined(z) && L.isUndefined(z["Content-Type"]) && (z["Content-Type"] = k);
  }
  var G, V = { transitional: I, adapter: ((typeof XMLHttpRequest < "u" || typeof process < "u" && Object.prototype.toString.call(process) === "[object process]") && (G = b(404)), G), transformRequest: [function(z, k) {
    if (M(k, "Accept"), M(k, "Content-Type"), L.isFormData(z) || L.isArrayBuffer(z) || L.isBuffer(z) || L.isStream(z) || L.isFile(z) || L.isBlob(z)) return z;
    if (L.isArrayBufferView(z)) return z.buffer;
    if (L.isURLSearchParams(z)) return U(k, "application/x-www-form-urlencoded;charset=utf-8"), z.toString();
    var H, W = L.isObject(z), $ = k && k["Content-Type"];
    if ((H = L.isFileList(z)) || W && $ === "multipart/form-data") {
      var j = this.env && this.env.FormData;
      return F(H ? { "files[]": z } : z, j && new j());
    }
    return W || $ === "application/json" ? (U(k, "application/json"), function(q, Y, J) {
      if (L.isString(q)) try {
        return (0, JSON.parse)(q), L.trim(q);
      } catch (K) {
        if (K.name !== "SyntaxError") throw K;
      }
      return (0, JSON.stringify)(q);
    }(z)) : z;
  }], transformResponse: [function(z) {
    var k = this.transitional || V.transitional, H = k && k.silentJSONParsing, W = k && k.forcedJSONParsing, $ = !H && this.responseType === "json";
    if ($ || W && L.isString(z) && z.length) try {
      return JSON.parse(z);
    } catch (j) {
      if ($)
        throw j.name === "SyntaxError" ? D.from(j, D.ERR_BAD_RESPONSE, this, null, this.response) : j;
    }
    return z;
  }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: b(538) }, validateStatus: function(z) {
    return z >= 200 && z < 300;
  }, headers: { common: { Accept: "application/json, text/plain, */*" } } };
  L.forEach(["delete", "get", "head"], function(z) {
    V.headers[z] = {};
  }), L.forEach(["post", "put", "patch"], function(z) {
    V.headers[z] = L.merge(N);
  }), B.exports = V;
}, 780: (B) => {
  B.exports = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 };
}, 925: (B) => {
  B.exports = { version: "0.27.2" };
}, 96: (B) => {
  B.exports = function(e, b) {
    return function() {
      for (var L = new Array(arguments.length), M = 0; M < L.length; M++) L[M] = arguments[M];
      return e.apply(b, L);
    };
  };
}, 134: (B, e, b) => {
  var L = b(952);
  function M(D) {
    return encodeURIComponent(D).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  B.exports = function(D, I, F) {
    if (!I) return D;
    var N;
    if (F) N = F(I);
    else if (L.isURLSearchParams(I)) N = I.toString();
    else {
      var U = [];
      L.forEach(I, function(V, z) {
        V != null && (L.isArray(V) ? z += "[]" : V = [V], L.forEach(V, function(k) {
          L.isDate(k) ? k = k.toISOString() : L.isObject(k) && (k = JSON.stringify(k)), U.push(M(z) + "=" + M(k));
        }));
      }), N = U.join("&");
    }
    if (N) {
      var G = D.indexOf("#");
      G !== -1 && (D = D.slice(0, G)), D += (D.indexOf("?") === -1 ? "?" : "&") + N;
    }
    return D;
  };
}, 756: (B) => {
  B.exports = function(e, b) {
    return b ? e.replace(/\/+$/, "") + "/" + b.replace(/^\/+/, "") : e;
  };
}, 48: (B, e, b) => {
  var L = b(952);
  B.exports = L.isStandardBrowserEnv() ? { write: function(M, D, I, F, N, U) {
    var G = [];
    G.push(M + "=" + encodeURIComponent(D)), L.isNumber(I) && G.push("expires=" + new Date(I).toGMTString()), L.isString(F) && G.push("path=" + F), L.isString(N) && G.push("domain=" + N), U === !0 && G.push("secure"), document.cookie = G.join("; ");
  }, read: function(M) {
    var D = document.cookie.match(new RegExp("(^|;\\s*)(" + M + ")=([^;]*)"));
    return D ? decodeURIComponent(D[3]) : null;
  }, remove: function(M) {
    this.write(M, "", Date.now() - 864e5);
  } } : { write: function() {
  }, read: function() {
    return null;
  }, remove: function() {
  } };
}, 261: (B) => {
  B.exports = function(e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
  };
}, 975: (B, e, b) => {
  var L = b(952);
  B.exports = function(M) {
    return L.isObject(M) && M.isAxiosError === !0;
  };
}, 238: (B, e, b) => {
  var L = b(952);
  B.exports = L.isStandardBrowserEnv() ? function() {
    var M, D = /(msie|trident)/i.test(navigator.userAgent), I = document.createElement("a");
    function F(N) {
      var U = N;
      return D && (I.setAttribute("href", U), U = I.href), I.setAttribute("href", U), { href: I.href, protocol: I.protocol ? I.protocol.replace(/:$/, "") : "", host: I.host, search: I.search ? I.search.replace(/^\?/, "") : "", hash: I.hash ? I.hash.replace(/^#/, "") : "", hostname: I.hostname, port: I.port, pathname: I.pathname.charAt(0) === "/" ? I.pathname : "/" + I.pathname };
    }
    return M = F(window.location.href), function(N) {
      var U = L.isString(N) ? F(N) : N;
      return U.protocol === M.protocol && U.host === M.host;
    };
  }() : function() {
    return !0;
  };
}, 646: (B, e, b) => {
  var L = b(952);
  B.exports = function(M, D) {
    L.forEach(M, function(I, F) {
      F !== D && F.toUpperCase() === D.toUpperCase() && (M[D] = I, delete M[F]);
    });
  };
}, 538: (B) => {
  B.exports = null;
}, 648: (B, e, b) => {
  var L = b(952), M = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
  B.exports = function(D) {
    var I, F, N, U = {};
    return D && L.forEach(D.split(`
`), function(G) {
      if (N = G.indexOf(":"), I = L.trim(G.substr(0, N)).toLowerCase(), F = L.trim(G.substr(N + 1)), I) {
        if (U[I] && M.indexOf(I) >= 0) return;
        U[I] = I === "set-cookie" ? (U[I] ? U[I] : []).concat([F]) : U[I] ? U[I] + ", " + F : F;
      }
    }), U;
  };
}, 860: (B) => {
  B.exports = function(e) {
    var b = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
    return b && b[1] || "";
  };
}, 696: (B) => {
  B.exports = function(e) {
    return function(b) {
      return e.apply(null, b);
    };
  };
}, 908: (B, e, b) => {
  var L = b(952);
  B.exports = function(M, D) {
    D = D || new FormData();
    var I = [];
    function F(N) {
      return N === null ? "" : L.isDate(N) ? N.toISOString() : L.isArrayBuffer(N) || L.isTypedArray(N) ? typeof Blob == "function" ? new Blob([N]) : Buffer.from(N) : N;
    }
    return function N(U, G) {
      if (L.isPlainObject(U) || L.isArray(U)) {
        if (I.indexOf(U) !== -1) throw Error("Circular reference detected in " + G);
        I.push(U), L.forEach(U, function(V, z) {
          if (!L.isUndefined(V)) {
            var k, H = G ? G + "." + z : z;
            if (V && !G && typeof V == "object") {
              if (L.endsWith(z, "{}")) V = JSON.stringify(V);
              else if (L.endsWith(z, "[]") && (k = L.toArray(V))) return void k.forEach(function(W) {
                !L.isUndefined(W) && D.append(H, F(W));
              });
            }
            N(V, H);
          }
        }), I.pop();
      } else D.append(G, F(U));
    }(M), D;
  };
}, 629: (B, e, b) => {
  var L = b(925).version, M = b(57), D = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(F, N) {
    D[F] = function(U) {
      return typeof U === F || "a" + (N < 1 ? "n " : " ") + F;
    };
  });
  var I = {};
  D.transitional = function(F, N, U) {
    function G(V, z) {
      return "[Axios v" + L + "] Transitional option '" + V + "'" + z + (U ? ". " + U : "");
    }
    return function(V, z, k) {
      if (F === !1) throw new M(G(z, " has been removed" + (N ? " in " + N : "")), M.ERR_DEPRECATED);
      return N && !I[z] && (I[z] = !0, console.warn(G(z, " has been deprecated since v" + N + " and will be removed in the near future"))), !F || F(V, z, k);
    };
  }, B.exports = { assertOptions: function(F, N, U) {
    if (typeof F != "object") throw new M("options must be an object", M.ERR_BAD_OPTION_VALUE);
    for (var G = Object.keys(F), V = G.length; V-- > 0; ) {
      var z = G[V], k = N[z];
      if (k) {
        var H = F[z], W = H === void 0 || k(H, z, F);
        if (W !== !0) throw new M("option " + z + " must be " + W, M.ERR_BAD_OPTION_VALUE);
      } else if (U !== !0) throw new M("Unknown option " + z, M.ERR_BAD_OPTION);
    }
  }, validators: D };
}, 952: (B, e, b) => {
  var L, M = b(96), D = Object.prototype.toString, I = (L = /* @__PURE__ */ Object.create(null), function(X) {
    var Z = D.call(X);
    return L[Z] || (L[Z] = Z.slice(8, -1).toLowerCase());
  });
  function F(X) {
    return X = X.toLowerCase(), function(Z) {
      return I(Z) === X;
    };
  }
  function N(X) {
    return Array.isArray(X);
  }
  function U(X) {
    return X === void 0;
  }
  var G = F("ArrayBuffer");
  function V(X) {
    return X !== null && typeof X == "object";
  }
  function z(X) {
    if (I(X) !== "object") return !1;
    var Z = Object.getPrototypeOf(X);
    return Z === null || Z === Object.prototype;
  }
  var k = F("Date"), H = F("File"), W = F("Blob"), $ = F("FileList");
  function j(X) {
    return D.call(X) === "[object Function]";
  }
  var q = F("URLSearchParams");
  function Y(X, Z) {
    if (X != null) if (typeof X != "object" && (X = [X]), N(X)) for (var Q = 0, ne = X.length; Q < ne; Q++) Z.call(null, X[Q], Q, X);
    else for (var le in X) Object.prototype.hasOwnProperty.call(X, le) && Z.call(null, X[le], le, X);
  }
  var J, K = (J = typeof Uint8Array < "u" && Object.getPrototypeOf(Uint8Array), function(X) {
    return J && X instanceof J;
  });
  B.exports = { isArray: N, isArrayBuffer: G, isBuffer: function(X) {
    return X !== null && !U(X) && X.constructor !== null && !U(X.constructor) && typeof X.constructor.isBuffer == "function" && X.constructor.isBuffer(X);
  }, isFormData: function(X) {
    var Z = "[object FormData]";
    return X && (typeof FormData == "function" && X instanceof FormData || D.call(X) === Z || j(X.toString) && X.toString() === Z);
  }, isArrayBufferView: function(X) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(X) : X && X.buffer && G(X.buffer);
  }, isString: function(X) {
    return typeof X == "string";
  }, isNumber: function(X) {
    return typeof X == "number";
  }, isObject: V, isPlainObject: z, isUndefined: U, isDate: k, isFile: H, isBlob: W, isFunction: j, isStream: function(X) {
    return V(X) && j(X.pipe);
  }, isURLSearchParams: q, isStandardBrowserEnv: function() {
    return (typeof navigator > "u" || navigator.product !== "ReactNative" && navigator.product !== "NativeScript" && navigator.product !== "NS") && typeof window < "u" && typeof document < "u";
  }, forEach: Y, merge: function X() {
    var Z = {};
    function Q(pe, ue) {
      z(Z[ue]) && z(pe) ? Z[ue] = X(Z[ue], pe) : z(pe) ? Z[ue] = X({}, pe) : N(pe) ? Z[ue] = pe.slice() : Z[ue] = pe;
    }
    for (var ne = 0, le = arguments.length; ne < le; ne++) Y(arguments[ne], Q);
    return Z;
  }, extend: function(X, Z, Q) {
    return Y(Z, function(ne, le) {
      X[le] = Q && typeof ne == "function" ? M(ne, Q) : ne;
    }), X;
  }, trim: function(X) {
    return X.trim ? X.trim() : X.replace(/^\s+|\s+$/g, "");
  }, stripBOM: function(X) {
    return X.charCodeAt(0) === 65279 && (X = X.slice(1)), X;
  }, inherits: function(X, Z, Q, ne) {
    X.prototype = Object.create(Z.prototype, ne), X.prototype.constructor = X, Q && Object.assign(X.prototype, Q);
  }, toFlatObject: function(X, Z, Q) {
    var ne, le, pe, ue = {};
    Z = Z || {};
    do {
      for (le = (ne = Object.getOwnPropertyNames(X)).length; le-- > 0; ) ue[pe = ne[le]] || (Z[pe] = X[pe], ue[pe] = !0);
      X = Object.getPrototypeOf(X);
    } while (X && (!Q || Q(X, Z)) && X !== Object.prototype);
    return Z;
  }, kindOf: I, kindOfTest: F, endsWith: function(X, Z, Q) {
    X = String(X), (Q === void 0 || Q > X.length) && (Q = X.length), Q -= Z.length;
    var ne = X.indexOf(Z, Q);
    return ne !== -1 && ne === Q;
  }, toArray: function(X) {
    if (!X) return null;
    var Z = X.length;
    if (U(Z)) return null;
    for (var Q = new Array(Z); Z-- > 0; ) Q[Z] = X[Z];
    return Q;
  }, isTypedArray: K, isFileList: $ };
} }, n = {};
function r(B) {
  var e = n[B];
  if (e !== void 0) return e.exports;
  var b = n[B] = { exports: {} };
  return t[B](b, b.exports, r), b.exports;
}
r.d = (B, e) => {
  for (var b in e) r.o(e, b) && !r.o(B, b) && Object.defineProperty(B, b, { enumerable: !0, get: e[b] });
}, r.o = (B, e) => Object.prototype.hasOwnProperty.call(B, e);
var o = {};
r.d(o, { A: () => S });
const i = (a = { Box3: () => Box3, Frustum: () => Frustum, Matrix4: () => Matrix4, Mesh: () => Mesh, MeshBasicMaterial: () => MeshBasicMaterial, PlaneGeometry: () => PlaneGeometry, TextureLoader: () => TextureLoader, Vector3: () => Vector3 }, s = {}, r.d(s, a), s);
var a, s, c = r(957);
const u = "https://cdn.zesty.xyz/images/zesty", l = { tall: { width: 0.75, height: 1, style: { standard: `${u}/zesty-banner-tall.png`, minimal: `${u}/zesty-banner-tall-minimal.png`, transparent: `${u}/zesty-banner-tall-transparent.png` } }, wide: { width: 4, height: 1, style: { standard: `${u}/zesty-banner-wide.png`, minimal: `${u}/zesty-banner-wide-minimal.png`, transparent: `${u}/zesty-banner-wide-transparent.png` } }, square: { width: 1, height: 1, style: { standard: `${u}/zesty-banner-square.png`, minimal: `${u}/zesty-banner-square-minimal.png`, transparent: `${u}/zesty-banner-square-transparent.png` } }, "mobile-phone-interstitial": { width: 0.56, height: 1, style: { standard: `${u}/zesty-default-mobile-phone-interstitial.png`, minimal: `${u}/zesty-default-mobile-phone-interstitial.png`, transparent: `${u}/zesty-default-mobile-phone-interstitial.png` } }, billboard: { width: 3.88, height: 1, style: { standard: `${u}/zesty-default-billboard.png`, minimal: `${u}/zesty-default-billboard.png`, transparent: `${u}/zesty-default-billboard.png` } }, "medium-rectangle": { width: 1.2, height: 1, style: { standard: `${u}/zesty-default-medium-rectangle.png`, minimal: `${u}/zesty-default-medium-rectangle.png`, transparent: `${u}/zesty-default-medium-rectangle.png` } } }, d = () => {
  const B = window.XRHand != null && window.XRMediaBinding != null, e = navigator.userAgent.includes("OculusBrowser"), b = B && e ? "Full" : B || e ? "Partial" : "None";
  return { match: b !== "None", confidence: b };
}, f = () => {
  const B = window.mozInnerScreenX != null && window.speechSynthesis == null, e = navigator.userAgent.includes("Mobile VR") && !navigator.userAgent.includes("OculusBrowser"), b = B && e ? "Full" : B || e ? "Partial" : "None";
  return { match: b !== "None", confidence: b };
}, p = async () => {
  const B = navigator.xr && await navigator.xr.isSessionSupported("immersive-vr") && await navigator.xr.isSessionSupported("immersive-ar"), e = navigator.userAgent.includes("Pico Neo 3 Link"), b = B && e ? "Full" : B || e ? "Partial" : "None";
  return { match: b !== "None", confidence: b };
}, h = () => {
  const B = navigator.maxTouchPoints === 0 || navigator.msMaxTouchPoints === 0, e = !navigator.userAgent.includes("Android") && !navigator.userAgent.includes("Mobile"), b = B && e ? "Full" : B || e ? "Partial" : "None";
  return { match: b !== "None", confidence: b };
}, m = async () => {
  let B = { platform: "", confidence: "" };
  return B = d().match ? { platform: "Oculus", confidence: d().confidence } : f().match ? { platform: "Wolvic", confidence: f().confidence } : await p().match ? { platform: "Pico", confidence: await p().confidence } : h().match ? { platform: "Desktop", confidence: h().confidence } : { platform: "Unknown", confidence: "None" }, B;
}, y = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, g = function(B) {
  if (!function(L) {
    return typeof L == "string" && y.test(L);
  }(B)) throw TypeError("Invalid UUID");
  var e, b = new Uint8Array(16);
  return b[0] = (e = parseInt(B.slice(0, 8), 16)) >>> 24, b[1] = e >>> 16 & 255, b[2] = e >>> 8 & 255, b[3] = 255 & e, b[4] = (e = parseInt(B.slice(9, 13), 16)) >>> 8, b[5] = 255 & e, b[6] = (e = parseInt(B.slice(14, 18), 16)) >>> 8, b[7] = 255 & e, b[8] = (e = parseInt(B.slice(19, 23), 16)) >>> 8, b[9] = 255 & e, b[10] = (e = parseInt(B.slice(24, 36), 16)) / 1099511627776 & 255, b[11] = e / 4294967296 & 255, b[12] = e >>> 24 & 255, b[13] = e >>> 16 & 255, b[14] = e >>> 8 & 255, b[15] = 255 & e, b;
}, v = "https://beacon2.zesty.market/zgraphql";
let w = !1, x = {};
const E = {}, O = {};
let A = "pb-slot-right-1";
const R = [{ id: "4902864a-5531-496b-8d4d-ec7b9849e8e1", format: "medium-rectangle", oldFormat: "tall", absoluteWidth: 0.75, absoluteHeight: 0.625 }], _ = (B, e, b = !1, L = null) => ({ Ads: [{ asset_url: l[b ? L : B].style[e], cta_url: "https://www.zesty.xyz" }], CampaignId: "DefaultCampaign" }), C = async (B, e = "tall", b = "standard") => {
  ["tall", "wide", "square"].includes(e) && console.warn(`The old Zesty banner formats (tall, wide, and square) are being deprecated and will be removed in a future version. Please update to one of the new IAB formats (mobile-phone-interstitial, billboard, and medium-rectangle).
Check https://docs.zesty.xyz/guides/developers/ad-units for more information.`);
  try {
    g(B);
  } catch {
    return console.warn(`Ad unit ID ${B} is not a valid UUID.`), new Promise((I) => I(_(e, b)));
  }
  let L = ((D) => R.find((I) => I.id === D) || {})(B), M = (L == null ? void 0 : L.oldFormat) && e == L.oldFormat;
  if (!B) return new Promise((D) => D(_(e, b, M, L.format)));
  if (w) x = null, E[B] = 0, O[B] = { asset_url: null, cta_url: null }, tude.cmd.push(function() {
    tude.refreshAdsViaDivMappings([{ divId: `zesty-div-${e}`, baseDivId: A }]);
  });
  else {
    const D = M ? L.format : e;
    E[B] = 0, O[B] = { asset_url: null, cta_url: null }, ((I, F) => {
      const N = document.createElement("div");
      N.id = "zesty-div", N.style.height = "250px", N.style.width = "300px", N.style.position = "fixed", N.style.top = "0", N.style.zIndex = "-2", document.body.appendChild(N);
      const U = document.createElement("link");
      U.href = "https://www.googletagservices.com/tag/js/gpt.js", U.rel = "preload", U.as = "script", document.head.appendChild(U);
      const G = document.createElement("script");
      G.src = "https://dn0qt3r0xannq.cloudfront.net/zesty-ig89tpzq8N/zesty-longform/prebid-load.js", G.async = !0, document.head.appendChild(G);
      const V = document.createElement("script");
      V.src = "https://cdn.jsdelivr.net/npm/gifler@0.1.0/gifler.min.js", document.head.appendChild(V), F == "medium-rectangle" ? N.id = "zesty-div-medium-rectangle" : F == "billboard" ? (A = "pb-slot-billboard", N.id = "zesty-div-billboard", N.style.width = "728px", N.style.height = "90px") : F == "mobile-phone-interstitial" && (A = "pb-slot-interstitial", N.id = "zesty-div-mobile-phone-interstitial", N.style.width = "1080px", N.style.height = "1920px"), window.Raven = window.Raven || { cmd: [] }, window.Raven.cmd.push(({ config: z }) => {
        z.setCustom({ param1: I });
      }), window.tude = window.tude || { cmd: [] }, tude.cmd.push(function() {
        tude.refreshAdsViaDivMappings([{ divId: `zesty-div-${F}`, baseDivId: A }]);
      }), setInterval(() => {
        const z = document.getElementById(`zesty-div-${F}`).querySelector('iframe:not([title*="prpb"])');
        if (z) {
          let k = function(H) {
            if (!H.contentDocument) return;
            const W = H.contentDocument.querySelectorAll("img"), $ = Array.prototype.filter.call(W, (j) => j.height > 1);
            return $.length != 0 ? { asset_url: $[0].src, cta_url: $[0].parentElement.href } : void 0;
          }(z);
          if (k) {
            const { asset_url: H, cta_url: W } = k;
            H === O[I].asset_url && W === O[I].cta_url || (O[I] = { asset_url: H, cta_url: W }, x = { asset_url: H, cta_url: W });
          }
        }
      }, 1e3), w = !0;
    })(B, D);
  }
  return new Promise((D, I) => {
    (async function F() {
      if (x != null && x.asset_url && (x != null && x.cta_url)) {
        const { asset_url: N, cta_url: U } = x;
        if (N.startsWith("canvas://")) {
          const G = document.createElement("iframe");
          G.id = "zesty-canvas-iframe", document.body.appendChild(G), G.contentDocument.open(), G.contentDocument.write(N.split("canvas://")[1]), G.contentDocument.close();
        }
        D({ Ads: [{ asset_url: N, cta_url: U }], CampaignId: "Prebid" });
      } else if (E[B]++, E[B] == 5) try {
        const N = encodeURI(window.top.location.href).replace(/\/$/, ""), U = await c.get(`https://api.zesty.market/api/ad?ad_unit_id=${B}&url=${N}`);
        U.data ? U(U.data) : U(_(e, b, M, L.format)), E[B] = 0;
      } catch {
        console.warn("Could not retrieve an active campaign banner. Retrieving default banner."), D(_(e, b, M, L.format)), E[B] = 0;
      }
      else setTimeout(F, 1e3);
    })();
  });
};
console.log("Zesty SDK Version: ", "3.0.0");
class S extends i.Mesh {
  constructor(e, b, L, M, D = null, I = !0) {
    super(), this.geometry = new i.PlaneGeometry(l[b].width * M, M, 1, 1), this.type = "ZestyBanner", this.adUnit = e, this.format = b, this.style = L, this.renderer = D, this.beacon = I, this.banner = {}, this.bannerPromise = T(e, b, L).then((F) => {
      this.material = new i.MeshBasicMaterial({ map: F.texture }), this.material.transparent = !0, this.banner = F, I && (async (N, U = null) => {
        const { platform: G, confidence: V } = await m();
        try {
          await c.post(v, { query: `mutation { increment(eventType: visits, spaceId: "${N}", campaignId: "${U}", platform: { name: ${G}, confidence: ${V} }) { message } }` }, { headers: { "Content-Type": "application/json" } });
        } catch (z) {
          console.log("Failed to emit onload event", z.message);
        }
      })(e, F.campaignId);
    }), this.onClick = this.onClick.bind(this), setInterval(this.refreshIfVisible.bind(this), 1e4);
  }
  onClick() {
    this.banner.url && (this.renderer != null && this.renderer.xr.getSession() != null && this.renderer.xr.getSession().end(), ((e) => {
      if (e) {
        if (d().match) {
          if (e.includes("https://www.meta.com/experiences/")) return void setTimeout(() => {
            window.open(e, "_blank");
          }, 1e3);
        } else if (f().match) {
          const b = document.createElement("div"), L = document.createElement("div"), M = document.createElement("p"), D = document.createElement("button"), I = document.createElement("button");
          return b.style.backgroundColor = "rgb(0, 0, 0, 0.75)", b.style.color = "white", b.style.textAlign = "center", b.style.position = "fixed", b.style.top = "50%", b.style.left = "50%", b.style.padding = "5%", b.style.borderRadius = "5%", b.style.transform = "translate(-50%, -50%)", M.innerHTML = `<b>This billboard leads to ${e}. Continue?</b>`, D.innerText = "Move cursor back into window.", D.style.width = "100vw", D.style.height = "100vh", D.onmouseenter = () => {
            D.style.width = "auto", D.style.height = "auto", D.innerText = "Yes";
          }, D.onclick = () => {
            window.open(e, "_blank"), b.remove();
          }, I.innerText = "No", I.onclick = () => {
            b.remove();
          }, b.append(L), L.append(M), L.append(D), L.append(I), void document.body.append(b);
        }
        window.open(e, "_blank");
      }
    })(this.banner.url), this.beacon && (async (e, b = null) => {
      const { platform: L, confidence: M } = await m();
      try {
        await c.post(v, { query: `mutation { increment(eventType: clicks, spaceId: "${e}", campaignId: "${b}", platform: { name: ${L}, confidence: ${M} }) { message } }` }, { headers: { "Content-Type": "application/json" } });
      } catch (D) {
        console.log("Failed to emit onclick event", D.message);
      }
    })(this.adUnit, this.banner.campaignId));
  }
  getCamera() {
    let e = null;
    return e = this.renderer.xr.isPresenting ? this.renderer.xr.getCamera() : (() => {
      let b = this.parent;
      for (; b.parent != null; ) b = b.parent;
      return b;
    })().getObjectByProperty("isCamera", !0), e;
  }
  refreshIfVisible() {
    const e = this.getCamera();
    this.geometry.computeBoundingBox();
    const b = new i.Box3().setFromObject(this);
    ((L, M, D, I) => {
      const F = new i.Box3(new i.Vector3().fromArray(L), new i.Vector3().fromArray(M)), N = new i.Frustum().setFromProjectionMatrix(new i.Matrix4().fromArray(D));
      return N.planes.forEach((U) => U.applyMatrix4(new i.Matrix4().fromArray(I))), N.intersectsBox(F);
    })(b.min.toArray(), b.max.toArray(), e.projectionMatrix.toArray(), e.matrixWorld.toArray()) && T(this.adUnit, this.format, this.style).then((L) => {
      this.material.map = L.texture, this.material.needsUpdate = !0, this.banner = L;
    });
  }
}
async function T(B, e, b) {
  const L = await C(B, e, b), { asset_url: M, cta_url: D } = L.Ads[0];
  return new Promise((I, F) => {
    new i.TextureLoader().load(M, function(N) {
      N.needsUpdate = !0, I({ texture: N, src: M, uri: L.uri, url: D, campaignId: L.CampaignId });
    }, void 0, function(N) {
      console.error("An error occurred while loading the ad."), F(N);
    });
  });
}
window.ZestyBanner = S;
var P = o.A;
window.Components = Components;
window.Systems = Systems;
window.THREE = THREE$1;
var world;
const urlParams = new URLSearchParams(window.location.search);
function detectWebXR() {
  "xr" in navigator ? navigator.xr.isSessionSupported("immersive-vr").then((B) => {
    B || document.getElementById("no-webxr").classList.remove("hidden");
  }) : document.getElementById("no-webxr").classList.remove("hidden");
}
function initGame() {
  detectWebXR(), world = new ECSYThreeWorld(), world.registerComponent(BallGenerator).registerComponent(GameState).registerComponent(Geometry).registerComponent(FloorCollided).registerComponent(Dissolve).registerComponent(Sound).registerComponent(Level).registerComponent(LevelItem).registerComponent(Colliding).registerComponent(CollisionStart).registerComponent(CollisionStop).registerComponent(Ball).registerComponent(Stop).registerComponent(Play).registerComponent(Text$1).registerComponent(RaycastReceiver).registerComponent(Target).registerComponent(Element).registerComponent(ParentObject3D).registerComponent(RigidBody).registerComponent(Animation).registerComponent(Floor).registerComponent(Position).registerComponent(Shape).registerComponent(Draggable).registerComponent(GLTFLoader$1).registerComponent(Transform).registerComponent(Visible).registerComponent(UI).registerComponent(Button).registerComponent(Ad), world.registerSystem(InputSystem).registerSystem(GameStateSystem).registerSystem(LevelManager).registerSystem(AnimationSystem).registerSystem(RaycasterSystem).registerSystem(UISystem).registerSystem(DissolveSystem).registerSystem(BallGeneratorSystem).registerSystem(VRControllerSystem).registerSystem(VRControllerInteraction).registerSystem(CameraRigSystem).registerSystem(ElementSystem).registerSystem(PhysicsSystem).registerSystem(SoundSystem).registerSystem(VisibilitySystem).registerSystem(TargetSystem).registerSystem(SDFTextSystem).registerSystem(RotatingSystem).registerSystem(OutputSystem).registerSystem(GLTFLoaderSystem).registerSystem(GeometrySystem);
  let B = initialize(world, { vr: !0 });
  var e = B.entities.scene.getObject3D();
  window.entityScene = B.entities.scene;
  let b = urlParams.has("level") ? parseInt(urlParams.get("level")) : 0;
  world.createEntity("singleton").addComponent(Scene, { value: B.entities.scene }).addComponent(GameState, {
    levelStartTime: performance.now(),
    gameStartTime: performance.now()
  }).addComponent(Level, { value: b }), world.getSystem(PhysicsSystem).stop(), L(B);
  function L(F) {
    e.fog = new FogExp2(new Color(5948892), 0.05), e.add(new HemisphereLight(13421772, 7368816));
    var N = new DirectionalLight(11184810);
    N.position.set(0.2, 1.7, -0.7), N.castShadow = !0, N.shadow.camera.top = 1, N.shadow.camera.bottom = -1, N.shadow.camera.right = 10, N.shadow.camera.left = -10, N.shadow.mapSize.set(4096, 4096), e.add(N), window.world = world, M(F);
    var U = new AudioListener(), G = new Audio$1(U), V = new Audio("assets/sounds/JosSs - Wehehey (Looped).ogg");
    V.loop = !0, G.setVolume(0.6), G.setMediaElementSource(V), world.execute(0.016, 0);
    const z = F.entities.renderer.getComponent(WebGLRendererContext).value, k = new P("1034346e-74d9-49f3-ac1c-a04b77a12cea", "mobile-phone-interstitial", "standard", 1.5, z);
    world.createEntity("zestyBanner").addComponent(OnObject3DAdded, {
      callback: (W) => {
        W.add(k);
      }
    }).addComponent(Position, { value: new Vector3(-1.5, 1.6, -2) }).addComponent(Parent, { value: F.entities.scene }).addComponent(Ad).addComponent(UI).addComponent(Button, { text: "", onClick: k.onClick }).addComponent(Visible, { value: !0 }).addComponent(GLTFLoader$1, {
      url: "assets/models/panelinfo.glb",
      onLoaded: (W) => {
        W.children[0].material = UIMaterial.clone(), W.children[0].renderOrder = 1, W.rotateZ(-Math.PI / 2), W.translateZ(-0.01), W.scale.set(1, 1.2, 1.2);
      }
    }), world.createEntity("newsPanel").addComponent(Position, { value: new Vector3(1.5, 1.6, -2) }).addComponent(Parent, { value: F.entities.scene }).addComponent(Visible, { value: !0 }).addComponent(GLTFLoader$1, {
      url: "assets/models/panelinfo.glb",
      onLoaded: (W) => {
        W.children[0].material = UIMaterial.clone(), W.children[0].renderOrder = 1, W.rotateZ(-Math.PI / 2), W.translateZ(-0.01), W.scale.set(1, 1.2, 1.2);
      }
    }), world.createEntity("adText").addComponent(Position, { value: new Vector3(-1.5, 2.75, -2) }).addComponent(Parent, { value: F.entities.scene }).addComponent(UI).addComponent(Visible, { value: !0 }).addComponent(Text$1, {
      color: "#FFF",
      font: "assets/fonts/WetinCaroWant.ttf",
      fontSize: 0.15,
      anchor: "center",
      textAlign: "center",
      baseline: "center",
      maxWidth: 10,
      lineHeight: 0,
      text: "Ad"
    }), world.createEntity("newsText").addComponent(Position, { value: new Vector3(1.5, 2.75, -2) }).addComponent(Parent, { value: F.entities.scene }).addComponent(UI).addComponent(Visible, { value: !0 }).addComponent(Text$1, {
      color: "#FFF",
      font: "assets/fonts/WetinCaroWant.ttf",
      fontSize: 0.15,
      anchor: "center",
      textAlign: "center",
      baseline: "center",
      maxWidth: 10,
      lineHeight: 0,
      text: "News"
    }), world.createEntity("futureUpdateText").addComponent(Position, { value: new Vector3(1.5, 1.75, -2) }).addComponent(Parent, { value: F.entities.scene }).addComponent(UI).addComponent(Visible, { value: !0 }).addComponent(Text$1, {
      color: "#FFF",
      font: "assets/fonts/WetinCaroWant.ttf",
      fontSize: 0.09,
      anchor: "center",
      textAlign: "center",
      baseline: "center",
      maxWidth: 1,
      lineHeight: 1,
      text: "New updates coming soon!"
    });
    let H = world.createEntity("startbutton").addComponent(UI).addComponent(GLTFLoader$1, {
      url: "assets/models/startbutton.glb",
      append: !0,
      onLoaded: (W) => {
        W.children[0].material = UIMaterial, W.children[0].material.color.setRGB(0.7, 0.7, 0.7);
      }
    }).addComponent(Button, {
      text: "START",
      onClick: () => {
        V.play(), world.getSystem(GameStateSystem).playGame(), setTimeout(() => {
          H.addComponent(Visible, { value: !1 });
        }, 300);
      }
    }).addComponent(Parent, { value: F.entities.scene }).addComponent(Position, { value: new Vector3(0, 0.6, -1.5) }).addComponent(Sound, { url: "assets/sounds/click.ogg" }).addComponent(Visible, { value: !urlParams.has("autostart") });
    urlParams.has("autostart") && world.getSystem(GameStateSystem).playGame(), F.entities.renderer.getComponent(
      WebGLRendererContext
    ).value.outputEncoding = sRGBEncoding;
  }
  function M(F) {
    D(F);
    let N = world.createEntity("playingGroup").addComponent(Object3DComponent, { value: new Group() }).addComponent(Parent, { value: F.entities.scene }).addComponent(Visible, { value: urlParams.has("autostart") });
    world.createEntity("levelGroup").addComponent(Object3DComponent, { value: new Group() }).addComponent(Parent, { value: N }).addComponent(Visible, { value: !0 }), world.createEntity().addComponent(GLTFLoader$1, {
      url: "assets/models/set.glb",
      onLoaded: (U) => {
        const G = U.getObjectByName("clouds").material;
        G.transparent = !0, G.fog = !1;
        const V = U.getObjectByName("sky").material;
        V.fog = !1;
      }
    }).addComponent(Parent, { value: F.entities.scene }), world.createEntity("help").addComponent(GLTFLoader$1, {
      url: "assets/models/help.glb",
      onLoaded: (U) => {
        U.children[0].material.transparent = !0, U.children[0].material.map.magFilter = LinearFilter, U.children[0].material.map.minFilter = LinearMipmapLinearFilter;
      }
    }).addComponent(Position, { value: new Vector3(0, 1.6, -2) }).addComponent(Parent, { value: F.entities.scene }).addComponent(Visible, { value: !0 }), world.createEntity("panelLevel").addComponent(GLTFLoader$1, {
      url: "assets/models/panellevel.glb",
      onLoaded: (U) => {
        U.children[0].material = UIMaterial, U.children[0].renderOrder = 1, world.createEntity("levelLabel").addComponent(
          Text$1,
          I("Level", "#20b4d6", 0.12, "center")
        ).addComponent(ParentObject3D, { value: U.children[0] }).addComponent(Position, { value: new Vector3(0, 0.2, 0.01) }), world.createEntity("level").addComponent(
          Text$1,
          I("1", "#90cdeb", 0.3, "center")
        ).addComponent(OnObject3DAdded, {
          callback: (G) => {
            U.children[0].add(G);
          }
        }).addComponent(ParentObject3D, { value: U.children[0] }).addComponent(Position, { value: new Vector3(0, 0, 0.01) });
      }
    }).addComponent(Parent, { value: N }).addComponent(Position, { value: new Vector3(0, 3.2, -6) }), world.createEntity("panelInfo").addComponent(GLTFLoader$1, {
      url: "assets/models/panelinfo.glb",
      onLoaded: (U) => {
        U.children[0].material = UIMaterial, U.children[0].children[0].material = UIMaterial, U.children[0].children[0].renderOrder = 1, U.children[0].renderOrder = 2;
        let G = U.children[0].children[0];
        world.createEntity("finished").addComponent(
          Text$1,
          I("Finished!", "#ffffff", 0.2, "center")
        ).addComponent(ParentObject3D, { value: G }).addComponent(Position, { value: new Vector3(0, 0.1, -0.1) }).addComponent(Visible, { value: !0 }), world.createEntity("numberBallsLabel").addComponent(
          Text$1,
          I("Balls", "#c0095d", 0.2, "center")
        ).addComponent(ParentObject3D, { value: U.children[0] }).addComponent(Position, { value: new Vector3(-0.4, 0.26, 0.01) }), world.createEntity("numberBalls").addComponent(
          Text$1,
          I("0", "#f9258b", 0.2, "center")
        ).addComponent(ParentObject3D, { value: U.children[0] }).addComponent(Position, { value: new Vector3(-0.4, 0, 0.01) }), world.createEntity("timeLabel").addComponent(
          Text$1,
          I("Time", "#836000", 0.2, "center")
        ).addComponent(ParentObject3D, { value: U.children[0] }).addComponent(Position, { value: new Vector3(0.4, 0.28, 0.01) }), world.createEntity("totalTimeLabel").addComponent(
          Text$1,
          I("Total", "#836000", 0.095, "center")
        ).addComponent(ParentObject3D, { value: U.children[0] }).addComponent(Position, { value: new Vector3(0.16, -0.21, 0.01) }), world.createEntity("timer").addComponent(
          Text$1,
          I("00:00", "#ebb808", 0.22, "center")
        ).addComponent(ParentObject3D, { value: U.children[0] }).addComponent(Position, { value: new Vector3(0.4, 0.04, 0.01) }), world.createEntity("timerTotal").addComponent(
          Text$1,
          I("00:00", "#ebb808", 0.12, "left")
        ).addComponent(ParentObject3D, { value: U.children[0] }).addComponent(Position, { value: new Vector3(0.36, -0.13, 0.01) });
      }
    }).addComponent(Parent, {
      value: F.entities.scene
      /*playingGroup*/
    }).addComponent(Animation, { duration: 2.35 }).addComponent(Position, { value: new Vector3(0, 2, -6) }).addComponent(Visible, { value: !1 });
  }
  function D(F) {
    world.createEntity().addComponent(Geometry, {
      primitive: "box",
      width: 100,
      height: 0.1,
      depth: 100
    }).addComponent(Shape, {
      primitive: "box",
      width: 100,
      height: 0.1,
      depth: 100
    }).addComponent(Visible, { value: !1 }).addComponent(Transform, {
      position: { x: 0, y: -0.05, z: 0 },
      rotation: { x: 0, y: 0, z: 0 }
    }).addComponent(Floor).addComponent(Sound, { url: "assets/sounds/miss.ogg" }).addComponent(RigidBody, {
      weight: 0,
      restitution: 0.5,
      friction: 3,
      linearDamping: 0,
      angularDamping: 0
    }).addComponent(Parent, { value: F.entities.scene });
  }
  function I(F, N, U, G) {
    return {
      color: N || "0xFFFFFF",
      fontSize: U || 0.5,
      anchor: G || "center",
      textAlign: G || "center",
      baseline: G || "center",
      font: "assets/fonts/WetinCaroWant.ttf",
      maxWidth: 10,
      lineHeight: 1.3,
      text: F || "LOREM IPSUM"
    };
  }
}
Ammo().then(initGame);
