Number.EPSILON === void 0 && (Number.EPSILON = Math.pow(2, -52));
Number.isInteger === void 0 && (Number.isInteger = function(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
});
Math.sign === void 0 && (Math.sign = function(e) {
  return e < 0 ? -1 : e > 0 ? 1 : +e;
});
"name" in Function.prototype || Object.defineProperty(Function.prototype, "name", {
  get: function() {
    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
  }
});
Object.assign === void 0 && (Object.assign = function(e) {
  if (e == null)
    throw new TypeError("Cannot convert undefined or null to object");
  const t = Object(e);
  for (let r = 1; r < arguments.length; r++) {
    const n = arguments[r];
    if (n != null)
      for (const a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a]);
  }
  return t;
});
const REVISION = "117", MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, CullFaceNone = 0, CullFaceBack = 1, CullFaceFront = 2, CullFaceFrontBack = 3, FrontFaceDirectionCW = 0, FrontFaceDirectionCCW = 1, BasicShadowMap = 0, PCFShadowMap = 1, PCFSoftShadowMap = 2, VSMShadowMap = 3, FrontSide = 0, BackSide = 1, DoubleSide = 2, FlatShading = 1, SmoothShading = 2, NoBlending = 0, NormalBlending = 1, AdditiveBlending = 2, SubtractiveBlending = 3, MultiplyBlending = 4, CustomBlending = 5, AddEquation = 100, SubtractEquation = 101, ReverseSubtractEquation = 102, MinEquation = 103, MaxEquation = 104, ZeroFactor = 200, OneFactor = 201, SrcColorFactor = 202, OneMinusSrcColorFactor = 203, SrcAlphaFactor = 204, OneMinusSrcAlphaFactor = 205, DstAlphaFactor = 206, OneMinusDstAlphaFactor = 207, DstColorFactor = 208, OneMinusDstColorFactor = 209, SrcAlphaSaturateFactor = 210, NeverDepth = 0, AlwaysDepth = 1, LessDepth = 2, LessEqualDepth = 3, EqualDepth = 4, GreaterEqualDepth = 5, GreaterDepth = 6, NotEqualDepth = 7, MultiplyOperation = 0, MixOperation = 1, AddOperation = 2, NoToneMapping = 0, LinearToneMapping = 1, ReinhardToneMapping = 2, Uncharted2ToneMapping = 3, CineonToneMapping = 4, ACESFilmicToneMapping = 5, UVMapping = 300, CubeReflectionMapping = 301, CubeRefractionMapping = 302, EquirectangularReflectionMapping = 303, EquirectangularRefractionMapping = 304, SphericalReflectionMapping = 305, CubeUVReflectionMapping = 306, CubeUVRefractionMapping = 307, RepeatWrapping = 1e3, ClampToEdgeWrapping = 1001, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipmapNearestFilter = 1004, NearestMipMapNearestFilter = 1004, NearestMipmapLinearFilter = 1005, NearestMipMapLinearFilter = 1005, LinearFilter = 1006, LinearMipmapNearestFilter = 1007, LinearMipMapNearestFilter = 1007, LinearMipmapLinearFilter = 1008, LinearMipMapLinearFilter = 1008, UnsignedByteType = 1009, ByteType = 1010, ShortType = 1011, UnsignedShortType = 1012, IntType = 1013, UnsignedIntType = 1014, FloatType = 1015, HalfFloatType = 1016, UnsignedShort4444Type = 1017, UnsignedShort5551Type = 1018, UnsignedShort565Type = 1019, UnsignedInt248Type = 1020, AlphaFormat = 1021, RGBFormat = 1022, RGBAFormat = 1023, LuminanceFormat = 1024, LuminanceAlphaFormat = 1025, RGBEFormat = RGBAFormat, DepthFormat = 1026, DepthStencilFormat = 1027, RedFormat = 1028, RedIntegerFormat = 1029, RGFormat = 1030, RGIntegerFormat = 1031, RGBIntegerFormat = 1032, RGBAIntegerFormat = 1033, RGB_S3TC_DXT1_Format = 33776, RGBA_S3TC_DXT1_Format = 33777, RGBA_S3TC_DXT3_Format = 33778, RGBA_S3TC_DXT5_Format = 33779, RGB_PVRTC_4BPPV1_Format = 35840, RGB_PVRTC_2BPPV1_Format = 35841, RGBA_PVRTC_4BPPV1_Format = 35842, RGBA_PVRTC_2BPPV1_Format = 35843, RGB_ETC1_Format = 36196, RGB_ETC2_Format = 37492, RGBA_ETC2_EAC_Format = 37496, RGBA_ASTC_4x4_Format = 37808, RGBA_ASTC_5x4_Format = 37809, RGBA_ASTC_5x5_Format = 37810, RGBA_ASTC_6x5_Format = 37811, RGBA_ASTC_6x6_Format = 37812, RGBA_ASTC_8x5_Format = 37813, RGBA_ASTC_8x6_Format = 37814, RGBA_ASTC_8x8_Format = 37815, RGBA_ASTC_10x5_Format = 37816, RGBA_ASTC_10x6_Format = 37817, RGBA_ASTC_10x8_Format = 37818, RGBA_ASTC_10x10_Format = 37819, RGBA_ASTC_12x10_Format = 37820, RGBA_ASTC_12x12_Format = 37821, RGBA_BPTC_Format = 36492, SRGB8_ALPHA8_ASTC_4x4_Format = 37840, SRGB8_ALPHA8_ASTC_5x4_Format = 37841, SRGB8_ALPHA8_ASTC_5x5_Format = 37842, SRGB8_ALPHA8_ASTC_6x5_Format = 37843, SRGB8_ALPHA8_ASTC_6x6_Format = 37844, SRGB8_ALPHA8_ASTC_8x5_Format = 37845, SRGB8_ALPHA8_ASTC_8x6_Format = 37846, SRGB8_ALPHA8_ASTC_8x8_Format = 37847, SRGB8_ALPHA8_ASTC_10x5_Format = 37848, SRGB8_ALPHA8_ASTC_10x6_Format = 37849, SRGB8_ALPHA8_ASTC_10x8_Format = 37850, SRGB8_ALPHA8_ASTC_10x10_Format = 37851, SRGB8_ALPHA8_ASTC_12x10_Format = 37852, SRGB8_ALPHA8_ASTC_12x12_Format = 37853, LoopOnce = 2200, LoopRepeat = 2201, LoopPingPong = 2202, InterpolateDiscrete = 2300, InterpolateLinear = 2301, InterpolateSmooth = 2302, ZeroCurvatureEnding = 2400, ZeroSlopeEnding = 2401, WrapAroundEnding = 2402, NormalAnimationBlendMode = 2500, AdditiveAnimationBlendMode = 2501, TrianglesDrawMode = 0, TriangleStripDrawMode = 1, TriangleFanDrawMode = 2, LinearEncoding = 3e3, sRGBEncoding = 3001, GammaEncoding = 3007, RGBEEncoding = 3002, LogLuvEncoding = 3003, RGBM7Encoding = 3004, RGBM16Encoding = 3005, RGBDEncoding = 3006, BasicDepthPacking = 3200, RGBADepthPacking = 3201, TangentSpaceNormalMap = 0, ObjectSpaceNormalMap = 1, ZeroStencilOp = 0, KeepStencilOp = 7680, ReplaceStencilOp = 7681, IncrementStencilOp = 7682, DecrementStencilOp = 7683, IncrementWrapStencilOp = 34055, DecrementWrapStencilOp = 34056, InvertStencilOp = 5386, NeverStencilFunc = 512, LessStencilFunc = 513, EqualStencilFunc = 514, LessEqualStencilFunc = 515, GreaterStencilFunc = 516, NotEqualStencilFunc = 517, GreaterEqualStencilFunc = 518, AlwaysStencilFunc = 519, StaticDrawUsage = 35044, DynamicDrawUsage = 35048, StreamDrawUsage = 35040, StaticReadUsage = 35045, DynamicReadUsage = 35049, StreamReadUsage = 35041, StaticCopyUsage = 35046, DynamicCopyUsage = 35050, StreamCopyUsage = 35042;
function EventDispatcher$1() {
}
Object.assign(EventDispatcher$1.prototype, {
  addEventListener: function(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    var r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  },
  hasEventListener: function(e, t) {
    if (this._listeners === void 0) return !1;
    var r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  },
  removeEventListener: function(e, t) {
    if (this._listeners !== void 0) {
      var r = this._listeners, n = r[e];
      if (n !== void 0) {
        var a = n.indexOf(t);
        a !== -1 && n.splice(a, 1);
      }
    }
  },
  dispatchEvent: function(e) {
    if (this._listeners !== void 0) {
      var t = this._listeners, r = t[e.type];
      if (r !== void 0) {
        e.target = this;
        for (var n = r.slice(0), a = 0, o = n.length; a < o; a++)
          n[a].call(this, e);
      }
    }
  }
});
var _lut = [];
for (var i = 0; i < 256; i++)
  _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
var MathUtils = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function() {
    var e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, a = _lut[e & 255] + _lut[e >> 8 & 255] + _lut[e >> 16 & 255] + _lut[e >> 24 & 255] + "-" + _lut[t & 255] + _lut[t >> 8 & 255] + "-" + _lut[t >> 16 & 15 | 64] + _lut[t >> 24 & 255] + "-" + _lut[r & 63 | 128] + _lut[r >> 8 & 255] + "-" + _lut[r >> 16 & 255] + _lut[r >> 24 & 255] + _lut[n & 255] + _lut[n >> 8 & 255] + _lut[n >> 16 & 255] + _lut[n >> 24 & 255];
    return a.toUpperCase();
  },
  clamp: function(e, t, r) {
    return Math.max(t, Math.min(r, e));
  },
  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  euclideanModulo: function(e, t) {
    return (e % t + t) % t;
  },
  // Linear mapping from range <a1, a2> to range <b1, b2>
  mapLinear: function(e, t, r, n, a) {
    return n + (e - t) * (a - n) / (r - t);
  },
  // https://en.wikipedia.org/wiki/Linear_interpolation
  lerp: function(e, t, r) {
    return (1 - r) * e + r * t;
  },
  // http://en.wikipedia.org/wiki/Smoothstep
  smoothstep: function(e, t, r) {
    return e <= t ? 0 : e >= r ? 1 : (e = (e - t) / (r - t), e * e * (3 - 2 * e));
  },
  smootherstep: function(e, t, r) {
    return e <= t ? 0 : e >= r ? 1 : (e = (e - t) / (r - t), e * e * e * (e * (e * 6 - 15) + 10));
  },
  // Random integer from <low, high> interval
  randInt: function(e, t) {
    return e + Math.floor(Math.random() * (t - e + 1));
  },
  // Random float from <low, high> interval
  randFloat: function(e, t) {
    return e + Math.random() * (t - e);
  },
  // Random float from <-range/2, range/2> interval
  randFloatSpread: function(e) {
    return e * (0.5 - Math.random());
  },
  degToRad: function(e) {
    return e * MathUtils.DEG2RAD;
  },
  radToDeg: function(e) {
    return e * MathUtils.RAD2DEG;
  },
  isPowerOfTwo: function(e) {
    return (e & e - 1) === 0 && e !== 0;
  },
  ceilPowerOfTwo: function(e) {
    return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
  },
  floorPowerOfTwo: function(e) {
    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
  },
  setQuaternionFromProperEuler: function(e, t, r, n, a) {
    var o = Math.cos, s = Math.sin, l = o(r / 2), c = s(r / 2), u = o((t + n) / 2), h = s((t + n) / 2), f = o((t - n) / 2), d = s((t - n) / 2), p = o((n - t) / 2), g = s((n - t) / 2);
    switch (a) {
      case "XYX":
        e.set(l * h, c * f, c * d, l * u);
        break;
      case "YZY":
        e.set(c * d, l * h, c * f, l * u);
        break;
      case "ZXZ":
        e.set(c * f, c * d, l * h, l * u);
        break;
      case "XZX":
        e.set(l * h, c * g, c * p, l * u);
        break;
      case "YXY":
        e.set(c * p, l * h, c * g, l * u);
        break;
      case "ZYZ":
        e.set(c * g, c * p, l * h, l * u);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + a);
    }
  }
};
function Vector2(e, t) {
  this.x = e || 0, this.y = t || 0;
}
Object.defineProperties(Vector2.prototype, {
  width: {
    get: function() {
      return this.x;
    },
    set: function(e) {
      this.x = e;
    }
  },
  height: {
    get: function() {
      return this.y;
    },
    set: function(e) {
      this.y = e;
    }
  }
});
Object.assign(Vector2.prototype, {
  isVector2: !0,
  set: function(e, t) {
    return this.x = e, this.y = t, this;
  },
  setScalar: function(e) {
    return this.x = e, this.y = e, this;
  },
  setX: function(e) {
    return this.x = e, this;
  },
  setY: function(e) {
    return this.y = e, this;
  },
  setComponent: function(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  },
  getComponent: function(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y);
  },
  copy: function(e) {
    return this.x = e.x, this.y = e.y, this;
  },
  add: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this);
  },
  addScalar: function(e) {
    return this.x += e, this.y += e, this;
  },
  addVectors: function(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  },
  addScaledVector: function(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  },
  sub: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this);
  },
  subScalar: function(e) {
    return this.x -= e, this.y -= e, this;
  },
  subVectors: function(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  },
  multiply: function(e) {
    return this.x *= e.x, this.y *= e.y, this;
  },
  multiplyScalar: function(e) {
    return this.x *= e, this.y *= e, this;
  },
  divide: function(e) {
    return this.x /= e.x, this.y /= e.y, this;
  },
  divideScalar: function(e) {
    return this.multiplyScalar(1 / e);
  },
  applyMatrix3: function(e) {
    var t = this.x, r = this.y, n = e.elements;
    return this.x = n[0] * t + n[3] * r + n[6], this.y = n[1] * t + n[4] * r + n[7], this;
  },
  min: function(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  },
  max: function(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  },
  clamp: function(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  },
  clampScalar: function(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  },
  clampLength: function(e, t) {
    var r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  },
  floor: function() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  },
  ceil: function() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  },
  round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  },
  roundToZero: function() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  },
  negate: function() {
    return this.x = -this.x, this.y = -this.y, this;
  },
  dot: function(e) {
    return this.x * e.x + this.y * e.y;
  },
  cross: function(e) {
    return this.x * e.y - this.y * e.x;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  angle: function() {
    var e = Math.atan2(-this.y, -this.x) + Math.PI;
    return e;
  },
  distanceTo: function(e) {
    return Math.sqrt(this.distanceToSquared(e));
  },
  distanceToSquared: function(e) {
    var t = this.x - e.x, r = this.y - e.y;
    return t * t + r * r;
  },
  manhattanDistanceTo: function(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  },
  setLength: function(e) {
    return this.normalize().multiplyScalar(e);
  },
  lerp: function(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  },
  lerpVectors: function(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this;
  },
  equals: function(e) {
    return e.x === this.x && e.y === this.y;
  },
  fromArray: function(e, t) {
    return t === void 0 && (t = 0), this.x = e[t], this.y = e[t + 1], this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this.x, e[t + 1] = this.y, e;
  },
  fromBufferAttribute: function(e, t, r) {
    return r !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this;
  },
  rotateAround: function(e, t) {
    var r = Math.cos(t), n = Math.sin(t), a = this.x - e.x, o = this.y - e.y;
    return this.x = a * r - o * n + e.x, this.y = a * n + o * r + e.y, this;
  },
  random: function() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
});
function Matrix3() {
  this.elements = [
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
  ], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
}
Object.assign(Matrix3.prototype, {
  isMatrix3: !0,
  set: function(e, t, r, n, a, o, s, l, c) {
    var u = this.elements;
    return u[0] = e, u[1] = n, u[2] = s, u[3] = t, u[4] = a, u[5] = l, u[6] = r, u[7] = o, u[8] = c, this;
  },
  identity: function() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  },
  clone: function() {
    return new this.constructor().fromArray(this.elements);
  },
  copy: function(e) {
    var t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this;
  },
  extractBasis: function(e, t, r) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this;
  },
  setFromMatrix4: function(e) {
    var t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  },
  multiply: function(e) {
    return this.multiplyMatrices(this, e);
  },
  premultiply: function(e) {
    return this.multiplyMatrices(e, this);
  },
  multiplyMatrices: function(e, t) {
    var r = e.elements, n = t.elements, a = this.elements, o = r[0], s = r[3], l = r[6], c = r[1], u = r[4], h = r[7], f = r[2], d = r[5], p = r[8], g = n[0], v = n[3], _ = n[6], m = n[1], y = n[4], b = n[7], M = n[2], x = n[5], w = n[8];
    return a[0] = o * g + s * m + l * M, a[3] = o * v + s * y + l * x, a[6] = o * _ + s * b + l * w, a[1] = c * g + u * m + h * M, a[4] = c * v + u * y + h * x, a[7] = c * _ + u * b + h * w, a[2] = f * g + d * m + p * M, a[5] = f * v + d * y + p * x, a[8] = f * _ + d * b + p * w, this;
  },
  multiplyScalar: function(e) {
    var t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  },
  determinant: function() {
    var e = this.elements, t = e[0], r = e[1], n = e[2], a = e[3], o = e[4], s = e[5], l = e[6], c = e[7], u = e[8];
    return t * o * u - t * s * c - r * a * u + r * s * l + n * a * c - n * o * l;
  },
  getInverse: function(e, t) {
    t !== void 0 && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
    var r = e.elements, n = this.elements, a = r[0], o = r[1], s = r[2], l = r[3], c = r[4], u = r[5], h = r[6], f = r[7], d = r[8], p = d * c - u * f, g = u * h - d * l, v = f * l - c * h, _ = a * p + o * g + s * v;
    if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    var m = 1 / _;
    return n[0] = p * m, n[1] = (s * f - d * o) * m, n[2] = (u * o - s * c) * m, n[3] = g * m, n[4] = (d * a - s * h) * m, n[5] = (s * l - u * a) * m, n[6] = v * m, n[7] = (o * h - f * a) * m, n[8] = (c * a - o * l) * m, this;
  },
  transpose: function() {
    var e, t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  },
  getNormalMatrix: function(e) {
    return this.setFromMatrix4(e).getInverse(this).transpose();
  },
  transposeIntoArray: function(e) {
    var t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  },
  setUvTransform: function(e, t, r, n, a, o, s) {
    var l = Math.cos(a), c = Math.sin(a);
    this.set(
      r * l,
      r * c,
      -r * (l * o + c * s) + o + e,
      -n * c,
      n * l,
      -n * (-c * o + l * s) + s + t,
      0,
      0,
      1
    );
  },
  scale: function(e, t) {
    var r = this.elements;
    return r[0] *= e, r[3] *= e, r[6] *= e, r[1] *= t, r[4] *= t, r[7] *= t, this;
  },
  rotate: function(e) {
    var t = Math.cos(e), r = Math.sin(e), n = this.elements, a = n[0], o = n[3], s = n[6], l = n[1], c = n[4], u = n[7];
    return n[0] = t * a + r * l, n[3] = t * o + r * c, n[6] = t * s + r * u, n[1] = -r * a + t * l, n[4] = -r * o + t * c, n[7] = -r * s + t * u, this;
  },
  translate: function(e, t) {
    var r = this.elements;
    return r[0] += e * r[2], r[3] += e * r[5], r[6] += e * r[8], r[1] += t * r[2], r[4] += t * r[5], r[7] += t * r[8], this;
  },
  equals: function(e) {
    for (var t = this.elements, r = e.elements, n = 0; n < 9; n++)
      if (t[n] !== r[n]) return !1;
    return !0;
  },
  fromArray: function(e, t) {
    t === void 0 && (t = 0);
    for (var r = 0; r < 9; r++)
      this.elements[r] = e[r + t];
    return this;
  },
  toArray: function(e, t) {
    e === void 0 && (e = []), t === void 0 && (t = 0);
    var r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e;
  }
});
var _canvas, ImageUtils = {
  getDataURL: function(e) {
    var t;
    if (typeof HTMLCanvasElement > "u")
      return e.src;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      _canvas === void 0 && (_canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), _canvas.width = e.width, _canvas.height = e.height;
      var r = _canvas.getContext("2d");
      e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height), t = _canvas;
    }
    return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", 0.6) : t.toDataURL("image/png");
  }
}, textureId = 0;
function Texture(e, t, r, n, a, o, s, l, c, u) {
  Object.defineProperty(this, "id", { value: textureId++ }), this.uuid = MathUtils.generateUUID(), this.name = "", this.image = e !== void 0 ? e : Texture.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = t !== void 0 ? t : Texture.DEFAULT_MAPPING, this.wrapS = r !== void 0 ? r : ClampToEdgeWrapping, this.wrapT = n !== void 0 ? n : ClampToEdgeWrapping, this.magFilter = a !== void 0 ? a : LinearFilter, this.minFilter = o !== void 0 ? o : LinearMipmapLinearFilter, this.anisotropy = c !== void 0 ? c : 1, this.format = s !== void 0 ? s : RGBAFormat, this.internalFormat = null, this.type = l !== void 0 ? l : UnsignedByteType, this.offset = new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Matrix3(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = u !== void 0 ? u : LinearEncoding, this.version = 0, this.onUpdate = null;
}
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype = Object.assign(Object.create(EventDispatcher$1.prototype), {
  constructor: Texture,
  isTexture: !0,
  updateMatrix: function() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this;
  },
  toJSON: function(e) {
    var t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    var r = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      var n = this.image;
      if (n.uuid === void 0 && (n.uuid = MathUtils.generateUUID()), !t && e.images[n.uuid] === void 0) {
        var a;
        if (Array.isArray(n)) {
          a = [];
          for (var o = 0, s = n.length; o < s; o++)
            a.push(ImageUtils.getDataURL(n[o]));
        } else
          a = ImageUtils.getDataURL(n);
        e.images[n.uuid] = {
          uuid: n.uuid,
          url: a
        };
      }
      r.image = n.uuid;
    }
    return t || (e.textures[this.uuid] = r), r;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  },
  transformUv: function(e) {
    if (this.mapping !== UVMapping) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case RepeatWrapping:
          e.x = e.x - Math.floor(e.x);
          break;
        case ClampToEdgeWrapping:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case RepeatWrapping:
          e.y = e.y - Math.floor(e.y);
          break;
        case ClampToEdgeWrapping:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
});
Object.defineProperty(Texture.prototype, "needsUpdate", {
  set: function(e) {
    e === !0 && this.version++;
  }
});
function Vector4(e, t, r, n) {
  this.x = e || 0, this.y = t || 0, this.z = r || 0, this.w = n !== void 0 ? n : 1;
}
Object.defineProperties(Vector4.prototype, {
  width: {
    get: function() {
      return this.z;
    },
    set: function(e) {
      this.z = e;
    }
  },
  height: {
    get: function() {
      return this.w;
    },
    set: function(e) {
      this.w = e;
    }
  }
});
Object.assign(Vector4.prototype, {
  isVector4: !0,
  set: function(e, t, r, n) {
    return this.x = e, this.y = t, this.z = r, this.w = n, this;
  },
  setScalar: function(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  },
  setX: function(e) {
    return this.x = e, this;
  },
  setY: function(e) {
    return this.y = e, this;
  },
  setZ: function(e) {
    return this.z = e, this;
  },
  setW: function(e) {
    return this.w = e, this;
  },
  setComponent: function(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  },
  getComponent: function(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  },
  copy: function(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  },
  add: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this);
  },
  addScalar: function(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  },
  addVectors: function(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  },
  addScaledVector: function(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  },
  sub: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this);
  },
  subScalar: function(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  },
  subVectors: function(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  },
  multiplyScalar: function(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  },
  applyMatrix4: function(e) {
    var t = this.x, r = this.y, n = this.z, a = this.w, o = e.elements;
    return this.x = o[0] * t + o[4] * r + o[8] * n + o[12] * a, this.y = o[1] * t + o[5] * r + o[9] * n + o[13] * a, this.z = o[2] * t + o[6] * r + o[10] * n + o[14] * a, this.w = o[3] * t + o[7] * r + o[11] * n + o[15] * a, this;
  },
  divideScalar: function(e) {
    return this.multiplyScalar(1 / e);
  },
  setAxisAngleFromQuaternion: function(e) {
    this.w = 2 * Math.acos(e.w);
    var t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  },
  setAxisAngleFromRotationMatrix: function(e) {
    var t, r, n, a, o = 0.01, s = 0.1, l = e.elements, c = l[0], u = l[4], h = l[8], f = l[1], d = l[5], p = l[9], g = l[2], v = l[6], _ = l[10];
    if (Math.abs(u - f) < o && Math.abs(h - g) < o && Math.abs(p - v) < o) {
      if (Math.abs(u + f) < s && Math.abs(h + g) < s && Math.abs(p + v) < s && Math.abs(c + d + _ - 3) < s)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      var m = (c + 1) / 2, y = (d + 1) / 2, b = (_ + 1) / 2, M = (u + f) / 4, x = (h + g) / 4, w = (p + v) / 4;
      return m > y && m > b ? m < o ? (r = 0, n = 0.707106781, a = 0.707106781) : (r = Math.sqrt(m), n = M / r, a = x / r) : y > b ? y < o ? (r = 0.707106781, n = 0, a = 0.707106781) : (n = Math.sqrt(y), r = M / n, a = w / n) : b < o ? (r = 0.707106781, n = 0.707106781, a = 0) : (a = Math.sqrt(b), r = x / a, n = w / a), this.set(r, n, a, t), this;
    }
    var P = Math.sqrt((v - p) * (v - p) + (h - g) * (h - g) + (f - u) * (f - u));
    return Math.abs(P) < 1e-3 && (P = 1), this.x = (v - p) / P, this.y = (h - g) / P, this.z = (f - u) / P, this.w = Math.acos((c + d + _ - 1) / 2), this;
  },
  min: function(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  },
  max: function(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  },
  clamp: function(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  },
  clampScalar: function(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  },
  clampLength: function(e, t) {
    var r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  },
  floor: function() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  },
  ceil: function() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  },
  round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  },
  roundToZero: function() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  },
  negate: function() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  },
  dot: function(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function(e) {
    return this.normalize().multiplyScalar(e);
  },
  lerp: function(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  },
  lerpVectors: function(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this.w = e.w + (t.w - e.w) * r, this;
  },
  equals: function(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  },
  fromArray: function(e, t) {
    return t === void 0 && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  },
  fromBufferAttribute: function(e, t, r) {
    return r !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  },
  random: function() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
});
function WebGLRenderTarget(e, t, r) {
  this.width = e, this.height = t, this.scissor = new Vector4(0, 0, e, t), this.scissorTest = !1, this.viewport = new Vector4(0, 0, e, t), r = r || {}, this.texture = new Texture(void 0, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.encoding), this.texture.image = {}, this.texture.image.width = e, this.texture.image.height = t, this.texture.generateMipmaps = r.generateMipmaps !== void 0 ? r.generateMipmaps : !1, this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : LinearFilter, this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0, this.stencilBuffer = r.stencilBuffer !== void 0 ? r.stencilBuffer : !0, this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null;
}
WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher$1.prototype), {
  constructor: WebGLRenderTarget,
  isWebGLRenderTarget: !0,
  setSize: function(e, t) {
    (this.width !== e || this.height !== t) && (this.width = e, this.height = t, this.texture.image.width = e, this.texture.image.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function WebGLMultisampleRenderTarget(e, t, r) {
  WebGLRenderTarget.call(this, e, t, r), this.samples = 4;
}
WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
  constructor: WebGLMultisampleRenderTarget,
  isWebGLMultisampleRenderTarget: !0,
  copy: function(e) {
    return WebGLRenderTarget.prototype.copy.call(this, e), this.samples = e.samples, this;
  }
});
function Quaternion(e, t, r, n) {
  this._x = e || 0, this._y = t || 0, this._z = r || 0, this._w = n !== void 0 ? n : 1;
}
Object.assign(Quaternion, {
  slerp: function(e, t, r, n) {
    return r.copy(e).slerp(t, n);
  },
  slerpFlat: function(e, t, r, n, a, o, s) {
    var l = r[n + 0], c = r[n + 1], u = r[n + 2], h = r[n + 3], f = a[o + 0], d = a[o + 1], p = a[o + 2], g = a[o + 3];
    if (h !== g || l !== f || c !== d || u !== p) {
      var v = 1 - s, _ = l * f + c * d + u * p + h * g, m = _ >= 0 ? 1 : -1, y = 1 - _ * _;
      if (y > Number.EPSILON) {
        var b = Math.sqrt(y), M = Math.atan2(b, _ * m);
        v = Math.sin(v * M) / b, s = Math.sin(s * M) / b;
      }
      var x = s * m;
      if (l = l * v + f * x, c = c * v + d * x, u = u * v + p * x, h = h * v + g * x, v === 1 - s) {
        var w = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
        l *= w, c *= w, u *= w, h *= w;
      }
    }
    e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h;
  },
  multiplyQuaternionsFlat: function(e, t, r, n, a, o) {
    var s = r[n], l = r[n + 1], c = r[n + 2], u = r[n + 3], h = a[o], f = a[o + 1], d = a[o + 2], p = a[o + 3];
    return e[t] = s * p + u * h + l * d - c * f, e[t + 1] = l * p + u * f + c * h - s * d, e[t + 2] = c * p + u * d + s * f - l * h, e[t + 3] = u * p - s * h - l * f - c * d, e;
  }
});
Object.defineProperties(Quaternion.prototype, {
  x: {
    get: function() {
      return this._x;
    },
    set: function(e) {
      this._x = e, this._onChangeCallback();
    }
  },
  y: {
    get: function() {
      return this._y;
    },
    set: function(e) {
      this._y = e, this._onChangeCallback();
    }
  },
  z: {
    get: function() {
      return this._z;
    },
    set: function(e) {
      this._z = e, this._onChangeCallback();
    }
  },
  w: {
    get: function() {
      return this._w;
    },
    set: function(e) {
      this._w = e, this._onChangeCallback();
    }
  }
});
Object.assign(Quaternion.prototype, {
  isQuaternion: !0,
  set: function(e, t, r, n) {
    return this._x = e, this._y = t, this._z = r, this._w = n, this._onChangeCallback(), this;
  },
  clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  },
  copy: function(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  },
  setFromEuler: function(e, t) {
    if (!(e && e.isEuler))
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    var r = e._x, n = e._y, a = e._z, o = e.order, s = Math.cos, l = Math.sin, c = s(r / 2), u = s(n / 2), h = s(a / 2), f = l(r / 2), d = l(n / 2), p = l(a / 2);
    switch (o) {
      case "XYZ":
        this._x = f * u * h + c * d * p, this._y = c * d * h - f * u * p, this._z = c * u * p + f * d * h, this._w = c * u * h - f * d * p;
        break;
      case "YXZ":
        this._x = f * u * h + c * d * p, this._y = c * d * h - f * u * p, this._z = c * u * p - f * d * h, this._w = c * u * h + f * d * p;
        break;
      case "ZXY":
        this._x = f * u * h - c * d * p, this._y = c * d * h + f * u * p, this._z = c * u * p + f * d * h, this._w = c * u * h - f * d * p;
        break;
      case "ZYX":
        this._x = f * u * h - c * d * p, this._y = c * d * h + f * u * p, this._z = c * u * p - f * d * h, this._w = c * u * h + f * d * p;
        break;
      case "YZX":
        this._x = f * u * h + c * d * p, this._y = c * d * h + f * u * p, this._z = c * u * p - f * d * h, this._w = c * u * h - f * d * p;
        break;
      case "XZY":
        this._x = f * u * h - c * d * p, this._y = c * d * h - f * u * p, this._z = c * u * p + f * d * h, this._w = c * u * h + f * d * p;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t !== !1 && this._onChangeCallback(), this;
  },
  setFromAxisAngle: function(e, t) {
    var r = t / 2, n = Math.sin(r);
    return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(r), this._onChangeCallback(), this;
  },
  setFromRotationMatrix: function(e) {
    var t = e.elements, r = t[0], n = t[4], a = t[8], o = t[1], s = t[5], l = t[9], c = t[2], u = t[6], h = t[10], f = r + s + h, d;
    return f > 0 ? (d = 0.5 / Math.sqrt(f + 1), this._w = 0.25 / d, this._x = (u - l) * d, this._y = (a - c) * d, this._z = (o - n) * d) : r > s && r > h ? (d = 2 * Math.sqrt(1 + r - s - h), this._w = (u - l) / d, this._x = 0.25 * d, this._y = (n + o) / d, this._z = (a + c) / d) : s > h ? (d = 2 * Math.sqrt(1 + s - r - h), this._w = (a - c) / d, this._x = (n + o) / d, this._y = 0.25 * d, this._z = (l + u) / d) : (d = 2 * Math.sqrt(1 + h - r - s), this._w = (o - n) / d, this._x = (a + c) / d, this._y = (l + u) / d, this._z = 0.25 * d), this._onChangeCallback(), this;
  },
  setFromUnitVectors: function(e, t) {
    var r = 1e-6, n = e.dot(t) + 1;
    return n < r ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  },
  angleTo: function(e) {
    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(e), -1, 1)));
  },
  rotateTowards: function(e, t) {
    var r = this.angleTo(e);
    if (r === 0) return this;
    var n = Math.min(1, t / r);
    return this.slerp(e, n), this;
  },
  inverse: function() {
    return this.conjugate();
  },
  conjugate: function() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  },
  dot: function(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  },
  lengthSq: function() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function() {
    var e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  },
  multiply: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e);
  },
  premultiply: function(e) {
    return this.multiplyQuaternions(e, this);
  },
  multiplyQuaternions: function(e, t) {
    var r = e._x, n = e._y, a = e._z, o = e._w, s = t._x, l = t._y, c = t._z, u = t._w;
    return this._x = r * u + o * s + n * c - a * l, this._y = n * u + o * l + a * s - r * c, this._z = a * u + o * c + r * l - n * s, this._w = o * u - r * s - n * l - a * c, this._onChangeCallback(), this;
  },
  slerp: function(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    var r = this._x, n = this._y, a = this._z, o = this._w, s = o * e._w + r * e._x + n * e._y + a * e._z;
    if (s < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, s = -s) : this.copy(e), s >= 1)
      return this._w = o, this._x = r, this._y = n, this._z = a, this;
    var l = 1 - s * s;
    if (l <= Number.EPSILON) {
      var c = 1 - t;
      return this._w = c * o + t * this._w, this._x = c * r + t * this._x, this._y = c * n + t * this._y, this._z = c * a + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    var u = Math.sqrt(l), h = Math.atan2(u, s), f = Math.sin((1 - t) * h) / u, d = Math.sin(t * h) / u;
    return this._w = o * f + this._w * d, this._x = r * f + this._x * d, this._y = n * f + this._y * d, this._z = a * f + this._z * d, this._onChangeCallback(), this;
  },
  equals: function(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  },
  fromArray: function(e, t) {
    return t === void 0 && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  },
  fromBufferAttribute: function(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  },
  _onChange: function(e) {
    return this._onChangeCallback = e, this;
  },
  _onChangeCallback: function() {
  }
});
var _vector = new Vector3(), _quaternion = new Quaternion();
function Vector3(e, t, r) {
  this.x = e || 0, this.y = t || 0, this.z = r || 0;
}
Object.assign(Vector3.prototype, {
  isVector3: !0,
  set: function(e, t, r) {
    return this.x = e, this.y = t, this.z = r, this;
  },
  setScalar: function(e) {
    return this.x = e, this.y = e, this.z = e, this;
  },
  setX: function(e) {
    return this.x = e, this;
  },
  setY: function(e) {
    return this.y = e, this;
  },
  setZ: function(e) {
    return this.z = e, this;
  },
  setComponent: function(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  },
  getComponent: function(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y, this.z);
  },
  copy: function(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  },
  add: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this);
  },
  addScalar: function(e) {
    return this.x += e, this.y += e, this.z += e, this;
  },
  addVectors: function(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  },
  addScaledVector: function(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  },
  sub: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this);
  },
  subScalar: function(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  },
  subVectors: function(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  },
  multiply: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this);
  },
  multiplyScalar: function(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  },
  multiplyVectors: function(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  },
  applyEuler: function(e) {
    return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(_quaternion.setFromEuler(e));
  },
  applyAxisAngle: function(e, t) {
    return this.applyQuaternion(_quaternion.setFromAxisAngle(e, t));
  },
  applyMatrix3: function(e) {
    var t = this.x, r = this.y, n = this.z, a = e.elements;
    return this.x = a[0] * t + a[3] * r + a[6] * n, this.y = a[1] * t + a[4] * r + a[7] * n, this.z = a[2] * t + a[5] * r + a[8] * n, this;
  },
  applyNormalMatrix: function(e) {
    return this.applyMatrix3(e).normalize();
  },
  applyMatrix4: function(e) {
    var t = this.x, r = this.y, n = this.z, a = e.elements, o = 1 / (a[3] * t + a[7] * r + a[11] * n + a[15]);
    return this.x = (a[0] * t + a[4] * r + a[8] * n + a[12]) * o, this.y = (a[1] * t + a[5] * r + a[9] * n + a[13]) * o, this.z = (a[2] * t + a[6] * r + a[10] * n + a[14]) * o, this;
  },
  applyQuaternion: function(e) {
    var t = this.x, r = this.y, n = this.z, a = e.x, o = e.y, s = e.z, l = e.w, c = l * t + o * n - s * r, u = l * r + s * t - a * n, h = l * n + a * r - o * t, f = -a * t - o * r - s * n;
    return this.x = c * l + f * -a + u * -s - h * -o, this.y = u * l + f * -o + h * -a - c * -s, this.z = h * l + f * -s + c * -o - u * -a, this;
  },
  project: function(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  },
  unproject: function(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  },
  transformDirection: function(e) {
    var t = this.x, r = this.y, n = this.z, a = e.elements;
    return this.x = a[0] * t + a[4] * r + a[8] * n, this.y = a[1] * t + a[5] * r + a[9] * n, this.z = a[2] * t + a[6] * r + a[10] * n, this.normalize();
  },
  divide: function(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  },
  divideScalar: function(e) {
    return this.multiplyScalar(1 / e);
  },
  min: function(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  },
  max: function(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  },
  clamp: function(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  },
  clampScalar: function(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  },
  clampLength: function(e, t) {
    var r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  },
  floor: function() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  },
  ceil: function() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  },
  round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  },
  roundToZero: function() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  },
  negate: function() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  },
  dot: function(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  },
  // TODO lengthSquared?
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function(e) {
    return this.normalize().multiplyScalar(e);
  },
  lerp: function(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  },
  lerpVectors: function(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this;
  },
  cross: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e);
  },
  crossVectors: function(e, t) {
    var r = e.x, n = e.y, a = e.z, o = t.x, s = t.y, l = t.z;
    return this.x = n * l - a * s, this.y = a * o - r * l, this.z = r * s - n * o, this;
  },
  projectOnVector: function(e) {
    var t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    var r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  },
  projectOnPlane: function(e) {
    return _vector.copy(this).projectOnVector(e), this.sub(_vector);
  },
  reflect: function(e) {
    return this.sub(_vector.copy(e).multiplyScalar(2 * this.dot(e)));
  },
  angleTo: function(e) {
    var t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    var r = this.dot(e) / t;
    return Math.acos(MathUtils.clamp(r, -1, 1));
  },
  distanceTo: function(e) {
    return Math.sqrt(this.distanceToSquared(e));
  },
  distanceToSquared: function(e) {
    var t = this.x - e.x, r = this.y - e.y, n = this.z - e.z;
    return t * t + r * r + n * n;
  },
  manhattanDistanceTo: function(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  },
  setFromSpherical: function(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  },
  setFromSphericalCoords: function(e, t, r) {
    var n = Math.sin(t) * e;
    return this.x = n * Math.sin(r), this.y = Math.cos(t) * e, this.z = n * Math.cos(r), this;
  },
  setFromCylindrical: function(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  },
  setFromCylindricalCoords: function(e, t, r) {
    return this.x = e * Math.sin(t), this.y = r, this.z = e * Math.cos(t), this;
  },
  setFromMatrixPosition: function(e) {
    var t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  },
  setFromMatrixScale: function(e) {
    var t = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = r, this.z = n, this;
  },
  setFromMatrixColumn: function(e, t) {
    return this.fromArray(e.elements, t * 4);
  },
  setFromMatrix3Column: function(e, t) {
    return this.fromArray(e.elements, t * 3);
  },
  equals: function(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  },
  fromArray: function(e, t) {
    return t === void 0 && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  },
  fromBufferAttribute: function(e, t, r) {
    return r !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  },
  random: function() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
});
var _v1 = new Vector3(), _m1 = new Matrix4(), _zero = new Vector3(0, 0, 0), _one = new Vector3(1, 1, 1), _x = new Vector3(), _y = new Vector3(), _z = new Vector3();
function Matrix4() {
  this.elements = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
}
Object.assign(Matrix4.prototype, {
  isMatrix4: !0,
  set: function(e, t, r, n, a, o, s, l, c, u, h, f, d, p, g, v) {
    var _ = this.elements;
    return _[0] = e, _[4] = t, _[8] = r, _[12] = n, _[1] = a, _[5] = o, _[9] = s, _[13] = l, _[2] = c, _[6] = u, _[10] = h, _[14] = f, _[3] = d, _[7] = p, _[11] = g, _[15] = v, this;
  },
  identity: function() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  clone: function() {
    return new Matrix4().fromArray(this.elements);
  },
  copy: function(e) {
    var t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], this;
  },
  copyPosition: function(e) {
    var t = this.elements, r = e.elements;
    return t[12] = r[12], t[13] = r[13], t[14] = r[14], this;
  },
  extractBasis: function(e, t, r) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this;
  },
  makeBasis: function(e, t, r) {
    return this.set(
      e.x,
      t.x,
      r.x,
      0,
      e.y,
      t.y,
      r.y,
      0,
      e.z,
      t.z,
      r.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  extractRotation: function(e) {
    var t = this.elements, r = e.elements, n = 1 / _v1.setFromMatrixColumn(e, 0).length(), a = 1 / _v1.setFromMatrixColumn(e, 1).length(), o = 1 / _v1.setFromMatrixColumn(e, 2).length();
    return t[0] = r[0] * n, t[1] = r[1] * n, t[2] = r[2] * n, t[3] = 0, t[4] = r[4] * a, t[5] = r[5] * a, t[6] = r[6] * a, t[7] = 0, t[8] = r[8] * o, t[9] = r[9] * o, t[10] = r[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  },
  makeRotationFromEuler: function(e) {
    e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    var t = this.elements, r = e.x, n = e.y, a = e.z, o = Math.cos(r), s = Math.sin(r), l = Math.cos(n), c = Math.sin(n), u = Math.cos(a), h = Math.sin(a);
    if (e.order === "XYZ") {
      var f = o * u, d = o * h, p = s * u, g = s * h;
      t[0] = l * u, t[4] = -l * h, t[8] = c, t[1] = d + p * c, t[5] = f - g * c, t[9] = -s * l, t[2] = g - f * c, t[6] = p + d * c, t[10] = o * l;
    } else if (e.order === "YXZ") {
      var v = l * u, _ = l * h, m = c * u, y = c * h;
      t[0] = v + y * s, t[4] = m * s - _, t[8] = o * c, t[1] = o * h, t[5] = o * u, t[9] = -s, t[2] = _ * s - m, t[6] = y + v * s, t[10] = o * l;
    } else if (e.order === "ZXY") {
      var v = l * u, _ = l * h, m = c * u, y = c * h;
      t[0] = v - y * s, t[4] = -o * h, t[8] = m + _ * s, t[1] = _ + m * s, t[5] = o * u, t[9] = y - v * s, t[2] = -o * c, t[6] = s, t[10] = o * l;
    } else if (e.order === "ZYX") {
      var f = o * u, d = o * h, p = s * u, g = s * h;
      t[0] = l * u, t[4] = p * c - d, t[8] = f * c + g, t[1] = l * h, t[5] = g * c + f, t[9] = d * c - p, t[2] = -c, t[6] = s * l, t[10] = o * l;
    } else if (e.order === "YZX") {
      var b = o * l, M = o * c, x = s * l, w = s * c;
      t[0] = l * u, t[4] = w - b * h, t[8] = x * h + M, t[1] = h, t[5] = o * u, t[9] = -s * u, t[2] = -c * u, t[6] = M * h + x, t[10] = b - w * h;
    } else if (e.order === "XZY") {
      var b = o * l, M = o * c, x = s * l, w = s * c;
      t[0] = l * u, t[4] = -h, t[8] = c * u, t[1] = b * h + w, t[5] = o * u, t[9] = M * h - x, t[2] = x * h - M, t[6] = s * u, t[10] = w * h + b;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  },
  makeRotationFromQuaternion: function(e) {
    return this.compose(_zero, e, _one);
  },
  lookAt: function(e, t, r) {
    var n = this.elements;
    return _z.subVectors(e, t), _z.lengthSq() === 0 && (_z.z = 1), _z.normalize(), _x.crossVectors(r, _z), _x.lengthSq() === 0 && (Math.abs(r.z) === 1 ? _z.x += 1e-4 : _z.z += 1e-4, _z.normalize(), _x.crossVectors(r, _z)), _x.normalize(), _y.crossVectors(_z, _x), n[0] = _x.x, n[4] = _y.x, n[8] = _z.x, n[1] = _x.y, n[5] = _y.y, n[9] = _z.y, n[2] = _x.z, n[6] = _y.z, n[10] = _z.z, this;
  },
  multiply: function(e, t) {
    return t !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e);
  },
  premultiply: function(e) {
    return this.multiplyMatrices(e, this);
  },
  multiplyMatrices: function(e, t) {
    var r = e.elements, n = t.elements, a = this.elements, o = r[0], s = r[4], l = r[8], c = r[12], u = r[1], h = r[5], f = r[9], d = r[13], p = r[2], g = r[6], v = r[10], _ = r[14], m = r[3], y = r[7], b = r[11], M = r[15], x = n[0], w = n[4], P = n[8], V = n[12], I = n[1], $ = n[5], E = n[9], G = n[13], O = n[2], W = n[6], B = n[10], q = n[14], te = n[3], ne = n[7], Q = n[11], ae = n[15];
    return a[0] = o * x + s * I + l * O + c * te, a[4] = o * w + s * $ + l * W + c * ne, a[8] = o * P + s * E + l * B + c * Q, a[12] = o * V + s * G + l * q + c * ae, a[1] = u * x + h * I + f * O + d * te, a[5] = u * w + h * $ + f * W + d * ne, a[9] = u * P + h * E + f * B + d * Q, a[13] = u * V + h * G + f * q + d * ae, a[2] = p * x + g * I + v * O + _ * te, a[6] = p * w + g * $ + v * W + _ * ne, a[10] = p * P + g * E + v * B + _ * Q, a[14] = p * V + g * G + v * q + _ * ae, a[3] = m * x + y * I + b * O + M * te, a[7] = m * w + y * $ + b * W + M * ne, a[11] = m * P + y * E + b * B + M * Q, a[15] = m * V + y * G + b * q + M * ae, this;
  },
  multiplyScalar: function(e) {
    var t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  },
  determinant: function() {
    var e = this.elements, t = e[0], r = e[4], n = e[8], a = e[12], o = e[1], s = e[5], l = e[9], c = e[13], u = e[2], h = e[6], f = e[10], d = e[14], p = e[3], g = e[7], v = e[11], _ = e[15];
    return p * (+a * l * h - n * c * h - a * s * f + r * c * f + n * s * d - r * l * d) + g * (+t * l * d - t * c * f + a * o * f - n * o * d + n * c * u - a * l * u) + v * (+t * c * h - t * s * d - a * o * h + r * o * d + a * s * u - r * c * u) + _ * (-n * s * u - t * l * h + t * s * f + n * o * h - r * o * f + r * l * u);
  },
  transpose: function() {
    var e = this.elements, t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  },
  setPosition: function(e, t, r) {
    var n = this.elements;
    return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = r), this;
  },
  getInverse: function(e, t) {
    t !== void 0 && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
    var r = this.elements, n = e.elements, a = n[0], o = n[1], s = n[2], l = n[3], c = n[4], u = n[5], h = n[6], f = n[7], d = n[8], p = n[9], g = n[10], v = n[11], _ = n[12], m = n[13], y = n[14], b = n[15], M = p * y * f - m * g * f + m * h * v - u * y * v - p * h * b + u * g * b, x = _ * g * f - d * y * f - _ * h * v + c * y * v + d * h * b - c * g * b, w = d * m * f - _ * p * f + _ * u * v - c * m * v - d * u * b + c * p * b, P = _ * p * h - d * m * h - _ * u * g + c * m * g + d * u * y - c * p * y, V = a * M + o * x + s * w + l * P;
    if (V === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    var I = 1 / V;
    return r[0] = M * I, r[1] = (m * g * l - p * y * l - m * s * v + o * y * v + p * s * b - o * g * b) * I, r[2] = (u * y * l - m * h * l + m * s * f - o * y * f - u * s * b + o * h * b) * I, r[3] = (p * h * l - u * g * l - p * s * f + o * g * f + u * s * v - o * h * v) * I, r[4] = x * I, r[5] = (d * y * l - _ * g * l + _ * s * v - a * y * v - d * s * b + a * g * b) * I, r[6] = (_ * h * l - c * y * l - _ * s * f + a * y * f + c * s * b - a * h * b) * I, r[7] = (c * g * l - d * h * l + d * s * f - a * g * f - c * s * v + a * h * v) * I, r[8] = w * I, r[9] = (_ * p * l - d * m * l - _ * o * v + a * m * v + d * o * b - a * p * b) * I, r[10] = (c * m * l - _ * u * l + _ * o * f - a * m * f - c * o * b + a * u * b) * I, r[11] = (d * u * l - c * p * l - d * o * f + a * p * f + c * o * v - a * u * v) * I, r[12] = P * I, r[13] = (d * m * s - _ * p * s + _ * o * g - a * m * g - d * o * y + a * p * y) * I, r[14] = (_ * u * s - c * m * s - _ * o * h + a * m * h + c * o * y - a * u * y) * I, r[15] = (c * p * s - d * u * s + d * o * h - a * p * h - c * o * g + a * u * g) * I, this;
  },
  scale: function(e) {
    var t = this.elements, r = e.x, n = e.y, a = e.z;
    return t[0] *= r, t[4] *= n, t[8] *= a, t[1] *= r, t[5] *= n, t[9] *= a, t[2] *= r, t[6] *= n, t[10] *= a, t[3] *= r, t[7] *= n, t[11] *= a, this;
  },
  getMaxScaleOnAxis: function() {
    var e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, n));
  },
  makeTranslation: function(e, t, r) {
    return this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      r,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationX: function(e) {
    var t = Math.cos(e), r = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationY: function(e) {
    var t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      0,
      r,
      0,
      0,
      1,
      0,
      0,
      -r,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationZ: function(e) {
    var t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeRotationAxis: function(e, t) {
    var r = Math.cos(t), n = Math.sin(t), a = 1 - r, o = e.x, s = e.y, l = e.z, c = a * o, u = a * s;
    return this.set(
      c * o + r,
      c * s - n * l,
      c * l + n * s,
      0,
      c * s + n * l,
      u * s + r,
      u * l - n * o,
      0,
      c * l - n * s,
      u * l + n * o,
      a * l * l + r,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeScale: function(e, t, r) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  makeShear: function(e, t, r) {
    return this.set(
      1,
      t,
      r,
      0,
      e,
      1,
      r,
      0,
      e,
      t,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  },
  compose: function(e, t, r) {
    var n = this.elements, a = t._x, o = t._y, s = t._z, l = t._w, c = a + a, u = o + o, h = s + s, f = a * c, d = a * u, p = a * h, g = o * u, v = o * h, _ = s * h, m = l * c, y = l * u, b = l * h, M = r.x, x = r.y, w = r.z;
    return n[0] = (1 - (g + _)) * M, n[1] = (d + b) * M, n[2] = (p - y) * M, n[3] = 0, n[4] = (d - b) * x, n[5] = (1 - (f + _)) * x, n[6] = (v + m) * x, n[7] = 0, n[8] = (p + y) * w, n[9] = (v - m) * w, n[10] = (1 - (f + g)) * w, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
  },
  decompose: function(e, t, r) {
    var n = this.elements, a = _v1.set(n[0], n[1], n[2]).length(), o = _v1.set(n[4], n[5], n[6]).length(), s = _v1.set(n[8], n[9], n[10]).length(), l = this.determinant();
    l < 0 && (a = -a), e.x = n[12], e.y = n[13], e.z = n[14], _m1.copy(this);
    var c = 1 / a, u = 1 / o, h = 1 / s;
    return _m1.elements[0] *= c, _m1.elements[1] *= c, _m1.elements[2] *= c, _m1.elements[4] *= u, _m1.elements[5] *= u, _m1.elements[6] *= u, _m1.elements[8] *= h, _m1.elements[9] *= h, _m1.elements[10] *= h, t.setFromRotationMatrix(_m1), r.x = a, r.y = o, r.z = s, this;
  },
  makePerspective: function(e, t, r, n, a, o) {
    o === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    var s = this.elements, l = 2 * a / (t - e), c = 2 * a / (r - n), u = (t + e) / (t - e), h = (r + n) / (r - n), f = -(o + a) / (o - a), d = -2 * o * a / (o - a);
    return s[0] = l, s[4] = 0, s[8] = u, s[12] = 0, s[1] = 0, s[5] = c, s[9] = h, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = f, s[14] = d, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this;
  },
  makeOrthographic: function(e, t, r, n, a, o) {
    var s = this.elements, l = 1 / (t - e), c = 1 / (r - n), u = 1 / (o - a), h = (t + e) * l, f = (r + n) * c, d = (o + a) * u;
    return s[0] = 2 * l, s[4] = 0, s[8] = 0, s[12] = -h, s[1] = 0, s[5] = 2 * c, s[9] = 0, s[13] = -f, s[2] = 0, s[6] = 0, s[10] = -2 * u, s[14] = -d, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this;
  },
  equals: function(e) {
    for (var t = this.elements, r = e.elements, n = 0; n < 16; n++)
      if (t[n] !== r[n]) return !1;
    return !0;
  },
  fromArray: function(e, t) {
    t === void 0 && (t = 0);
    for (var r = 0; r < 16; r++)
      this.elements[r] = e[r + t];
    return this;
  },
  toArray: function(e, t) {
    e === void 0 && (e = []), t === void 0 && (t = 0);
    var r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], e;
  }
});
var _matrix = new Matrix4(), _quaternion$1 = new Quaternion();
function Euler(e, t, r, n) {
  this._x = e || 0, this._y = t || 0, this._z = r || 0, this._order = n || Euler.DefaultOrder;
}
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
Euler.DefaultOrder = "XYZ";
Object.defineProperties(Euler.prototype, {
  x: {
    get: function() {
      return this._x;
    },
    set: function(e) {
      this._x = e, this._onChangeCallback();
    }
  },
  y: {
    get: function() {
      return this._y;
    },
    set: function(e) {
      this._y = e, this._onChangeCallback();
    }
  },
  z: {
    get: function() {
      return this._z;
    },
    set: function(e) {
      this._z = e, this._onChangeCallback();
    }
  },
  order: {
    get: function() {
      return this._order;
    },
    set: function(e) {
      this._order = e, this._onChangeCallback();
    }
  }
});
Object.assign(Euler.prototype, {
  isEuler: !0,
  set: function(e, t, r, n) {
    return this._x = e, this._y = t, this._z = r, this._order = n || this._order, this._onChangeCallback(), this;
  },
  clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  },
  copy: function(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  },
  setFromRotationMatrix: function(e, t, r) {
    var n = MathUtils.clamp, a = e.elements, o = a[0], s = a[4], l = a[8], c = a[1], u = a[5], h = a[9], f = a[2], d = a[6], p = a[10];
    switch (t = t || this._order, t) {
      case "XYZ":
        this._y = Math.asin(n(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, p), this._z = Math.atan2(-s, o)) : (this._x = Math.atan2(d, u), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-n(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(l, p), this._z = Math.atan2(c, u)) : (this._y = Math.atan2(-f, o), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(n(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-f, p), this._z = Math.atan2(-s, u)) : (this._y = 0, this._z = Math.atan2(c, o));
        break;
      case "ZYX":
        this._y = Math.asin(-n(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-s, u));
        break;
      case "YZX":
        this._z = Math.asin(n(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-h, u), this._y = Math.atan2(-f, o)) : (this._x = 0, this._y = Math.atan2(l, p));
        break;
      case "XZY":
        this._z = Math.asin(-n(s, -1, 1)), Math.abs(s) < 0.9999999 ? (this._x = Math.atan2(d, u), this._y = Math.atan2(l, o)) : (this._x = Math.atan2(-h, p), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, r !== !1 && this._onChangeCallback(), this;
  },
  setFromQuaternion: function(e, t, r) {
    return _matrix.makeRotationFromQuaternion(e), this.setFromRotationMatrix(_matrix, t, r);
  },
  setFromVector3: function(e, t) {
    return this.set(e.x, e.y, e.z, t || this._order);
  },
  reorder: function(e) {
    return _quaternion$1.setFromEuler(this), this.setFromQuaternion(_quaternion$1, e);
  },
  equals: function(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  },
  fromArray: function(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  },
  toVector3: function(e) {
    return e ? e.set(this._x, this._y, this._z) : new Vector3(this._x, this._y, this._z);
  },
  _onChange: function(e) {
    return this._onChangeCallback = e, this;
  },
  _onChangeCallback: function() {
  }
});
function Layers() {
  this.mask = 1;
}
Object.assign(Layers.prototype, {
  set: function(e) {
    this.mask = 1 << e | 0;
  },
  enable: function(e) {
    this.mask |= 1 << e | 0;
  },
  enableAll: function() {
    this.mask = -1;
  },
  toggle: function(e) {
    this.mask ^= 1 << e | 0;
  },
  disable: function(e) {
    this.mask &= ~(1 << e | 0);
  },
  disableAll: function() {
    this.mask = 0;
  },
  test: function(e) {
    return (this.mask & e.mask) !== 0;
  }
});
let _object3DId = 0;
const _v1$1 = new Vector3(), _q1 = new Quaternion(), _m1$1 = new Matrix4(), _target = new Vector3(), _position = new Vector3(), _scale = new Vector3(), _quaternion$2 = new Quaternion(), _xAxis = new Vector3(1, 0, 0), _yAxis = new Vector3(0, 1, 0), _zAxis = new Vector3(0, 0, 1), _addedEvent = { type: "added" }, _removedEvent = { type: "removed" };
function Object3D() {
  Object.defineProperty(this, "id", { value: _object3DId++ }), this.uuid = MathUtils.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Object3D.DefaultUp.clone();
  var e = new Vector3(), t = new Euler(), r = new Quaternion(), n = new Vector3(1, 1, 1);
  function a() {
    r.setFromEuler(t, !1);
  }
  function o() {
    t.setFromQuaternion(r, void 0, !1);
  }
  t._onChange(a), r._onChange(o), Object.defineProperties(this, {
    position: {
      configurable: !0,
      enumerable: !0,
      value: e
    },
    rotation: {
      configurable: !0,
      enumerable: !0,
      value: t
    },
    quaternion: {
      configurable: !0,
      enumerable: !0,
      value: r
    },
    scale: {
      configurable: !0,
      enumerable: !0,
      value: n
    },
    modelViewMatrix: {
      value: new Matrix4()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  }), this.matrix = new Matrix4(), this.matrixWorld = new Matrix4(), this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Layers(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {};
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = !0;
Object3D.prototype = Object.assign(Object.create(EventDispatcher$1.prototype), {
  constructor: Object3D,
  isObject3D: !0,
  onBeforeRender: function() {
  },
  onAfterRender: function() {
  },
  applyMatrix4: function(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function(e) {
    return this.quaternion.premultiply(e), this;
  },
  setRotationFromAxisAngle: function(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  },
  setRotationFromEuler: function(e) {
    this.quaternion.setFromEuler(e, !0);
  },
  setRotationFromMatrix: function(e) {
    this.quaternion.setFromRotationMatrix(e);
  },
  setRotationFromQuaternion: function(e) {
    this.quaternion.copy(e);
  },
  rotateOnAxis: function(e, t) {
    return _q1.setFromAxisAngle(e, t), this.quaternion.multiply(_q1), this;
  },
  rotateOnWorldAxis: function(e, t) {
    return _q1.setFromAxisAngle(e, t), this.quaternion.premultiply(_q1), this;
  },
  rotateX: function(e) {
    return this.rotateOnAxis(_xAxis, e);
  },
  rotateY: function(e) {
    return this.rotateOnAxis(_yAxis, e);
  },
  rotateZ: function(e) {
    return this.rotateOnAxis(_zAxis, e);
  },
  translateOnAxis: function(e, t) {
    return _v1$1.copy(e).applyQuaternion(this.quaternion), this.position.add(_v1$1.multiplyScalar(t)), this;
  },
  translateX: function(e) {
    return this.translateOnAxis(_xAxis, e);
  },
  translateY: function(e) {
    return this.translateOnAxis(_yAxis, e);
  },
  translateZ: function(e) {
    return this.translateOnAxis(_zAxis, e);
  },
  localToWorld: function(e) {
    return e.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function(e) {
    return e.applyMatrix4(_m1$1.getInverse(this.matrixWorld));
  },
  lookAt: function(e, t, r) {
    e.isVector3 ? _target.copy(e) : _target.set(e, t, r);
    var n = this.parent;
    this.updateWorldMatrix(!0, !1), _position.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? _m1$1.lookAt(_position, _target, this.up) : _m1$1.lookAt(_target, _position, this.up), this.quaternion.setFromRotationMatrix(_m1$1), n && (_m1$1.extractRotation(n.matrixWorld), _q1.setFromRotationMatrix(_m1$1), this.quaternion.premultiply(_q1.inverse()));
  },
  add: function(e) {
    if (arguments.length > 1) {
      for (var t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(_addedEvent)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  },
  remove: function(e) {
    if (arguments.length > 1) {
      for (var t = 0; t < arguments.length; t++)
        this.remove(arguments[t]);
      return this;
    }
    var r = this.children.indexOf(e);
    return r !== -1 && (e.parent = null, this.children.splice(r, 1), e.dispatchEvent(_removedEvent)), this;
  },
  attach: function(e) {
    return this.updateWorldMatrix(!0, !1), _m1$1.getInverse(this.matrixWorld), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), _m1$1.multiply(e.parent.matrixWorld)), e.applyMatrix4(_m1$1), e.updateWorldMatrix(!1, !1), this.add(e), this;
  },
  getObjectById: function(e) {
    return this.getObjectByProperty("id", e);
  },
  getObjectByName: function(e) {
    return this.getObjectByProperty("name", e);
  },
  getObjectByProperty: function(e, t) {
    if (this[e] === t) return this;
    for (var r = 0, n = this.children.length; r < n; r++) {
      var a = this.children[r], o = a.getObjectByProperty(e, t);
      if (o !== void 0)
        return o;
    }
  },
  getWorldPosition: function(e) {
    return e === void 0 && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new Vector3()), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function(e) {
    return e === void 0 && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), e = new Quaternion()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(_position, e, _scale), e;
  },
  getWorldScale: function(e) {
    return e === void 0 && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), e = new Vector3()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(_position, _quaternion$2, e), e;
  },
  getWorldDirection: function(e) {
    e === void 0 && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new Vector3()), this.updateMatrixWorld(!0);
    var t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  },
  raycast: function() {
  },
  traverse: function(e) {
    e(this);
    for (var t = this.children, r = 0, n = t.length; r < n; r++)
      t[r].traverse(e);
  },
  traverseVisible: function(e) {
    if (this.visible !== !1) {
      e(this);
      for (var t = this.children, r = 0, n = t.length; r < n; r++)
        t[r].traverseVisible(e);
    }
  },
  traverseAncestors: function(e) {
    var t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  },
  updateMatrixWorld: function(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    for (var t = this.children, r = 0, n = t.length; r < n; r++)
      t[r].updateMatrixWorld(e);
  },
  updateWorldMatrix: function(e, t) {
    var r = this.parent;
    if (e === !0 && r !== null && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0)
      for (var n = this.children, a = 0, o = n.length; a < o; a++)
        n[a].updateWorldMatrix(!1, !0);
  },
  toJSON: function(e) {
    var t = e === void 0 || typeof e == "string", r = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {}
    }, r.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    var n = {};
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === !0 && (n.castShadow = !0), this.receiveShadow === !0 && (n.receiveShadow = !0), this.visible === !1 && (n.visible = !1), this.frustumCulled === !1 && (n.frustumCulled = !1), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON());
    function a(_, m) {
      return _[m.uuid] === void 0 && (_[m.uuid] = m.toJSON(e)), m.uuid;
    }
    if (this.isMesh || this.isLine || this.isPoints) {
      n.geometry = a(e.geometries, this.geometry);
      var o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        var s = o.shapes;
        if (Array.isArray(s))
          for (var l = 0, c = s.length; l < c; l++) {
            var u = s[l];
            a(e.shapes, u);
          }
        else
          a(e.shapes, s);
      }
    }
    if (this.material !== void 0)
      if (Array.isArray(this.material)) {
        for (var h = [], l = 0, c = this.material.length; l < c; l++)
          h.push(a(e.materials, this.material[l]));
        n.material = h;
      } else
        n.material = a(e.materials, this.material);
    if (this.children.length > 0) {
      n.children = [];
      for (var l = 0; l < this.children.length; l++)
        n.children.push(this.children[l].toJSON(e).object);
    }
    if (t) {
      var f = v(e.geometries), d = v(e.materials), p = v(e.textures), g = v(e.images), s = v(e.shapes);
      f.length > 0 && (r.geometries = f), d.length > 0 && (r.materials = d), p.length > 0 && (r.textures = p), g.length > 0 && (r.images = g), s.length > 0 && (r.shapes = s);
    }
    return r.object = n, r;
    function v(_) {
      var m = [];
      for (var y in _) {
        var b = _[y];
        delete b.metadata, m.push(b);
      }
      return m;
    }
  },
  clone: function(e) {
    return new this.constructor().copy(this, e);
  },
  copy: function(e, t) {
    if (t === void 0 && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (var r = 0; r < e.children.length; r++) {
        var n = e.children[r];
        this.add(n.clone());
      }
    return this;
  }
});
function Scene$1() {
  Object3D.call(this), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
Scene$1.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Scene$1,
  isScene: !0,
  copy: function(e, t) {
    return Object3D.prototype.copy.call(this, e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  },
  toJSON: function(e) {
    var t = Object3D.prototype.toJSON.call(this, e);
    return this.background !== null && (t.object.background = this.background.toJSON(e)), this.environment !== null && (t.object.environment = this.environment.toJSON(e)), this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
var _points = [
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3()
], _vector$1 = new Vector3(), _box = new Box3(), _v0 = new Vector3(), _v1$2 = new Vector3(), _v2 = new Vector3(), _f0 = new Vector3(), _f1 = new Vector3(), _f2 = new Vector3(), _center = new Vector3(), _extents = new Vector3(), _triangleNormal = new Vector3(), _testAxis = new Vector3();
function Box3(e, t) {
  this.min = e !== void 0 ? e : new Vector3(1 / 0, 1 / 0, 1 / 0), this.max = t !== void 0 ? t : new Vector3(-1 / 0, -1 / 0, -1 / 0);
}
Object.assign(Box3.prototype, {
  isBox3: !0,
  set: function(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  },
  setFromArray: function(e) {
    for (var t = 1 / 0, r = 1 / 0, n = 1 / 0, a = -1 / 0, o = -1 / 0, s = -1 / 0, l = 0, c = e.length; l < c; l += 3) {
      var u = e[l], h = e[l + 1], f = e[l + 2];
      u < t && (t = u), h < r && (r = h), f < n && (n = f), u > a && (a = u), h > o && (o = h), f > s && (s = f);
    }
    return this.min.set(t, r, n), this.max.set(a, o, s), this;
  },
  setFromBufferAttribute: function(e) {
    for (var t = 1 / 0, r = 1 / 0, n = 1 / 0, a = -1 / 0, o = -1 / 0, s = -1 / 0, l = 0, c = e.count; l < c; l++) {
      var u = e.getX(l), h = e.getY(l), f = e.getZ(l);
      u < t && (t = u), h < r && (r = h), f < n && (n = f), u > a && (a = u), h > o && (o = h), f > s && (s = f);
    }
    return this.min.set(t, r, n), this.max.set(a, o, s), this;
  },
  setFromPoints: function(e) {
    this.makeEmpty();
    for (var t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  },
  setFromCenterAndSize: function(e, t) {
    var r = _vector$1.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  },
  setFromObject: function(e) {
    return this.makeEmpty(), this.expandByObject(e);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  },
  makeEmpty: function() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  },
  isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  getCenter: function(e) {
    return e === void 0 && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new Vector3()), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function(e) {
    return e === void 0 && (console.warn("THREE.Box3: .getSize() target is now required"), e = new Vector3()), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  },
  expandByPoint: function(e) {
    return this.min.min(e), this.max.max(e), this;
  },
  expandByVector: function(e) {
    return this.min.sub(e), this.max.add(e), this;
  },
  expandByScalar: function(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  },
  expandByObject: function(e) {
    e.updateWorldMatrix(!1, !1);
    var t = e.geometry;
    t !== void 0 && (t.boundingBox === null && t.computeBoundingBox(), _box.copy(t.boundingBox), _box.applyMatrix4(e.matrixWorld), this.union(_box));
    for (var r = e.children, n = 0, a = r.length; n < a; n++)
      this.expandByObject(r[n]);
    return this;
  },
  containsPoint: function(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  },
  containsBox: function(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  },
  getParameter: function(e, t) {
    return t === void 0 && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new Vector3()), t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  },
  intersectsBox: function(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  },
  intersectsSphere: function(e) {
    return this.clampPoint(e.center, _vector$1), _vector$1.distanceToSquared(e.center) <= e.radius * e.radius;
  },
  intersectsPlane: function(e) {
    var t, r;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z), t <= -e.constant && r >= -e.constant;
  },
  intersectsTriangle: function(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(_center), _extents.subVectors(this.max, _center), _v0.subVectors(e.a, _center), _v1$2.subVectors(e.b, _center), _v2.subVectors(e.c, _center), _f0.subVectors(_v1$2, _v0), _f1.subVectors(_v2, _v1$2), _f2.subVectors(_v0, _v2);
    var t = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    return !satForAxes(t, _v0, _v1$2, _v2, _extents) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !satForAxes(t, _v0, _v1$2, _v2, _extents)) ? !1 : (_triangleNormal.crossVectors(_f0, _f1), t = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z], satForAxes(t, _v0, _v1$2, _v2, _extents));
  },
  clampPoint: function(e, t) {
    return t === void 0 && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new Vector3()), t.copy(e).clamp(this.min, this.max);
  },
  distanceToPoint: function(e) {
    var t = _vector$1.copy(e).clamp(this.min, this.max);
    return t.sub(e).length();
  },
  getBoundingSphere: function(e) {
    return e === void 0 && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = this.getSize(_vector$1).length() * 0.5, e;
  },
  intersect: function(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  },
  union: function(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  },
  applyMatrix4: function(e) {
    return this.isEmpty() ? this : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(_points), this);
  },
  translate: function(e) {
    return this.min.add(e), this.max.add(e), this;
  },
  equals: function(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
});
function satForAxes(e, t, r, n, a) {
  var o, s;
  for (o = 0, s = e.length - 3; o <= s; o += 3) {
    _testAxis.fromArray(e, o);
    var l = a.x * Math.abs(_testAxis.x) + a.y * Math.abs(_testAxis.y) + a.z * Math.abs(_testAxis.z), c = t.dot(_testAxis), u = r.dot(_testAxis), h = n.dot(_testAxis);
    if (Math.max(-Math.max(c, u, h), Math.min(c, u, h)) > l)
      return !1;
  }
  return !0;
}
var _box$1 = new Box3();
function Sphere(e, t) {
  this.center = e !== void 0 ? e : new Vector3(), this.radius = t !== void 0 ? t : -1;
}
Object.assign(Sphere.prototype, {
  set: function(e, t) {
    return this.center.copy(e), this.radius = t, this;
  },
  setFromPoints: function(e, t) {
    var r = this.center;
    t !== void 0 ? r.copy(t) : _box$1.setFromPoints(e).getCenter(r);
    for (var n = 0, a = 0, o = e.length; a < o; a++)
      n = Math.max(n, r.distanceToSquared(e[a]));
    return this.radius = Math.sqrt(n), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  },
  isEmpty: function() {
    return this.radius < 0;
  },
  makeEmpty: function() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  },
  containsPoint: function(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function(e) {
    return e.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function(e) {
    var t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  },
  intersectsBox: function(e) {
    return e.intersectsSphere(this);
  },
  intersectsPlane: function(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  },
  clampPoint: function(e, t) {
    var r = this.center.distanceToSquared(e);
    return t === void 0 && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new Vector3()), t.copy(e), r > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  },
  getBoundingBox: function(e) {
    return e === void 0 && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new Box3()), this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  },
  applyMatrix4: function(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  },
  translate: function(e) {
    return this.center.add(e), this;
  },
  equals: function(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
});
var _vector$2 = new Vector3(), _segCenter = new Vector3(), _segDir = new Vector3(), _diff = new Vector3(), _edge1 = new Vector3(), _edge2 = new Vector3(), _normal = new Vector3();
function Ray(e, t) {
  this.origin = e !== void 0 ? e : new Vector3(), this.direction = t !== void 0 ? t : new Vector3(0, 0, -1);
}
Object.assign(Ray.prototype, {
  set: function(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  },
  at: function(e, t) {
    return t === void 0 && (console.warn("THREE.Ray: .at() target is now required"), t = new Vector3()), t.copy(this.direction).multiplyScalar(e).add(this.origin);
  },
  lookAt: function(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  },
  recast: function(e) {
    return this.origin.copy(this.at(e, _vector$2)), this;
  },
  closestPointToPoint: function(e, t) {
    t === void 0 && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new Vector3()), t.subVectors(e, this.origin);
    var r = t.dot(this.direction);
    return r < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(r).add(this.origin);
  },
  distanceToPoint: function(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  },
  distanceSqToPoint: function(e) {
    var t = _vector$2.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (_vector$2.copy(this.direction).multiplyScalar(t).add(this.origin), _vector$2.distanceToSquared(e));
  },
  distanceSqToSegment: function(e, t, r, n) {
    _segCenter.copy(e).add(t).multiplyScalar(0.5), _segDir.copy(t).sub(e).normalize(), _diff.copy(this.origin).sub(_segCenter);
    var a = e.distanceTo(t) * 0.5, o = -this.direction.dot(_segDir), s = _diff.dot(this.direction), l = -_diff.dot(_segDir), c = _diff.lengthSq(), u = Math.abs(1 - o * o), h, f, d, p;
    if (u > 0)
      if (h = o * l - s, f = o * s - l, p = a * u, h >= 0)
        if (f >= -p)
          if (f <= p) {
            var g = 1 / u;
            h *= g, f *= g, d = h * (h + o * f + 2 * s) + f * (o * h + f + 2 * l) + c;
          } else
            f = a, h = Math.max(0, -(o * f + s)), d = -h * h + f * (f + 2 * l) + c;
        else
          f = -a, h = Math.max(0, -(o * f + s)), d = -h * h + f * (f + 2 * l) + c;
      else
        f <= -p ? (h = Math.max(0, -(-o * a + s)), f = h > 0 ? -a : Math.min(Math.max(-a, -l), a), d = -h * h + f * (f + 2 * l) + c) : f <= p ? (h = 0, f = Math.min(Math.max(-a, -l), a), d = f * (f + 2 * l) + c) : (h = Math.max(0, -(o * a + s)), f = h > 0 ? a : Math.min(Math.max(-a, -l), a), d = -h * h + f * (f + 2 * l) + c);
    else
      f = o > 0 ? -a : a, h = Math.max(0, -(o * f + s)), d = -h * h + f * (f + 2 * l) + c;
    return r && r.copy(this.direction).multiplyScalar(h).add(this.origin), n && n.copy(_segDir).multiplyScalar(f).add(_segCenter), d;
  },
  intersectSphere: function(e, t) {
    _vector$2.subVectors(e.center, this.origin);
    var r = _vector$2.dot(this.direction), n = _vector$2.dot(_vector$2) - r * r, a = e.radius * e.radius;
    if (n > a) return null;
    var o = Math.sqrt(a - n), s = r - o, l = r + o;
    return s < 0 && l < 0 ? null : s < 0 ? this.at(l, t) : this.at(s, t);
  },
  intersectsSphere: function(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  },
  distanceToPlane: function(e) {
    var t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    var r = -(this.origin.dot(e.normal) + e.constant) / t;
    return r >= 0 ? r : null;
  },
  intersectPlane: function(e, t) {
    var r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, t);
  },
  intersectsPlane: function(e) {
    var t = e.distanceToPoint(this.origin);
    if (t === 0)
      return !0;
    var r = e.normal.dot(this.direction);
    return r * t < 0;
  },
  intersectBox: function(e, t) {
    var r, n, a, o, s, l, c = 1 / this.direction.x, u = 1 / this.direction.y, h = 1 / this.direction.z, f = this.origin;
    return c >= 0 ? (r = (e.min.x - f.x) * c, n = (e.max.x - f.x) * c) : (r = (e.max.x - f.x) * c, n = (e.min.x - f.x) * c), u >= 0 ? (a = (e.min.y - f.y) * u, o = (e.max.y - f.y) * u) : (a = (e.max.y - f.y) * u, o = (e.min.y - f.y) * u), r > o || a > n || ((a > r || r !== r) && (r = a), (o < n || n !== n) && (n = o), h >= 0 ? (s = (e.min.z - f.z) * h, l = (e.max.z - f.z) * h) : (s = (e.max.z - f.z) * h, l = (e.min.z - f.z) * h), r > l || s > n) || ((s > r || r !== r) && (r = s), (l < n || n !== n) && (n = l), n < 0) ? null : this.at(r >= 0 ? r : n, t);
  },
  intersectsBox: function(e) {
    return this.intersectBox(e, _vector$2) !== null;
  },
  intersectTriangle: function(e, t, r, n, a) {
    _edge1.subVectors(t, e), _edge2.subVectors(r, e), _normal.crossVectors(_edge1, _edge2);
    var o = this.direction.dot(_normal), s;
    if (o > 0) {
      if (n) return null;
      s = 1;
    } else if (o < 0)
      s = -1, o = -o;
    else
      return null;
    _diff.subVectors(this.origin, e);
    var l = s * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (l < 0)
      return null;
    var c = s * this.direction.dot(_edge1.cross(_diff));
    if (c < 0 || l + c > o)
      return null;
    var u = -s * _diff.dot(_normal);
    return u < 0 ? null : this.at(u / o, a);
  },
  applyMatrix4: function(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  },
  equals: function(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
});
var _vector1 = new Vector3(), _vector2 = new Vector3(), _normalMatrix = new Matrix3();
function Plane(e, t) {
  this.normal = e !== void 0 ? e : new Vector3(1, 0, 0), this.constant = t !== void 0 ? t : 0;
}
Object.assign(Plane.prototype, {
  isPlane: !0,
  set: function(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  },
  setComponents: function(e, t, r, n) {
    return this.normal.set(e, t, r), this.constant = n, this;
  },
  setFromNormalAndCoplanarPoint: function(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  },
  setFromCoplanarPoints: function(e, t, r) {
    var n = _vector1.subVectors(r, t).cross(_vector2.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(n, e), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  },
  normalize: function() {
    var e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  },
  negate: function() {
    return this.constant *= -1, this.normal.negate(), this;
  },
  distanceToPoint: function(e) {
    return this.normal.dot(e) + this.constant;
  },
  distanceToSphere: function(e) {
    return this.distanceToPoint(e.center) - e.radius;
  },
  projectPoint: function(e, t) {
    return t === void 0 && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new Vector3()), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  },
  intersectLine: function(e, t) {
    t === void 0 && (console.warn("THREE.Plane: .intersectLine() target is now required"), t = new Vector3());
    var r = e.delta(_vector1), n = this.normal.dot(r);
    if (n === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : void 0;
    var a = -(e.start.dot(this.normal) + this.constant) / n;
    if (!(a < 0 || a > 1))
      return t.copy(r).multiplyScalar(a).add(e.start);
  },
  intersectsLine: function(e) {
    var t = this.distanceToPoint(e.start), r = this.distanceToPoint(e.end);
    return t < 0 && r > 0 || r < 0 && t > 0;
  },
  intersectsBox: function(e) {
    return e.intersectsPlane(this);
  },
  intersectsSphere: function(e) {
    return e.intersectsPlane(this);
  },
  coplanarPoint: function(e) {
    return e === void 0 && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new Vector3()), e.copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function(e, t) {
    var r = t || _normalMatrix.getNormalMatrix(e), n = this.coplanarPoint(_vector1).applyMatrix4(e), a = this.normal.applyMatrix3(r).normalize();
    return this.constant = -n.dot(a), this;
  },
  translate: function(e) {
    return this.constant -= e.dot(this.normal), this;
  },
  equals: function(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
});
var _v0$1 = new Vector3(), _v1$3 = new Vector3(), _v2$1 = new Vector3(), _v3 = new Vector3(), _vab = new Vector3(), _vac = new Vector3(), _vbc = new Vector3(), _vap = new Vector3(), _vbp = new Vector3(), _vcp = new Vector3();
function Triangle(e, t, r) {
  this.a = e !== void 0 ? e : new Vector3(), this.b = t !== void 0 ? t : new Vector3(), this.c = r !== void 0 ? r : new Vector3();
}
Object.assign(Triangle, {
  getNormal: function(e, t, r, n) {
    n === void 0 && (console.warn("THREE.Triangle: .getNormal() target is now required"), n = new Vector3()), n.subVectors(r, t), _v0$1.subVectors(e, t), n.cross(_v0$1);
    var a = n.lengthSq();
    return a > 0 ? n.multiplyScalar(1 / Math.sqrt(a)) : n.set(0, 0, 0);
  },
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  getBarycoord: function(e, t, r, n, a) {
    _v0$1.subVectors(n, t), _v1$3.subVectors(r, t), _v2$1.subVectors(e, t);
    var o = _v0$1.dot(_v0$1), s = _v0$1.dot(_v1$3), l = _v0$1.dot(_v2$1), c = _v1$3.dot(_v1$3), u = _v1$3.dot(_v2$1), h = o * c - s * s;
    if (a === void 0 && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), a = new Vector3()), h === 0)
      return a.set(-2, -1, -1);
    var f = 1 / h, d = (c * l - s * u) * f, p = (o * u - s * l) * f;
    return a.set(1 - d - p, p, d);
  },
  containsPoint: function(e, t, r, n) {
    return Triangle.getBarycoord(e, t, r, n, _v3), _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
  },
  getUV: function(e, t, r, n, a, o, s, l) {
    return this.getBarycoord(e, t, r, n, _v3), l.set(0, 0), l.addScaledVector(a, _v3.x), l.addScaledVector(o, _v3.y), l.addScaledVector(s, _v3.z), l;
  },
  isFrontFacing: function(e, t, r, n) {
    return _v0$1.subVectors(r, t), _v1$3.subVectors(e, t), _v0$1.cross(_v1$3).dot(n) < 0;
  }
});
Object.assign(Triangle.prototype, {
  set: function(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  },
  setFromPointsAndIndices: function(e, t, r, n) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[n]), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  },
  getArea: function() {
    return _v0$1.subVectors(this.c, this.b), _v1$3.subVectors(this.a, this.b), _v0$1.cross(_v1$3).length() * 0.5;
  },
  getMidpoint: function(e) {
    return e === void 0 && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new Vector3()), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  getNormal: function(e) {
    return Triangle.getNormal(this.a, this.b, this.c, e);
  },
  getPlane: function(e) {
    return e === void 0 && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new Plane()), e.setFromCoplanarPoints(this.a, this.b, this.c);
  },
  getBarycoord: function(e, t) {
    return Triangle.getBarycoord(e, this.a, this.b, this.c, t);
  },
  getUV: function(e, t, r, n, a) {
    return Triangle.getUV(e, this.a, this.b, this.c, t, r, n, a);
  },
  containsPoint: function(e) {
    return Triangle.containsPoint(e, this.a, this.b, this.c);
  },
  isFrontFacing: function(e) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, e);
  },
  intersectsBox: function(e) {
    return e.intersectsTriangle(this);
  },
  closestPointToPoint: function(e, t) {
    t === void 0 && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), t = new Vector3());
    var r = this.a, n = this.b, a = this.c, o, s;
    _vab.subVectors(n, r), _vac.subVectors(a, r), _vap.subVectors(e, r);
    var l = _vab.dot(_vap), c = _vac.dot(_vap);
    if (l <= 0 && c <= 0)
      return t.copy(r);
    _vbp.subVectors(e, n);
    var u = _vab.dot(_vbp), h = _vac.dot(_vbp);
    if (u >= 0 && h <= u)
      return t.copy(n);
    var f = l * h - u * c;
    if (f <= 0 && l >= 0 && u <= 0)
      return o = l / (l - u), t.copy(r).addScaledVector(_vab, o);
    _vcp.subVectors(e, a);
    var d = _vab.dot(_vcp), p = _vac.dot(_vcp);
    if (p >= 0 && d <= p)
      return t.copy(a);
    var g = d * c - l * p;
    if (g <= 0 && c >= 0 && p <= 0)
      return s = c / (c - p), t.copy(r).addScaledVector(_vac, s);
    var v = u * p - d * h;
    if (v <= 0 && h - u >= 0 && d - p >= 0)
      return _vbc.subVectors(a, n), s = (h - u) / (h - u + (d - p)), t.copy(n).addScaledVector(_vbc, s);
    var _ = 1 / (v + g + f);
    return o = g * _, s = f * _, t.copy(r).addScaledVector(_vab, o).addScaledVector(_vac, s);
  },
  equals: function(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
});
var _colorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, _hslA = { h: 0, s: 0, l: 0 }, _hslB = { h: 0, s: 0, l: 0 };
function Color(e, t, r) {
  return t === void 0 && r === void 0 ? this.set(e) : this.setRGB(e, t, r);
}
function hue2rgb(e, t, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + (t - e) * 6 * r : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * 6 * (2 / 3 - r) : e;
}
function SRGBToLinear(e) {
  return e < 0.04045 ? e * 0.0773993808 : Math.pow(e * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(e) {
  return e < 31308e-7 ? e * 12.92 : 1.055 * Math.pow(e, 0.41666) - 0.055;
}
Object.assign(Color.prototype, {
  isColor: !0,
  r: 1,
  g: 1,
  b: 1,
  set: function(e) {
    return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
  },
  setScalar: function(e) {
    return this.r = e, this.g = e, this.b = e, this;
  },
  setHex: function(e) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, this;
  },
  setRGB: function(e, t, r) {
    return this.r = e, this.g = t, this.b = r, this;
  },
  setHSL: function(e, t, r) {
    if (e = MathUtils.euclideanModulo(e, 1), t = MathUtils.clamp(t, 0, 1), r = MathUtils.clamp(r, 0, 1), t === 0)
      this.r = this.g = this.b = r;
    else {
      var n = r <= 0.5 ? r * (1 + t) : r + t - r * t, a = 2 * r - n;
      this.r = hue2rgb(a, n, e + 1 / 3), this.g = hue2rgb(a, n, e), this.b = hue2rgb(a, n, e - 1 / 3);
    }
    return this;
  },
  setStyle: function(e) {
    function t(f) {
      f !== void 0 && parseFloat(f) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    var r;
    if (r = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
      var n, a = r[1], o = r[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))
            return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, t(n[5]), this;
          if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))
            return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, t(n[5]), this;
          break;
        case "hsl":
        case "hsla":
          if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
            var s = parseFloat(n[1]) / 360, l = parseInt(n[2], 10) / 100, c = parseInt(n[3], 10) / 100;
            return t(n[5]), this.setHSL(s, l, c);
          }
          break;
      }
    } else if (r = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
      var u = r[1], h = u.length;
      if (h === 3)
        return this.r = parseInt(u.charAt(0) + u.charAt(0), 16) / 255, this.g = parseInt(u.charAt(1) + u.charAt(1), 16) / 255, this.b = parseInt(u.charAt(2) + u.charAt(2), 16) / 255, this;
      if (h === 6)
        return this.r = parseInt(u.charAt(0) + u.charAt(1), 16) / 255, this.g = parseInt(u.charAt(2) + u.charAt(3), 16) / 255, this.b = parseInt(u.charAt(4) + u.charAt(5), 16) / 255, this;
    }
    return e && e.length > 0 ? this.setColorName(e) : this;
  },
  setColorName: function(e) {
    var t = _colorKeywords[e];
    return t !== void 0 ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this;
  },
  clone: function() {
    return new this.constructor(this.r, this.g, this.b);
  },
  copy: function(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  },
  copyGammaToLinear: function(e, t) {
    return t === void 0 && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this;
  },
  copyLinearToGamma: function(e, t) {
    t === void 0 && (t = 2);
    var r = t > 0 ? 1 / t : 1;
    return this.r = Math.pow(e.r, r), this.g = Math.pow(e.g, r), this.b = Math.pow(e.b, r), this;
  },
  convertGammaToLinear: function(e) {
    return this.copyGammaToLinear(this, e), this;
  },
  convertLinearToGamma: function(e) {
    return this.copyLinearToGamma(this, e), this;
  },
  copySRGBToLinear: function(e) {
    return this.r = SRGBToLinear(e.r), this.g = SRGBToLinear(e.g), this.b = SRGBToLinear(e.b), this;
  },
  copyLinearToSRGB: function(e) {
    return this.r = LinearToSRGB(e.r), this.g = LinearToSRGB(e.g), this.b = LinearToSRGB(e.b), this;
  },
  convertSRGBToLinear: function() {
    return this.copySRGBToLinear(this), this;
  },
  convertLinearToSRGB: function() {
    return this.copyLinearToSRGB(this), this;
  },
  getHex: function() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  },
  getHexString: function() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function(e) {
    e === void 0 && (console.warn("THREE.Color: .getHSL() target is now required"), e = { h: 0, s: 0, l: 0 });
    var t = this.r, r = this.g, n = this.b, a = Math.max(t, r, n), o = Math.min(t, r, n), s, l, c = (o + a) / 2;
    if (o === a)
      s = 0, l = 0;
    else {
      var u = a - o;
      switch (l = c <= 0.5 ? u / (a + o) : u / (2 - a - o), a) {
        case t:
          s = (r - n) / u + (r < n ? 6 : 0);
          break;
        case r:
          s = (n - t) / u + 2;
          break;
        case n:
          s = (t - r) / u + 4;
          break;
      }
      s /= 6;
    }
    return e.h = s, e.s = l, e.l = c, e;
  },
  getStyle: function() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  },
  offsetHSL: function(e, t, r) {
    return this.getHSL(_hslA), _hslA.h += e, _hslA.s += t, _hslA.l += r, this.setHSL(_hslA.h, _hslA.s, _hslA.l), this;
  },
  add: function(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  },
  addColors: function(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  },
  addScalar: function(e) {
    return this.r += e, this.g += e, this.b += e, this;
  },
  sub: function(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  },
  multiply: function(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  },
  multiplyScalar: function(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  },
  lerp: function(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  },
  lerpHSL: function(e, t) {
    this.getHSL(_hslA), e.getHSL(_hslB);
    var r = MathUtils.lerp(_hslA.h, _hslB.h, t), n = MathUtils.lerp(_hslA.s, _hslB.s, t), a = MathUtils.lerp(_hslA.l, _hslB.l, t);
    return this.setHSL(r, n, a), this;
  },
  equals: function(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  },
  fromArray: function(e, t) {
    return t === void 0 && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  },
  toArray: function(e, t) {
    return e === void 0 && (e = []), t === void 0 && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  },
  toJSON: function() {
    return this.getHex();
  }
});
Color.NAMES = _colorKeywords;
function Face3(e, t, r, n, a, o) {
  this.a = e, this.b = t, this.c = r, this.normal = n && n.isVector3 ? n : new Vector3(), this.vertexNormals = Array.isArray(n) ? n : [], this.color = a && a.isColor ? a : new Color(), this.vertexColors = Array.isArray(a) ? a : [], this.materialIndex = o !== void 0 ? o : 0;
}
Object.assign(Face3.prototype, {
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
    for (var t = 0, r = e.vertexNormals.length; t < r; t++)
      this.vertexNormals[t] = e.vertexNormals[t].clone();
    for (var t = 0, r = e.vertexColors.length; t < r; t++)
      this.vertexColors[t] = e.vertexColors[t].clone();
    return this;
  }
});
var materialId = 0;
function Material() {
  Object.defineProperty(this, "id", { value: materialId++ }), this.uuid = MathUtils.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = NormalBlending, this.side = FrontSide, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = SrcAlphaFactor, this.blendDst = OneMinusSrcAlphaFactor, this.blendEquation = AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = LessEqualDepth, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = AlwaysStencilFunc, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = KeepStencilOp, this.stencilZFail = KeepStencilOp, this.stencilZPass = KeepStencilOp, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0;
}
Material.prototype = Object.assign(Object.create(EventDispatcher$1.prototype), {
  constructor: Material,
  isMaterial: !0,
  onBeforeCompile: function() {
  },
  setValues: function(e) {
    if (e !== void 0)
      for (var t in e) {
        var r = e[t];
        if (r === void 0) {
          console.warn("THREE.Material: '" + t + "' parameter is undefined.");
          continue;
        }
        if (t === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = r === FlatShading;
          continue;
        }
        var n = this[t];
        if (n === void 0) {
          console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
          continue;
        }
        n && n.isColor ? n.set(r) : n && n.isVector3 && r && r.isVector3 ? n.copy(r) : this[t] = r;
      }
  },
  toJSON: function(e) {
    var t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    var r = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), this.roughness !== void 0 && (r.roughness = this.roughness), this.metalness !== void 0 && (r.metalness = this.metalness), this.sheen && this.sheen.isColor && (r.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), this.shininess !== void 0 && (r.shininess = this.shininess), this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, r.reflectivity = this.reflectivity, r.refractionRatio = this.refractionRatio, this.combine !== void 0 && (r.combine = this.combine), this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), this.size !== void 0 && (r.size = this.size), this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== NormalBlending && (r.blending = this.blending), this.flatShading === !0 && (r.flatShading = this.flatShading), this.side !== FrontSide && (r.side = this.side), this.vertexColors && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), this.transparent === !0 && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, this.rotation && this.rotation !== 0 && (r.rotation = this.rotation), this.polygonOffset === !0 && (r.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && this.linewidth !== 1 && (r.linewidth = this.linewidth), this.dashSize !== void 0 && (r.dashSize = this.dashSize), this.gapSize !== void 0 && (r.gapSize = this.gapSize), this.scale !== void 0 && (r.scale = this.scale), this.dithering === !0 && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), this.premultipliedAlpha === !0 && (r.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === !0 && (r.morphTargets = !0), this.morphNormals === !0 && (r.morphNormals = !0), this.skinning === !0 && (r.skinning = !0), this.visible === !1 && (r.visible = !1), this.toneMapped === !1 && (r.toneMapped = !1), JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData);
    function n(s) {
      var l = [];
      for (var c in s) {
        var u = s[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
    if (t) {
      var a = n(e.textures), o = n(e.images);
      a.length > 0 && (r.textures = a), o.length > 0 && (r.images = o);
    }
    return r;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    var t = e.clippingPlanes, r = null;
    if (t !== null) {
      var n = t.length;
      r = new Array(n);
      for (var a = 0; a !== n; ++a)
        r[a] = t[a].clone();
    }
    return this.clippingPlanes = r, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
Object.defineProperty(Material.prototype, "needsUpdate", {
  set: function(e) {
    e === !0 && this.version++;
  }
});
function MeshBasicMaterial(e) {
  Material.call(this), this.type = "MeshBasicMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(e);
}
MeshBasicMaterial.prototype = Object.create(Material.prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = !0;
MeshBasicMaterial.prototype.copy = function(e) {
  return Material.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this;
};
var _vector$3 = new Vector3();
function BufferAttribute(e, t, r) {
  if (Array.isArray(e))
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = r === !0, this.usage = StaticDrawUsage, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
}
Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
  set: function(e) {
    e === !0 && this.version++;
  }
});
Object.assign(BufferAttribute.prototype, {
  isBufferAttribute: !0,
  onUploadCallback: function() {
  },
  setUsage: function(e) {
    return this.usage = e, this;
  },
  copy: function(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
  },
  copyAt: function(e, t, r) {
    e *= this.itemSize, r *= t.itemSize;
    for (var n = 0, a = this.itemSize; n < a; n++)
      this.array[e + n] = t.array[r + n];
    return this;
  },
  copyArray: function(e) {
    return this.array.set(e), this;
  },
  copyColorsArray: function(e) {
    for (var t = this.array, r = 0, n = 0, a = e.length; n < a; n++) {
      var o = e[n];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), o = new Color()), t[r++] = o.r, t[r++] = o.g, t[r++] = o.b;
    }
    return this;
  },
  copyVector2sArray: function(e) {
    for (var t = this.array, r = 0, n = 0, a = e.length; n < a; n++) {
      var o = e[n];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), o = new Vector2()), t[r++] = o.x, t[r++] = o.y;
    }
    return this;
  },
  copyVector3sArray: function(e) {
    for (var t = this.array, r = 0, n = 0, a = e.length; n < a; n++) {
      var o = e[n];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), o = new Vector3()), t[r++] = o.x, t[r++] = o.y, t[r++] = o.z;
    }
    return this;
  },
  copyVector4sArray: function(e) {
    for (var t = this.array, r = 0, n = 0, a = e.length; n < a; n++) {
      var o = e[n];
      o === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), o = new Vector4()), t[r++] = o.x, t[r++] = o.y, t[r++] = o.z, t[r++] = o.w;
    }
    return this;
  },
  applyMatrix3: function(e) {
    for (var t = 0, r = this.count; t < r; t++)
      _vector$3.x = this.getX(t), _vector$3.y = this.getY(t), _vector$3.z = this.getZ(t), _vector$3.applyMatrix3(e), this.setXYZ(t, _vector$3.x, _vector$3.y, _vector$3.z);
    return this;
  },
  applyMatrix4: function(e) {
    for (var t = 0, r = this.count; t < r; t++)
      _vector$3.x = this.getX(t), _vector$3.y = this.getY(t), _vector$3.z = this.getZ(t), _vector$3.applyMatrix4(e), this.setXYZ(t, _vector$3.x, _vector$3.y, _vector$3.z);
    return this;
  },
  applyNormalMatrix: function(e) {
    for (var t = 0, r = this.count; t < r; t++)
      _vector$3.x = this.getX(t), _vector$3.y = this.getY(t), _vector$3.z = this.getZ(t), _vector$3.applyNormalMatrix(e), this.setXYZ(t, _vector$3.x, _vector$3.y, _vector$3.z);
    return this;
  },
  transformDirection: function(e) {
    for (var t = 0, r = this.count; t < r; t++)
      _vector$3.x = this.getX(t), _vector$3.y = this.getY(t), _vector$3.z = this.getZ(t), _vector$3.transformDirection(e), this.setXYZ(t, _vector$3.x, _vector$3.y, _vector$3.z);
    return this;
  },
  set: function(e, t) {
    return t === void 0 && (t = 0), this.array.set(e, t), this;
  },
  getX: function(e) {
    return this.array[e * this.itemSize];
  },
  setX: function(e, t) {
    return this.array[e * this.itemSize] = t, this;
  },
  getY: function(e) {
    return this.array[e * this.itemSize + 1];
  },
  setY: function(e, t) {
    return this.array[e * this.itemSize + 1] = t, this;
  },
  getZ: function(e) {
    return this.array[e * this.itemSize + 2];
  },
  setZ: function(e, t) {
    return this.array[e * this.itemSize + 2] = t, this;
  },
  getW: function(e) {
    return this.array[e * this.itemSize + 3];
  },
  setW: function(e, t) {
    return this.array[e * this.itemSize + 3] = t, this;
  },
  setXY: function(e, t, r) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = r, this;
  },
  setXYZ: function(e, t, r, n) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this;
  },
  setXYZW: function(e, t, r, n, a) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this.array[e + 3] = a, this;
  },
  onUpload: function(e) {
    return this.onUploadCallback = e, this;
  },
  clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function() {
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
  }
});
function Int8BufferAttribute(e, t, r) {
  BufferAttribute.call(this, new Int8Array(e), t, r);
}
Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute(e, t, r) {
  BufferAttribute.call(this, new Uint8Array(e), t, r);
}
Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute(e, t, r) {
  BufferAttribute.call(this, new Uint8ClampedArray(e), t, r);
}
Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute(e, t, r) {
  BufferAttribute.call(this, new Int16Array(e), t, r);
}
Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute(e, t, r) {
  BufferAttribute.call(this, new Uint16Array(e), t, r);
}
Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute(e, t, r) {
  BufferAttribute.call(this, new Int32Array(e), t, r);
}
Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute(e, t, r) {
  BufferAttribute.call(this, new Uint32Array(e), t, r);
}
Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float32BufferAttribute(e, t, r) {
  BufferAttribute.call(this, new Float32Array(e), t, r);
}
Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute(e, t, r) {
  BufferAttribute.call(this, new Float64Array(e), t, r);
}
Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
function DirectGeometry() {
  this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1;
}
Object.assign(DirectGeometry.prototype, {
  computeGroups: function(e) {
    for (var t, r = [], n = void 0, a = e.faces, o = 0; o < a.length; o++) {
      var s = a[o];
      s.materialIndex !== n && (n = s.materialIndex, t !== void 0 && (t.count = o * 3 - t.start, r.push(t)), t = {
        start: o * 3,
        materialIndex: n
      });
    }
    t !== void 0 && (t.count = o * 3 - t.start, r.push(t)), this.groups = r;
  },
  fromGeometry: function(e) {
    var t = e.faces, r = e.vertices, n = e.faceVertexUvs, a = n[0] && n[0].length > 0, o = n[1] && n[1].length > 0, s = e.morphTargets, l = s.length, c;
    if (l > 0) {
      c = [];
      for (var u = 0; u < l; u++)
        c[u] = {
          name: s[u].name,
          data: []
        };
      this.morphTargets.position = c;
    }
    var h = e.morphNormals, f = h.length, d;
    if (f > 0) {
      d = [];
      for (var u = 0; u < f; u++)
        d[u] = {
          name: h[u].name,
          data: []
        };
      this.morphTargets.normal = d;
    }
    var p = e.skinIndices, g = e.skinWeights, v = p.length === r.length, _ = g.length === r.length;
    r.length > 0 && t.length === 0 && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    for (var u = 0; u < t.length; u++) {
      var m = t[u];
      this.vertices.push(r[m.a], r[m.b], r[m.c]);
      var y = m.vertexNormals;
      if (y.length === 3)
        this.normals.push(y[0], y[1], y[2]);
      else {
        var b = m.normal;
        this.normals.push(b, b, b);
      }
      var M = m.vertexColors;
      if (M.length === 3)
        this.colors.push(M[0], M[1], M[2]);
      else {
        var x = m.color;
        this.colors.push(x, x, x);
      }
      if (a === !0) {
        var w = n[0][u];
        w !== void 0 ? this.uvs.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", u), this.uvs.push(new Vector2(), new Vector2(), new Vector2()));
      }
      if (o === !0) {
        var w = n[1][u];
        w !== void 0 ? this.uvs2.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", u), this.uvs2.push(new Vector2(), new Vector2(), new Vector2()));
      }
      for (var P = 0; P < l; P++) {
        var V = s[P].vertices;
        c[P].data.push(V[m.a], V[m.b], V[m.c]);
      }
      for (var P = 0; P < f; P++) {
        var I = h[P].vertexNormals[u];
        d[P].data.push(I.a, I.b, I.c);
      }
      v && this.skinIndices.push(p[m.a], p[m.b], p[m.c]), _ && this.skinWeights.push(g[m.a], g[m.b], g[m.c]);
    }
    return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), this;
  }
});
function arrayMax(e) {
  if (e.length === 0) return -1 / 0;
  let t = e[0];
  for (let r = 1, n = e.length; r < n; ++r)
    e[r] > t && (t = e[r]);
  return t;
}
var _bufferGeometryId = 1, _m1$2 = new Matrix4(), _obj = new Object3D(), _offset = new Vector3(), _box$2 = new Box3(), _boxMorphTargets = new Box3(), _vector$4 = new Vector3();
function BufferGeometry() {
  Object.defineProperty(this, "id", { value: _bufferGeometryId += 2 }), this.uuid = MathUtils.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
}
BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher$1.prototype), {
  constructor: BufferGeometry,
  isBufferGeometry: !0,
  getIndex: function() {
    return this.index;
  },
  setIndex: function(e) {
    Array.isArray(e) ? this.index = new (arrayMax(e) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(e, 1) : this.index = e;
  },
  getAttribute: function(e) {
    return this.attributes[e];
  },
  setAttribute: function(e, t) {
    return this.attributes[e] = t, this;
  },
  deleteAttribute: function(e) {
    return delete this.attributes[e], this;
  },
  addGroup: function(e, t, r) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: r !== void 0 ? r : 0
    });
  },
  clearGroups: function() {
    this.groups = [];
  },
  setDrawRange: function(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  },
  applyMatrix4: function(e) {
    var t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    var r = this.attributes.normal;
    if (r !== void 0) {
      var n = new Matrix3().getNormalMatrix(e);
      r.applyNormalMatrix(n), r.needsUpdate = !0;
    }
    var a = this.attributes.tangent;
    return a !== void 0 && (a.transformDirection(e), a.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  },
  rotateX: function(e) {
    return _m1$2.makeRotationX(e), this.applyMatrix4(_m1$2), this;
  },
  rotateY: function(e) {
    return _m1$2.makeRotationY(e), this.applyMatrix4(_m1$2), this;
  },
  rotateZ: function(e) {
    return _m1$2.makeRotationZ(e), this.applyMatrix4(_m1$2), this;
  },
  translate: function(e, t, r) {
    return _m1$2.makeTranslation(e, t, r), this.applyMatrix4(_m1$2), this;
  },
  scale: function(e, t, r) {
    return _m1$2.makeScale(e, t, r), this.applyMatrix4(_m1$2), this;
  },
  lookAt: function(e) {
    return _obj.lookAt(e), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this;
  },
  center: function() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(_offset).negate(), this.translate(_offset.x, _offset.y, _offset.z), this;
  },
  setFromObject: function(e) {
    var t = e.geometry;
    if (e.isPoints || e.isLine) {
      var r = new Float32BufferAttribute(t.vertices.length * 3, 3), n = new Float32BufferAttribute(t.colors.length * 3, 3);
      if (this.setAttribute("position", r.copyVector3sArray(t.vertices)), this.setAttribute("color", n.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
        var a = new Float32BufferAttribute(t.lineDistances.length, 1);
        this.setAttribute("lineDistance", a.copyArray(t.lineDistances));
      }
      t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone());
    } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
    return this;
  },
  setFromPoints: function(e) {
    for (var t = [], r = 0, n = e.length; r < n; r++) {
      var a = e[r];
      t.push(a.x, a.y, a.z || 0);
    }
    return this.setAttribute("position", new Float32BufferAttribute(t, 3)), this;
  },
  updateFromObject: function(e) {
    var t = e.geometry;
    if (e.isMesh) {
      var r = t.__directGeometry;
      if (t.elementsNeedUpdate === !0 && (r = void 0, t.elementsNeedUpdate = !1), r === void 0)
        return this.fromGeometry(t);
      r.verticesNeedUpdate = t.verticesNeedUpdate, r.normalsNeedUpdate = t.normalsNeedUpdate, r.colorsNeedUpdate = t.colorsNeedUpdate, r.uvsNeedUpdate = t.uvsNeedUpdate, r.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = r;
    }
    var n;
    return t.verticesNeedUpdate === !0 && (n = this.attributes.position, n !== void 0 && (n.copyVector3sArray(t.vertices), n.needsUpdate = !0), t.verticesNeedUpdate = !1), t.normalsNeedUpdate === !0 && (n = this.attributes.normal, n !== void 0 && (n.copyVector3sArray(t.normals), n.needsUpdate = !0), t.normalsNeedUpdate = !1), t.colorsNeedUpdate === !0 && (n = this.attributes.color, n !== void 0 && (n.copyColorsArray(t.colors), n.needsUpdate = !0), t.colorsNeedUpdate = !1), t.uvsNeedUpdate && (n = this.attributes.uv, n !== void 0 && (n.copyVector2sArray(t.uvs), n.needsUpdate = !0), t.uvsNeedUpdate = !1), t.lineDistancesNeedUpdate && (n = this.attributes.lineDistance, n !== void 0 && (n.copyArray(t.lineDistances), n.needsUpdate = !0), t.lineDistancesNeedUpdate = !1), t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this;
  },
  fromGeometry: function(e) {
    return e.__directGeometry = new DirectGeometry().fromGeometry(e), this.fromDirectGeometry(e.__directGeometry);
  },
  fromDirectGeometry: function(e) {
    var t = new Float32Array(e.vertices.length * 3);
    if (this.setAttribute("position", new BufferAttribute(t, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) {
      var r = new Float32Array(e.normals.length * 3);
      this.setAttribute("normal", new BufferAttribute(r, 3).copyVector3sArray(e.normals));
    }
    if (e.colors.length > 0) {
      var n = new Float32Array(e.colors.length * 3);
      this.setAttribute("color", new BufferAttribute(n, 3).copyColorsArray(e.colors));
    }
    if (e.uvs.length > 0) {
      var a = new Float32Array(e.uvs.length * 2);
      this.setAttribute("uv", new BufferAttribute(a, 2).copyVector2sArray(e.uvs));
    }
    if (e.uvs2.length > 0) {
      var o = new Float32Array(e.uvs2.length * 2);
      this.setAttribute("uv2", new BufferAttribute(o, 2).copyVector2sArray(e.uvs2));
    }
    this.groups = e.groups;
    for (var s in e.morphTargets) {
      for (var l = [], c = e.morphTargets[s], u = 0, h = c.length; u < h; u++) {
        var f = c[u], d = new Float32BufferAttribute(f.data.length * 3, 3);
        d.name = f.name, l.push(d.copyVector3sArray(f.data));
      }
      this.morphAttributes[s] = l;
    }
    if (e.skinIndices.length > 0) {
      var p = new Float32BufferAttribute(e.skinIndices.length * 4, 4);
      this.setAttribute("skinIndex", p.copyVector4sArray(e.skinIndices));
    }
    if (e.skinWeights.length > 0) {
      var g = new Float32BufferAttribute(e.skinWeights.length * 4, 4);
      this.setAttribute("skinWeight", g.copyVector4sArray(e.skinWeights));
    }
    return e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), this;
  },
  computeBoundingBox: function() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    var e = this.attributes.position, t = this.morphAttributes.position;
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (var r = 0, n = t.length; r < n; r++) {
          var a = t[r];
          _box$2.setFromBufferAttribute(a), this.morphTargetsRelative ? (_vector$4.addVectors(this.boundingBox.min, _box$2.min), this.boundingBox.expandByPoint(_vector$4), _vector$4.addVectors(this.boundingBox.max, _box$2.max), this.boundingBox.expandByPoint(_vector$4)) : (this.boundingBox.expandByPoint(_box$2.min), this.boundingBox.expandByPoint(_box$2.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  },
  computeBoundingSphere: function() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere());
    var e = this.attributes.position, t = this.morphAttributes.position;
    if (e) {
      var r = this.boundingSphere.center;
      if (_box$2.setFromBufferAttribute(e), t)
        for (var n = 0, a = t.length; n < a; n++) {
          var o = t[n];
          _boxMorphTargets.setFromBufferAttribute(o), this.morphTargetsRelative ? (_vector$4.addVectors(_box$2.min, _boxMorphTargets.min), _box$2.expandByPoint(_vector$4), _vector$4.addVectors(_box$2.max, _boxMorphTargets.max), _box$2.expandByPoint(_vector$4)) : (_box$2.expandByPoint(_boxMorphTargets.min), _box$2.expandByPoint(_boxMorphTargets.max));
        }
      _box$2.getCenter(r);
      for (var s = 0, n = 0, a = e.count; n < a; n++)
        _vector$4.fromBufferAttribute(e, n), s = Math.max(s, r.distanceToSquared(_vector$4));
      if (t)
        for (var n = 0, a = t.length; n < a; n++)
          for (var o = t[n], l = this.morphTargetsRelative, c = 0, u = o.count; c < u; c++)
            _vector$4.fromBufferAttribute(o, c), l && (_offset.fromBufferAttribute(e, c), _vector$4.add(_offset)), s = Math.max(s, r.distanceToSquared(_vector$4));
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeFaceNormals: function() {
  },
  computeVertexNormals: function() {
    var e = this.index, t = this.attributes;
    if (t.position) {
      var r = t.position.array;
      if (t.normal === void 0)
        this.setAttribute("normal", new BufferAttribute(new Float32Array(r.length), 3));
      else
        for (var n = t.normal.array, a = 0, o = n.length; a < o; a++)
          n[a] = 0;
      var s = t.normal.array, l, c, u, h = new Vector3(), f = new Vector3(), d = new Vector3(), p = new Vector3(), g = new Vector3();
      if (e)
        for (var v = e.array, a = 0, o = e.count; a < o; a += 3)
          l = v[a + 0] * 3, c = v[a + 1] * 3, u = v[a + 2] * 3, h.fromArray(r, l), f.fromArray(r, c), d.fromArray(r, u), p.subVectors(d, f), g.subVectors(h, f), p.cross(g), s[l] += p.x, s[l + 1] += p.y, s[l + 2] += p.z, s[c] += p.x, s[c + 1] += p.y, s[c + 2] += p.z, s[u] += p.x, s[u + 1] += p.y, s[u + 2] += p.z;
      else
        for (var a = 0, o = r.length; a < o; a += 9)
          h.fromArray(r, a), f.fromArray(r, a + 3), d.fromArray(r, a + 6), p.subVectors(d, f), g.subVectors(h, f), p.cross(g), s[a] = p.x, s[a + 1] = p.y, s[a + 2] = p.z, s[a + 3] = p.x, s[a + 4] = p.y, s[a + 5] = p.z, s[a + 6] = p.x, s[a + 7] = p.y, s[a + 8] = p.z;
      this.normalizeNormals(), t.normal.needsUpdate = !0;
    }
  },
  merge: function(e, t) {
    if (!(e && e.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
      return;
    }
    t === void 0 && (t = 0, console.warn(
      "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
    ));
    var r = this.attributes;
    for (var n in r)
      if (e.attributes[n] !== void 0)
        for (var a = r[n], o = a.array, s = e.attributes[n], l = s.array, c = s.itemSize * t, u = Math.min(l.length, o.length - c), h = 0, f = c; h < u; h++, f++)
          o[f] = l[h];
    return this;
  },
  normalizeNormals: function() {
    for (var e = this.attributes.normal, t = 0, r = e.count; t < r; t++)
      _vector$4.x = e.getX(t), _vector$4.y = e.getY(t), _vector$4.z = e.getZ(t), _vector$4.normalize(), e.setXYZ(t, _vector$4.x, _vector$4.y, _vector$4.z);
  },
  toNonIndexed: function() {
    function e(v, _) {
      for (var m = v.array, y = v.itemSize, b = v.normalized, M = new m.constructor(_.length * y), x = 0, w = 0, P = 0, V = _.length; P < V; P++) {
        x = _[P] * y;
        for (var I = 0; I < y; I++)
          M[w++] = m[x++];
      }
      return new BufferAttribute(M, y, b);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
    var t = new BufferGeometry(), r = this.index.array, n = this.attributes;
    for (var a in n) {
      var o = n[a], s = e(o, r);
      t.setAttribute(a, s);
    }
    var l = this.morphAttributes;
    for (a in l) {
      for (var c = [], u = l[a], h = 0, f = u.length; h < f; h++) {
        var o = u[h], s = e(o, r);
        c.push(s);
      }
      t.morphAttributes[a] = c;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    for (var d = this.groups, h = 0, p = d.length; h < p; h++) {
      var g = d[h];
      t.addGroup(g.start, g.count, g.materialIndex);
    }
    return t;
  },
  toJSON: function() {
    var e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      var t = this.parameters;
      for (var r in t)
        t[r] !== void 0 && (e[r] = t[r]);
      return e;
    }
    e.data = { attributes: {} };
    var n = this.index;
    n !== null && (e.data.index = {
      type: n.array.constructor.name,
      array: Array.prototype.slice.call(n.array)
    });
    var a = this.attributes;
    for (var r in a) {
      var o = a[r], s = o.toJSON();
      o.name !== "" && (s.name = o.name), e.data.attributes[r] = s;
    }
    var l = {}, c = !1;
    for (var r in this.morphAttributes) {
      for (var u = this.morphAttributes[r], h = [], f = 0, d = u.length; f < d; f++) {
        var o = u[f], s = o.toJSON();
        o.name !== "" && (s.name = o.name), h.push(s);
      }
      h.length > 0 && (l[r] = h, c = !0);
    }
    c && (e.data.morphAttributes = l, e.data.morphTargetsRelative = this.morphTargetsRelative);
    var p = this.groups;
    p.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(p)));
    var g = this.boundingSphere;
    return g !== null && (e.data.boundingSphere = {
      center: g.center.toArray(),
      radius: g.radius
    }), e;
  },
  clone: function() {
    return new BufferGeometry().copy(this);
  },
  copy: function(e) {
    var t, r, n;
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
    var a = e.index;
    a !== null && this.setIndex(a.clone());
    var o = e.attributes;
    for (t in o) {
      var s = o[t];
      this.setAttribute(t, s.clone());
    }
    var l = e.morphAttributes;
    for (t in l) {
      var c = [], u = l[t];
      for (r = 0, n = u.length; r < n; r++)
        c.push(u[r].clone());
      this.morphAttributes[t] = c;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    var h = e.groups;
    for (r = 0, n = h.length; r < n; r++) {
      var f = h[r];
      this.addGroup(f.start, f.count, f.materialIndex);
    }
    var d = e.boundingBox;
    d !== null && (this.boundingBox = d.clone());
    var p = e.boundingSphere;
    return p !== null && (this.boundingSphere = p.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
var _inverseMatrix = new Matrix4(), _ray = new Ray(), _sphere = new Sphere(), _vA = new Vector3(), _vB = new Vector3(), _vC = new Vector3(), _tempA = new Vector3(), _tempB = new Vector3(), _tempC = new Vector3(), _morphA = new Vector3(), _morphB = new Vector3(), _morphC = new Vector3(), _uvA = new Vector2(), _uvB = new Vector2(), _uvC = new Vector2(), _intersectionPoint = new Vector3(), _intersectionPointWorld = new Vector3();
function Mesh(e, t) {
  Object3D.call(this), this.type = "Mesh", this.geometry = e !== void 0 ? e : new BufferGeometry(), this.material = t !== void 0 ? t : new MeshBasicMaterial(), this.updateMorphTargets();
}
Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Mesh,
  isMesh: !0,
  copy: function(e) {
    return Object3D.prototype.copy.call(this, e), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this;
  },
  updateMorphTargets: function() {
    var e = this.geometry, t, r, n;
    if (e.isBufferGeometry) {
      var a = e.morphAttributes, o = Object.keys(a);
      if (o.length > 0) {
        var s = a[o[0]];
        if (s !== void 0)
          for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, r = s.length; t < r; t++)
            n = s[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t;
      }
    } else {
      var l = e.morphTargets;
      l !== void 0 && l.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  raycast: function(e, t) {
    var r = this.geometry, n = this.material, a = this.matrixWorld;
    if (n !== void 0 && (r.boundingSphere === null && r.computeBoundingSphere(), _sphere.copy(r.boundingSphere), _sphere.applyMatrix4(a), e.ray.intersectsSphere(_sphere) !== !1 && (_inverseMatrix.getInverse(a), _ray.copy(e.ray).applyMatrix4(_inverseMatrix), !(r.boundingBox !== null && _ray.intersectsBox(r.boundingBox) === !1)))) {
      var o;
      if (r.isBufferGeometry) {
        var s, l, c, u = r.index, h = r.attributes.position, f = r.morphAttributes.position, d = r.morphTargetsRelative, p = r.attributes.uv, g = r.attributes.uv2, v = r.groups, _ = r.drawRange, m, y, b, M, x, w, P, V;
        if (u !== null)
          if (Array.isArray(n))
            for (m = 0, b = v.length; m < b; m++)
              for (x = v[m], w = n[x.materialIndex], P = Math.max(x.start, _.start), V = Math.min(x.start + x.count, _.start + _.count), y = P, M = V; y < M; y += 3)
                s = u.getX(y), l = u.getX(y + 1), c = u.getX(y + 2), o = checkBufferGeometryIntersection(this, w, e, _ray, h, f, d, p, g, s, l, c), o && (o.faceIndex = Math.floor(y / 3), o.face.materialIndex = x.materialIndex, t.push(o));
          else
            for (P = Math.max(0, _.start), V = Math.min(u.count, _.start + _.count), m = P, b = V; m < b; m += 3)
              s = u.getX(m), l = u.getX(m + 1), c = u.getX(m + 2), o = checkBufferGeometryIntersection(this, n, e, _ray, h, f, d, p, g, s, l, c), o && (o.faceIndex = Math.floor(m / 3), t.push(o));
        else if (h !== void 0)
          if (Array.isArray(n))
            for (m = 0, b = v.length; m < b; m++)
              for (x = v[m], w = n[x.materialIndex], P = Math.max(x.start, _.start), V = Math.min(x.start + x.count, _.start + _.count), y = P, M = V; y < M; y += 3)
                s = y, l = y + 1, c = y + 2, o = checkBufferGeometryIntersection(this, w, e, _ray, h, f, d, p, g, s, l, c), o && (o.faceIndex = Math.floor(y / 3), o.face.materialIndex = x.materialIndex, t.push(o));
          else
            for (P = Math.max(0, _.start), V = Math.min(h.count, _.start + _.count), m = P, b = V; m < b; m += 3)
              s = m, l = m + 1, c = m + 2, o = checkBufferGeometryIntersection(this, n, e, _ray, h, f, d, p, g, s, l, c), o && (o.faceIndex = Math.floor(m / 3), t.push(o));
      } else if (r.isGeometry) {
        var I, $, E, G = Array.isArray(n), O = r.vertices, W = r.faces, B, q = r.faceVertexUvs[0];
        q.length > 0 && (B = q);
        for (var te = 0, ne = W.length; te < ne; te++) {
          var Q = W[te], ae = G ? n[Q.materialIndex] : n;
          if (ae !== void 0 && (I = O[Q.a], $ = O[Q.b], E = O[Q.c], o = checkIntersection(this, ae, e, _ray, I, $, E, _intersectionPoint), o)) {
            if (B && B[te]) {
              var oe = B[te];
              _uvA.copy(oe[0]), _uvB.copy(oe[1]), _uvC.copy(oe[2]), o.uv = Triangle.getUV(_intersectionPoint, I, $, E, _uvA, _uvB, _uvC, new Vector2());
            }
            o.face = Q, o.faceIndex = te, t.push(o);
          }
        }
      }
    }
  },
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function checkIntersection(e, t, r, n, a, o, s, l) {
  var c;
  if (t.side === BackSide ? c = n.intersectTriangle(s, o, a, !0, l) : c = n.intersectTriangle(a, o, s, t.side !== DoubleSide, l), c === null) return null;
  _intersectionPointWorld.copy(l), _intersectionPointWorld.applyMatrix4(e.matrixWorld);
  var u = r.ray.origin.distanceTo(_intersectionPointWorld);
  return u < r.near || u > r.far ? null : {
    distance: u,
    point: _intersectionPointWorld.clone(),
    object: e
  };
}
function checkBufferGeometryIntersection(e, t, r, n, a, o, s, l, c, u, h, f) {
  _vA.fromBufferAttribute(a, u), _vB.fromBufferAttribute(a, h), _vC.fromBufferAttribute(a, f);
  var d = e.morphTargetInfluences;
  if (t.morphTargets && o && d) {
    _morphA.set(0, 0, 0), _morphB.set(0, 0, 0), _morphC.set(0, 0, 0);
    for (var p = 0, g = o.length; p < g; p++) {
      var v = d[p], _ = o[p];
      v !== 0 && (_tempA.fromBufferAttribute(_, u), _tempB.fromBufferAttribute(_, h), _tempC.fromBufferAttribute(_, f), s ? (_morphA.addScaledVector(_tempA, v), _morphB.addScaledVector(_tempB, v), _morphC.addScaledVector(_tempC, v)) : (_morphA.addScaledVector(_tempA.sub(_vA), v), _morphB.addScaledVector(_tempB.sub(_vB), v), _morphC.addScaledVector(_tempC.sub(_vC), v)));
    }
    _vA.add(_morphA), _vB.add(_morphB), _vC.add(_morphC);
  }
  e.isSkinnedMesh && (e.boneTransform(u, _vA), e.boneTransform(h, _vB), e.boneTransform(f, _vC));
  var m = checkIntersection(e, t, r, n, _vA, _vB, _vC, _intersectionPoint);
  if (m) {
    l && (_uvA.fromBufferAttribute(l, u), _uvB.fromBufferAttribute(l, h), _uvC.fromBufferAttribute(l, f), m.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2())), c && (_uvA.fromBufferAttribute(c, u), _uvB.fromBufferAttribute(c, h), _uvC.fromBufferAttribute(c, f), m.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()));
    var y = new Face3(u, h, f);
    Triangle.getNormal(_vA, _vB, _vC, y.normal), m.face = y;
  }
  return m;
}
var _geometryId = 0, _m1$3 = new Matrix4(), _obj$1 = new Object3D(), _offset$1 = new Vector3();
function Geometry$1() {
  Object.defineProperty(this, "id", { value: _geometryId += 2 }), this.uuid = MathUtils.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1;
}
Geometry$1.prototype = Object.assign(Object.create(EventDispatcher$1.prototype), {
  constructor: Geometry$1,
  isGeometry: !0,
  applyMatrix4: function(e) {
    for (var t = new Matrix3().getNormalMatrix(e), r = 0, n = this.vertices.length; r < n; r++) {
      var a = this.vertices[r];
      a.applyMatrix4(e);
    }
    for (var r = 0, n = this.faces.length; r < n; r++) {
      var o = this.faces[r];
      o.normal.applyMatrix3(t).normalize();
      for (var s = 0, l = o.vertexNormals.length; s < l; s++)
        o.vertexNormals[s].applyMatrix3(t).normalize();
    }
    return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this;
  },
  rotateX: function(e) {
    return _m1$3.makeRotationX(e), this.applyMatrix4(_m1$3), this;
  },
  rotateY: function(e) {
    return _m1$3.makeRotationY(e), this.applyMatrix4(_m1$3), this;
  },
  rotateZ: function(e) {
    return _m1$3.makeRotationZ(e), this.applyMatrix4(_m1$3), this;
  },
  translate: function(e, t, r) {
    return _m1$3.makeTranslation(e, t, r), this.applyMatrix4(_m1$3), this;
  },
  scale: function(e, t, r) {
    return _m1$3.makeScale(e, t, r), this.applyMatrix4(_m1$3), this;
  },
  lookAt: function(e) {
    return _obj$1.lookAt(e), _obj$1.updateMatrix(), this.applyMatrix4(_obj$1.matrix), this;
  },
  fromBufferGeometry: function(e) {
    var t = this, r = e.index !== null ? e.index.array : void 0, n = e.attributes;
    if (n.position === void 0)
      return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
    var a = n.position.array, o = n.normal !== void 0 ? n.normal.array : void 0, s = n.color !== void 0 ? n.color.array : void 0, l = n.uv !== void 0 ? n.uv.array : void 0, c = n.uv2 !== void 0 ? n.uv2.array : void 0;
    c !== void 0 && (this.faceVertexUvs[1] = []);
    for (var u = 0; u < a.length; u += 3)
      t.vertices.push(new Vector3().fromArray(a, u)), s !== void 0 && t.colors.push(new Color().fromArray(s, u));
    function h(m, y, b, M) {
      var x = s === void 0 ? [] : [
        t.colors[m].clone(),
        t.colors[y].clone(),
        t.colors[b].clone()
      ], w = o === void 0 ? [] : [
        new Vector3().fromArray(o, m * 3),
        new Vector3().fromArray(o, y * 3),
        new Vector3().fromArray(o, b * 3)
      ], P = new Face3(m, y, b, w, x, M);
      t.faces.push(P), l !== void 0 && t.faceVertexUvs[0].push([
        new Vector2().fromArray(l, m * 2),
        new Vector2().fromArray(l, y * 2),
        new Vector2().fromArray(l, b * 2)
      ]), c !== void 0 && t.faceVertexUvs[1].push([
        new Vector2().fromArray(c, m * 2),
        new Vector2().fromArray(c, y * 2),
        new Vector2().fromArray(c, b * 2)
      ]);
    }
    var f = e.groups;
    if (f.length > 0)
      for (var u = 0; u < f.length; u++)
        for (var d = f[u], p = d.start, g = d.count, v = p, _ = p + g; v < _; v += 3)
          r !== void 0 ? h(r[v], r[v + 1], r[v + 2], d.materialIndex) : h(v, v + 1, v + 2, d.materialIndex);
    else if (r !== void 0)
      for (var u = 0; u < r.length; u += 3)
        h(r[u], r[u + 1], r[u + 2]);
    else
      for (var u = 0; u < a.length / 3; u += 3)
        h(u, u + 1, u + 2);
    return this.computeFaceNormals(), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  },
  center: function() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(_offset$1).negate(), this.translate(_offset$1.x, _offset$1.y, _offset$1.z), this;
  },
  normalize: function() {
    this.computeBoundingSphere();
    var e = this.boundingSphere.center, t = this.boundingSphere.radius, r = t === 0 ? 1 : 1 / t, n = new Matrix4();
    return n.set(
      r,
      0,
      0,
      -r * e.x,
      0,
      r,
      0,
      -r * e.y,
      0,
      0,
      r,
      -r * e.z,
      0,
      0,
      0,
      1
    ), this.applyMatrix4(n), this;
  },
  computeFaceNormals: function() {
    for (var e = new Vector3(), t = new Vector3(), r = 0, n = this.faces.length; r < n; r++) {
      var a = this.faces[r], o = this.vertices[a.a], s = this.vertices[a.b], l = this.vertices[a.c];
      e.subVectors(l, s), t.subVectors(o, s), e.cross(t), e.normalize(), a.normal.copy(e);
    }
  },
  computeVertexNormals: function(e) {
    e === void 0 && (e = !0);
    var t, r, n, a, o, s;
    for (s = new Array(this.vertices.length), t = 0, r = this.vertices.length; t < r; t++)
      s[t] = new Vector3();
    if (e) {
      var l, c, u, h = new Vector3(), f = new Vector3();
      for (n = 0, a = this.faces.length; n < a; n++)
        o = this.faces[n], l = this.vertices[o.a], c = this.vertices[o.b], u = this.vertices[o.c], h.subVectors(u, c), f.subVectors(l, c), h.cross(f), s[o.a].add(h), s[o.b].add(h), s[o.c].add(h);
    } else
      for (this.computeFaceNormals(), n = 0, a = this.faces.length; n < a; n++)
        o = this.faces[n], s[o.a].add(o.normal), s[o.b].add(o.normal), s[o.c].add(o.normal);
    for (t = 0, r = this.vertices.length; t < r; t++)
      s[t].normalize();
    for (n = 0, a = this.faces.length; n < a; n++) {
      o = this.faces[n];
      var d = o.vertexNormals;
      d.length === 3 ? (d[0].copy(s[o.a]), d[1].copy(s[o.b]), d[2].copy(s[o.c])) : (d[0] = s[o.a].clone(), d[1] = s[o.b].clone(), d[2] = s[o.c].clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeFlatVertexNormals: function() {
    var e, t, r;
    for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
      r = this.faces[e];
      var n = r.vertexNormals;
      n.length === 3 ? (n[0].copy(r.normal), n[1].copy(r.normal), n[2].copy(r.normal)) : (n[0] = r.normal.clone(), n[1] = r.normal.clone(), n[2] = r.normal.clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeMorphNormals: function() {
    var e, t, r, n, a;
    for (r = 0, n = this.faces.length; r < n; r++)
      for (a = this.faces[r], a.__originalFaceNormal ? a.__originalFaceNormal.copy(a.normal) : a.__originalFaceNormal = a.normal.clone(), a.__originalVertexNormals || (a.__originalVertexNormals = []), e = 0, t = a.vertexNormals.length; e < t; e++)
        a.__originalVertexNormals[e] ? a.__originalVertexNormals[e].copy(a.vertexNormals[e]) : a.__originalVertexNormals[e] = a.vertexNormals[e].clone();
    var o = new Geometry$1();
    for (o.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
      if (!this.morphNormals[e]) {
        this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
        var s = this.morphNormals[e].faceNormals, l = this.morphNormals[e].vertexNormals, u, h;
        for (r = 0, n = this.faces.length; r < n; r++)
          u = new Vector3(), h = { a: new Vector3(), b: new Vector3(), c: new Vector3() }, s.push(u), l.push(h);
      }
      var c = this.morphNormals[e];
      o.vertices = this.morphTargets[e].vertices, o.computeFaceNormals(), o.computeVertexNormals();
      var u, h;
      for (r = 0, n = this.faces.length; r < n; r++)
        a = this.faces[r], u = c.faceNormals[r], h = c.vertexNormals[r], u.copy(a.normal), h.a.copy(a.vertexNormals[0]), h.b.copy(a.vertexNormals[1]), h.c.copy(a.vertexNormals[2]);
    }
    for (r = 0, n = this.faces.length; r < n; r++)
      a = this.faces[r], a.normal = a.__originalFaceNormal, a.vertexNormals = a.__originalVertexNormals;
  },
  computeBoundingBox: function() {
    this.boundingBox === null && (this.boundingBox = new Box3()), this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere()), this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function(e, t, r) {
    if (!(e && e.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e);
      return;
    }
    var n, a = this.vertices.length, o = this.vertices, s = e.vertices, l = this.faces, c = e.faces, u = this.colors, h = e.colors;
    r === void 0 && (r = 0), t !== void 0 && (n = new Matrix3().getNormalMatrix(t));
    for (var f = 0, d = s.length; f < d; f++) {
      var p = s[f], g = p.clone();
      t !== void 0 && g.applyMatrix4(t), o.push(g);
    }
    for (var f = 0, d = h.length; f < d; f++)
      u.push(h[f].clone());
    for (f = 0, d = c.length; f < d; f++) {
      var v = c[f], _, m, y, b = v.vertexNormals, M = v.vertexColors;
      _ = new Face3(v.a + a, v.b + a, v.c + a), _.normal.copy(v.normal), n !== void 0 && _.normal.applyMatrix3(n).normalize();
      for (var x = 0, w = b.length; x < w; x++)
        m = b[x].clone(), n !== void 0 && m.applyMatrix3(n).normalize(), _.vertexNormals.push(m);
      _.color.copy(v.color);
      for (var x = 0, w = M.length; x < w; x++)
        y = M[x], _.vertexColors.push(y.clone());
      _.materialIndex = v.materialIndex + r, l.push(_);
    }
    for (var f = 0, d = e.faceVertexUvs.length; f < d; f++) {
      var P = e.faceVertexUvs[f];
      this.faceVertexUvs[f] === void 0 && (this.faceVertexUvs[f] = []);
      for (var x = 0, w = P.length; x < w; x++) {
        for (var V = P[x], I = [], $ = 0, E = V.length; $ < E; $++)
          I.push(V[$].clone());
        this.faceVertexUvs[f].push(I);
      }
    }
  },
  mergeMesh: function(e) {
    if (!(e && e.isMesh)) {
      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e);
      return;
    }
    e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix);
  },
  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */
  mergeVertices: function() {
    var e = {}, t = [], r = [], n, a, o = 4, s = Math.pow(10, o), l, c, u, h, f, d;
    for (l = 0, c = this.vertices.length; l < c; l++)
      n = this.vertices[l], a = Math.round(n.x * s) + "_" + Math.round(n.y * s) + "_" + Math.round(n.z * s), e[a] === void 0 ? (e[a] = l, t.push(this.vertices[l]), r[l] = t.length - 1) : r[l] = r[e[a]];
    var p = [];
    for (l = 0, c = this.faces.length; l < c; l++) {
      u = this.faces[l], u.a = r[u.a], u.b = r[u.b], u.c = r[u.c], h = [u.a, u.b, u.c];
      for (var g = 0; g < 3; g++)
        if (h[g] === h[(g + 1) % 3]) {
          p.push(l);
          break;
        }
    }
    for (l = p.length - 1; l >= 0; l--) {
      var v = p[l];
      for (this.faces.splice(v, 1), f = 0, d = this.faceVertexUvs.length; f < d; f++)
        this.faceVertexUvs[f].splice(v, 1);
    }
    var _ = this.vertices.length - t.length;
    return this.vertices = t, _;
  },
  setFromPoints: function(e) {
    this.vertices = [];
    for (var t = 0, r = e.length; t < r; t++) {
      var n = e[t];
      this.vertices.push(new Vector3(n.x, n.y, n.z || 0));
    }
    return this;
  },
  sortFacesByMaterialIndex: function() {
    for (var e = this.faces, t = e.length, r = 0; r < t; r++)
      e[r]._id = r;
    function n(u, h) {
      return u.materialIndex - h.materialIndex;
    }
    e.sort(n);
    var a = this.faceVertexUvs[0], o = this.faceVertexUvs[1], s, l;
    a && a.length === t && (s = []), o && o.length === t && (l = []);
    for (var r = 0; r < t; r++) {
      var c = e[r]._id;
      s && s.push(a[c]), l && l.push(o[c]);
    }
    s && (this.faceVertexUvs[0] = s), l && (this.faceVertexUvs[1] = l);
  },
  toJSON: function() {
    var e = {
      metadata: {
        version: 4.5,
        type: "Geometry",
        generator: "Geometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), this.parameters !== void 0) {
      var t = this.parameters;
      for (var r in t)
        t[r] !== void 0 && (e[r] = t[r]);
      return e;
    }
    for (var n = [], a = 0; a < this.vertices.length; a++) {
      var o = this.vertices[a];
      n.push(o.x, o.y, o.z);
    }
    for (var s = [], l = [], c = {}, u = [], h = {}, f = [], d = {}, a = 0; a < this.faces.length; a++) {
      var p = this.faces[a], g = !0, v = !1, _ = this.faceVertexUvs[0][a] !== void 0, m = p.normal.length() > 0, y = p.vertexNormals.length > 0, b = p.color.r !== 1 || p.color.g !== 1 || p.color.b !== 1, M = p.vertexColors.length > 0, x = 0;
      if (x = I(x, 0, 0), x = I(x, 1, g), x = I(x, 2, v), x = I(x, 3, _), x = I(x, 4, m), x = I(x, 5, y), x = I(x, 6, b), x = I(x, 7, M), s.push(x), s.push(p.a, p.b, p.c), s.push(p.materialIndex), _) {
        var w = this.faceVertexUvs[0][a];
        s.push(
          G(w[0]),
          G(w[1]),
          G(w[2])
        );
      }
      if (m && s.push($(p.normal)), y) {
        var P = p.vertexNormals;
        s.push(
          $(P[0]),
          $(P[1]),
          $(P[2])
        );
      }
      if (b && s.push(E(p.color)), M) {
        var V = p.vertexColors;
        s.push(
          E(V[0]),
          E(V[1]),
          E(V[2])
        );
      }
    }
    function I(O, W, B) {
      return B ? O | 1 << W : O & ~(1 << W);
    }
    function $(O) {
      var W = O.x.toString() + O.y.toString() + O.z.toString();
      return c[W] !== void 0 || (c[W] = l.length / 3, l.push(O.x, O.y, O.z)), c[W];
    }
    function E(O) {
      var W = O.r.toString() + O.g.toString() + O.b.toString();
      return h[W] !== void 0 || (h[W] = u.length, u.push(O.getHex())), h[W];
    }
    function G(O) {
      var W = O.x.toString() + O.y.toString();
      return d[W] !== void 0 || (d[W] = f.length / 2, f.push(O.x, O.y)), d[W];
    }
    return e.data = {}, e.data.vertices = n, e.data.normals = l, u.length > 0 && (e.data.colors = u), f.length > 0 && (e.data.uvs = [f]), e.data.faces = s, e;
  },
  clone: function() {
    return new Geometry$1().copy(this);
  },
  copy: function(e) {
    var t, r, n, a, o, s;
    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
    var l = e.vertices;
    for (t = 0, r = l.length; t < r; t++)
      this.vertices.push(l[t].clone());
    var c = e.colors;
    for (t = 0, r = c.length; t < r; t++)
      this.colors.push(c[t].clone());
    var u = e.faces;
    for (t = 0, r = u.length; t < r; t++)
      this.faces.push(u[t].clone());
    for (t = 0, r = e.faceVertexUvs.length; t < r; t++) {
      var h = e.faceVertexUvs[t];
      for (this.faceVertexUvs[t] === void 0 && (this.faceVertexUvs[t] = []), n = 0, a = h.length; n < a; n++) {
        var f = h[n], d = [];
        for (o = 0, s = f.length; o < s; o++) {
          var p = f[o];
          d.push(p.clone());
        }
        this.faceVertexUvs[t].push(d);
      }
    }
    var g = e.morphTargets;
    for (t = 0, r = g.length; t < r; t++) {
      var v = {};
      if (v.name = g[t].name, g[t].vertices !== void 0)
        for (v.vertices = [], n = 0, a = g[t].vertices.length; n < a; n++)
          v.vertices.push(g[t].vertices[n].clone());
      if (g[t].normals !== void 0)
        for (v.normals = [], n = 0, a = g[t].normals.length; n < a; n++)
          v.normals.push(g[t].normals[n].clone());
      this.morphTargets.push(v);
    }
    var _ = e.morphNormals;
    for (t = 0, r = _.length; t < r; t++) {
      var m = {};
      if (_[t].vertexNormals !== void 0)
        for (m.vertexNormals = [], n = 0, a = _[t].vertexNormals.length; n < a; n++) {
          var y = _[t].vertexNormals[n], b = {};
          b.a = y.a.clone(), b.b = y.b.clone(), b.c = y.c.clone(), m.vertexNormals.push(b);
        }
      if (_[t].faceNormals !== void 0)
        for (m.faceNormals = [], n = 0, a = _[t].faceNormals.length; n < a; n++)
          m.faceNormals.push(_[t].faceNormals[n].clone());
      this.morphNormals.push(m);
    }
    var M = e.skinWeights;
    for (t = 0, r = M.length; t < r; t++)
      this.skinWeights.push(M[t].clone());
    var x = e.skinIndices;
    for (t = 0, r = x.length; t < r; t++)
      this.skinIndices.push(x[t].clone());
    var w = e.lineDistances;
    for (t = 0, r = w.length; t < r; t++)
      this.lineDistances.push(w[t]);
    var P = e.boundingBox;
    P !== null && (this.boundingBox = P.clone());
    var V = e.boundingSphere;
    return V !== null && (this.boundingSphere = V.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
class BoxGeometry extends Geometry$1 {
  constructor(t, r, n, a, o, s) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: t,
      height: r,
      depth: n,
      widthSegments: a,
      heightSegments: o,
      depthSegments: s
    }, this.fromBufferGeometry(new BoxBufferGeometry(t, r, n, a, o, s)), this.mergeVertices();
  }
}
class BoxBufferGeometry extends BufferGeometry {
  constructor(t, r, n, a, o, s) {
    super(), this.type = "BoxBufferGeometry", this.parameters = {
      width: t,
      height: r,
      depth: n,
      widthSegments: a,
      heightSegments: o,
      depthSegments: s
    };
    const l = this;
    t = t || 1, r = r || 1, n = n || 1, a = Math.floor(a) || 1, o = Math.floor(o) || 1, s = Math.floor(s) || 1;
    const c = [], u = [], h = [], f = [];
    let d = 0, p = 0;
    g("z", "y", "x", -1, -1, n, r, t, s, o, 0), g("z", "y", "x", 1, -1, n, r, -t, s, o, 1), g("x", "z", "y", 1, 1, t, n, r, a, s, 2), g("x", "z", "y", 1, -1, t, n, -r, a, s, 3), g("x", "y", "z", 1, -1, t, r, n, a, o, 4), g("x", "y", "z", -1, -1, t, r, -n, a, o, 5), this.setIndex(c), this.setAttribute("position", new Float32BufferAttribute(u, 3)), this.setAttribute("normal", new Float32BufferAttribute(h, 3)), this.setAttribute("uv", new Float32BufferAttribute(f, 2));
    function g(v, _, m, y, b, M, x, w, P, V, I) {
      const $ = M / P, E = x / V, G = M / 2, O = x / 2, W = w / 2, B = P + 1, q = V + 1;
      let te = 0, ne = 0;
      const Q = new Vector3();
      for (let ae = 0; ae < q; ae++) {
        const oe = ae * E - O;
        for (let _e = 0; _e < B; _e++) {
          const A = _e * $ - G;
          Q[v] = A * y, Q[_] = oe * b, Q[m] = W, u.push(Q.x, Q.y, Q.z), Q[v] = 0, Q[_] = 0, Q[m] = w > 0 ? 1 : -1, h.push(Q.x, Q.y, Q.z), f.push(_e / P), f.push(1 - ae / V), te += 1;
        }
      }
      for (let ae = 0; ae < V; ae++)
        for (let oe = 0; oe < P; oe++) {
          const _e = d + oe + B * ae, A = d + oe + B * (ae + 1), L = d + (oe + 1) + B * (ae + 1), D = d + (oe + 1) + B * ae;
          c.push(_e, A, D), c.push(A, L, D), ne += 6;
        }
      l.addGroup(p, ne, I), p += ne, d += te;
    }
  }
}
function cloneUniforms(e) {
  var t = {};
  for (var r in e) {
    t[r] = {};
    for (var n in e[r]) {
      var a = e[r][n];
      a && (a.isColor || a.isMatrix3 || a.isMatrix4 || a.isVector2 || a.isVector3 || a.isVector4 || a.isTexture) ? t[r][n] = a.clone() : Array.isArray(a) ? t[r][n] = a.slice() : t[r][n] = a;
    }
  }
  return t;
}
function mergeUniforms(e) {
  for (var t = {}, r = 0; r < e.length; r++) {
    var n = cloneUniforms(e[r]);
    for (var a in n)
      t[a] = n[a];
  }
  return t;
}
var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms }, default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
function ShaderMaterial(e) {
  Material.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = default_vertex, this.fragmentShader = default_fragment, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
    derivatives: !1,
    // set to use derivatives
    fragDepth: !1,
    // set to use fragment depth values
    drawBuffers: !1,
    // set to use draw buffers
    shaderTextureLOD: !1
    // set to use shader texture LOD
  }, this.defaultAttributeValues = {
    color: [1, 1, 1],
    uv: [0, 0],
    uv2: [0, 0]
  }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, e !== void 0 && (e.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e));
}
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = !0;
ShaderMaterial.prototype.copy = function(e) {
  return Material.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = cloneUniforms(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = Object.assign({}, e.extensions), this;
};
ShaderMaterial.prototype.toJSON = function(e) {
  var t = Material.prototype.toJSON.call(this, e);
  t.uniforms = {};
  for (var r in this.uniforms) {
    var n = this.uniforms[r], a = n.value;
    a && a.isTexture ? t.uniforms[r] = {
      type: "t",
      value: a.toJSON(e).uuid
    } : a && a.isColor ? t.uniforms[r] = {
      type: "c",
      value: a.getHex()
    } : a && a.isVector2 ? t.uniforms[r] = {
      type: "v2",
      value: a.toArray()
    } : a && a.isVector3 ? t.uniforms[r] = {
      type: "v3",
      value: a.toArray()
    } : a && a.isVector4 ? t.uniforms[r] = {
      type: "v4",
      value: a.toArray()
    } : a && a.isMatrix3 ? t.uniforms[r] = {
      type: "m3",
      value: a.toArray()
    } : a && a.isMatrix4 ? t.uniforms[r] = {
      type: "m4",
      value: a.toArray()
    } : t.uniforms[r] = {
      value: a
    };
  }
  Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
  var o = {};
  for (var s in this.extensions)
    this.extensions[s] === !0 && (o[s] = !0);
  return Object.keys(o).length > 0 && (t.extensions = o), t;
};
function Camera$1() {
  Object3D.call(this), this.type = "Camera", this.matrixWorldInverse = new Matrix4(), this.projectionMatrix = new Matrix4(), this.projectionMatrixInverse = new Matrix4();
}
Camera$1.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Camera$1,
  isCamera: !0,
  copy: function(e, t) {
    return Object3D.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this;
  },
  getWorldDirection: function(e) {
    e === void 0 && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new Vector3()), this.updateMatrixWorld(!0);
    var t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  },
  updateMatrixWorld: function(e) {
    Object3D.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  updateWorldMatrix: function(e, t) {
    Object3D.prototype.updateWorldMatrix.call(this, e, t), this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function PerspectiveCamera(e, t, r, n) {
  Camera$1.call(this), this.type = "PerspectiveCamera", this.fov = e !== void 0 ? e : 50, this.zoom = 1, this.near = r !== void 0 ? r : 0.1, this.far = n !== void 0 ? n : 2e3, this.focus = 10, this.aspect = t !== void 0 ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign(Object.create(Camera$1.prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: !0,
  copy: function(e, t) {
    return Camera$1.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  },
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength: function(e) {
    var t = 0.5 * this.getFilmHeight() / e;
    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(t), this.updateProjectionMatrix();
  },
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength: function() {
    var e = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  },
  getEffectiveFOV: function() {
    return MathUtils.RAD2DEG * 2 * Math.atan(
      Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  },
  getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   var w = 1920;
   *   var h = 1080;
   *   var fullWidth = w * 3;
   *   var fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset: function(e, t, r, n, a, o) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = n, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    var e = this.near, t = e * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom, r = 2 * t, n = this.aspect * r, a = -0.5 * n, o = this.view;
    if (this.view !== null && this.view.enabled) {
      var s = o.fullWidth, l = o.fullHeight;
      a += o.offsetX * n / s, t -= o.offsetY * r / l, n *= o.width / s, r *= o.height / l;
    }
    var c = this.filmOffset;
    c !== 0 && (a += e * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(a, a + n, t, t - r, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function(e) {
    var t = Object3D.prototype.toJSON.call(this, e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
});
var fov = 90, aspect = 1;
function CubeCamera(e, t, r) {
  if (Object3D.call(this), this.type = "CubeCamera", r.isWebGLCubeRenderTarget !== !0) {
    console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
    return;
  }
  this.renderTarget = r;
  var n = new PerspectiveCamera(fov, aspect, e, t);
  n.layers = this.layers, n.up.set(0, -1, 0), n.lookAt(new Vector3(1, 0, 0)), this.add(n);
  var a = new PerspectiveCamera(fov, aspect, e, t);
  a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new Vector3(-1, 0, 0)), this.add(a);
  var o = new PerspectiveCamera(fov, aspect, e, t);
  o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new Vector3(0, 1, 0)), this.add(o);
  var s = new PerspectiveCamera(fov, aspect, e, t);
  s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new Vector3(0, -1, 0)), this.add(s);
  var l = new PerspectiveCamera(fov, aspect, e, t);
  l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Vector3(0, 0, 1)), this.add(l);
  var c = new PerspectiveCamera(fov, aspect, e, t);
  c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new Vector3(0, 0, -1)), this.add(c), this.update = function(u, h) {
    this.parent === null && this.updateMatrixWorld();
    var f = u.xr.enabled, d = u.getRenderTarget();
    u.xr.enabled = !1;
    var p = r.texture.generateMipmaps;
    r.texture.generateMipmaps = !1, u.setRenderTarget(r, 0), u.render(h, n), u.setRenderTarget(r, 1), u.render(h, a), u.setRenderTarget(r, 2), u.render(h, o), u.setRenderTarget(r, 3), u.render(h, s), u.setRenderTarget(r, 4), u.render(h, l), r.texture.generateMipmaps = p, u.setRenderTarget(r, 5), u.render(h, c), u.setRenderTarget(d), u.xr.enabled = f;
  }, this.clear = function(u, h, f, d) {
    for (var p = u.getRenderTarget(), g = 0; g < 6; g++)
      u.setRenderTarget(r, g), u.clear(h, f, d);
    u.setRenderTarget(p);
  };
}
CubeCamera.prototype = Object.create(Object3D.prototype);
CubeCamera.prototype.constructor = CubeCamera;
function WebGLCubeRenderTarget(e, t, r) {
  Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = r), WebGLRenderTarget.call(this, e, e, t);
}
WebGLCubeRenderTarget.prototype = Object.create(WebGLRenderTarget.prototype);
WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = !0;
WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function(e, t) {
  this.texture.type = t.type, this.texture.format = t.format, this.texture.encoding = t.encoding;
  var r = new Scene$1(), n = {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: [
      "varying vec3 vWorldDirection;",
      "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",
      "	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",
      "}",
      "void main() {",
      "	vWorldDirection = transformDirection( position, modelMatrix );",
      "	#include <begin_vertex>",
      "	#include <project_vertex>",
      "}"
    ].join(`
`),
    fragmentShader: [
      "uniform sampler2D tEquirect;",
      "varying vec3 vWorldDirection;",
      "#include <common>",
      "void main() {",
      "	vec3 direction = normalize( vWorldDirection );",
      "	vec2 sampleUV = equirectUv( direction );",
      "	gl_FragColor = texture2D( tEquirect, sampleUV );",
      "}"
    ].join(`
`)
  }, a = new ShaderMaterial({
    type: "CubemapFromEquirect",
    uniforms: cloneUniforms(n.uniforms),
    vertexShader: n.vertexShader,
    fragmentShader: n.fragmentShader,
    side: BackSide,
    blending: NoBlending
  });
  a.uniforms.tEquirect.value = t;
  var o = new Mesh(new BoxBufferGeometry(5, 5, 5), a);
  r.add(o);
  var s = new CubeCamera(1, 10, this);
  return s.update(e, r), o.geometry.dispose(), o.material.dispose(), this;
};
function DataTexture(e, t, r, n, a, o, s, l, c, u, h, f) {
  Texture.call(this, null, o, s, l, c, u, n, a, h, f), this.image = { data: e || null, width: t || 1, height: r || 1 }, this.magFilter = c !== void 0 ? c : NearestFilter, this.minFilter = u !== void 0 ? u : NearestFilter, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0;
}
DataTexture.prototype = Object.create(Texture.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = !0;
var _sphere$1 = new Sphere(), _vector$5 = new Vector3();
function Frustum(e, t, r, n, a, o) {
  this.planes = [
    e !== void 0 ? e : new Plane(),
    t !== void 0 ? t : new Plane(),
    r !== void 0 ? r : new Plane(),
    n !== void 0 ? n : new Plane(),
    a !== void 0 ? a : new Plane(),
    o !== void 0 ? o : new Plane()
  ];
}
Object.assign(Frustum.prototype, {
  set: function(e, t, r, n, a, o) {
    var s = this.planes;
    return s[0].copy(e), s[1].copy(t), s[2].copy(r), s[3].copy(n), s[4].copy(a), s[5].copy(o), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    for (var t = this.planes, r = 0; r < 6; r++)
      t[r].copy(e.planes[r]);
    return this;
  },
  setFromProjectionMatrix: function(e) {
    var t = this.planes, r = e.elements, n = r[0], a = r[1], o = r[2], s = r[3], l = r[4], c = r[5], u = r[6], h = r[7], f = r[8], d = r[9], p = r[10], g = r[11], v = r[12], _ = r[13], m = r[14], y = r[15];
    return t[0].setComponents(s - n, h - l, g - f, y - v).normalize(), t[1].setComponents(s + n, h + l, g + f, y + v).normalize(), t[2].setComponents(s + a, h + c, g + d, y + _).normalize(), t[3].setComponents(s - a, h - c, g - d, y - _).normalize(), t[4].setComponents(s - o, h - u, g - p, y - m).normalize(), t[5].setComponents(s + o, h + u, g + p, y + m).normalize(), this;
  },
  intersectsObject: function(e) {
    var t = e.geometry;
    return t.boundingSphere === null && t.computeBoundingSphere(), _sphere$1.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(_sphere$1);
  },
  intersectsSprite: function(e) {
    return _sphere$1.center.set(0, 0, 0), _sphere$1.radius = 0.7071067811865476, _sphere$1.applyMatrix4(e.matrixWorld), this.intersectsSphere(_sphere$1);
  },
  intersectsSphere: function(e) {
    for (var t = this.planes, r = e.center, n = -e.radius, a = 0; a < 6; a++) {
      var o = t[a].distanceToPoint(r);
      if (o < n)
        return !1;
    }
    return !0;
  },
  intersectsBox: function(e) {
    for (var t = this.planes, r = 0; r < 6; r++) {
      var n = t[r];
      if (_vector$5.x = n.normal.x > 0 ? e.max.x : e.min.x, _vector$5.y = n.normal.y > 0 ? e.max.y : e.min.y, _vector$5.z = n.normal.z > 0 ? e.max.z : e.min.z, n.distanceToPoint(_vector$5) < 0)
        return !1;
    }
    return !0;
  },
  containsPoint: function(e) {
    for (var t = this.planes, r = 0; r < 6; r++)
      if (t[r].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
});
var UniformsLib = {
  common: {
    diffuse: { value: new Color(15658734) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Matrix3() },
    uv2Transform: { value: new Matrix3() },
    alphaMap: { value: null }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    refractionRatio: { value: 0.98 },
    maxMipLevel: { value: 0 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } }
  },
  points: {
    diffuse: { value: new Color(15658734) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new Matrix3() }
  },
  sprite: {
    diffuse: { value: new Color(15658734) },
    opacity: { value: 1 },
    center: { value: new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    uvTransform: { value: new Matrix3() }
  }
};
function WebGLAnimation() {
  var e = null, t = !1, r = null;
  function n(a, o) {
    t !== !1 && (r(a, o), e.requestAnimationFrame(n));
  }
  return {
    start: function() {
      t !== !0 && r !== null && (e.requestAnimationFrame(n), t = !0);
    },
    stop: function() {
      t = !1;
    },
    setAnimationLoop: function(a) {
      r = a;
    },
    setContext: function(a) {
      e = a;
    }
  };
}
function WebGLAttributes(e, t) {
  var r = t.isWebGL2, n = /* @__PURE__ */ new WeakMap();
  function a(u, h) {
    var f = u.array, d = u.usage, p = e.createBuffer();
    e.bindBuffer(h, p), e.bufferData(h, f, d), u.onUploadCallback();
    var g = 5126;
    return f instanceof Float32Array ? g = 5126 : f instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : f instanceof Uint16Array ? g = 5123 : f instanceof Int16Array ? g = 5122 : f instanceof Uint32Array ? g = 5125 : f instanceof Int32Array ? g = 5124 : f instanceof Int8Array ? g = 5120 : f instanceof Uint8Array && (g = 5121), {
      buffer: p,
      type: g,
      bytesPerElement: f.BYTES_PER_ELEMENT,
      version: u.version
    };
  }
  function o(u, h, f) {
    var d = h.array, p = h.updateRange;
    e.bindBuffer(f, u), p.count === -1 ? e.bufferSubData(f, 0, d) : (r ? e.bufferSubData(
      f,
      p.offset * d.BYTES_PER_ELEMENT,
      d,
      p.offset,
      p.count
    ) : e.bufferSubData(
      f,
      p.offset * d.BYTES_PER_ELEMENT,
      d.subarray(p.offset, p.offset + p.count)
    ), p.count = -1);
  }
  function s(u) {
    return u.isInterleavedBufferAttribute && (u = u.data), n.get(u);
  }
  function l(u) {
    u.isInterleavedBufferAttribute && (u = u.data);
    var h = n.get(u);
    h && (e.deleteBuffer(h.buffer), n.delete(u));
  }
  function c(u, h) {
    u.isInterleavedBufferAttribute && (u = u.data);
    var f = n.get(u);
    f === void 0 ? n.set(u, a(u, h)) : f.version < u.version && (o(f.buffer, u, h), f.version = u.version);
  }
  return {
    get: s,
    remove: l,
    update: c
  };
}
function PlaneGeometry(e, t, r, n) {
  Geometry$1.call(this), this.type = "PlaneGeometry", this.parameters = {
    width: e,
    height: t,
    widthSegments: r,
    heightSegments: n
  }, this.fromBufferGeometry(new PlaneBufferGeometry(e, t, r, n)), this.mergeVertices();
}
PlaneGeometry.prototype = Object.create(Geometry$1.prototype);
PlaneGeometry.prototype.constructor = PlaneGeometry;
function PlaneBufferGeometry(e, t, r, n) {
  BufferGeometry.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
    width: e,
    height: t,
    widthSegments: r,
    heightSegments: n
  }, e = e || 1, t = t || 1;
  var a = e / 2, o = t / 2, s = Math.floor(r) || 1, l = Math.floor(n) || 1, c = s + 1, u = l + 1, h = e / s, f = t / l, d, p, g = [], v = [], _ = [], m = [];
  for (p = 0; p < u; p++) {
    var y = p * f - o;
    for (d = 0; d < c; d++) {
      var b = d * h - a;
      v.push(b, -y, 0), _.push(0, 0, 1), m.push(d / s), m.push(1 - p / l);
    }
  }
  for (p = 0; p < l; p++)
    for (d = 0; d < s; d++) {
      var M = d + c * p, x = d + c * (p + 1), w = d + 1 + c * (p + 1), P = d + 1 + c * p;
      g.push(M, x, P), g.push(x, w, P);
    }
  this.setIndex(g), this.setAttribute("position", new Float32BufferAttribute(v, 3)), this.setAttribute("normal", new Float32BufferAttribute(_, 3)), this.setAttribute("uv", new Float32BufferAttribute(m, 2));
}
PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
var alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, alphatest_fragment = `#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`, aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`, aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, begin_vertex = "vec3 transformed = vec3( position );", beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, bsdfs = `vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha  = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`, bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, color_fragment = `#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`, color_pars_fragment = `#ifdef USE_COLOR
	varying vec3 vColor;
#endif`, color_pars_vertex = `#ifdef USE_COLOR
	varying vec3 vColor;
#endif`, color_vertex = `#ifdef USE_COLOR
	vColor.xyz = color.xyz;
#endif`, common = `#define PI 3.14159265359
#define PI2 6.28318530718
#define PI_HALF 1.5707963267949
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
  return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
#define cubeUV_maxMipLevel 8.0
#define cubeUV_minMipLevel 4.0
#define cubeUV_maxTileSize 256.0
#define cubeUV_minTileSize 16.0
float getFace(vec3 direction) {
    vec3 absDirection = abs(direction);
    float face = -1.0;
    if (absDirection.x > absDirection.z) {
      if (absDirection.x > absDirection.y)
        face = direction.x > 0.0 ? 0.0 : 3.0;
      else
        face = direction.y > 0.0 ? 1.0 : 4.0;
    } else {
      if (absDirection.z > absDirection.y)
        face = direction.z > 0.0 ? 2.0 : 5.0;
      else
        face = direction.y > 0.0 ? 1.0 : 4.0;
    }
    return face;
}
vec2 getUV(vec3 direction, float face) {
    vec2 uv;
    if (face == 0.0) {
      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {
      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {
      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {
      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {
      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {
      uv = vec2(direction.x, direction.y) / abs(direction.z);    }
    return 0.5 * (uv + 1.0);
}
vec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
  float face = getFace(direction);
  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
  mipInt = max(mipInt, cubeUV_minMipLevel);
  float faceSize = exp2(mipInt);
  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
  vec2 uv = getUV(direction, face) * (faceSize - 1.0);
  vec2 f = fract(uv);
  uv += 0.5 - f;
  if (face > 2.0) {
    uv.y += faceSize;
    face -= 3.0;
  }
  uv.x += face * faceSize;
  if(mipInt < cubeUV_maxMipLevel){
    uv.y += 2.0 * cubeUV_maxTileSize;
  }
  uv.y += filterInt * 2.0 * cubeUV_minTileSize;
  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
  uv *= texelSize;
  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.x += texelSize;
  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.y += texelSize;
  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  uv.x -= texelSize;
  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
  vec3 tm = mix(tl, tr, f.x);
  vec3 bm = mix(bl, br, f.x);
  return mix(tm, bm, f.y);
}
#define r0 1.0
#define v0 0.339
#define m0 -2.0
#define r1 0.8
#define v1 0.276
#define m1 -1.0
#define r4 0.4
#define v4 0.046
#define m4 2.0
#define r5 0.305
#define v5 0.016
#define m5 3.0
#define r6 0.21
#define v6 0.0038
#define m6 4.0
float roughnessToMip(float roughness) {
  float mip = 0.0;
  if (roughness >= r1) {
    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
  } else if (roughness >= r4) {
    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
  } else if (roughness >= r5) {
    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
  } else if (roughness >= r6) {
    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
  } else {
    mip = -2.0 * log2(1.16 * roughness);  }
  return mip;
}
vec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {
  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);
  float mipF = fract(mip);
  float mipInt = floor(mip);
  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);
  if (mipF == 0.0) {
    return vec4(color0, 1.0);
  } else {
    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);
    return vec4(mix(color0, color1, mipF), 1.0);
  }
}
#endif`, defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment = `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`, envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		}  else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#elif defined( ENVMAP_TYPE_EQUIREC )
		reflectVec = normalize( reflectVec );
		vec2 sampleUV = equirectUv( reflectVec );
		vec4 envColor = texture2D( envMap, sampleUV );
	#elif defined( ENVMAP_TYPE_SPHERE )
		reflectVec = normalize( reflectVec );
		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );
		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) { 
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, fog_vertex = `#ifdef USE_FOG
	fogDepth = -mvPosition.z;
#endif`, fog_pars_vertex = `#ifdef USE_FOG
	varying float fogDepth;
#endif`, fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`, lightmap_fragment = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`, lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, lights_lambert_vertex = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`, lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
		struct PointLightShadow {
			float shadowBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`, envmap_physical_pars_fragment = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
		  vec3 reflectVec = reflect( -viewDir, normal );
		  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
		  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#elif defined( ENVMAP_TYPE_EQUIREC )
			vec2 sampleUV = equirectUv( reflectVec );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_SPHERE )
			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
			#else
				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`, lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, lights_toon_pars_fragment = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3	diffuseColor;
	vec3	specularColor;
	float	specularShininess;
	float	specularStrength;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`, lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, lights_phong_pars_fragment = `varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3	diffuseColor;
	vec3	specularColor;
	float	specularShininess;
	float	specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`, lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`, lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3	diffuseColor;
	float	specularRoughness;
	vec3	specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, lights_fragment_begin = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`, lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, logdepthbuf_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, logdepthbuf_pars_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, logdepthbuf_pars_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, logdepthbuf_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, map_fragment = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`, map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, map_particle_pars_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`, morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
	uniform float morphTargetInfluences[ 8 ];
	#else
	uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`, morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
	transformed += morphTarget4 * morphTargetInfluences[ 4 ];
	transformed += morphTarget5 * morphTargetInfluences[ 5 ];
	transformed += morphTarget6 * morphTargetInfluences[ 6 ];
	transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`, normal_fragment_begin = `#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, normal_fragment_maps = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif`, normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		float scale = sign( st1.t * st0.s - st0.t * st1.s );
		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );
		mat3 tsn = mat3( S, T, N );
		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		return normalize( tsn * mapN );
	}
#endif`, clearcoat_normal_fragment_begin = `#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );
	#endif
#endif`, clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, shadowmap_pars_fragment = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, shadowmap_pars_vertex = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, shadowmap_vertex = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`, shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`, skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, tonemapping_pars_fragment = `#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );
}`, uv_pars_fragment = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, uv_pars_vertex = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, uv_vertex = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, uv2_pars_fragment = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, uv2_pars_vertex = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, uv2_vertex = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`, background_frag = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, background_vert = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, cube_frag = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, cube_vert = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, depth_frag = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, depth_vert = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, distanceRGBA_frag = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, distanceRGBA_vert = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, equirect_frag = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, equirect_vert = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, linedashed_frag = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, linedashed_vert = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, meshbasic_frag = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshbasic_vert = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, meshlambert_frag = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshlambert_vert = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshmatcap_frag = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshmatcap_vert = `#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, meshtoon_frag = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshtoon_vert = `#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshphong_frag = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshphong_vert = `#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshphysical_frag = `#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSPARENCY
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSPARENCY
	uniform float transparency;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSPARENCY
		diffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshphysical_vert = `#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, normal_frag = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`, normal_vert = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, points_frag = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, points_vert = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, shadow_frag = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, shadow_vert = `#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, sprite_frag = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, sprite_vert = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_frag,
  background_vert,
  cube_frag,
  cube_vert,
  depth_frag,
  depth_vert,
  distanceRGBA_frag,
  distanceRGBA_vert,
  equirect_frag,
  equirect_vert,
  linedashed_frag,
  linedashed_vert,
  meshbasic_frag,
  meshbasic_vert,
  meshlambert_frag,
  meshlambert_vert,
  meshmatcap_frag,
  meshmatcap_vert,
  meshtoon_frag,
  meshtoon_vert,
  meshphong_frag,
  meshphong_vert,
  meshphysical_frag,
  meshphysical_vert,
  normal_frag,
  normal_vert,
  points_frag,
  points_vert,
  shadow_frag,
  shadow_vert,
  sprite_frag,
  sprite_vert
}, ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        specular: { value: new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        specular: { value: new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix3() },
      t2D: { value: null }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: new Color(0) },
      transparency: { value: 0 }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(e, t, r, n) {
  var a = new Color(0), o = 0, s, l, c = null, u = 0, h = null;
  function f(p, g, v, _) {
    var m = g.background, y = e.xr, b = y.getSession && y.getSession();
    if (b && b.environmentBlendMode === "additive" && (m = null), m === null ? d(a, o) : m && m.isColor && (d(m, 1), _ = !0), (e.autoClear || _) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), m && (m.isCubeTexture || m.isWebGLCubeRenderTarget || m.mapping === CubeUVReflectionMapping)) {
      l === void 0 && (l = new Mesh(
        new BoxBufferGeometry(1, 1, 1),
        new ShaderMaterial({
          type: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: !1,
          depthWrite: !1,
          fog: !1
        })
      ), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(x, w, P) {
        this.matrixWorld.copyPosition(P.matrixWorld);
      }, Object.defineProperty(l.material, "envMap", {
        get: function() {
          return this.uniforms.envMap.value;
        }
      }), r.update(l));
      var M = m.isWebGLCubeRenderTarget ? m.texture : m;
      l.material.uniforms.envMap.value = M, l.material.uniforms.flipEnvMap.value = M.isCubeTexture ? -1 : 1, (c !== m || u !== M.version || h !== e.toneMapping) && (l.material.needsUpdate = !0, c = m, u = M.version, h = e.toneMapping), p.unshift(l, l.geometry, l.material, 0, 0, null);
    } else m && m.isTexture && (s === void 0 && (s = new Mesh(
      new PlaneBufferGeometry(2, 2),
      new ShaderMaterial({
        type: "BackgroundMaterial",
        uniforms: cloneUniforms(ShaderLib.background.uniforms),
        vertexShader: ShaderLib.background.vertexShader,
        fragmentShader: ShaderLib.background.fragmentShader,
        side: FrontSide,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), s.geometry.deleteAttribute("normal"), Object.defineProperty(s.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), r.update(s)), s.material.uniforms.t2D.value = m, m.matrixAutoUpdate === !0 && m.updateMatrix(), s.material.uniforms.uvTransform.value.copy(m.matrix), (c !== m || u !== m.version || h !== e.toneMapping) && (s.material.needsUpdate = !0, c = m, u = m.version, h = e.toneMapping), p.unshift(s, s.geometry, s.material, 0, 0, null));
  }
  function d(p, g) {
    t.buffers.color.setClear(p.r, p.g, p.b, g, n);
  }
  return {
    getClearColor: function() {
      return a;
    },
    setClearColor: function(p, g) {
      a.set(p), o = g !== void 0 ? g : 1, d(a, o);
    },
    getClearAlpha: function() {
      return o;
    },
    setClearAlpha: function(p) {
      o = p, d(a, o);
    },
    render: f
  };
}
function WebGLBufferRenderer(e, t, r, n) {
  var a = n.isWebGL2, o;
  function s(u) {
    o = u;
  }
  function l(u, h) {
    e.drawArrays(o, u, h), r.update(h, o);
  }
  function c(u, h, f, d) {
    if (d !== 0) {
      var p, g;
      if (a)
        p = e, g = "drawArraysInstanced";
      else if (p = t.get("ANGLE_instanced_arrays"), g = "drawArraysInstancedANGLE", p === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
      p[g](o, h, f, d), r.update(f, o, d);
    }
  }
  this.setMode = s, this.render = l, this.renderInstances = c;
}
function WebGLCapabilities(e, t, r) {
  var n;
  function a() {
    if (n !== void 0) return n;
    var w = t.get("EXT_texture_filter_anisotropic");
    return w !== null ? n = e.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : n = 0, n;
  }
  function o(w) {
    if (w === "highp") {
      if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      w = "mediump";
    }
    return w === "mediump" && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  var s = typeof WebGL2RenderingContext < "u" && e instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && e instanceof WebGL2ComputeRenderingContext, l = r.precision !== void 0 ? r.precision : "highp", c = o(l);
  c !== l && (console.warn("THREE.WebGLRenderer:", l, "not supported, using", c, "instead."), l = c);
  var u = r.logarithmicDepthBuffer === !0, h = e.getParameter(34930), f = e.getParameter(35660), d = e.getParameter(3379), p = e.getParameter(34076), g = e.getParameter(34921), v = e.getParameter(36347), _ = e.getParameter(36348), m = e.getParameter(36349), y = f > 0, b = s || !!t.get("OES_texture_float"), M = y && b, x = s ? e.getParameter(36183) : 0;
  return {
    isWebGL2: s,
    getMaxAnisotropy: a,
    getMaxPrecision: o,
    precision: l,
    logarithmicDepthBuffer: u,
    maxTextures: h,
    maxVertexTextures: f,
    maxTextureSize: d,
    maxCubemapSize: p,
    maxAttributes: g,
    maxVertexUniforms: v,
    maxVaryings: _,
    maxFragmentUniforms: m,
    vertexTextures: y,
    floatFragmentTextures: b,
    floatVertexTextures: M,
    maxSamples: x
  };
}
function WebGLClipping() {
  var e = this, t = null, r = 0, n = !1, a = !1, o = new Plane(), s = new Matrix3(), l = { value: null, needsUpdate: !1 };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, f, d) {
    var p = h.length !== 0 || f || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    r !== 0 || n;
    return n = f, t = u(h, d, 0), r = h.length, p;
  }, this.beginShadows = function() {
    a = !0, u(null);
  }, this.endShadows = function() {
    a = !1, c();
  }, this.setState = function(h, f, d, p, g, v) {
    if (!n || h === null || h.length === 0 || a && !d)
      a ? u(null) : c();
    else {
      var _ = a ? 0 : r, m = _ * 4, y = g.clippingState || null;
      l.value = y, y = u(h, p, m, v);
      for (var b = 0; b !== m; ++b)
        y[b] = t[b];
      g.clippingState = y, this.numIntersection = f ? this.numPlanes : 0, this.numPlanes += _;
    }
  };
  function c() {
    l.value !== t && (l.value = t, l.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0;
  }
  function u(h, f, d, p) {
    var g = h !== null ? h.length : 0, v = null;
    if (g !== 0) {
      if (v = l.value, p !== !0 || v === null) {
        var _ = d + g * 4, m = f.matrixWorldInverse;
        s.getNormalMatrix(m), (v === null || v.length < _) && (v = new Float32Array(_));
        for (var y = 0, b = d; y !== g; ++y, b += 4)
          o.copy(h[y]).applyMatrix4(m, s), o.normal.toArray(v, b), v[b + 3] = o.constant;
      }
      l.value = v, l.needsUpdate = !0;
    }
    return e.numPlanes = g, e.numIntersection = 0, v;
  }
}
function WebGLExtensions(e) {
  var t = {};
  return {
    get: function(r) {
      if (t[r] !== void 0)
        return t[r];
      var n;
      switch (r) {
        case "WEBGL_depth_texture":
          n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          n = e.getExtension(r);
      }
      return n === null && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."), t[r] = n, n;
    }
  };
}
function WebGLGeometries(e, t, r) {
  var n = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap();
  function o(h) {
    var f = h.target, d = n.get(f);
    d.index !== null && t.remove(d.index);
    for (var p in d.attributes)
      t.remove(d.attributes[p]);
    f.removeEventListener("dispose", o), n.delete(f);
    var g = a.get(d);
    g && (t.remove(g), a.delete(d)), r.memory.geometries--;
  }
  function s(h, f) {
    var d = n.get(f);
    return d || (f.addEventListener("dispose", o), f.isBufferGeometry ? d = f : f.isGeometry && (f._bufferGeometry === void 0 && (f._bufferGeometry = new BufferGeometry().setFromObject(h)), d = f._bufferGeometry), n.set(f, d), r.memory.geometries++, d);
  }
  function l(h) {
    var f = h.index, d = h.attributes;
    f !== null && t.update(f, 34963);
    for (var p in d)
      t.update(d[p], 34962);
    var g = h.morphAttributes;
    for (var p in g)
      for (var v = g[p], _ = 0, m = v.length; _ < m; _++)
        t.update(v[_], 34962);
  }
  function c(h) {
    var f = [], d = h.index, p = h.attributes.position, g = 0;
    if (d !== null) {
      var v = d.array;
      g = d.version;
      for (var _ = 0, m = v.length; _ < m; _ += 3) {
        var y = v[_ + 0], b = v[_ + 1], M = v[_ + 2];
        f.push(y, b, b, M, M, y);
      }
    } else {
      var v = p.array;
      g = p.version;
      for (var _ = 0, m = v.length / 3 - 1; _ < m; _ += 3) {
        var y = _ + 0, b = _ + 1, M = _ + 2;
        f.push(y, b, b, M, M, y);
      }
    }
    var x = new (arrayMax(f) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(f, 1);
    x.version = g, t.update(x, 34963);
    var w = a.get(h);
    w && t.remove(w), a.set(h, x);
  }
  function u(h) {
    var f = a.get(h);
    if (f) {
      var d = h.index;
      d !== null && f.version < d.version && c(h);
    } else
      c(h);
    return a.get(h);
  }
  return {
    get: s,
    update: l,
    getWireframeAttribute: u
  };
}
function WebGLIndexedBufferRenderer(e, t, r, n) {
  var a = n.isWebGL2, o;
  function s(d) {
    o = d;
  }
  var l, c;
  function u(d) {
    l = d.type, c = d.bytesPerElement;
  }
  function h(d, p) {
    e.drawElements(o, p, l, d * c), r.update(p, o);
  }
  function f(d, p, g, v) {
    if (v !== 0) {
      var _, m;
      if (a)
        _ = e, m = "drawElementsInstanced";
      else if (_ = t.get("ANGLE_instanced_arrays"), m = "drawElementsInstancedANGLE", _ === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
      _[m](o, g, l, p * c, v), r.update(g, o, v);
    }
  }
  this.setMode = s, this.setIndex = u, this.render = h, this.renderInstances = f;
}
function WebGLInfo(e) {
  var t = {
    geometries: 0,
    textures: 0
  }, r = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(o, s, l) {
    switch (l = l || 1, r.calls++, s) {
      case 4:
        r.triangles += l * (o / 3);
        break;
      case 1:
        r.lines += l * (o / 2);
        break;
      case 3:
        r.lines += l * (o - 1);
        break;
      case 2:
        r.lines += l * o;
        break;
      case 0:
        r.points += l * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", s);
        break;
    }
  }
  function a() {
    r.frame++, r.calls = 0, r.triangles = 0, r.points = 0, r.lines = 0;
  }
  return {
    memory: t,
    render: r,
    programs: null,
    autoReset: !0,
    reset: a,
    update: n
  };
}
function absNumericalSort(e, t) {
  return Math.abs(t[1]) - Math.abs(e[1]);
}
function WebGLMorphtargets(e) {
  var t = {}, r = new Float32Array(8);
  function n(a, o, s, l) {
    var c = a.morphTargetInfluences, u = c === void 0 ? 0 : c.length, h = t[o.id];
    if (h === void 0) {
      h = [];
      for (var f = 0; f < u; f++)
        h[f] = [f, 0];
      t[o.id] = h;
    }
    for (var d = s.morphTargets && o.morphAttributes.position, p = s.morphNormals && o.morphAttributes.normal, f = 0; f < u; f++) {
      var g = h[f];
      g[1] !== 0 && (d && o.deleteAttribute("morphTarget" + f), p && o.deleteAttribute("morphNormal" + f));
    }
    for (var f = 0; f < u; f++) {
      var g = h[f];
      g[0] = f, g[1] = c[f];
    }
    h.sort(absNumericalSort);
    for (var v = 0, f = 0; f < 8; f++) {
      var g = h[f];
      if (g) {
        var _ = g[0], m = g[1];
        if (m) {
          d && o.setAttribute("morphTarget" + f, d[_]), p && o.setAttribute("morphNormal" + f, p[_]), r[f] = m, v += m;
          continue;
        }
      }
      r[f] = 0;
    }
    var y = o.morphTargetsRelative ? 1 : 1 - v;
    l.getUniforms().setValue(e, "morphTargetBaseInfluence", y), l.getUniforms().setValue(e, "morphTargetInfluences", r);
  }
  return {
    update: n
  };
}
function WebGLObjects(e, t, r, n) {
  var a = /* @__PURE__ */ new WeakMap();
  function o(l) {
    var c = n.render.frame, u = l.geometry, h = t.get(l, u);
    return a.get(h) !== c && (u.isGeometry && h.updateFromObject(l), t.update(h), a.set(h, c)), l.isInstancedMesh && r.update(l.instanceMatrix, 34962), h;
  }
  function s() {
    a = /* @__PURE__ */ new WeakMap();
  }
  return {
    update: o,
    dispose: s
  };
}
function CubeTexture(e, t, r, n, a, o, s, l, c, u) {
  e = e !== void 0 ? e : [], t = t !== void 0 ? t : CubeReflectionMapping, s = s !== void 0 ? s : RGBFormat, Texture.call(this, e, t, r, n, a, o, s, l, c, u), this.flipY = !1;
}
CubeTexture.prototype = Object.create(Texture.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = !0;
Object.defineProperty(CubeTexture.prototype, "images", {
  get: function() {
    return this.image;
  },
  set: function(e) {
    this.image = e;
  }
});
function DataTexture2DArray(e, t, r, n) {
  Texture.call(this, null), this.image = { data: e || null, width: t || 1, height: r || 1, depth: n || 1 }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0;
}
DataTexture2DArray.prototype = Object.create(Texture.prototype);
DataTexture2DArray.prototype.constructor = DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray = !0;
function DataTexture3D(e, t, r, n) {
  Texture.call(this, null), this.image = { data: e || null, width: t || 1, height: r || 1, depth: n || 1 }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0;
}
DataTexture3D.prototype = Object.create(Texture.prototype);
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = !0;
var emptyTexture = new Texture(), emptyTexture2dArray = new DataTexture2DArray(), emptyTexture3d = new DataTexture3D(), emptyCubeTexture = new CubeTexture(), arrayCacheF32 = [], arrayCacheI32 = [], mat4array = new Float32Array(16), mat3array = new Float32Array(9), mat2array = new Float32Array(4);
function flatten(e, t, r) {
  var n = e[0];
  if (n <= 0 || n > 0) return e;
  var a = t * r, o = arrayCacheF32[a];
  if (o === void 0 && (o = new Float32Array(a), arrayCacheF32[a] = o), t !== 0) {
    n.toArray(o, 0);
    for (var s = 1, l = 0; s !== t; ++s)
      l += r, e[s].toArray(o, l);
  }
  return o;
}
function arraysEqual(e, t) {
  if (e.length !== t.length) return !1;
  for (var r = 0, n = e.length; r < n; r++)
    if (e[r] !== t[r]) return !1;
  return !0;
}
function copyArray$1(e, t) {
  for (var r = 0, n = t.length; r < n; r++)
    e[r] = t[r];
}
function allocTexUnits(e, t) {
  var r = arrayCacheI32[t];
  r === void 0 && (r = new Int32Array(t), arrayCacheI32[t] = r);
  for (var n = 0; n !== t; ++n)
    r[n] = e.allocateTextureUnit();
  return r;
}
function setValueV1f(e, t) {
  var r = this.cache;
  r[0] !== t && (e.uniform1f(this.addr, t), r[0] = t);
}
function setValueV2f(e, t) {
  var r = this.cache;
  if (t.x !== void 0)
    (r[0] !== t.x || r[1] !== t.y) && (e.uniform2f(this.addr, t.x, t.y), r[0] = t.x, r[1] = t.y);
  else {
    if (arraysEqual(r, t)) return;
    e.uniform2fv(this.addr, t), copyArray$1(r, t);
  }
}
function setValueV3f(e, t) {
  var r = this.cache;
  if (t.x !== void 0)
    (r[0] !== t.x || r[1] !== t.y || r[2] !== t.z) && (e.uniform3f(this.addr, t.x, t.y, t.z), r[0] = t.x, r[1] = t.y, r[2] = t.z);
  else if (t.r !== void 0)
    (r[0] !== t.r || r[1] !== t.g || r[2] !== t.b) && (e.uniform3f(this.addr, t.r, t.g, t.b), r[0] = t.r, r[1] = t.g, r[2] = t.b);
  else {
    if (arraysEqual(r, t)) return;
    e.uniform3fv(this.addr, t), copyArray$1(r, t);
  }
}
function setValueV4f(e, t) {
  var r = this.cache;
  if (t.x !== void 0)
    (r[0] !== t.x || r[1] !== t.y || r[2] !== t.z || r[3] !== t.w) && (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = t.w);
  else {
    if (arraysEqual(r, t)) return;
    e.uniform4fv(this.addr, t), copyArray$1(r, t);
  }
}
function setValueM2(e, t) {
  var r = this.cache, n = t.elements;
  if (n === void 0) {
    if (arraysEqual(r, t)) return;
    e.uniformMatrix2fv(this.addr, !1, t), copyArray$1(r, t);
  } else {
    if (arraysEqual(r, n)) return;
    mat2array.set(n), e.uniformMatrix2fv(this.addr, !1, mat2array), copyArray$1(r, n);
  }
}
function setValueM3(e, t) {
  var r = this.cache, n = t.elements;
  if (n === void 0) {
    if (arraysEqual(r, t)) return;
    e.uniformMatrix3fv(this.addr, !1, t), copyArray$1(r, t);
  } else {
    if (arraysEqual(r, n)) return;
    mat3array.set(n), e.uniformMatrix3fv(this.addr, !1, mat3array), copyArray$1(r, n);
  }
}
function setValueM4(e, t) {
  var r = this.cache, n = t.elements;
  if (n === void 0) {
    if (arraysEqual(r, t)) return;
    e.uniformMatrix4fv(this.addr, !1, t), copyArray$1(r, t);
  } else {
    if (arraysEqual(r, n)) return;
    mat4array.set(n), e.uniformMatrix4fv(this.addr, !1, mat4array), copyArray$1(r, n);
  }
}
function setValueT1(e, t, r) {
  var n = this.cache, a = r.allocateTextureUnit();
  n[0] !== a && (e.uniform1i(this.addr, a), n[0] = a), r.safeSetTexture2D(t || emptyTexture, a);
}
function setValueT2DArray1(e, t, r) {
  var n = this.cache, a = r.allocateTextureUnit();
  n[0] !== a && (e.uniform1i(this.addr, a), n[0] = a), r.setTexture2DArray(t || emptyTexture2dArray, a);
}
function setValueT3D1(e, t, r) {
  var n = this.cache, a = r.allocateTextureUnit();
  n[0] !== a && (e.uniform1i(this.addr, a), n[0] = a), r.setTexture3D(t || emptyTexture3d, a);
}
function setValueT6(e, t, r) {
  var n = this.cache, a = r.allocateTextureUnit();
  n[0] !== a && (e.uniform1i(this.addr, a), n[0] = a), r.safeSetTextureCube(t || emptyCubeTexture, a);
}
function setValueV1i(e, t) {
  var r = this.cache;
  r[0] !== t && (e.uniform1i(this.addr, t), r[0] = t);
}
function setValueV2i(e, t) {
  var r = this.cache;
  arraysEqual(r, t) || (e.uniform2iv(this.addr, t), copyArray$1(r, t));
}
function setValueV3i(e, t) {
  var r = this.cache;
  arraysEqual(r, t) || (e.uniform3iv(this.addr, t), copyArray$1(r, t));
}
function setValueV4i(e, t) {
  var r = this.cache;
  arraysEqual(r, t) || (e.uniform4iv(this.addr, t), copyArray$1(r, t));
}
function setValueV1ui(e, t) {
  var r = this.cache;
  r[0] !== t && (e.uniform1ui(this.addr, t), r[0] = t);
}
function getSingularSetter(e) {
  switch (e) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(e, t) {
  e.uniform1fv(this.addr, t);
}
function setValueV1iArray(e, t) {
  e.uniform1iv(this.addr, t);
}
function setValueV2iArray(e, t) {
  e.uniform2iv(this.addr, t);
}
function setValueV3iArray(e, t) {
  e.uniform3iv(this.addr, t);
}
function setValueV4iArray(e, t) {
  e.uniform4iv(this.addr, t);
}
function setValueV2fArray(e, t) {
  var r = flatten(t, this.size, 2);
  e.uniform2fv(this.addr, r);
}
function setValueV3fArray(e, t) {
  var r = flatten(t, this.size, 3);
  e.uniform3fv(this.addr, r);
}
function setValueV4fArray(e, t) {
  var r = flatten(t, this.size, 4);
  e.uniform4fv(this.addr, r);
}
function setValueM2Array(e, t) {
  var r = flatten(t, this.size, 4);
  e.uniformMatrix2fv(this.addr, !1, r);
}
function setValueM3Array(e, t) {
  var r = flatten(t, this.size, 9);
  e.uniformMatrix3fv(this.addr, !1, r);
}
function setValueM4Array(e, t) {
  var r = flatten(t, this.size, 16);
  e.uniformMatrix4fv(this.addr, !1, r);
}
function setValueT1Array(e, t, r) {
  var n = t.length, a = allocTexUnits(r, n);
  e.uniform1iv(this.addr, a);
  for (var o = 0; o !== n; ++o)
    r.safeSetTexture2D(t[o] || emptyTexture, a[o]);
}
function setValueT6Array(e, t, r) {
  var n = t.length, a = allocTexUnits(r, n);
  e.uniform1iv(this.addr, a);
  for (var o = 0; o !== n; ++o)
    r.safeSetTextureCube(t[o] || emptyCubeTexture, a[o]);
}
function getPureArraySetter(e) {
  switch (e) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
  }
}
function SingleUniform(e, t, r) {
  this.id = e, this.addr = r, this.cache = [], this.setValue = getSingularSetter(t.type);
}
function PureArrayUniform(e, t, r) {
  this.id = e, this.addr = r, this.cache = [], this.size = t.size, this.setValue = getPureArraySetter(t.type);
}
PureArrayUniform.prototype.updateCache = function(e) {
  var t = this.cache;
  e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), copyArray$1(t, e);
};
function StructuredUniform(e) {
  this.id = e, this.seq = [], this.map = {};
}
StructuredUniform.prototype.setValue = function(e, t, r) {
  for (var n = this.seq, a = 0, o = n.length; a !== o; ++a) {
    var s = n[a];
    s.setValue(e, t[s.id], r);
  }
};
var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
function addUniform(e, t) {
  e.seq.push(t), e.map[t.id] = t;
}
function parseUniform(e, t, r) {
  var n = e.name, a = n.length;
  for (RePathPart.lastIndex = 0; ; ) {
    var o = RePathPart.exec(n), s = RePathPart.lastIndex, l = o[1], c = o[2] === "]", u = o[3];
    if (c && (l = l | 0), u === void 0 || u === "[" && s + 2 === a) {
      addUniform(r, u === void 0 ? new SingleUniform(l, e, t) : new PureArrayUniform(l, e, t));
      break;
    } else {
      var h = r.map, f = h[l];
      f === void 0 && (f = new StructuredUniform(l), addUniform(r, f)), r = f;
    }
  }
}
function WebGLUniforms(e, t) {
  this.seq = [], this.map = {};
  for (var r = e.getProgramParameter(t, 35718), n = 0; n < r; ++n) {
    var a = e.getActiveUniform(t, n), o = e.getUniformLocation(t, a.name);
    parseUniform(a, o, this);
  }
}
WebGLUniforms.prototype.setValue = function(e, t, r, n) {
  var a = this.map[t];
  a !== void 0 && a.setValue(e, r, n);
};
WebGLUniforms.prototype.setOptional = function(e, t, r) {
  var n = t[r];
  n !== void 0 && this.setValue(e, r, n);
};
WebGLUniforms.upload = function(e, t, r, n) {
  for (var a = 0, o = t.length; a !== o; ++a) {
    var s = t[a], l = r[s.id];
    l.needsUpdate !== !1 && s.setValue(e, l.value, n);
  }
};
WebGLUniforms.seqWithValue = function(e, t) {
  for (var r = [], n = 0, a = e.length; n !== a; ++n) {
    var o = e[n];
    o.id in t && r.push(o);
  }
  return r;
};
function WebGLShader(e, t, r) {
  var n = e.createShader(t);
  return e.shaderSource(n, r), e.compileShader(n), n;
}
var programIdCount = 0;
function addLineNumbers(e) {
  for (var t = e.split(`
`), r = 0; r < t.length; r++)
    t[r] = r + 1 + ": " + t[r];
  return t.join(`
`);
}
function getEncodingComponents(e) {
  switch (e) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case LogLuvEncoding:
      return ["LogLuv", "( value )"];
    default:
      throw new Error("unsupported encoding: " + e);
  }
}
function getShaderErrors(e, t, r) {
  var n = e.getShaderParameter(t, 35713), a = e.getShaderInfoLog(t).trim();
  if (n && a === "") return "";
  var o = e.getShaderSource(t);
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + r + `
` + a + addLineNumbers(o);
}
function getTexelDecodingFunction(e, t) {
  var r = getEncodingComponents(t);
  return "vec4 " + e + "( vec4 value ) { return " + r[0] + "ToLinear" + r[1] + "; }";
}
function getTexelEncodingFunction(e, t) {
  var r = getEncodingComponents(t);
  return "vec4 " + e + "( vec4 value ) { return LinearTo" + r[0] + r[1] + "; }";
}
function getToneMappingFunction(e, t) {
  var r;
  switch (t) {
    case LinearToneMapping:
      r = "Linear";
      break;
    case ReinhardToneMapping:
      r = "Reinhard";
      break;
    case Uncharted2ToneMapping:
      r = "Uncharted2";
      break;
    case CineonToneMapping:
      r = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      r = "ACESFilmic";
      break;
    default:
      throw new Error("unsupported toneMapping: " + t);
  }
  return "vec3 " + e + "( vec3 color ) { return " + r + "ToneMapping( color ); }";
}
function generateExtensions(e) {
  var t = [
    e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || e.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (e.extensionShaderTextureLOD || e.envMap) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return t.filter(filterEmptyLine).join(`
`);
}
function generateDefines(e) {
  var t = [];
  for (var r in e) {
    var n = e[r];
    n !== !1 && t.push("#define " + r + " " + n);
  }
  return t.join(`
`);
}
function fetchAttributeLocations(e, t) {
  for (var r = {}, n = e.getProgramParameter(t, 35721), a = 0; a < n; a++) {
    var o = e.getActiveAttrib(t, a), s = o.name;
    r[s] = e.getAttribLocation(t, s);
  }
  return r;
}
function filterEmptyLine(e) {
  return e !== "";
}
function replaceLightNums(e, t) {
  return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
}
function replaceClippingPlaneNums(e, t) {
  return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
}
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(e) {
  return e.replace(includePattern, includeReplacer);
}
function includeReplacer(e, t) {
  var r = ShaderChunk[t];
  if (r === void 0)
    throw new Error("Can not resolve #include <" + t + ">");
  return resolveIncludes(r);
}
var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, unrollLoopPattern = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;
function unrollLoops(e) {
  return e.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(e, t, r, n) {
  return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), loopReplacer(e, t, r, n);
}
function loopReplacer(e, t, r, n) {
  for (var a = "", o = parseInt(t); o < parseInt(r); o++)
    a += n.replace(/\[ i \]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
  return a;
}
function generatePrecision(e) {
  var t = "precision " + e.precision + ` float;
precision ` + e.precision + " int;";
  return e.precision === "highp" ? t += `
#define HIGH_PRECISION` : e.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : e.precision === "lowp" && (t += `
#define LOW_PRECISION`), t;
}
function generateShadowMapTypeDefine(e) {
  var t = "SHADOWMAP_TYPE_BASIC";
  return e.shadowMapType === PCFShadowMap ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === PCFSoftShadowMap ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === VSMShadowMap && (t = "SHADOWMAP_TYPE_VSM"), t;
}
function generateEnvMapTypeDefine(e) {
  var t = "ENVMAP_TYPE_CUBE";
  if (e.envMap)
    switch (e.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        t = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        t = "ENVMAP_TYPE_CUBE_UV";
        break;
      case EquirectangularReflectionMapping:
      case EquirectangularRefractionMapping:
        t = "ENVMAP_TYPE_EQUIREC";
        break;
      case SphericalReflectionMapping:
        t = "ENVMAP_TYPE_SPHERE";
        break;
    }
  return t;
}
function generateEnvMapModeDefine(e) {
  var t = "ENVMAP_MODE_REFLECTION";
  if (e.envMap)
    switch (e.envMapMode) {
      case CubeRefractionMapping:
      case EquirectangularRefractionMapping:
        t = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return t;
}
function generateEnvMapBlendingDefine(e) {
  var t = "ENVMAP_BLENDING_NONE";
  if (e.envMap)
    switch (e.combine) {
      case MultiplyOperation:
        t = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        t = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        t = "ENVMAP_BLENDING_ADD";
        break;
    }
  return t;
}
function WebGLProgram(e, t, r) {
  var n = e.getContext(), a = r.defines, o = r.vertexShader, s = r.fragmentShader, l = generateShadowMapTypeDefine(r), c = generateEnvMapTypeDefine(r), u = generateEnvMapModeDefine(r), h = generateEnvMapBlendingDefine(r), f = e.gammaFactor > 0 ? e.gammaFactor : 1, d = r.isWebGL2 ? "" : generateExtensions(r), p = generateDefines(a), g = n.createProgram(), v, _;
  if (r.isRawShaderMaterial ? (v = [
    p
  ].filter(filterEmptyLine).join(`
`), v.length > 0 && (v += `
`), _ = [
    d,
    p
  ].filter(filterEmptyLine).join(`
`), _.length > 0 && (_ += `
`)) : (v = [
    generatePrecision(r),
    "#define SHADER_NAME " + r.shaderName,
    p,
    r.instancing ? "#define USE_INSTANCING" : "",
    r.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
    "#define GAMMA_FACTOR " + f,
    "#define MAX_BONES " + r.maxBones,
    r.useFog && r.fog ? "#define USE_FOG" : "",
    r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "",
    r.map ? "#define USE_MAP" : "",
    r.envMap ? "#define USE_ENVMAP" : "",
    r.envMap ? "#define " + u : "",
    r.lightMap ? "#define USE_LIGHTMAP" : "",
    r.aoMap ? "#define USE_AOMAP" : "",
    r.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    r.bumpMap ? "#define USE_BUMPMAP" : "",
    r.normalMap ? "#define USE_NORMALMAP" : "",
    r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    r.displacementMap && r.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
    r.specularMap ? "#define USE_SPECULARMAP" : "",
    r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    r.metalnessMap ? "#define USE_METALNESSMAP" : "",
    r.alphaMap ? "#define USE_ALPHAMAP" : "",
    r.vertexTangents ? "#define USE_TANGENT" : "",
    r.vertexColors ? "#define USE_COLOR" : "",
    r.vertexUvs ? "#define USE_UV" : "",
    r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    r.flatShading ? "#define FLAT_SHADED" : "",
    r.skinning ? "#define USE_SKINNING" : "",
    r.useVertexTexture ? "#define BONE_TEXTURE" : "",
    r.morphTargets ? "#define USE_MORPHTARGETS" : "",
    r.morphNormals && r.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    r.doubleSided ? "#define DOUBLE_SIDED" : "",
    r.flipSided ? "#define FLIP_SIDED" : "",
    r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    r.shadowMapEnabled ? "#define " + l : "",
    r.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    " attribute mat4 instanceMatrix;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#ifdef USE_COLOR",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_MORPHTARGETS",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(filterEmptyLine).join(`
`), _ = [
    d,
    generatePrecision(r),
    "#define SHADER_NAME " + r.shaderName,
    p,
    r.alphaTest ? "#define ALPHATEST " + r.alphaTest + (r.alphaTest % 1 ? "" : ".0") : "",
    // add '.0' if integer
    "#define GAMMA_FACTOR " + f,
    r.useFog && r.fog ? "#define USE_FOG" : "",
    r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "",
    r.map ? "#define USE_MAP" : "",
    r.matcap ? "#define USE_MATCAP" : "",
    r.envMap ? "#define USE_ENVMAP" : "",
    r.envMap ? "#define " + c : "",
    r.envMap ? "#define " + u : "",
    r.envMap ? "#define " + h : "",
    r.lightMap ? "#define USE_LIGHTMAP" : "",
    r.aoMap ? "#define USE_AOMAP" : "",
    r.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    r.bumpMap ? "#define USE_BUMPMAP" : "",
    r.normalMap ? "#define USE_NORMALMAP" : "",
    r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    r.specularMap ? "#define USE_SPECULARMAP" : "",
    r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    r.metalnessMap ? "#define USE_METALNESSMAP" : "",
    r.alphaMap ? "#define USE_ALPHAMAP" : "",
    r.sheen ? "#define USE_SHEEN" : "",
    r.vertexTangents ? "#define USE_TANGENT" : "",
    r.vertexColors ? "#define USE_COLOR" : "",
    r.vertexUvs ? "#define USE_UV" : "",
    r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    r.gradientMap ? "#define USE_GRADIENTMAP" : "",
    r.flatShading ? "#define FLAT_SHADED" : "",
    r.doubleSided ? "#define DOUBLE_SIDED" : "",
    r.flipSided ? "#define FLIP_SIDED" : "",
    r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    r.shadowMapEnabled ? "#define " + l : "",
    r.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    r.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
    r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    (r.extensionShaderTextureLOD || r.envMap) && r.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    r.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
    r.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    r.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", r.toneMapping) : "",
    r.dithering ? "#define DITHERING" : "",
    r.outputEncoding || r.mapEncoding || r.matcapEncoding || r.envMapEncoding || r.emissiveMapEncoding || r.lightMapEncoding ? ShaderChunk.encodings_pars_fragment : "",
    // this code is required here because it is used by the various encoding/decoding function defined below
    r.mapEncoding ? getTexelDecodingFunction("mapTexelToLinear", r.mapEncoding) : "",
    r.matcapEncoding ? getTexelDecodingFunction("matcapTexelToLinear", r.matcapEncoding) : "",
    r.envMapEncoding ? getTexelDecodingFunction("envMapTexelToLinear", r.envMapEncoding) : "",
    r.emissiveMapEncoding ? getTexelDecodingFunction("emissiveMapTexelToLinear", r.emissiveMapEncoding) : "",
    r.lightMapEncoding ? getTexelDecodingFunction("lightMapTexelToLinear", r.lightMapEncoding) : "",
    r.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", r.outputEncoding) : "",
    r.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "",
    `
`
  ].filter(filterEmptyLine).join(`
`)), o = resolveIncludes(o), o = replaceLightNums(o, r), o = replaceClippingPlaneNums(o, r), s = resolveIncludes(s), s = replaceLightNums(s, r), s = replaceClippingPlaneNums(s, r), o = unrollLoops(o), s = unrollLoops(s), r.isWebGL2 && !r.isRawShaderMaterial) {
    var m = !1, y = /^\s*#version\s+300\s+es\s*\n/;
    r.isShaderMaterial && o.match(y) !== null && s.match(y) !== null && (m = !0, o = o.replace(y, ""), s = s.replace(y, "")), v = [
      `#version 300 es
`,
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join(`
`) + `
` + v, _ = [
      `#version 300 es
`,
      "#define varying in",
      m ? "" : "out highp vec4 pc_fragColor;",
      m ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join(`
`) + `
` + _;
  }
  var b = v + o, M = _ + s, x = WebGLShader(n, 35633, b), w = WebGLShader(n, 35632, M);
  if (n.attachShader(g, x), n.attachShader(g, w), r.index0AttributeName !== void 0 ? n.bindAttribLocation(g, 0, r.index0AttributeName) : r.morphTargets === !0 && n.bindAttribLocation(g, 0, "position"), n.linkProgram(g), e.debug.checkShaderErrors) {
    var P = n.getProgramInfoLog(g).trim(), V = n.getShaderInfoLog(x).trim(), I = n.getShaderInfoLog(w).trim(), $ = !0, E = !0;
    if (n.getProgramParameter(g, 35714) === !1) {
      $ = !1;
      var G = getShaderErrors(n, x, "vertex"), O = getShaderErrors(n, w, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", n.getError(), "35715", n.getProgramParameter(g, 35715), "gl.getProgramInfoLog", P, G, O);
    } else P !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", P) : (V === "" || I === "") && (E = !1);
    E && (this.diagnostics = {
      runnable: $,
      programLog: P,
      vertexShader: {
        log: V,
        prefix: v
      },
      fragmentShader: {
        log: I,
        prefix: _
      }
    });
  }
  n.deleteShader(x), n.deleteShader(w);
  var W;
  this.getUniforms = function() {
    return W === void 0 && (W = new WebGLUniforms(n, g)), W;
  };
  var B;
  return this.getAttributes = function() {
    return B === void 0 && (B = fetchAttributeLocations(n, g)), B;
  }, this.destroy = function() {
    n.deleteProgram(g), this.program = void 0;
  }, this.name = r.shaderName, this.id = programIdCount++, this.cacheKey = t, this.usedTimes = 1, this.program = g, this.vertexShader = x, this.fragmentShader = w, this;
}
function WebGLPrograms(e, t, r) {
  var n = [], a = r.isWebGL2, o = r.logarithmicDepthBuffer, s = r.floatVertexTextures, l = r.precision, c = r.maxVertexUniforms, u = r.vertexTextures, h = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  }, f = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "maxMorphTargets",
    "maxMorphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "sheen"
  ];
  function d(v, _) {
    var m;
    if (_) {
      var y = ShaderLib[_];
      m = {
        name: v.type,
        uniforms: UniformsUtils.clone(y.uniforms),
        vertexShader: y.vertexShader,
        fragmentShader: y.fragmentShader
      };
    } else
      m = {
        name: v.type,
        uniforms: v.uniforms,
        vertexShader: v.vertexShader,
        fragmentShader: v.fragmentShader
      };
    return m;
  }
  function p(v) {
    var _ = v.skeleton, m = _.bones;
    if (s)
      return 1024;
    var y = c, b = Math.floor((y - 20) / 4), M = Math.min(b, m.length);
    return M < m.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + m.length + " bones. This GPU supports " + M + "."), 0) : M;
  }
  function g(v) {
    var _;
    return v ? v.isTexture ? _ = v.encoding : v.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), _ = v.texture.encoding) : _ = LinearEncoding, _;
  }
  this.getParameters = function(v, _, m, y, b, M, x) {
    var w = y.fog, P = v.isMeshStandardMaterial ? y.environment : null, V = v.envMap || P, I = h[v.type], $ = x.isSkinnedMesh ? p(x) : 0;
    v.precision !== null && (l = r.getMaxPrecision(v.precision), l !== v.precision && console.warn("THREE.WebGLProgram.getParameters:", v.precision, "not supported, using", l, "instead."));
    var E = d(v, I);
    v.onBeforeCompile(E, e);
    var G = e.getRenderTarget(), O = {
      isWebGL2: a,
      shaderID: I,
      shaderName: E.name,
      uniforms: E.uniforms,
      vertexShader: E.vertexShader,
      fragmentShader: E.fragmentShader,
      defines: v.defines,
      isRawShaderMaterial: v.isRawShaderMaterial,
      isShaderMaterial: v.isShaderMaterial,
      precision: l,
      instancing: x.isInstancedMesh === !0,
      supportsVertexTextures: u,
      outputEncoding: G !== null ? g(G.texture) : e.outputEncoding,
      map: !!v.map,
      mapEncoding: g(v.map),
      matcap: !!v.matcap,
      matcapEncoding: g(v.matcap),
      envMap: !!V,
      envMapMode: V && V.mapping,
      envMapEncoding: g(V),
      envMapCubeUV: !!V && (V.mapping === CubeUVReflectionMapping || V.mapping === CubeUVRefractionMapping),
      lightMap: !!v.lightMap,
      lightMapEncoding: g(v.lightMap),
      aoMap: !!v.aoMap,
      emissiveMap: !!v.emissiveMap,
      emissiveMapEncoding: g(v.emissiveMap),
      bumpMap: !!v.bumpMap,
      normalMap: !!v.normalMap,
      objectSpaceNormalMap: v.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: v.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!v.clearcoatMap,
      clearcoatRoughnessMap: !!v.clearcoatRoughnessMap,
      clearcoatNormalMap: !!v.clearcoatNormalMap,
      displacementMap: !!v.displacementMap,
      roughnessMap: !!v.roughnessMap,
      metalnessMap: !!v.metalnessMap,
      specularMap: !!v.specularMap,
      alphaMap: !!v.alphaMap,
      gradientMap: !!v.gradientMap,
      sheen: !!v.sheen,
      combine: v.combine,
      vertexTangents: v.normalMap && v.vertexTangents,
      vertexColors: v.vertexColors,
      vertexUvs: !!v.map || !!v.bumpMap || !!v.normalMap || !!v.specularMap || !!v.alphaMap || !!v.emissiveMap || !!v.roughnessMap || !!v.metalnessMap || !!v.clearcoatMap || !!v.clearcoatRoughnessMap || !!v.clearcoatNormalMap || !!v.displacementMap,
      uvsVertexOnly: !(v.map || v.bumpMap || v.normalMap || v.specularMap || v.alphaMap || v.emissiveMap || v.roughnessMap || v.metalnessMap || v.clearcoatNormalMap) && !!v.displacementMap,
      fog: !!w,
      useFog: v.fog,
      fogExp2: w && w.isFogExp2,
      flatShading: v.flatShading,
      sizeAttenuation: v.sizeAttenuation,
      logarithmicDepthBuffer: o,
      skinning: v.skinning && $ > 0,
      maxBones: $,
      useVertexTexture: s,
      morphTargets: v.morphTargets,
      morphNormals: v.morphNormals,
      maxMorphTargets: e.maxMorphTargets,
      maxMorphNormals: e.maxMorphNormals,
      numDirLights: _.directional.length,
      numPointLights: _.point.length,
      numSpotLights: _.spot.length,
      numRectAreaLights: _.rectArea.length,
      numHemiLights: _.hemi.length,
      numDirLightShadows: _.directionalShadowMap.length,
      numPointLightShadows: _.pointShadowMap.length,
      numSpotLightShadows: _.spotShadowMap.length,
      numClippingPlanes: b,
      numClipIntersection: M,
      dithering: v.dithering,
      shadowMapEnabled: e.shadowMap.enabled && m.length > 0,
      shadowMapType: e.shadowMap.type,
      toneMapping: v.toneMapped ? e.toneMapping : NoToneMapping,
      physicallyCorrectLights: e.physicallyCorrectLights,
      premultipliedAlpha: v.premultipliedAlpha,
      alphaTest: v.alphaTest,
      doubleSided: v.side === DoubleSide,
      flipSided: v.side === BackSide,
      depthPacking: v.depthPacking !== void 0 ? v.depthPacking : !1,
      index0AttributeName: v.index0AttributeName,
      extensionDerivatives: v.extensions && v.extensions.derivatives,
      extensionFragDepth: v.extensions && v.extensions.fragDepth,
      extensionDrawBuffers: v.extensions && v.extensions.drawBuffers,
      extensionShaderTextureLOD: v.extensions && v.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: a || t.get("EXT_frag_depth") !== null,
      rendererExtensionDrawBuffers: a || t.get("WEBGL_draw_buffers") !== null,
      rendererExtensionShaderTextureLod: a || t.get("EXT_shader_texture_lod") !== null,
      onBeforeCompile: v.onBeforeCompile
    };
    return O;
  }, this.getProgramCacheKey = function(v) {
    var _ = [];
    if (v.shaderID ? _.push(v.shaderID) : (_.push(v.fragmentShader), _.push(v.vertexShader)), v.defines !== void 0)
      for (var m in v.defines)
        _.push(m), _.push(v.defines[m]);
    if (v.isRawShaderMaterial === void 0) {
      for (var y = 0; y < f.length; y++)
        _.push(v[f[y]]);
      _.push(e.outputEncoding), _.push(e.gammaFactor);
    }
    return _.push(v.onBeforeCompile.toString()), _.join();
  }, this.acquireProgram = function(v, _) {
    for (var m, y = 0, b = n.length; y < b; y++) {
      var M = n[y];
      if (M.cacheKey === _) {
        m = M, ++m.usedTimes;
        break;
      }
    }
    return m === void 0 && (m = new WebGLProgram(e, _, v), n.push(m)), m;
  }, this.releaseProgram = function(v) {
    if (--v.usedTimes === 0) {
      var _ = n.indexOf(v);
      n[_] = n[n.length - 1], n.pop(), v.destroy();
    }
  }, this.programs = n;
}
function WebGLProperties() {
  var e = /* @__PURE__ */ new WeakMap();
  function t(o) {
    var s = e.get(o);
    return s === void 0 && (s = {}, e.set(o, s)), s;
  }
  function r(o) {
    e.delete(o);
  }
  function n(o, s, l) {
    e.get(o)[s] = l;
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    remove: r,
    update: n,
    dispose: a
  };
}
function painterSortStable(e, t) {
  return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id;
}
function reversePainterSortStable(e, t) {
  return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id;
}
function WebGLRenderList() {
  var e = [], t = 0, r = [], n = [], a = { id: -1 };
  function o() {
    t = 0, r.length = 0, n.length = 0;
  }
  function s(f, d, p, g, v, _) {
    var m = e[t];
    return m === void 0 ? (m = {
      id: f.id,
      object: f,
      geometry: d,
      material: p,
      program: p.program || a,
      groupOrder: g,
      renderOrder: f.renderOrder,
      z: v,
      group: _
    }, e[t] = m) : (m.id = f.id, m.object = f, m.geometry = d, m.material = p, m.program = p.program || a, m.groupOrder = g, m.renderOrder = f.renderOrder, m.z = v, m.group = _), t++, m;
  }
  function l(f, d, p, g, v, _) {
    var m = s(f, d, p, g, v, _);
    (p.transparent === !0 ? n : r).push(m);
  }
  function c(f, d, p, g, v, _) {
    var m = s(f, d, p, g, v, _);
    (p.transparent === !0 ? n : r).unshift(m);
  }
  function u(f, d) {
    r.length > 1 && r.sort(f || painterSortStable), n.length > 1 && n.sort(d || reversePainterSortStable);
  }
  function h() {
    for (var f = t, d = e.length; f < d; f++) {
      var p = e[f];
      if (p.id === null) break;
      p.id = null, p.object = null, p.geometry = null, p.material = null, p.program = null, p.group = null;
    }
  }
  return {
    opaque: r,
    transparent: n,
    init: o,
    push: l,
    unshift: c,
    finish: h,
    sort: u
  };
}
function WebGLRenderLists() {
  var e = /* @__PURE__ */ new WeakMap();
  function t(a) {
    var o = a.target;
    o.removeEventListener("dispose", t), e.delete(o);
  }
  function r(a, o) {
    var s = e.get(a), l;
    return s === void 0 ? (l = new WebGLRenderList(), e.set(a, /* @__PURE__ */ new WeakMap()), e.get(a).set(o, l), a.addEventListener("dispose", t)) : (l = s.get(o), l === void 0 && (l = new WebGLRenderList(), s.set(o, l))), l;
  }
  function n() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: r,
    dispose: n
  };
}
function UniformsCache() {
  var e = {};
  return {
    get: function(t) {
      if (e[t.id] !== void 0)
        return e[t.id];
      var r;
      switch (t.type) {
        case "DirectionalLight":
          r = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          r = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          r = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          r = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          r = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      return e[t.id] = r, r;
    }
  };
}
function ShadowUniformsCache() {
  var e = {};
  return {
    get: function(t) {
      if (e[t.id] !== void 0)
        return e[t.id];
      var r;
      switch (t.type) {
        case "DirectionalLight":
          r = {
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          r = {
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          r = {
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return e[t.id] = r, r;
    }
  };
}
var nextVersion = 0;
function shadowCastingLightsFirst(e, t) {
  return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0);
}
function WebGLLights() {
  for (var e = new UniformsCache(), t = ShadowUniformsCache(), r = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  }, n = 0; n < 9; n++) r.probe.push(new Vector3());
  var a = new Vector3(), o = new Matrix4(), s = new Matrix4();
  function l(c, u, h) {
    for (var f = 0, d = 0, p = 0, g = 0; g < 9; g++) r.probe[g].set(0, 0, 0);
    var v = 0, _ = 0, m = 0, y = 0, b = 0, M = 0, x = 0, w = 0, P = h.matrixWorldInverse;
    c.sort(shadowCastingLightsFirst);
    for (var g = 0, V = c.length; g < V; g++) {
      var I = c[g], $ = I.color, E = I.intensity, G = I.distance, O = I.shadow && I.shadow.map ? I.shadow.map.texture : null;
      if (I.isAmbientLight)
        f += $.r * E, d += $.g * E, p += $.b * E;
      else if (I.isLightProbe)
        for (var W = 0; W < 9; W++)
          r.probe[W].addScaledVector(I.sh.coefficients[W], E);
      else if (I.isDirectionalLight) {
        var B = e.get(I);
        if (B.color.copy(I.color).multiplyScalar(I.intensity), B.direction.setFromMatrixPosition(I.matrixWorld), a.setFromMatrixPosition(I.target.matrixWorld), B.direction.sub(a), B.direction.transformDirection(P), I.castShadow) {
          var q = I.shadow, te = t.get(I);
          te.shadowBias = q.bias, te.shadowRadius = q.radius, te.shadowMapSize = q.mapSize, r.directionalShadow[v] = te, r.directionalShadowMap[v] = O, r.directionalShadowMatrix[v] = I.shadow.matrix, M++;
        }
        r.directional[v] = B, v++;
      } else if (I.isSpotLight) {
        var B = e.get(I);
        if (B.position.setFromMatrixPosition(I.matrixWorld), B.position.applyMatrix4(P), B.color.copy($).multiplyScalar(E), B.distance = G, B.direction.setFromMatrixPosition(I.matrixWorld), a.setFromMatrixPosition(I.target.matrixWorld), B.direction.sub(a), B.direction.transformDirection(P), B.coneCos = Math.cos(I.angle), B.penumbraCos = Math.cos(I.angle * (1 - I.penumbra)), B.decay = I.decay, I.castShadow) {
          var q = I.shadow, te = t.get(I);
          te.shadowBias = q.bias, te.shadowRadius = q.radius, te.shadowMapSize = q.mapSize, r.spotShadow[m] = te, r.spotShadowMap[m] = O, r.spotShadowMatrix[m] = I.shadow.matrix, w++;
        }
        r.spot[m] = B, m++;
      } else if (I.isRectAreaLight) {
        var B = e.get(I);
        B.color.copy($).multiplyScalar(E), B.position.setFromMatrixPosition(I.matrixWorld), B.position.applyMatrix4(P), s.identity(), o.copy(I.matrixWorld), o.premultiply(P), s.extractRotation(o), B.halfWidth.set(I.width * 0.5, 0, 0), B.halfHeight.set(0, I.height * 0.5, 0), B.halfWidth.applyMatrix4(s), B.halfHeight.applyMatrix4(s), r.rectArea[y] = B, y++;
      } else if (I.isPointLight) {
        var B = e.get(I);
        if (B.position.setFromMatrixPosition(I.matrixWorld), B.position.applyMatrix4(P), B.color.copy(I.color).multiplyScalar(I.intensity), B.distance = I.distance, B.decay = I.decay, I.castShadow) {
          var q = I.shadow, te = t.get(I);
          te.shadowBias = q.bias, te.shadowRadius = q.radius, te.shadowMapSize = q.mapSize, te.shadowCameraNear = q.camera.near, te.shadowCameraFar = q.camera.far, r.pointShadow[_] = te, r.pointShadowMap[_] = O, r.pointShadowMatrix[_] = I.shadow.matrix, x++;
        }
        r.point[_] = B, _++;
      } else if (I.isHemisphereLight) {
        var B = e.get(I);
        B.direction.setFromMatrixPosition(I.matrixWorld), B.direction.transformDirection(P), B.direction.normalize(), B.skyColor.copy(I.color).multiplyScalar(E), B.groundColor.copy(I.groundColor).multiplyScalar(E), r.hemi[b] = B, b++;
      }
    }
    r.ambient[0] = f, r.ambient[1] = d, r.ambient[2] = p;
    var ne = r.hash;
    (ne.directionalLength !== v || ne.pointLength !== _ || ne.spotLength !== m || ne.rectAreaLength !== y || ne.hemiLength !== b || ne.numDirectionalShadows !== M || ne.numPointShadows !== x || ne.numSpotShadows !== w) && (r.directional.length = v, r.spot.length = m, r.rectArea.length = y, r.point.length = _, r.hemi.length = b, r.directionalShadow.length = M, r.directionalShadowMap.length = M, r.pointShadow.length = x, r.pointShadowMap.length = x, r.spotShadow.length = w, r.spotShadowMap.length = w, r.directionalShadowMatrix.length = M, r.pointShadowMatrix.length = x, r.spotShadowMatrix.length = w, ne.directionalLength = v, ne.pointLength = _, ne.spotLength = m, ne.rectAreaLength = y, ne.hemiLength = b, ne.numDirectionalShadows = M, ne.numPointShadows = x, ne.numSpotShadows = w, r.version = nextVersion++);
  }
  return {
    setup: l,
    state: r
  };
}
function WebGLRenderState() {
  var e = new WebGLLights(), t = [], r = [];
  function n() {
    t.length = 0, r.length = 0;
  }
  function a(c) {
    t.push(c);
  }
  function o(c) {
    r.push(c);
  }
  function s(c) {
    e.setup(t, r, c);
  }
  var l = {
    lightsArray: t,
    shadowsArray: r,
    lights: e
  };
  return {
    init: n,
    state: l,
    setupLights: s,
    pushLight: a,
    pushShadow: o
  };
}
function WebGLRenderStates() {
  var e = /* @__PURE__ */ new WeakMap();
  function t(a) {
    var o = a.target;
    o.removeEventListener("dispose", t), e.delete(o);
  }
  function r(a, o) {
    var s;
    return e.has(a) === !1 ? (s = new WebGLRenderState(), e.set(a, /* @__PURE__ */ new WeakMap()), e.get(a).set(o, s), a.addEventListener("dispose", t)) : e.get(a).has(o) === !1 ? (s = new WebGLRenderState(), e.get(a).set(o, s)) : s = e.get(a).get(o), s;
  }
  function n() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: r,
    dispose: n
  };
}
function MeshDepthMaterial(e) {
  Material.call(this), this.type = "MeshDepthMaterial", this.depthPacking = BasicDepthPacking, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e);
}
MeshDepthMaterial.prototype = Object.create(Material.prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = !0;
MeshDepthMaterial.prototype.copy = function(e) {
  return Material.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
};
function MeshDistanceMaterial(e) {
  Material.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Vector3(), this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e);
}
MeshDistanceMaterial.prototype = Object.create(Material.prototype);
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = !0;
MeshDistanceMaterial.prototype.copy = function(e) {
  return Material.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
};
var vsm_frag = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
  float mean = 0.0;
  float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );
  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
    #ifdef HORIZONAL_PASS
      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
      mean += distribution.x;
      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
    #else
      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );
      mean += depth;
      squared_mean += depth * depth;
    #endif
  }
  mean = mean * HALF_SAMPLE_RATE;
  squared_mean = squared_mean * HALF_SAMPLE_RATE;
  float std_dev = sqrt( squared_mean - mean * mean );
  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`, vsm_vert = `void main() {
	gl_Position = vec4( position, 1.0 );
}`;
function WebGLShadowMap(e, t, r) {
  var n = new Frustum(), a = new Vector2(), o = new Vector2(), s = new Vector4(), l = [], c = [], u = {}, h = { 0: BackSide, 1: FrontSide, 2: DoubleSide }, f = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  }), d = f.clone();
  d.defines.HORIZONAL_PASS = 1;
  var p = new BufferGeometry();
  p.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  var g = new Mesh(p, f), v = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = PCFShadowMap, this.render = function(x, w, P) {
    if (v.enabled !== !1 && !(v.autoUpdate === !1 && v.needsUpdate === !1) && x.length !== 0) {
      var V = e.getRenderTarget(), I = e.getActiveCubeFace(), $ = e.getActiveMipmapLevel(), E = e.state;
      E.setBlending(NoBlending), E.buffers.color.setClear(1, 1, 1, 1), E.buffers.depth.setTest(!0), E.setScissorTest(!1);
      for (var G = 0, O = x.length; G < O; G++) {
        var W = x[G], B = W.shadow;
        if (B === void 0) {
          console.warn("THREE.WebGLShadowMap:", W, "has no shadow.");
          continue;
        }
        a.copy(B.mapSize);
        var q = B.getFrameExtents();
        if (a.multiply(q), o.copy(B.mapSize), (a.x > r || a.y > r) && (a.x > r && (o.x = Math.floor(r / q.x), a.x = o.x * q.x, B.mapSize.x = o.x), a.y > r && (o.y = Math.floor(r / q.y), a.y = o.y * q.y, B.mapSize.y = o.y)), B.map === null && !B.isPointLightShadow && this.type === VSMShadowMap) {
          var te = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
          B.map = new WebGLRenderTarget(a.x, a.y, te), B.map.texture.name = W.name + ".shadowMap", B.mapPass = new WebGLRenderTarget(a.x, a.y, te), B.camera.updateProjectionMatrix();
        }
        if (B.map === null) {
          var te = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
          B.map = new WebGLRenderTarget(a.x, a.y, te), B.map.texture.name = W.name + ".shadowMap", B.camera.updateProjectionMatrix();
        }
        e.setRenderTarget(B.map), e.clear();
        for (var ne = B.getViewportCount(), Q = 0; Q < ne; Q++) {
          var ae = B.getViewport(Q);
          s.set(
            o.x * ae.x,
            o.y * ae.y,
            o.x * ae.z,
            o.y * ae.w
          ), E.viewport(s), B.updateMatrices(W, Q), n = B.getFrustum(), M(w, P, B.camera, W, this.type);
        }
        !B.isPointLightShadow && this.type === VSMShadowMap && _(B, P);
      }
      v.needsUpdate = !1, e.setRenderTarget(V, I, $);
    }
  };
  function _(x, w) {
    var P = t.update(g);
    f.uniforms.shadow_pass.value = x.map.texture, f.uniforms.resolution.value = x.mapSize, f.uniforms.radius.value = x.radius, e.setRenderTarget(x.mapPass), e.clear(), e.renderBufferDirect(w, null, P, f, g, null), d.uniforms.shadow_pass.value = x.mapPass.texture, d.uniforms.resolution.value = x.mapSize, d.uniforms.radius.value = x.radius, e.setRenderTarget(x.map), e.clear(), e.renderBufferDirect(w, null, P, d, g, null);
  }
  function m(x, w, P) {
    var V = x << 0 | w << 1 | P << 2, I = l[V];
    return I === void 0 && (I = new MeshDepthMaterial({
      depthPacking: RGBADepthPacking,
      morphTargets: x,
      skinning: w
    }), l[V] = I), I;
  }
  function y(x, w, P) {
    var V = x << 0 | w << 1 | P << 2, I = c[V];
    return I === void 0 && (I = new MeshDistanceMaterial({
      morphTargets: x,
      skinning: w
    }), c[V] = I), I;
  }
  function b(x, w, P, V, I, $, E) {
    var G = null, O = m, W = x.customDepthMaterial;
    if (V.isPointLight === !0 && (O = y, W = x.customDistanceMaterial), W === void 0) {
      var B = !1;
      P.morphTargets === !0 && (B = w.morphAttributes && w.morphAttributes.position && w.morphAttributes.position.length > 0);
      var q = !1;
      x.isSkinnedMesh === !0 && (P.skinning === !0 ? q = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", x));
      var te = x.isInstancedMesh === !0;
      G = O(B, q, te);
    } else
      G = W;
    if (e.localClippingEnabled && P.clipShadows === !0 && P.clippingPlanes.length !== 0) {
      var ne = G.uuid, Q = P.uuid, ae = u[ne];
      ae === void 0 && (ae = {}, u[ne] = ae);
      var oe = ae[Q];
      oe === void 0 && (oe = G.clone(), ae[Q] = oe), G = oe;
    }
    return G.visible = P.visible, G.wireframe = P.wireframe, E === VSMShadowMap ? G.side = P.shadowSide !== null ? P.shadowSide : P.side : G.side = P.shadowSide !== null ? P.shadowSide : h[P.side], G.clipShadows = P.clipShadows, G.clippingPlanes = P.clippingPlanes, G.clipIntersection = P.clipIntersection, G.wireframeLinewidth = P.wireframeLinewidth, G.linewidth = P.linewidth, V.isPointLight === !0 && G.isMeshDistanceMaterial === !0 && (G.referencePosition.setFromMatrixPosition(V.matrixWorld), G.nearDistance = I, G.farDistance = $), G;
  }
  function M(x, w, P, V, I) {
    if (x.visible !== !1) {
      var $ = x.layers.test(w.layers);
      if ($ && (x.isMesh || x.isLine || x.isPoints) && (x.castShadow || x.receiveShadow && I === VSMShadowMap) && (!x.frustumCulled || n.intersectsObject(x))) {
        x.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, x.matrixWorld);
        var E = t.update(x), G = x.material;
        if (Array.isArray(G))
          for (var O = E.groups, W = 0, B = O.length; W < B; W++) {
            var q = O[W], te = G[q.materialIndex];
            if (te && te.visible) {
              var ne = b(x, E, te, V, P.near, P.far, I);
              e.renderBufferDirect(P, null, E, ne, x, q);
            }
          }
        else if (G.visible) {
          var ne = b(x, E, G, V, P.near, P.far, I);
          e.renderBufferDirect(P, null, E, ne, x, null);
        }
      }
      for (var Q = x.children, ae = 0, oe = Q.length; ae < oe; ae++)
        M(Q[ae], w, P, V, I);
    }
  }
}
function WebGLState(e, t, r) {
  var n = r.isWebGL2;
  function a() {
    var k = !1, pe = new Vector4(), me = null, Ce = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(ge) {
        me !== ge && !k && (e.colorMask(ge, ge, ge, ge), me = ge);
      },
      setLocked: function(ge) {
        k = ge;
      },
      setClear: function(ge, Re, De, Oe, He) {
        He === !0 && (ge *= Oe, Re *= Oe, De *= Oe), pe.set(ge, Re, De, Oe), Ce.equals(pe) === !1 && (e.clearColor(ge, Re, De, Oe), Ce.copy(pe));
      },
      reset: function() {
        k = !1, me = null, Ce.set(-1, 0, 0, 0);
      }
    };
  }
  function o() {
    var k = !1, pe = null, me = null, Ce = null;
    return {
      setTest: function(ge) {
        ge ? N(2929) : F(2929);
      },
      setMask: function(ge) {
        pe !== ge && !k && (e.depthMask(ge), pe = ge);
      },
      setFunc: function(ge) {
        if (me !== ge) {
          if (ge)
            switch (ge) {
              case NeverDepth:
                e.depthFunc(512);
                break;
              case AlwaysDepth:
                e.depthFunc(519);
                break;
              case LessDepth:
                e.depthFunc(513);
                break;
              case LessEqualDepth:
                e.depthFunc(515);
                break;
              case EqualDepth:
                e.depthFunc(514);
                break;
              case GreaterEqualDepth:
                e.depthFunc(518);
                break;
              case GreaterDepth:
                e.depthFunc(516);
                break;
              case NotEqualDepth:
                e.depthFunc(517);
                break;
              default:
                e.depthFunc(515);
            }
          else
            e.depthFunc(515);
          me = ge;
        }
      },
      setLocked: function(ge) {
        k = ge;
      },
      setClear: function(ge) {
        Ce !== ge && (e.clearDepth(ge), Ce = ge);
      },
      reset: function() {
        k = !1, pe = null, me = null, Ce = null;
      }
    };
  }
  function s() {
    var k = !1, pe = null, me = null, Ce = null, ge = null, Re = null, De = null, Oe = null, He = null;
    return {
      setTest: function(Pe) {
        k || (Pe ? N(2960) : F(2960));
      },
      setMask: function(Pe) {
        pe !== Pe && !k && (e.stencilMask(Pe), pe = Pe);
      },
      setFunc: function(Pe, Ne, Ve) {
        (me !== Pe || Ce !== Ne || ge !== Ve) && (e.stencilFunc(Pe, Ne, Ve), me = Pe, Ce = Ne, ge = Ve);
      },
      setOp: function(Pe, Ne, Ve) {
        (Re !== Pe || De !== Ne || Oe !== Ve) && (e.stencilOp(Pe, Ne, Ve), Re = Pe, De = Ne, Oe = Ve);
      },
      setLocked: function(Pe) {
        k = Pe;
      },
      setClear: function(Pe) {
        He !== Pe && (e.clearStencil(Pe), He = Pe);
      },
      reset: function() {
        k = !1, pe = null, me = null, Ce = null, ge = null, Re = null, De = null, Oe = null, He = null;
      }
    };
  }
  var l = new a(), c = new o(), u = new s(), h = e.getParameter(34921), f = new Uint8Array(h), d = new Uint8Array(h), p = new Uint8Array(h), g = {}, v = null, _ = null, m = null, y = null, b = null, M = null, x = null, w = null, P = null, V = !1, I = null, $ = null, E = null, G = null, O = null, W = e.getParameter(35661), B = !1, q = 0, te = e.getParameter(7938);
  te.indexOf("WebGL") !== -1 ? (q = parseFloat(/^WebGL\ ([0-9])/.exec(te)[1]), B = q >= 1) : te.indexOf("OpenGL ES") !== -1 && (q = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(te)[1]), B = q >= 2);
  var ne = null, Q = {}, ae = new Vector4(), oe = new Vector4();
  function _e(k, pe, me) {
    var Ce = new Uint8Array(4), ge = e.createTexture();
    e.bindTexture(k, ge), e.texParameteri(k, 10241, 9728), e.texParameteri(k, 10240, 9728);
    for (var Re = 0; Re < me; Re++)
      e.texImage2D(pe + Re, 0, 6408, 1, 1, 0, 6408, 5121, Ce);
    return ge;
  }
  var A = {};
  A[3553] = _e(3553, 3553, 1), A[34067] = _e(34067, 34069, 6), l.setClear(0, 0, 0, 1), c.setClear(1), u.setClear(0), N(2929), c.setFunc(LessEqualDepth), T(!1), C(CullFaceBack), N(2884), re(NoBlending);
  function L() {
    for (var k = 0, pe = f.length; k < pe; k++)
      f[k] = 0;
  }
  function D(k) {
    S(k, 0);
  }
  function S(k, pe) {
    if (f[k] = 1, d[k] === 0 && (e.enableVertexAttribArray(k), d[k] = 1), p[k] !== pe) {
      var me = n ? e : t.get("ANGLE_instanced_arrays");
      me[n ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](k, pe), p[k] = pe;
    }
  }
  function H() {
    for (var k = 0, pe = d.length; k !== pe; ++k)
      d[k] !== f[k] && (e.disableVertexAttribArray(k), d[k] = 0);
  }
  function z(k, pe, me, Ce, ge, Re) {
    n === !0 && (me === 5124 || me === 5125) ? e.vertexAttribIPointer(k, pe, me, Ce, ge, Re) : e.vertexAttribPointer(k, pe, me, Ce, ge, Re);
  }
  function N(k) {
    g[k] !== !0 && (e.enable(k), g[k] = !0);
  }
  function F(k) {
    g[k] !== !1 && (e.disable(k), g[k] = !1);
  }
  function U(k) {
    return v !== k ? (e.useProgram(k), v = k, !0) : !1;
  }
  var j = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (n)
    j[MinEquation] = 32775, j[MaxEquation] = 32776;
  else {
    var K = t.get("EXT_blend_minmax");
    K !== null && (j[MinEquation] = K.MIN_EXT, j[MaxEquation] = K.MAX_EXT);
  }
  var Y = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function re(k, pe, me, Ce, ge, Re, De, Oe) {
    if (k === NoBlending) {
      _ && (F(3042), _ = !1);
      return;
    }
    if (_ || (N(3042), _ = !0), k !== CustomBlending) {
      if (k !== m || Oe !== V) {
        if ((y !== AddEquation || x !== AddEquation) && (e.blendEquation(32774), y = AddEquation, x = AddEquation), Oe)
          switch (k) {
            case NormalBlending:
              e.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              e.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              e.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              e.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", k);
              break;
          }
        else
          switch (k) {
            case NormalBlending:
              e.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              e.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              e.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              e.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", k);
              break;
          }
        b = null, M = null, w = null, P = null, m = k, V = Oe;
      }
      return;
    }
    ge = ge || pe, Re = Re || me, De = De || Ce, (pe !== y || ge !== x) && (e.blendEquationSeparate(j[pe], j[ge]), y = pe, x = ge), (me !== b || Ce !== M || Re !== w || De !== P) && (e.blendFuncSeparate(Y[me], Y[Ce], Y[Re], Y[De]), b = me, M = Ce, w = Re, P = De), m = k, V = null;
  }
  function le(k, pe) {
    k.side === DoubleSide ? F(2884) : N(2884);
    var me = k.side === BackSide;
    pe && (me = !me), T(me), k.blending === NormalBlending && k.transparent === !1 ? re(NoBlending) : re(k.blending, k.blendEquation, k.blendSrc, k.blendDst, k.blendEquationAlpha, k.blendSrcAlpha, k.blendDstAlpha, k.premultipliedAlpha), c.setFunc(k.depthFunc), c.setTest(k.depthTest), c.setMask(k.depthWrite), l.setMask(k.colorWrite);
    var Ce = k.stencilWrite;
    u.setTest(Ce), Ce && (u.setMask(k.stencilWriteMask), u.setFunc(k.stencilFunc, k.stencilRef, k.stencilFuncMask), u.setOp(k.stencilFail, k.stencilZFail, k.stencilZPass)), Z(k.polygonOffset, k.polygonOffsetFactor, k.polygonOffsetUnits);
  }
  function T(k) {
    I !== k && (k ? e.frontFace(2304) : e.frontFace(2305), I = k);
  }
  function C(k) {
    k !== CullFaceNone ? (N(2884), k !== $ && (k === CullFaceBack ? e.cullFace(1029) : k === CullFaceFront ? e.cullFace(1028) : e.cullFace(1032))) : F(2884), $ = k;
  }
  function ie(k) {
    k !== E && (B && e.lineWidth(k), E = k);
  }
  function Z(k, pe, me) {
    k ? (N(32823), (G !== pe || O !== me) && (e.polygonOffset(pe, me), G = pe, O = me)) : F(32823);
  }
  function ce(k) {
    k ? N(3089) : F(3089);
  }
  function se(k) {
    k === void 0 && (k = 33984 + W - 1), ne !== k && (e.activeTexture(k), ne = k);
  }
  function ue(k, pe) {
    ne === null && se();
    var me = Q[ne];
    me === void 0 && (me = { type: void 0, texture: void 0 }, Q[ne] = me), (me.type !== k || me.texture !== pe) && (e.bindTexture(k, pe || A[k]), me.type = k, me.texture = pe);
  }
  function Le() {
    var k = Q[ne];
    k !== void 0 && k.type !== void 0 && (e.bindTexture(k.type, null), k.type = void 0, k.texture = void 0);
  }
  function Me() {
    try {
      e.compressedTexImage2D.apply(e, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function ye() {
    try {
      e.texImage2D.apply(e, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function he() {
    try {
      e.texImage3D.apply(e, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function de(k) {
    ae.equals(k) === !1 && (e.scissor(k.x, k.y, k.z, k.w), ae.copy(k));
  }
  function ve(k) {
    oe.equals(k) === !1 && (e.viewport(k.x, k.y, k.z, k.w), oe.copy(k));
  }
  function xe() {
    for (var k = 0; k < d.length; k++)
      d[k] === 1 && (e.disableVertexAttribArray(k), d[k] = 0);
    g = {}, ne = null, Q = {}, v = null, m = null, I = null, $ = null, l.reset(), c.reset(), u.reset();
  }
  return {
    buffers: {
      color: l,
      depth: c,
      stencil: u
    },
    initAttributes: L,
    enableAttribute: D,
    enableAttributeAndDivisor: S,
    disableUnusedAttributes: H,
    vertexAttribPointer: z,
    enable: N,
    disable: F,
    useProgram: U,
    setBlending: re,
    setMaterial: le,
    setFlipSided: T,
    setCullFace: C,
    setLineWidth: ie,
    setPolygonOffset: Z,
    setScissorTest: ce,
    activeTexture: se,
    bindTexture: ue,
    unbindTexture: Le,
    compressedTexImage2D: Me,
    texImage2D: ye,
    texImage3D: he,
    scissor: de,
    viewport: ve,
    reset: xe
  };
}
function WebGLTextures(e, t, r, n, a, o, s) {
  var l = a.isWebGL2, c = a.maxTextures, u = a.maxCubemapSize, h = a.maxTextureSize, f = a.maxSamples, d = /* @__PURE__ */ new WeakMap(), p, g = !1;
  try {
    g = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function v(T, C) {
    return g ? new OffscreenCanvas(T, C) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function _(T, C, ie, Z) {
    var ce = 1;
    if ((T.width > Z || T.height > Z) && (ce = Z / Math.max(T.width, T.height)), ce < 1 || C === !0)
      if (typeof HTMLImageElement < "u" && T instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && T instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && T instanceof ImageBitmap) {
        var se = C ? MathUtils.floorPowerOfTwo : Math.floor, ue = se(ce * T.width), Le = se(ce * T.height);
        p === void 0 && (p = v(ue, Le));
        var Me = ie ? v(ue, Le) : p;
        Me.width = ue, Me.height = Le;
        var ye = Me.getContext("2d");
        return ye.drawImage(T, 0, 0, ue, Le), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + T.width + "x" + T.height + ") to (" + ue + "x" + Le + ")."), Me;
      } else
        return "data" in T && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + T.width + "x" + T.height + ")."), T;
    return T;
  }
  function m(T) {
    return MathUtils.isPowerOfTwo(T.width) && MathUtils.isPowerOfTwo(T.height);
  }
  function y(T) {
    return l ? !1 : T.wrapS !== ClampToEdgeWrapping || T.wrapT !== ClampToEdgeWrapping || T.minFilter !== NearestFilter && T.minFilter !== LinearFilter;
  }
  function b(T, C) {
    return T.generateMipmaps && C && T.minFilter !== NearestFilter && T.minFilter !== LinearFilter;
  }
  function M(T, C, ie, Z) {
    e.generateMipmap(T);
    var ce = n.get(C);
    ce.__maxMipLevel = Math.log(Math.max(ie, Z)) * Math.LOG2E;
  }
  function x(T, C, ie) {
    if (l === !1) return C;
    if (T !== null) {
      if (e[T] !== void 0) return e[T];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + T + "'");
    }
    var Z = C;
    return C === 6403 && (ie === 5126 && (Z = 33326), ie === 5131 && (Z = 33325), ie === 5121 && (Z = 33321)), C === 6407 && (ie === 5126 && (Z = 34837), ie === 5131 && (Z = 34843), ie === 5121 && (Z = 32849)), C === 6408 && (ie === 5126 && (Z = 34836), ie === 5131 && (Z = 34842), ie === 5121 && (Z = 32856)), (Z === 33325 || Z === 33326 || Z === 34842 || Z === 34836) && t.get("EXT_color_buffer_float"), Z;
  }
  function w(T) {
    return T === NearestFilter || T === NearestMipmapNearestFilter || T === NearestMipmapLinearFilter ? 9728 : 9729;
  }
  function P(T) {
    var C = T.target;
    C.removeEventListener("dispose", P), I(C), C.isVideoTexture && d.delete(C), s.memory.textures--;
  }
  function V(T) {
    var C = T.target;
    C.removeEventListener("dispose", V), $(C), s.memory.textures--;
  }
  function I(T) {
    var C = n.get(T);
    C.__webglInit !== void 0 && (e.deleteTexture(C.__webglTexture), n.remove(T));
  }
  function $(T) {
    var C = n.get(T), ie = n.get(T.texture);
    if (T) {
      if (ie.__webglTexture !== void 0 && e.deleteTexture(ie.__webglTexture), T.depthTexture && T.depthTexture.dispose(), T.isWebGLCubeRenderTarget)
        for (var Z = 0; Z < 6; Z++)
          e.deleteFramebuffer(C.__webglFramebuffer[Z]), C.__webglDepthbuffer && e.deleteRenderbuffer(C.__webglDepthbuffer[Z]);
      else
        e.deleteFramebuffer(C.__webglFramebuffer), C.__webglDepthbuffer && e.deleteRenderbuffer(C.__webglDepthbuffer), C.__webglMultisampledFramebuffer && e.deleteFramebuffer(C.__webglMultisampledFramebuffer), C.__webglColorRenderbuffer && e.deleteRenderbuffer(C.__webglColorRenderbuffer), C.__webglDepthRenderbuffer && e.deleteRenderbuffer(C.__webglDepthRenderbuffer);
      n.remove(T.texture), n.remove(T);
    }
  }
  var E = 0;
  function G() {
    E = 0;
  }
  function O() {
    var T = E;
    return T >= c && console.warn("THREE.WebGLTextures: Trying to use " + T + " texture units while this GPU supports only " + c), E += 1, T;
  }
  function W(T, C) {
    var ie = n.get(T);
    if (T.isVideoTexture && j(T), T.version > 0 && ie.__version !== T.version) {
      var Z = T.image;
      if (Z === void 0)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      else if (Z.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        A(ie, T, C);
        return;
      }
    }
    r.activeTexture(33984 + C), r.bindTexture(3553, ie.__webglTexture);
  }
  function B(T, C) {
    var ie = n.get(T);
    if (T.version > 0 && ie.__version !== T.version) {
      A(ie, T, C);
      return;
    }
    r.activeTexture(33984 + C), r.bindTexture(35866, ie.__webglTexture);
  }
  function q(T, C) {
    var ie = n.get(T);
    if (T.version > 0 && ie.__version !== T.version) {
      A(ie, T, C);
      return;
    }
    r.activeTexture(33984 + C), r.bindTexture(32879, ie.__webglTexture);
  }
  function te(T, C) {
    if (T.image.length === 6) {
      var ie = n.get(T);
      if (T.version > 0 && ie.__version !== T.version) {
        _e(ie, T), r.activeTexture(33984 + C), r.bindTexture(34067, ie.__webglTexture), e.pixelStorei(37440, T.flipY);
        for (var Z = T && (T.isCompressedTexture || T.image[0].isCompressedTexture), ce = T.image[0] && T.image[0].isDataTexture, se = [], ue = 0; ue < 6; ue++)
          !Z && !ce ? se[ue] = _(T.image[ue], !1, !0, u) : se[ue] = ce ? T.image[ue].image : T.image[ue];
        var Le = se[0], Me = m(Le) || l, ye = o.convert(T.format), he = o.convert(T.type), de = x(T.internalFormat, ye, he);
        oe(34067, T, Me);
        var ve;
        if (Z) {
          for (var ue = 0; ue < 6; ue++) {
            ve = se[ue].mipmaps;
            for (var xe = 0; xe < ve.length; xe++) {
              var k = ve[xe];
              T.format !== RGBAFormat && T.format !== RGBFormat ? ye !== null ? r.compressedTexImage2D(34069 + ue, xe, de, k.width, k.height, 0, k.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : r.texImage2D(34069 + ue, xe, de, k.width, k.height, 0, ye, he, k.data);
            }
          }
          ie.__maxMipLevel = ve.length - 1;
        } else {
          ve = T.mipmaps;
          for (var ue = 0; ue < 6; ue++)
            if (ce) {
              r.texImage2D(34069 + ue, 0, de, se[ue].width, se[ue].height, 0, ye, he, se[ue].data);
              for (var xe = 0; xe < ve.length; xe++) {
                var k = ve[xe], pe = k.image[ue].image;
                r.texImage2D(34069 + ue, xe + 1, de, pe.width, pe.height, 0, ye, he, pe.data);
              }
            } else {
              r.texImage2D(34069 + ue, 0, de, ye, he, se[ue]);
              for (var xe = 0; xe < ve.length; xe++) {
                var k = ve[xe];
                r.texImage2D(34069 + ue, xe + 1, de, ye, he, k.image[ue]);
              }
            }
          ie.__maxMipLevel = ve.length;
        }
        b(T, Me) && M(34067, T, Le.width, Le.height), ie.__version = T.version, T.onUpdate && T.onUpdate(T);
      } else
        r.activeTexture(33984 + C), r.bindTexture(34067, ie.__webglTexture);
    }
  }
  function ne(T, C) {
    r.activeTexture(33984 + C), r.bindTexture(34067, n.get(T).__webglTexture);
  }
  var Q = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  }, ae = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function oe(T, C, ie) {
    ie ? (e.texParameteri(T, 10242, Q[C.wrapS]), e.texParameteri(T, 10243, Q[C.wrapT]), (T === 32879 || T === 35866) && e.texParameteri(T, 32882, Q[C.wrapR]), e.texParameteri(T, 10240, ae[C.magFilter]), e.texParameteri(T, 10241, ae[C.minFilter])) : (e.texParameteri(T, 10242, 33071), e.texParameteri(T, 10243, 33071), (T === 32879 || T === 35866) && e.texParameteri(T, 32882, 33071), (C.wrapS !== ClampToEdgeWrapping || C.wrapT !== ClampToEdgeWrapping) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(T, 10240, w(C.magFilter)), e.texParameteri(T, 10241, w(C.minFilter)), C.minFilter !== NearestFilter && C.minFilter !== LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
    var Z = t.get("EXT_texture_filter_anisotropic");
    if (Z) {
      if (C.type === FloatType && t.get("OES_texture_float_linear") === null || C.type === HalfFloatType && (l || t.get("OES_texture_half_float_linear")) === null) return;
      (C.anisotropy > 1 || n.get(C).__currentAnisotropy) && (e.texParameterf(T, Z.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(C.anisotropy, a.getMaxAnisotropy())), n.get(C).__currentAnisotropy = C.anisotropy);
    }
  }
  function _e(T, C) {
    T.__webglInit === void 0 && (T.__webglInit = !0, C.addEventListener("dispose", P), T.__webglTexture = e.createTexture(), s.memory.textures++);
  }
  function A(T, C, ie) {
    var Z = 3553;
    C.isDataTexture2DArray && (Z = 35866), C.isDataTexture3D && (Z = 32879), _e(T, C), r.activeTexture(33984 + ie), r.bindTexture(Z, T.__webglTexture), e.pixelStorei(37440, C.flipY), e.pixelStorei(37441, C.premultiplyAlpha), e.pixelStorei(3317, C.unpackAlignment);
    var ce = y(C) && m(C.image) === !1, se = _(C.image, ce, !1, h), ue = m(se) || l, Le = o.convert(C.format), Me = o.convert(C.type), ye = x(C.internalFormat, Le, Me);
    oe(Z, C, ue);
    var he, de = C.mipmaps;
    if (C.isDepthTexture)
      ye = 6402, l ? C.type === FloatType ? ye = 36012 : C.type === UnsignedIntType ? ye = 33190 : C.type === UnsignedInt248Type ? ye = 35056 : ye = 33189 : C.type === FloatType && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), C.format === DepthFormat && ye === 6402 && C.type !== UnsignedShortType && C.type !== UnsignedIntType && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), C.type = UnsignedShortType, Me = o.convert(C.type)), C.format === DepthStencilFormat && ye === 6402 && (ye = 34041, C.type !== UnsignedInt248Type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), C.type = UnsignedInt248Type, Me = o.convert(C.type))), r.texImage2D(3553, 0, ye, se.width, se.height, 0, Le, Me, null);
    else if (C.isDataTexture)
      if (de.length > 0 && ue) {
        for (var ve = 0, xe = de.length; ve < xe; ve++)
          he = de[ve], r.texImage2D(3553, ve, ye, he.width, he.height, 0, Le, Me, he.data);
        C.generateMipmaps = !1, T.__maxMipLevel = de.length - 1;
      } else
        r.texImage2D(3553, 0, ye, se.width, se.height, 0, Le, Me, se.data), T.__maxMipLevel = 0;
    else if (C.isCompressedTexture) {
      for (var ve = 0, xe = de.length; ve < xe; ve++)
        he = de[ve], C.format !== RGBAFormat && C.format !== RGBFormat ? Le !== null ? r.compressedTexImage2D(3553, ve, ye, he.width, he.height, 0, he.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : r.texImage2D(3553, ve, ye, he.width, he.height, 0, Le, Me, he.data);
      T.__maxMipLevel = de.length - 1;
    } else if (C.isDataTexture2DArray)
      r.texImage3D(35866, 0, ye, se.width, se.height, se.depth, 0, Le, Me, se.data), T.__maxMipLevel = 0;
    else if (C.isDataTexture3D)
      r.texImage3D(32879, 0, ye, se.width, se.height, se.depth, 0, Le, Me, se.data), T.__maxMipLevel = 0;
    else if (de.length > 0 && ue) {
      for (var ve = 0, xe = de.length; ve < xe; ve++)
        he = de[ve], r.texImage2D(3553, ve, ye, Le, Me, he);
      C.generateMipmaps = !1, T.__maxMipLevel = de.length - 1;
    } else
      r.texImage2D(3553, 0, ye, Le, Me, se), T.__maxMipLevel = 0;
    b(C, ue) && M(Z, C, se.width, se.height), T.__version = C.version, C.onUpdate && C.onUpdate(C);
  }
  function L(T, C, ie, Z) {
    var ce = o.convert(C.texture.format), se = o.convert(C.texture.type), ue = x(C.texture.internalFormat, ce, se);
    r.texImage2D(Z, 0, ue, C.width, C.height, 0, ce, se, null), e.bindFramebuffer(36160, T), e.framebufferTexture2D(36160, ie, Z, n.get(C.texture).__webglTexture, 0), e.bindFramebuffer(36160, null);
  }
  function D(T, C, ie) {
    if (e.bindRenderbuffer(36161, T), C.depthBuffer && !C.stencilBuffer) {
      var Z = 33189;
      if (ie) {
        var ce = C.depthTexture;
        ce && ce.isDepthTexture && (ce.type === FloatType ? Z = 36012 : ce.type === UnsignedIntType && (Z = 33190));
        var se = U(C);
        e.renderbufferStorageMultisample(36161, se, Z, C.width, C.height);
      } else
        e.renderbufferStorage(36161, Z, C.width, C.height);
      e.framebufferRenderbuffer(36160, 36096, 36161, T);
    } else if (C.depthBuffer && C.stencilBuffer) {
      if (ie) {
        var se = U(C);
        e.renderbufferStorageMultisample(36161, se, 35056, C.width, C.height);
      } else
        e.renderbufferStorage(36161, 34041, C.width, C.height);
      e.framebufferRenderbuffer(36160, 33306, 36161, T);
    } else {
      var ue = o.convert(C.texture.format), Le = o.convert(C.texture.type), Z = x(C.texture.internalFormat, ue, Le);
      if (ie) {
        var se = U(C);
        e.renderbufferStorageMultisample(36161, se, Z, C.width, C.height);
      } else
        e.renderbufferStorage(36161, Z, C.width, C.height);
    }
    e.bindRenderbuffer(36161, null);
  }
  function S(T, C) {
    var ie = C && C.isWebGLCubeRenderTarget;
    if (ie) throw new Error("Depth Texture with cube render targets is not supported");
    if (e.bindFramebuffer(36160, T), !(C.depthTexture && C.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!n.get(C.depthTexture).__webglTexture || C.depthTexture.image.width !== C.width || C.depthTexture.image.height !== C.height) && (C.depthTexture.image.width = C.width, C.depthTexture.image.height = C.height, C.depthTexture.needsUpdate = !0), W(C.depthTexture, 0);
    var Z = n.get(C.depthTexture).__webglTexture;
    if (C.depthTexture.format === DepthFormat)
      e.framebufferTexture2D(36160, 36096, 3553, Z, 0);
    else if (C.depthTexture.format === DepthStencilFormat)
      e.framebufferTexture2D(36160, 33306, 3553, Z, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function H(T) {
    var C = n.get(T), ie = T.isWebGLCubeRenderTarget === !0;
    if (T.depthTexture) {
      if (ie) throw new Error("target.depthTexture not supported in Cube render targets");
      S(C.__webglFramebuffer, T);
    } else if (ie) {
      C.__webglDepthbuffer = [];
      for (var Z = 0; Z < 6; Z++)
        e.bindFramebuffer(36160, C.__webglFramebuffer[Z]), C.__webglDepthbuffer[Z] = e.createRenderbuffer(), D(C.__webglDepthbuffer[Z], T, !1);
    } else
      e.bindFramebuffer(36160, C.__webglFramebuffer), C.__webglDepthbuffer = e.createRenderbuffer(), D(C.__webglDepthbuffer, T, !1);
    e.bindFramebuffer(36160, null);
  }
  function z(T) {
    var C = n.get(T), ie = n.get(T.texture);
    T.addEventListener("dispose", V), ie.__webglTexture = e.createTexture(), s.memory.textures++;
    var Z = T.isWebGLCubeRenderTarget === !0, ce = T.isWebGLMultisampleRenderTarget === !0, se = m(T) || l;
    if (l && T.texture.format === RGBFormat && (T.texture.type === FloatType || T.texture.type === HalfFloatType) && (T.texture.format = RGBAFormat, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), Z) {
      C.__webglFramebuffer = [];
      for (var ue = 0; ue < 6; ue++)
        C.__webglFramebuffer[ue] = e.createFramebuffer();
    } else if (C.__webglFramebuffer = e.createFramebuffer(), ce)
      if (l) {
        C.__webglMultisampledFramebuffer = e.createFramebuffer(), C.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, C.__webglColorRenderbuffer);
        var Le = o.convert(T.texture.format), Me = o.convert(T.texture.type), ye = x(T.texture.internalFormat, Le, Me), he = U(T);
        e.renderbufferStorageMultisample(36161, he, ye, T.width, T.height), e.bindFramebuffer(36160, C.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, C.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), T.depthBuffer && (C.__webglDepthRenderbuffer = e.createRenderbuffer(), D(C.__webglDepthRenderbuffer, T, !0)), e.bindFramebuffer(36160, null);
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
    if (Z) {
      r.bindTexture(34067, ie.__webglTexture), oe(34067, T.texture, se);
      for (var ue = 0; ue < 6; ue++)
        L(C.__webglFramebuffer[ue], T, 36064, 34069 + ue);
      b(T.texture, se) && M(34067, T.texture, T.width, T.height), r.bindTexture(34067, null);
    } else
      r.bindTexture(3553, ie.__webglTexture), oe(3553, T.texture, se), L(C.__webglFramebuffer, T, 36064, 3553), b(T.texture, se) && M(3553, T.texture, T.width, T.height), r.bindTexture(3553, null);
    T.depthBuffer && H(T);
  }
  function N(T) {
    var C = T.texture, ie = m(T) || l;
    if (b(C, ie)) {
      var Z = T.isWebGLCubeRenderTarget ? 34067 : 3553, ce = n.get(C).__webglTexture;
      r.bindTexture(Z, ce), M(Z, C, T.width, T.height), r.bindTexture(Z, null);
    }
  }
  function F(T) {
    if (T.isWebGLMultisampleRenderTarget)
      if (l) {
        var C = n.get(T);
        e.bindFramebuffer(36008, C.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, C.__webglFramebuffer);
        var ie = T.width, Z = T.height, ce = 16384;
        T.depthBuffer && (ce |= 256), T.stencilBuffer && (ce |= 1024), e.blitFramebuffer(0, 0, ie, Z, 0, 0, ie, Z, ce, 9728), e.bindFramebuffer(36160, C.__webglMultisampledFramebuffer);
      } else
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
  }
  function U(T) {
    return l && T.isWebGLMultisampleRenderTarget ? Math.min(f, T.samples) : 0;
  }
  function j(T) {
    var C = s.render.frame;
    d.get(T) !== C && (d.set(T, C), T.update());
  }
  var K = !1, Y = !1;
  function re(T, C) {
    T && T.isWebGLRenderTarget && (K === !1 && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), K = !0), T = T.texture), W(T, C);
  }
  function le(T, C) {
    T && T.isWebGLCubeRenderTarget && (Y === !1 && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), Y = !0), T = T.texture), T && T.isCubeTexture || Array.isArray(T.image) && T.image.length === 6 ? te(T, C) : ne(T, C);
  }
  this.allocateTextureUnit = O, this.resetTextureUnits = G, this.setTexture2D = W, this.setTexture2DArray = B, this.setTexture3D = q, this.setTextureCube = te, this.setTextureCubeDynamic = ne, this.setupRenderTarget = z, this.updateRenderTargetMipmap = N, this.updateMultisampleRenderTarget = F, this.safeSetTexture2D = re, this.safeSetTextureCube = le;
}
function WebGLUtils(e, t, r) {
  var n = r.isWebGL2;
  function a(o) {
    var s;
    if (o === UnsignedByteType) return 5121;
    if (o === UnsignedShort4444Type) return 32819;
    if (o === UnsignedShort5551Type) return 32820;
    if (o === UnsignedShort565Type) return 33635;
    if (o === ByteType) return 5120;
    if (o === ShortType) return 5122;
    if (o === UnsignedShortType) return 5123;
    if (o === IntType) return 5124;
    if (o === UnsignedIntType) return 5125;
    if (o === FloatType) return 5126;
    if (o === HalfFloatType)
      return n ? 5131 : (s = t.get("OES_texture_half_float"), s !== null ? s.HALF_FLOAT_OES : null);
    if (o === AlphaFormat) return 6406;
    if (o === RGBFormat) return 6407;
    if (o === RGBAFormat) return 6408;
    if (o === LuminanceFormat) return 6409;
    if (o === LuminanceAlphaFormat) return 6410;
    if (o === DepthFormat) return 6402;
    if (o === DepthStencilFormat) return 34041;
    if (o === RedFormat) return 6403;
    if (o === RedIntegerFormat) return 36244;
    if (o === RGFormat) return 33319;
    if (o === RGIntegerFormat) return 33320;
    if (o === RGBIntegerFormat) return 36248;
    if (o === RGBAIntegerFormat) return 36249;
    if (o === RGB_S3TC_DXT1_Format || o === RGBA_S3TC_DXT1_Format || o === RGBA_S3TC_DXT3_Format || o === RGBA_S3TC_DXT5_Format)
      if (s = t.get("WEBGL_compressed_texture_s3tc"), s !== null) {
        if (o === RGB_S3TC_DXT1_Format) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (o === RGBA_S3TC_DXT1_Format) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (o === RGBA_S3TC_DXT3_Format) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (o === RGBA_S3TC_DXT5_Format) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (o === RGB_PVRTC_4BPPV1_Format || o === RGB_PVRTC_2BPPV1_Format || o === RGBA_PVRTC_4BPPV1_Format || o === RGBA_PVRTC_2BPPV1_Format)
      if (s = t.get("WEBGL_compressed_texture_pvrtc"), s !== null) {
        if (o === RGB_PVRTC_4BPPV1_Format) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (o === RGB_PVRTC_2BPPV1_Format) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (o === RGBA_PVRTC_4BPPV1_Format) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (o === RGBA_PVRTC_2BPPV1_Format) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (o === RGB_ETC1_Format)
      return s = t.get("WEBGL_compressed_texture_etc1"), s !== null ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
    if ((o === RGB_ETC2_Format || o === RGBA_ETC2_EAC_Format) && (s = t.get("WEBGL_compressed_texture_etc"), s !== null)) {
      if (o === RGB_ETC2_Format) return s.COMPRESSED_RGB8_ETC2;
      if (o === RGBA_ETC2_EAC_Format) return s.COMPRESSED_RGBA8_ETC2_EAC;
    }
    if (o === RGBA_ASTC_4x4_Format || o === RGBA_ASTC_5x4_Format || o === RGBA_ASTC_5x5_Format || o === RGBA_ASTC_6x5_Format || o === RGBA_ASTC_6x6_Format || o === RGBA_ASTC_8x5_Format || o === RGBA_ASTC_8x6_Format || o === RGBA_ASTC_8x8_Format || o === RGBA_ASTC_10x5_Format || o === RGBA_ASTC_10x6_Format || o === RGBA_ASTC_10x8_Format || o === RGBA_ASTC_10x10_Format || o === RGBA_ASTC_12x10_Format || o === RGBA_ASTC_12x12_Format || o === SRGB8_ALPHA8_ASTC_4x4_Format || o === SRGB8_ALPHA8_ASTC_5x4_Format || o === SRGB8_ALPHA8_ASTC_5x5_Format || o === SRGB8_ALPHA8_ASTC_6x5_Format || o === SRGB8_ALPHA8_ASTC_6x6_Format || o === SRGB8_ALPHA8_ASTC_8x5_Format || o === SRGB8_ALPHA8_ASTC_8x6_Format || o === SRGB8_ALPHA8_ASTC_8x8_Format || o === SRGB8_ALPHA8_ASTC_10x5_Format || o === SRGB8_ALPHA8_ASTC_10x6_Format || o === SRGB8_ALPHA8_ASTC_10x8_Format || o === SRGB8_ALPHA8_ASTC_10x10_Format || o === SRGB8_ALPHA8_ASTC_12x10_Format || o === SRGB8_ALPHA8_ASTC_12x12_Format)
      return s = t.get("WEBGL_compressed_texture_astc"), s !== null ? o : null;
    if (o === RGBA_BPTC_Format)
      return s = t.get("EXT_texture_compression_bptc"), s !== null ? o : null;
    if (o === UnsignedInt248Type)
      return n ? 34042 : (s = t.get("WEBGL_depth_texture"), s !== null ? s.UNSIGNED_INT_24_8_WEBGL : null);
  }
  return { convert: a };
}
function ArrayCamera(e) {
  PerspectiveCamera.call(this), this.cameras = e || [];
}
ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
  constructor: ArrayCamera,
  isArrayCamera: !0
});
function Group() {
  Object3D.call(this), this.type = "Group";
}
Group.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Group,
  isGroup: !0
});
function WebXRController() {
  this._targetRay = null, this._grip = null;
}
Object.assign(WebXRController.prototype, {
  constructor: WebXRController,
  getTargetRaySpace: function() {
    return this._targetRay === null && (this._targetRay = new Group(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay;
  },
  getGripSpace: function() {
    return this._grip === null && (this._grip = new Group(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip;
  },
  dispatchEvent: function(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this;
  },
  disconnect: function(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this;
  },
  update: function(e, t, r) {
    var n = null, a = null, o = this._targetRay, s = this._grip;
    return e && (o !== null && (n = t.getPose(e.targetRaySpace, r), n !== null && (o.matrix.fromArray(n.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale))), s !== null && e.gripSpace && (a = t.getPose(e.gripSpace, r), a !== null && (s.matrix.fromArray(a.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale)))), o !== null && (o.visible = n !== null), s !== null && (s.visible = a !== null), this;
  }
});
function WebXRManager(e, t) {
  var r = this, n = null, a = 1, o = null, s = "local-floor", l = null, c = [], u = /* @__PURE__ */ new Map(), h = new PerspectiveCamera();
  h.layers.enable(1), h.viewport = new Vector4();
  var f = new PerspectiveCamera();
  f.layers.enable(2), f.viewport = new Vector4();
  var d = [h, f], p = new ArrayCamera();
  p.layers.enable(1), p.layers.enable(2);
  var g = null, v = null;
  this.enabled = !1, this.isPresenting = !1, this.getController = function(E) {
    var G = c[E];
    return G === void 0 && (G = new WebXRController(), c[E] = G), G.getTargetRaySpace();
  }, this.getControllerGrip = function(E) {
    var G = c[E];
    return G === void 0 && (G = new WebXRController(), c[E] = G), G.getGripSpace();
  };
  function _(E) {
    var G = u.get(E.inputSource);
    G && G.dispatchEvent({ type: E.type });
  }
  function m() {
    u.forEach(function(E, G) {
      E.disconnect(G);
    }), u.clear(), e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), $.stop(), r.isPresenting = !1, r.dispatchEvent({ type: "sessionend" });
  }
  function y(E) {
    o = E, $.setContext(n), $.start(), r.isPresenting = !0, r.dispatchEvent({ type: "sessionstart" });
  }
  this.setFramebufferScaleFactor = function(E) {
    a = E, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
  }, this.setReferenceSpaceType = function(E) {
    s = E, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
  }, this.getReferenceSpace = function() {
    return o;
  }, this.getSession = function() {
    return n;
  }, this.setSession = function(E) {
    if (n = E, n !== null) {
      n.addEventListener("select", _), n.addEventListener("selectstart", _), n.addEventListener("selectend", _), n.addEventListener("squeeze", _), n.addEventListener("squeezestart", _), n.addEventListener("squeezeend", _), n.addEventListener("end", m);
      var G = t.getContextAttributes();
      G.xrCompatible !== !0 && t.makeXRCompatible();
      var O = {
        antialias: G.antialias,
        alpha: G.alpha,
        depth: G.depth,
        stencil: G.stencil,
        framebufferScaleFactor: a
      }, W = new XRWebGLLayer(n, t, O);
      n.updateRenderState({ baseLayer: W }), n.requestReferenceSpace(s).then(y), n.addEventListener("inputsourceschange", b);
    }
  };
  function b(E) {
    for (var G = n.inputSources, O = 0; O < c.length; O++)
      u.set(G[O], c[O]);
    for (var O = 0; O < E.removed.length; O++) {
      var W = E.removed[O], B = u.get(W);
      B && (B.dispatchEvent({ type: "disconnected", data: W }), u.delete(W));
    }
    for (var O = 0; O < E.added.length; O++) {
      var W = E.added[O], B = u.get(W);
      B && B.dispatchEvent({ type: "connected", data: W });
    }
  }
  var M = new Vector3(), x = new Vector3();
  function w(E, G, O) {
    M.setFromMatrixPosition(G.matrixWorld), x.setFromMatrixPosition(O.matrixWorld);
    var W = M.distanceTo(x), B = G.projectionMatrix.elements, q = O.projectionMatrix.elements, te = B[14] / (B[10] - 1), ne = B[14] / (B[10] + 1), Q = (B[9] + 1) / B[5], ae = (B[9] - 1) / B[5], oe = (B[8] - 1) / B[0], _e = (q[8] + 1) / q[0], A = te * oe, L = te * _e, D = W / (-oe + _e), S = D * -oe;
    G.matrixWorld.decompose(E.position, E.quaternion, E.scale), E.translateX(S), E.translateZ(D), E.matrixWorld.compose(E.position, E.quaternion, E.scale), E.matrixWorldInverse.getInverse(E.matrixWorld);
    var H = te + D, z = ne + D, N = A - S, F = L + (W - S), U = Q * ne / z * H, j = ae * ne / z * H;
    E.projectionMatrix.makePerspective(N, F, U, j, H, z);
  }
  function P(E, G) {
    G === null ? E.matrixWorld.copy(E.matrix) : E.matrixWorld.multiplyMatrices(G.matrixWorld, E.matrix), E.matrixWorldInverse.getInverse(E.matrixWorld);
  }
  this.getCamera = function(E) {
    p.near = f.near = h.near = E.near, p.far = f.far = h.far = E.far, (g !== p.near || v !== p.far) && (n.updateRenderState({
      depthNear: p.near,
      depthFar: p.far
    }), g = p.near, v = p.far);
    var G = E.parent, O = p.cameras;
    P(p, G);
    for (var W = 0; W < O.length; W++)
      P(O[W], G);
    E.matrixWorld.copy(p.matrixWorld);
    for (var B = E.children, W = 0, q = B.length; W < q; W++)
      B[W].updateMatrixWorld(!0);
    return O.length === 2 ? w(p, h, f) : p.projectionMatrix.copy(h.projectionMatrix), p;
  };
  var V = null;
  function I(E, G) {
    if (l = G.getViewerPose(o), l !== null) {
      var O = l.views, W = n.renderState.baseLayer;
      e.setFramebuffer(W.framebuffer);
      var B = !1;
      O.length !== p.cameras.length && (p.cameras.length = 0, B = !0);
      for (var q = 0; q < O.length; q++) {
        var te = O[q], ne = W.getViewport(te), Q = d[q];
        Q.matrix.fromArray(te.transform.matrix), Q.projectionMatrix.fromArray(te.projectionMatrix), Q.viewport.set(ne.x, ne.y, ne.width, ne.height), q === 0 && p.matrix.copy(Q.matrix), B === !0 && p.cameras.push(Q);
      }
    }
    for (var ae = n.inputSources, q = 0; q < c.length; q++) {
      var oe = c[q], _e = ae[q];
      oe.update(_e, G, o);
    }
    V && V(E, G);
  }
  var $ = new WebGLAnimation();
  $.setAnimationLoop(I), this.setAnimationLoop = function(E) {
    V = E;
  }, this.dispose = function() {
  };
}
Object.assign(WebXRManager.prototype, EventDispatcher$1.prototype);
function WebGLMaterials(e) {
  function t(m, y) {
    m.fogColor.value.copy(y.color), y.isFog ? (m.fogNear.value = y.near, m.fogFar.value = y.far) : y.isFogExp2 && (m.fogDensity.value = y.density);
  }
  function r(m, y, b, M, x) {
    y.isMeshBasicMaterial ? n(m, y) : y.isMeshLambertMaterial ? (n(m, y), c(m, y)) : y.isMeshToonMaterial ? (n(m, y), h(m, y)) : y.isMeshPhongMaterial ? (n(m, y), u(m, y)) : y.isMeshStandardMaterial ? (n(m, y, b), y.isMeshPhysicalMaterial ? d(m, y, b) : f(m, y, b)) : y.isMeshMatcapMaterial ? (n(m, y), p(m, y)) : y.isMeshDepthMaterial ? (n(m, y), g(m, y)) : y.isMeshDistanceMaterial ? (n(m, y), v(m, y)) : y.isMeshNormalMaterial ? (n(m, y), _(m, y)) : y.isLineBasicMaterial ? (a(m, y), y.isLineDashedMaterial && o(m, y)) : y.isPointsMaterial ? s(m, y, M, x) : y.isSpriteMaterial ? l(m, y) : y.isShadowMaterial ? (m.color.value.copy(y.color), m.opacity.value = y.opacity) : y.isShaderMaterial && (y.uniformsNeedUpdate = !1);
  }
  function n(m, y, b) {
    m.opacity.value = y.opacity, y.color && m.diffuse.value.copy(y.color), y.emissive && m.emissive.value.copy(y.emissive).multiplyScalar(y.emissiveIntensity), y.map && (m.map.value = y.map), y.alphaMap && (m.alphaMap.value = y.alphaMap), y.specularMap && (m.specularMap.value = y.specularMap);
    var M = y.envMap || b;
    M && (m.envMap.value = M, m.flipEnvMap.value = M.isCubeTexture ? -1 : 1, m.reflectivity.value = y.reflectivity, m.refractionRatio.value = y.refractionRatio, m.maxMipLevel.value = e.get(M).__maxMipLevel), y.lightMap && (m.lightMap.value = y.lightMap, m.lightMapIntensity.value = y.lightMapIntensity), y.aoMap && (m.aoMap.value = y.aoMap, m.aoMapIntensity.value = y.aoMapIntensity);
    var x;
    y.map ? x = y.map : y.specularMap ? x = y.specularMap : y.displacementMap ? x = y.displacementMap : y.normalMap ? x = y.normalMap : y.bumpMap ? x = y.bumpMap : y.roughnessMap ? x = y.roughnessMap : y.metalnessMap ? x = y.metalnessMap : y.alphaMap ? x = y.alphaMap : y.emissiveMap && (x = y.emissiveMap), x !== void 0 && (x.isWebGLRenderTarget && (x = x.texture), x.matrixAutoUpdate === !0 && x.updateMatrix(), m.uvTransform.value.copy(x.matrix));
    var w;
    y.aoMap ? w = y.aoMap : y.lightMap && (w = y.lightMap), w !== void 0 && (w.isWebGLRenderTarget && (w = w.texture), w.matrixAutoUpdate === !0 && w.updateMatrix(), m.uv2Transform.value.copy(w.matrix));
  }
  function a(m, y) {
    m.diffuse.value.copy(y.color), m.opacity.value = y.opacity;
  }
  function o(m, y) {
    m.dashSize.value = y.dashSize, m.totalSize.value = y.dashSize + y.gapSize, m.scale.value = y.scale;
  }
  function s(m, y, b, M) {
    m.diffuse.value.copy(y.color), m.opacity.value = y.opacity, m.size.value = y.size * b, m.scale.value = M * 0.5, y.map && (m.map.value = y.map), y.alphaMap && (m.alphaMap.value = y.alphaMap);
    var x;
    y.map ? x = y.map : y.alphaMap && (x = y.alphaMap), x !== void 0 && (x.matrixAutoUpdate === !0 && x.updateMatrix(), m.uvTransform.value.copy(x.matrix));
  }
  function l(m, y) {
    m.diffuse.value.copy(y.color), m.opacity.value = y.opacity, m.rotation.value = y.rotation, y.map && (m.map.value = y.map), y.alphaMap && (m.alphaMap.value = y.alphaMap);
    var b;
    y.map ? b = y.map : y.alphaMap && (b = y.alphaMap), b !== void 0 && (b.matrixAutoUpdate === !0 && b.updateMatrix(), m.uvTransform.value.copy(b.matrix));
  }
  function c(m, y) {
    y.emissiveMap && (m.emissiveMap.value = y.emissiveMap);
  }
  function u(m, y) {
    m.specular.value.copy(y.specular), m.shininess.value = Math.max(y.shininess, 1e-4), y.emissiveMap && (m.emissiveMap.value = y.emissiveMap), y.bumpMap && (m.bumpMap.value = y.bumpMap, m.bumpScale.value = y.bumpScale, y.side === BackSide && (m.bumpScale.value *= -1)), y.normalMap && (m.normalMap.value = y.normalMap, m.normalScale.value.copy(y.normalScale), y.side === BackSide && m.normalScale.value.negate()), y.displacementMap && (m.displacementMap.value = y.displacementMap, m.displacementScale.value = y.displacementScale, m.displacementBias.value = y.displacementBias);
  }
  function h(m, y) {
    m.specular.value.copy(y.specular), m.shininess.value = Math.max(y.shininess, 1e-4), y.gradientMap && (m.gradientMap.value = y.gradientMap), y.emissiveMap && (m.emissiveMap.value = y.emissiveMap), y.bumpMap && (m.bumpMap.value = y.bumpMap, m.bumpScale.value = y.bumpScale, y.side === BackSide && (m.bumpScale.value *= -1)), y.normalMap && (m.normalMap.value = y.normalMap, m.normalScale.value.copy(y.normalScale), y.side === BackSide && m.normalScale.value.negate()), y.displacementMap && (m.displacementMap.value = y.displacementMap, m.displacementScale.value = y.displacementScale, m.displacementBias.value = y.displacementBias);
  }
  function f(m, y, b) {
    m.roughness.value = y.roughness, m.metalness.value = y.metalness, y.roughnessMap && (m.roughnessMap.value = y.roughnessMap), y.metalnessMap && (m.metalnessMap.value = y.metalnessMap), y.emissiveMap && (m.emissiveMap.value = y.emissiveMap), y.bumpMap && (m.bumpMap.value = y.bumpMap, m.bumpScale.value = y.bumpScale, y.side === BackSide && (m.bumpScale.value *= -1)), y.normalMap && (m.normalMap.value = y.normalMap, m.normalScale.value.copy(y.normalScale), y.side === BackSide && m.normalScale.value.negate()), y.displacementMap && (m.displacementMap.value = y.displacementMap, m.displacementScale.value = y.displacementScale, m.displacementBias.value = y.displacementBias), (y.envMap || b) && (m.envMapIntensity.value = y.envMapIntensity);
  }
  function d(m, y, b) {
    f(m, y, b), m.reflectivity.value = y.reflectivity, m.clearcoat.value = y.clearcoat, m.clearcoatRoughness.value = y.clearcoatRoughness, y.sheen && m.sheen.value.copy(y.sheen), y.clearcoatMap && (m.clearcoatMap.value = y.clearcoatMap), y.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = y.clearcoatRoughnessMap), y.clearcoatNormalMap && (m.clearcoatNormalScale.value.copy(y.clearcoatNormalScale), m.clearcoatNormalMap.value = y.clearcoatNormalMap, y.side === BackSide && m.clearcoatNormalScale.value.negate()), m.transparency.value = y.transparency;
  }
  function p(m, y) {
    y.matcap && (m.matcap.value = y.matcap), y.bumpMap && (m.bumpMap.value = y.bumpMap, m.bumpScale.value = y.bumpScale, y.side === BackSide && (m.bumpScale.value *= -1)), y.normalMap && (m.normalMap.value = y.normalMap, m.normalScale.value.copy(y.normalScale), y.side === BackSide && m.normalScale.value.negate()), y.displacementMap && (m.displacementMap.value = y.displacementMap, m.displacementScale.value = y.displacementScale, m.displacementBias.value = y.displacementBias);
  }
  function g(m, y) {
    y.displacementMap && (m.displacementMap.value = y.displacementMap, m.displacementScale.value = y.displacementScale, m.displacementBias.value = y.displacementBias);
  }
  function v(m, y) {
    y.displacementMap && (m.displacementMap.value = y.displacementMap, m.displacementScale.value = y.displacementScale, m.displacementBias.value = y.displacementBias), m.referencePosition.value.copy(y.referencePosition), m.nearDistance.value = y.nearDistance, m.farDistance.value = y.farDistance;
  }
  function _(m, y) {
    y.bumpMap && (m.bumpMap.value = y.bumpMap, m.bumpScale.value = y.bumpScale, y.side === BackSide && (m.bumpScale.value *= -1)), y.normalMap && (m.normalMap.value = y.normalMap, m.normalScale.value.copy(y.normalScale), y.side === BackSide && m.normalScale.value.negate()), y.displacementMap && (m.displacementMap.value = y.displacementMap, m.displacementScale.value = y.displacementScale, m.displacementBias.value = y.displacementBias);
  }
  return {
    refreshFogUniforms: t,
    refreshMaterialUniforms: r
  };
}
function WebGLRenderer$1(e) {
  e = e || {};
  var t = e.canvas !== void 0 ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), r = e.context !== void 0 ? e.context : null, n = e.alpha !== void 0 ? e.alpha : !1, a = e.depth !== void 0 ? e.depth : !0, o = e.stencil !== void 0 ? e.stencil : !0, s = e.antialias !== void 0 ? e.antialias : !1, l = e.premultipliedAlpha !== void 0 ? e.premultipliedAlpha : !0, c = e.preserveDrawingBuffer !== void 0 ? e.preserveDrawingBuffer : !1, u = e.powerPreference !== void 0 ? e.powerPreference : "default", h = e.failIfMajorPerformanceCaveat !== void 0 ? e.failIfMajorPerformanceCaveat : !1, f = null, d = null;
  this.domElement = t, this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: !0
  }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = LinearEncoding, this.physicallyCorrectLights = !1, this.toneMapping = NoToneMapping, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
  var p = this, g = !1, v = null, _ = 0, m = 0, y = null, b = null, M = -1, x = {
    geometry: null,
    program: null,
    wireframe: !1
  }, w = null, P = null, V = new Vector4(), I = new Vector4(), $ = null, E = t.width, G = t.height, O = 1, W = null, B = null, q = new Vector4(0, 0, E, G), te = new Vector4(0, 0, E, G), ne = !1, Q = new Frustum(), ae = new WebGLClipping(), oe = !1, _e = !1, A = new Matrix4(), L = new Vector3();
  function D() {
    return y === null ? O : 1;
  }
  var S;
  try {
    var H = {
      alpha: n,
      depth: a,
      stencil: o,
      antialias: s,
      premultipliedAlpha: l,
      preserveDrawingBuffer: c,
      powerPreference: u,
      failIfMajorPerformanceCaveat: h
    };
    if (t.addEventListener("webglcontextlost", ve, !1), t.addEventListener("webglcontextrestored", xe, !1), S = r || t.getContext("webgl", H) || t.getContext("experimental-webgl", H), S === null)
      throw t.getContext("webgl") !== null ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    S.getShaderPrecisionFormat === void 0 && (S.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (R) {
    throw console.error("THREE.WebGLRenderer: " + R.message), R;
  }
  var z, N, F, U, j, K, Y, re, le, T, C, ie, Z, ce, se, ue, Le, Me;
  function ye() {
    z = new WebGLExtensions(S), N = new WebGLCapabilities(S, z, e), N.isWebGL2 === !1 && (z.get("WEBGL_depth_texture"), z.get("OES_texture_float"), z.get("OES_texture_half_float"), z.get("OES_texture_half_float_linear"), z.get("OES_standard_derivatives"), z.get("OES_element_index_uint"), z.get("ANGLE_instanced_arrays")), z.get("OES_texture_float_linear"), Me = new WebGLUtils(S, z, N), F = new WebGLState(S, z, N), F.scissor(I.copy(te).multiplyScalar(O).floor()), F.viewport(V.copy(q).multiplyScalar(O).floor()), U = new WebGLInfo(), j = new WebGLProperties(), K = new WebGLTextures(S, z, F, j, N, Me, U), Y = new WebGLAttributes(S, N), re = new WebGLGeometries(S, Y, U), le = new WebGLObjects(S, re, Y, U), se = new WebGLMorphtargets(S), T = new WebGLPrograms(p, z, N), C = new WebGLMaterials(j), ie = new WebGLRenderLists(), Z = new WebGLRenderStates(), ce = new WebGLBackground(p, F, le, l), ue = new WebGLBufferRenderer(S, z, U, N), Le = new WebGLIndexedBufferRenderer(S, z, U, N), U.programs = T.programs, p.capabilities = N, p.extensions = z, p.properties = j, p.renderLists = ie, p.state = F, p.info = U;
  }
  ye();
  var he = new WebXRManager(p, S);
  this.xr = he;
  var de = new WebGLShadowMap(p, le, N.maxTextureSize);
  this.shadowMap = de, this.getContext = function() {
    return S;
  }, this.getContextAttributes = function() {
    return S.getContextAttributes();
  }, this.forceContextLoss = function() {
    var R = z.get("WEBGL_lose_context");
    R && R.loseContext();
  }, this.forceContextRestore = function() {
    var R = z.get("WEBGL_lose_context");
    R && R.restoreContext();
  }, this.getPixelRatio = function() {
    return O;
  }, this.setPixelRatio = function(R) {
    R !== void 0 && (O = R, this.setSize(E, G, !1));
  }, this.getSize = function(R) {
    return R === void 0 && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), R = new Vector2()), R.set(E, G);
  }, this.setSize = function(R, J, X) {
    if (he.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    E = R, G = J, t.width = Math.floor(R * O), t.height = Math.floor(J * O), X !== !1 && (t.style.width = R + "px", t.style.height = J + "px"), this.setViewport(0, 0, R, J);
  }, this.getDrawingBufferSize = function(R) {
    return R === void 0 && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), R = new Vector2()), R.set(E * O, G * O).floor();
  }, this.setDrawingBufferSize = function(R, J, X) {
    E = R, G = J, O = X, t.width = Math.floor(R * X), t.height = Math.floor(J * X), this.setViewport(0, 0, R, J);
  }, this.getCurrentViewport = function(R) {
    return R === void 0 && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), R = new Vector4()), R.copy(V);
  }, this.getViewport = function(R) {
    return R.copy(q);
  }, this.setViewport = function(R, J, X, ee) {
    R.isVector4 ? q.set(R.x, R.y, R.z, R.w) : q.set(R, J, X, ee), F.viewport(V.copy(q).multiplyScalar(O).floor());
  }, this.getScissor = function(R) {
    return R.copy(te);
  }, this.setScissor = function(R, J, X, ee) {
    R.isVector4 ? te.set(R.x, R.y, R.z, R.w) : te.set(R, J, X, ee), F.scissor(I.copy(te).multiplyScalar(O).floor());
  }, this.getScissorTest = function() {
    return ne;
  }, this.setScissorTest = function(R) {
    F.setScissorTest(ne = R);
  }, this.setOpaqueSort = function(R) {
    W = R;
  }, this.setTransparentSort = function(R) {
    B = R;
  }, this.getClearColor = function() {
    return ce.getClearColor();
  }, this.setClearColor = function() {
    ce.setClearColor.apply(ce, arguments);
  }, this.getClearAlpha = function() {
    return ce.getClearAlpha();
  }, this.setClearAlpha = function() {
    ce.setClearAlpha.apply(ce, arguments);
  }, this.clear = function(R, J, X) {
    var ee = 0;
    (R === void 0 || R) && (ee |= 16384), (J === void 0 || J) && (ee |= 256), (X === void 0 || X) && (ee |= 1024), S.clear(ee);
  }, this.clearColor = function() {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function() {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function() {
    this.clear(!1, !1, !0);
  }, this.dispose = function() {
    t.removeEventListener("webglcontextlost", ve, !1), t.removeEventListener("webglcontextrestored", xe, !1), ie.dispose(), Z.dispose(), j.dispose(), le.dispose(), he.dispose(), He.stop();
  };
  function ve(R) {
    R.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0;
  }
  function xe() {
    console.log("THREE.WebGLRenderer: Context Restored."), g = !1, ye();
  }
  function k(R) {
    var J = R.target;
    J.removeEventListener("dispose", k), pe(J);
  }
  function pe(R) {
    me(R), j.remove(R);
  }
  function me(R) {
    var J = j.get(R).program;
    R.program = void 0, J !== void 0 && T.releaseProgram(J);
  }
  function Ce(R, J) {
    R.render(function(X) {
      p.renderBufferImmediate(X, J);
    });
  }
  this.renderBufferImmediate = function(R, J) {
    F.initAttributes();
    var X = j.get(R);
    R.hasPositions && !X.position && (X.position = S.createBuffer()), R.hasNormals && !X.normal && (X.normal = S.createBuffer()), R.hasUvs && !X.uv && (X.uv = S.createBuffer()), R.hasColors && !X.color && (X.color = S.createBuffer());
    var ee = J.getAttributes();
    R.hasPositions && (S.bindBuffer(34962, X.position), S.bufferData(34962, R.positionArray, 35048), F.enableAttribute(ee.position), S.vertexAttribPointer(ee.position, 3, 5126, !1, 0, 0)), R.hasNormals && (S.bindBuffer(34962, X.normal), S.bufferData(34962, R.normalArray, 35048), F.enableAttribute(ee.normal), S.vertexAttribPointer(ee.normal, 3, 5126, !1, 0, 0)), R.hasUvs && (S.bindBuffer(34962, X.uv), S.bufferData(34962, R.uvArray, 35048), F.enableAttribute(ee.uv), S.vertexAttribPointer(ee.uv, 2, 5126, !1, 0, 0)), R.hasColors && (S.bindBuffer(34962, X.color), S.bufferData(34962, R.colorArray, 35048), F.enableAttribute(ee.color), S.vertexAttribPointer(ee.color, 3, 5126, !1, 0, 0)), F.disableUnusedAttributes(), S.drawArrays(4, 0, R.count), R.count = 0;
  };
  var ge = new Scene$1();
  this.renderBufferDirect = function(R, J, X, ee, fe, Te) {
    J === null && (J = ge);
    var Se = fe.isMesh && fe.matrixWorld.determinant() < 0, be = je(R, J, ee, fe);
    F.setMaterial(ee, Se);
    var we = !1;
    (x.geometry !== X.id || x.program !== be.id || x.wireframe !== (ee.wireframe === !0)) && (x.geometry = X.id, x.program = be.id, x.wireframe = ee.wireframe === !0, we = !0), (ee.morphTargets || ee.morphNormals) && (se.update(fe, X, ee, be), we = !0), fe.isInstancedMesh === !0 && (we = !0);
    var Ae = X.index, Ge = X.attributes.position;
    if (Ae === null) {
      if (Ge === void 0 || Ge.count === 0) return;
    } else if (Ae.count === 0)
      return;
    var Fe = 1;
    ee.wireframe === !0 && (Ae = re.getWireframeAttribute(X), Fe = 2);
    var Ie, Ee = ue;
    Ae !== null && (Ie = Y.get(Ae), Ee = Le, Ee.setIndex(Ie)), we && (Re(fe, X, ee, be), Ae !== null && S.bindBuffer(34963, Ie.buffer));
    var Be = Ae !== null ? Ae.count : Ge.count, ze = X.drawRange.start * Fe, $e = X.drawRange.count * Fe, ke = Te !== null ? Te.start * Fe : 0, Ye = Te !== null ? Te.count * Fe : 1 / 0, Ue = Math.max(ze, ke), Ze = Math.min(Be, ze + $e, ke + Ye) - 1, qe = Math.max(0, Ze - Ue + 1);
    if (qe !== 0) {
      if (fe.isMesh)
        ee.wireframe === !0 ? (F.setLineWidth(ee.wireframeLinewidth * D()), Ee.setMode(1)) : Ee.setMode(4);
      else if (fe.isLine) {
        var Qe = ee.linewidth;
        Qe === void 0 && (Qe = 1), F.setLineWidth(Qe * D()), fe.isLineSegments ? Ee.setMode(1) : fe.isLineLoop ? Ee.setMode(2) : Ee.setMode(3);
      } else fe.isPoints ? Ee.setMode(0) : fe.isSprite && Ee.setMode(4);
      if (fe.isInstancedMesh)
        Ee.renderInstances(X, Ue, qe, fe.count);
      else if (X.isInstancedBufferGeometry) {
        var Ke = Math.min(X.instanceCount, X._maxInstanceCount);
        Ee.renderInstances(X, Ue, qe, Ke);
      } else
        Ee.render(Ue, qe);
    }
  };
  function Re(R, J, X, ee) {
    if (!(N.isWebGL2 === !1 && (R.isInstancedMesh || J.isInstancedBufferGeometry) && z.get("ANGLE_instanced_arrays") === null)) {
      F.initAttributes();
      var fe = J.attributes, Te = ee.getAttributes(), Se = X.defaultAttributeValues;
      for (var be in Te) {
        var we = Te[be];
        if (we >= 0) {
          var Ae = fe[be];
          if (Ae !== void 0) {
            var Ge = Ae.normalized, Fe = Ae.itemSize, Ie = Y.get(Ae);
            if (Ie === void 0) continue;
            var Ee = Ie.buffer, Be = Ie.type, ze = Ie.bytesPerElement;
            if (Ae.isInterleavedBufferAttribute) {
              var $e = Ae.data, ke = $e.stride, Ye = Ae.offset;
              $e && $e.isInstancedInterleavedBuffer ? (F.enableAttributeAndDivisor(we, $e.meshPerAttribute), J._maxInstanceCount === void 0 && (J._maxInstanceCount = $e.meshPerAttribute * $e.count)) : F.enableAttribute(we), S.bindBuffer(34962, Ee), F.vertexAttribPointer(we, Fe, Be, Ge, ke * ze, Ye * ze);
            } else
              Ae.isInstancedBufferAttribute ? (F.enableAttributeAndDivisor(we, Ae.meshPerAttribute), J._maxInstanceCount === void 0 && (J._maxInstanceCount = Ae.meshPerAttribute * Ae.count)) : F.enableAttribute(we), S.bindBuffer(34962, Ee), F.vertexAttribPointer(we, Fe, Be, Ge, 0, 0);
          } else if (be === "instanceMatrix") {
            var Ie = Y.get(R.instanceMatrix);
            if (Ie === void 0) continue;
            var Ee = Ie.buffer, Be = Ie.type;
            F.enableAttributeAndDivisor(we + 0, 1), F.enableAttributeAndDivisor(we + 1, 1), F.enableAttributeAndDivisor(we + 2, 1), F.enableAttributeAndDivisor(we + 3, 1), S.bindBuffer(34962, Ee), S.vertexAttribPointer(we + 0, 4, Be, !1, 64, 0), S.vertexAttribPointer(we + 1, 4, Be, !1, 64, 16), S.vertexAttribPointer(we + 2, 4, Be, !1, 64, 32), S.vertexAttribPointer(we + 3, 4, Be, !1, 64, 48);
          } else if (Se !== void 0) {
            var Ue = Se[be];
            if (Ue !== void 0)
              switch (Ue.length) {
                case 2:
                  S.vertexAttrib2fv(we, Ue);
                  break;
                case 3:
                  S.vertexAttrib3fv(we, Ue);
                  break;
                case 4:
                  S.vertexAttrib4fv(we, Ue);
                  break;
                default:
                  S.vertexAttrib1fv(we, Ue);
              }
          }
        }
      }
      F.disableUnusedAttributes();
    }
  }
  this.compile = function(R, J) {
    d = Z.get(R, J), d.init(), R.traverse(function(ee) {
      ee.isLight && (d.pushLight(ee), ee.castShadow && d.pushShadow(ee));
    }), d.setupLights(J);
    const X = {};
    R.traverse(function(ee) {
      let fe = ee.material;
      if (fe)
        if (Array.isArray(fe))
          for (let Te = 0; Te < fe.length; Te++) {
            let Se = fe[Te];
            Se.uuid in X || (We(Se, R, ee), X[Se.uuid] = !0);
          }
        else fe.uuid in X || (We(fe, R, ee), X[fe.uuid] = !0);
    });
  };
  var De = null;
  function Oe(R) {
    he.isPresenting || De && De(R);
  }
  var He = new WebGLAnimation();
  He.setAnimationLoop(Oe), typeof window < "u" && He.setContext(window), this.setAnimationLoop = function(R) {
    De = R, he.setAnimationLoop(R), He.start();
  }, this.render = function(R, J) {
    var X, ee;
    if (arguments[2] !== void 0 && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), X = arguments[2]), arguments[3] !== void 0 && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), ee = arguments[3]), !(J && J.isCamera)) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (!g) {
      x.geometry = null, x.program = null, x.wireframe = !1, M = -1, w = null, R.autoUpdate === !0 && R.updateMatrixWorld(), J.parent === null && J.updateMatrixWorld(), he.enabled && he.isPresenting && (J = he.getCamera(J)), R.onBeforeRender(p, R, J, X || y), d = Z.get(R, J), d.init(), A.multiplyMatrices(J.projectionMatrix, J.matrixWorldInverse), Q.setFromProjectionMatrix(A), _e = this.localClippingEnabled, oe = ae.init(this.clippingPlanes, _e, J), f = ie.get(R, J), f.init(), Pe(R, J, 0, p.sortObjects), f.finish(), p.sortObjects === !0 && f.sort(W, B), oe && ae.beginShadows();
      var fe = d.state.shadowsArray;
      de.render(fe, R, J), d.setupLights(J), oe && ae.endShadows(), this.info.autoReset && this.info.reset(), X !== void 0 && this.setRenderTarget(X), ce.render(f, R, J, ee);
      var Te = f.opaque, Se = f.transparent;
      if (R.overrideMaterial) {
        var be = R.overrideMaterial;
        Te.length && Ne(Te, R, J, be), Se.length && Ne(Se, R, J, be);
      } else
        Te.length && Ne(Te, R, J), Se.length && Ne(Se, R, J);
      R.onAfterRender(p, R, J), y !== null && (K.updateRenderTargetMipmap(y), K.updateMultisampleRenderTarget(y)), F.buffers.depth.setTest(!0), F.buffers.depth.setMask(!0), F.buffers.color.setMask(!0), F.setPolygonOffset(!1), f = null, d = null;
    }
  };
  function Pe(R, J, X, ee) {
    if (R.visible !== !1) {
      var fe = R.layers.test(J.layers);
      if (fe) {
        if (R.isGroup)
          X = R.renderOrder;
        else if (R.isLOD)
          R.autoUpdate === !0 && R.update(J);
        else if (R.isLight)
          d.pushLight(R), R.castShadow && d.pushShadow(R);
        else if (R.isSprite) {
          if (!R.frustumCulled || Q.intersectsSprite(R)) {
            ee && L.setFromMatrixPosition(R.matrixWorld).applyMatrix4(A);
            var Te = le.update(R), Se = R.material;
            Se.visible && f.push(R, Te, Se, X, L.z, null);
          }
        } else if (R.isImmediateRenderObject)
          ee && L.setFromMatrixPosition(R.matrixWorld).applyMatrix4(A), f.push(R, null, R.material, X, L.z, null);
        else if ((R.isMesh || R.isLine || R.isPoints) && (R.isSkinnedMesh && R.skeleton.frame !== U.render.frame && (R.skeleton.update(), R.skeleton.frame = U.render.frame), !R.frustumCulled || Q.intersectsObject(R))) {
          ee && L.setFromMatrixPosition(R.matrixWorld).applyMatrix4(A);
          var Te = le.update(R), Se = R.material;
          if (Array.isArray(Se))
            for (var be = Te.groups, we = 0, Ae = be.length; we < Ae; we++) {
              var Ge = be[we], Fe = Se[Ge.materialIndex];
              Fe && Fe.visible && f.push(R, Te, Fe, X, L.z, Ge);
            }
          else Se.visible && f.push(R, Te, Se, X, L.z, null);
        }
      }
      for (var Ie = R.children, we = 0, Ae = Ie.length; we < Ae; we++)
        Pe(Ie[we], J, X, ee);
    }
  }
  function Ne(R, J, X, ee) {
    for (var fe = 0, Te = R.length; fe < Te; fe++) {
      var Se = R[fe], be = Se.object, we = Se.geometry, Ae = ee === void 0 ? Se.material : ee, Ge = Se.group;
      if (X.isArrayCamera) {
        P = X;
        for (var Fe = X.cameras, Ie = 0, Ee = Fe.length; Ie < Ee; Ie++) {
          var Be = Fe[Ie];
          be.layers.test(Be.layers) && (F.viewport(V.copy(Be.viewport)), d.setupLights(Be), Ve(be, J, Be, we, Ae, Ge));
        }
      } else
        P = null, Ve(be, J, X, we, Ae, Ge);
    }
  }
  function Ve(R, J, X, ee, fe, Te) {
    if (R.onBeforeRender(p, J, X, ee, fe, Te), d = Z.get(J, P || X), R.modelViewMatrix.multiplyMatrices(X.matrixWorldInverse, R.matrixWorld), R.normalMatrix.getNormalMatrix(R.modelViewMatrix), R.isImmediateRenderObject) {
      var Se = je(X, J, fe, R);
      F.setMaterial(fe), x.geometry = null, x.program = null, x.wireframe = !1, Ce(R, Se);
    } else
      p.renderBufferDirect(X, J, ee, fe, R, Te);
    R.onAfterRender(p, J, X, ee, fe, Te), d = Z.get(J, P || X);
  }
  function We(R, J, X) {
    var ee = j.get(R), fe = d.state.lights, Te = d.state.shadowsArray, Se = fe.state.version, be = T.getParameters(R, fe.state, Te, J, ae.numPlanes, ae.numIntersection, X), we = T.getProgramCacheKey(be), Ae = ee.program, Ge = !0;
    if (Ae === void 0)
      R.addEventListener("dispose", k);
    else if (Ae.cacheKey !== we)
      me(R);
    else if (ee.lightsStateVersion !== Se)
      ee.lightsStateVersion = Se, Ge = !1;
    else {
      if (be.shaderID !== void 0)
        return;
      Ge = !1;
    }
    Ge && (Ae = T.acquireProgram(be, we), ee.program = Ae, ee.uniforms = be.uniforms, ee.outputEncoding = be.outputEncoding, R.program = Ae);
    var Fe = Ae.getAttributes();
    if (R.morphTargets) {
      R.numSupportedMorphTargets = 0;
      for (var Ie = 0; Ie < p.maxMorphTargets; Ie++)
        Fe["morphTarget" + Ie] >= 0 && R.numSupportedMorphTargets++;
    }
    if (R.morphNormals) {
      R.numSupportedMorphNormals = 0;
      for (var Ie = 0; Ie < p.maxMorphNormals; Ie++)
        Fe["morphNormal" + Ie] >= 0 && R.numSupportedMorphNormals++;
    }
    var Ee = ee.uniforms;
    (!R.isShaderMaterial && !R.isRawShaderMaterial || R.clipping === !0) && (ee.numClippingPlanes = ae.numPlanes, ee.numIntersection = ae.numIntersection, Ee.clippingPlanes = ae.uniform), ee.environment = R.isMeshStandardMaterial ? J.environment : null, ee.fog = J.fog, ee.needsLights = Xe(R), ee.lightsStateVersion = Se, ee.needsLights && (Ee.ambientLightColor.value = fe.state.ambient, Ee.lightProbe.value = fe.state.probe, Ee.directionalLights.value = fe.state.directional, Ee.directionalLightShadows.value = fe.state.directionalShadow, Ee.spotLights.value = fe.state.spot, Ee.spotLightShadows.value = fe.state.spotShadow, Ee.rectAreaLights.value = fe.state.rectArea, Ee.pointLights.value = fe.state.point, Ee.pointLightShadows.value = fe.state.pointShadow, Ee.hemisphereLights.value = fe.state.hemi, Ee.directionalShadowMap.value = fe.state.directionalShadowMap, Ee.directionalShadowMatrix.value = fe.state.directionalShadowMatrix, Ee.spotShadowMap.value = fe.state.spotShadowMap, Ee.spotShadowMatrix.value = fe.state.spotShadowMatrix, Ee.pointShadowMap.value = fe.state.pointShadowMap, Ee.pointShadowMatrix.value = fe.state.pointShadowMatrix);
    var Be = ee.program.getUniforms(), ze = WebGLUniforms.seqWithValue(Be.seq, Ee);
    ee.uniformsList = ze;
  }
  function je(R, J, X, ee) {
    K.resetTextureUnits();
    var fe = J.fog, Te = X.isMeshStandardMaterial ? J.environment : null, Se = y === null ? p.outputEncoding : y.texture.encoding, be = j.get(X), we = d.state.lights;
    if (oe && (_e || R !== w)) {
      var Ae = R === w && X.id === M;
      ae.setState(
        X.clippingPlanes,
        X.clipIntersection,
        X.clipShadows,
        R,
        be,
        Ae
      );
    }
    X.version === be.__version ? (be.program === void 0 || X.fog && be.fog !== fe || be.environment !== Te || be.needsLights && be.lightsStateVersion !== we.state.version || be.numClippingPlanes !== void 0 && (be.numClippingPlanes !== ae.numPlanes || be.numIntersection !== ae.numIntersection) || be.outputEncoding !== Se) && We(X, J, ee) : (We(X, J, ee), be.__version = X.version);
    var Ge = !1, Fe = !1, Ie = !1, Ee = be.program, Be = Ee.getUniforms(), ze = be.uniforms;
    if (F.useProgram(Ee.program) && (Ge = !0, Fe = !0, Ie = !0), X.id !== M && (M = X.id, Fe = !0), Ge || w !== R) {
      if (Be.setValue(S, "projectionMatrix", R.projectionMatrix), N.logarithmicDepthBuffer && Be.setValue(
        S,
        "logDepthBufFC",
        2 / (Math.log(R.far + 1) / Math.LN2)
      ), w !== R && (w = R, Fe = !0, Ie = !0), X.isShaderMaterial || X.isMeshPhongMaterial || X.isMeshToonMaterial || X.isMeshStandardMaterial || X.envMap) {
        var $e = Be.map.cameraPosition;
        $e !== void 0 && $e.setValue(
          S,
          L.setFromMatrixPosition(R.matrixWorld)
        );
      }
      (X.isMeshPhongMaterial || X.isMeshToonMaterial || X.isMeshLambertMaterial || X.isMeshBasicMaterial || X.isMeshStandardMaterial || X.isShaderMaterial) && Be.setValue(S, "isOrthographic", R.isOrthographicCamera === !0), (X.isMeshPhongMaterial || X.isMeshToonMaterial || X.isMeshLambertMaterial || X.isMeshBasicMaterial || X.isMeshStandardMaterial || X.isShaderMaterial || X.skinning) && Be.setValue(S, "viewMatrix", R.matrixWorldInverse);
    }
    if (X.skinning) {
      Be.setOptional(S, ee, "bindMatrix"), Be.setOptional(S, ee, "bindMatrixInverse");
      var ke = ee.skeleton;
      if (ke) {
        var Ye = ke.bones;
        if (N.floatVertexTextures) {
          if (ke.boneTexture === void 0) {
            var Ue = Math.sqrt(Ye.length * 4);
            Ue = MathUtils.ceilPowerOfTwo(Ue), Ue = Math.max(Ue, 4);
            var Ze = new Float32Array(Ue * Ue * 4);
            Ze.set(ke.boneMatrices);
            var qe = new DataTexture(Ze, Ue, Ue, RGBAFormat, FloatType);
            ke.boneMatrices = Ze, ke.boneTexture = qe, ke.boneTextureSize = Ue;
          }
          Be.setValue(S, "boneTexture", ke.boneTexture, K), Be.setValue(S, "boneTextureSize", ke.boneTextureSize);
        } else
          Be.setOptional(S, ke, "boneMatrices");
      }
    }
    return (Fe || be.receiveShadow !== ee.receiveShadow) && (be.receiveShadow = ee.receiveShadow, Be.setValue(S, "receiveShadow", ee.receiveShadow)), Fe && (Be.setValue(S, "toneMappingExposure", p.toneMappingExposure), Be.setValue(S, "toneMappingWhitePoint", p.toneMappingWhitePoint), be.needsLights && Je(ze, Ie), fe && X.fog && C.refreshFogUniforms(ze, fe), C.refreshMaterialUniforms(ze, X, Te, O, G), ze.ltc_1 !== void 0 && (ze.ltc_1.value = UniformsLib.LTC_1), ze.ltc_2 !== void 0 && (ze.ltc_2.value = UniformsLib.LTC_2), WebGLUniforms.upload(S, be.uniformsList, ze, K)), X.isShaderMaterial && X.uniformsNeedUpdate === !0 && (WebGLUniforms.upload(S, be.uniformsList, ze, K), X.uniformsNeedUpdate = !1), X.isSpriteMaterial && Be.setValue(S, "center", ee.center), Be.setValue(S, "modelViewMatrix", ee.modelViewMatrix), Be.setValue(S, "normalMatrix", ee.normalMatrix), Be.setValue(S, "modelMatrix", ee.matrixWorld), Ee;
  }
  function Je(R, J) {
    R.ambientLightColor.needsUpdate = J, R.lightProbe.needsUpdate = J, R.directionalLights.needsUpdate = J, R.directionalLightShadows.needsUpdate = J, R.pointLights.needsUpdate = J, R.pointLightShadows.needsUpdate = J, R.spotLights.needsUpdate = J, R.spotLightShadows.needsUpdate = J, R.rectAreaLights.needsUpdate = J, R.hemisphereLights.needsUpdate = J;
  }
  function Xe(R) {
    return R.isMeshLambertMaterial || R.isMeshToonMaterial || R.isMeshPhongMaterial || R.isMeshStandardMaterial || R.isShadowMaterial || R.isShaderMaterial && R.lights === !0;
  }
  this.setFramebuffer = function(R) {
    v !== R && y === null && S.bindFramebuffer(36160, R), v = R;
  }, this.getActiveCubeFace = function() {
    return _;
  }, this.getActiveMipmapLevel = function() {
    return m;
  }, this.getRenderTarget = function() {
    return y;
  }, this.setRenderTarget = function(R, J, X) {
    y = R, _ = J, m = X, R && j.get(R).__webglFramebuffer === void 0 && K.setupRenderTarget(R);
    var ee = v, fe = !1;
    if (R) {
      var Te = j.get(R).__webglFramebuffer;
      R.isWebGLCubeRenderTarget ? (ee = Te[J || 0], fe = !0) : R.isWebGLMultisampleRenderTarget ? ee = j.get(R).__webglMultisampledFramebuffer : ee = Te, V.copy(R.viewport), I.copy(R.scissor), $ = R.scissorTest;
    } else
      V.copy(q).multiplyScalar(O).floor(), I.copy(te).multiplyScalar(O).floor(), $ = ne;
    if (b !== ee && (S.bindFramebuffer(36160, ee), b = ee), F.viewport(V), F.scissor(I), F.setScissorTest($), fe) {
      var Se = j.get(R.texture);
      S.framebufferTexture2D(36160, 36064, 34069 + (J || 0), Se.__webglTexture, X || 0);
    }
  }, this.readRenderTargetPixels = function(R, J, X, ee, fe, Te, Se) {
    if (!(R && R.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    var be = j.get(R).__webglFramebuffer;
    if (R.isWebGLCubeRenderTarget && Se !== void 0 && (be = be[Se]), be) {
      var we = !1;
      be !== b && (S.bindFramebuffer(36160, be), we = !0);
      try {
        var Ae = R.texture, Ge = Ae.format, Fe = Ae.type;
        if (Ge !== RGBAFormat && Me.convert(Ge) !== S.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        if (Fe !== UnsignedByteType && Me.convert(Fe) !== S.getParameter(35738) && // IE11, Edge and Chrome Mac < 52 (#9513)
        !(Fe === FloatType && (N.isWebGL2 || z.get("OES_texture_float") || z.get("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
        !(Fe === HalfFloatType && (N.isWebGL2 ? z.get("EXT_color_buffer_float") : z.get("EXT_color_buffer_half_float")))) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        S.checkFramebufferStatus(36160) === 36053 ? J >= 0 && J <= R.width - ee && X >= 0 && X <= R.height - fe && S.readPixels(J, X, ee, fe, Me.convert(Ge), Me.convert(Fe), Te) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
      } finally {
        we && S.bindFramebuffer(36160, b);
      }
    }
  }, this.copyFramebufferToTexture = function(R, J, X) {
    X === void 0 && (X = 0);
    var ee = Math.pow(2, -X), fe = Math.floor(J.image.width * ee), Te = Math.floor(J.image.height * ee), Se = Me.convert(J.format);
    K.setTexture2D(J, 0), S.copyTexImage2D(3553, X, Se, R.x, R.y, fe, Te, 0), F.unbindTexture();
  }, this.copyTextureToTexture = function(R, J, X, ee) {
    ee === void 0 && (ee = 0);
    var fe = J.image.width, Te = J.image.height, Se = Me.convert(X.format), be = Me.convert(X.type);
    K.setTexture2D(X, 0), J.isDataTexture ? S.texSubImage2D(3553, ee, R.x, R.y, fe, Te, Se, be, J.image.data) : J.isCompressedTexture ? S.compressedTexSubImage2D(3553, ee, R.x, R.y, J.mipmaps[0].width, J.mipmaps[0].height, Se, J.mipmaps[0].data) : S.texSubImage2D(3553, ee, R.x, R.y, Se, be, J.image), ee === 0 && X.generateMipmaps && S.generateMipmap(3553), F.unbindTexture();
  }, this.initTexture = function(R) {
    K.setTexture2D(R, 0), F.unbindTexture();
  }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
function FogExp2(e, t) {
  this.name = "", this.color = new Color(e), this.density = t !== void 0 ? t : 25e-5;
}
Object.assign(FogExp2.prototype, {
  isFogExp2: !0,
  clone: function() {
    return new FogExp2(this.color, this.density);
  },
  toJSON: function() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
});
function Fog(e, t, r) {
  this.name = "", this.color = new Color(e), this.near = t !== void 0 ? t : 1, this.far = r !== void 0 ? r : 1e3;
}
Object.assign(Fog.prototype, {
  isFog: !0,
  clone: function() {
    return new Fog(this.color, this.near, this.far);
  },
  toJSON: function() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
});
function InterleavedBuffer(e, t) {
  this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = StaticDrawUsage, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
}
Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
  set: function(e) {
    e === !0 && this.version++;
  }
});
Object.assign(InterleavedBuffer.prototype, {
  isInterleavedBuffer: !0,
  onUploadCallback: function() {
  },
  setUsage: function(e) {
    return this.usage = e, this;
  },
  copy: function(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  },
  copyAt: function(e, t, r) {
    e *= this.stride, r *= t.stride;
    for (var n = 0, a = this.stride; n < a; n++)
      this.array[e + n] = t.array[r + n];
    return this;
  },
  set: function(e, t) {
    return t === void 0 && (t = 0), this.array.set(e, t), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  onUpload: function(e) {
    return this.onUploadCallback = e, this;
  }
});
var _vector$6 = new Vector3();
function InterleavedBufferAttribute(e, t, r, n) {
  this.name = "", this.data = e, this.itemSize = t, this.offset = r, this.normalized = n === !0;
}
Object.defineProperties(InterleavedBufferAttribute.prototype, {
  count: {
    get: function() {
      return this.data.count;
    }
  },
  array: {
    get: function() {
      return this.data.array;
    }
  }
});
Object.assign(InterleavedBufferAttribute.prototype, {
  isInterleavedBufferAttribute: !0,
  applyMatrix4: function(e) {
    for (var t = 0, r = this.data.count; t < r; t++)
      _vector$6.x = this.getX(t), _vector$6.y = this.getY(t), _vector$6.z = this.getZ(t), _vector$6.applyMatrix4(e), this.setXYZ(t, _vector$6.x, _vector$6.y, _vector$6.z);
    return this;
  },
  setX: function(e, t) {
    return this.data.array[e * this.data.stride + this.offset] = t, this;
  },
  setY: function(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  },
  setZ: function(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  },
  setW: function(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  },
  getX: function(e) {
    return this.data.array[e * this.data.stride + this.offset];
  },
  getY: function(e) {
    return this.data.array[e * this.data.stride + this.offset + 1];
  },
  getZ: function(e) {
    return this.data.array[e * this.data.stride + this.offset + 2];
  },
  getW: function(e) {
    return this.data.array[e * this.data.stride + this.offset + 3];
  },
  setXY: function(e, t, r) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = r, this;
  },
  setXYZ: function(e, t, r, n) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = n, this;
  },
  setXYZW: function(e, t, r, n, a) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = n, this.data.array[e + 3] = a, this;
  },
  clone: function() {
    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
    for (var e = [], t = 0; t < this.count; t++)
      for (var r = t * this.data.stride + this.offset, n = 0; n < this.itemSize; n++)
        e.push(this.data.array[r + n]);
    return new BufferAttribute(new this.array.constructor(e), this.itemSize, this.normalized);
  },
  toJSON: function() {
    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
    for (var e = [], t = 0; t < this.count; t++)
      for (var r = t * this.data.stride + this.offset, n = 0; n < this.itemSize; n++)
        e.push(this.data.array[r + n]);
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: e,
      normalized: this.normalized
    };
  }
});
function SpriteMaterial(e) {
  Material.call(this), this.type = "SpriteMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e);
}
SpriteMaterial.prototype = Object.create(Material.prototype);
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = !0;
SpriteMaterial.prototype.copy = function(e) {
  return Material.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this;
};
var _geometry, _intersectPoint = new Vector3(), _worldScale = new Vector3(), _mvPosition = new Vector3(), _alignedPosition = new Vector2(), _rotatedPosition = new Vector2(), _viewWorldMatrix = new Matrix4(), _vA$1 = new Vector3(), _vB$1 = new Vector3(), _vC$1 = new Vector3(), _uvA$1 = new Vector2(), _uvB$1 = new Vector2(), _uvC$1 = new Vector2();
function Sprite(e) {
  if (Object3D.call(this), this.type = "Sprite", _geometry === void 0) {
    _geometry = new BufferGeometry();
    var t = new Float32Array([
      -0.5,
      -0.5,
      0,
      0,
      0,
      0.5,
      -0.5,
      0,
      1,
      0,
      0.5,
      0.5,
      0,
      1,
      1,
      -0.5,
      0.5,
      0,
      0,
      1
    ]), r = new InterleavedBuffer(t, 5);
    _geometry.setIndex([0, 1, 2, 0, 2, 3]), _geometry.setAttribute("position", new InterleavedBufferAttribute(r, 3, 0, !1)), _geometry.setAttribute("uv", new InterleavedBufferAttribute(r, 2, 3, !1));
  }
  this.geometry = _geometry, this.material = e !== void 0 ? e : new SpriteMaterial(), this.center = new Vector2(0.5, 0.5);
}
Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Sprite,
  isSprite: !0,
  raycast: function(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), _worldScale.setFromMatrixScale(this.matrixWorld), _viewWorldMatrix.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), _mvPosition.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && _worldScale.multiplyScalar(-_mvPosition.z);
    var r = this.material.rotation, n, a;
    r !== 0 && (a = Math.cos(r), n = Math.sin(r));
    var o = this.center;
    transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, o, _worldScale, n, a), transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, o, _worldScale, n, a), transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, o, _worldScale, n, a), _uvA$1.set(0, 0), _uvB$1.set(1, 0), _uvC$1.set(1, 1);
    var s = e.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, !1, _intersectPoint);
    if (!(s === null && (transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, o, _worldScale, n, a), _uvB$1.set(0, 1), s = e.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, !1, _intersectPoint), s === null))) {
      var l = e.ray.origin.distanceTo(_intersectPoint);
      l < e.near || l > e.far || t.push({
        distance: l,
        point: _intersectPoint.clone(),
        uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
        face: null,
        object: this
      });
    }
  },
  clone: function() {
    return new this.constructor(this.material).copy(this);
  },
  copy: function(e) {
    return Object3D.prototype.copy.call(this, e), e.center !== void 0 && this.center.copy(e.center), this;
  }
});
function transformVertex(e, t, r, n, a, o) {
  _alignedPosition.subVectors(e, r).addScalar(0.5).multiply(n), a !== void 0 ? (_rotatedPosition.x = o * _alignedPosition.x - a * _alignedPosition.y, _rotatedPosition.y = a * _alignedPosition.x + o * _alignedPosition.y) : _rotatedPosition.copy(_alignedPosition), e.copy(t), e.x += _rotatedPosition.x, e.y += _rotatedPosition.y, e.applyMatrix4(_viewWorldMatrix);
}
var _v1$4 = new Vector3(), _v2$2 = new Vector3();
function LOD() {
  Object3D.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
    levels: {
      enumerable: !0,
      value: []
    }
  }), this.autoUpdate = !0;
}
LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: LOD,
  isLOD: !0,
  copy: function(e) {
    Object3D.prototype.copy.call(this, e, !1);
    for (var t = e.levels, r = 0, n = t.length; r < n; r++) {
      var a = t[r];
      this.addLevel(a.object.clone(), a.distance);
    }
    return this.autoUpdate = e.autoUpdate, this;
  },
  addLevel: function(e, t) {
    t === void 0 && (t = 0), t = Math.abs(t);
    for (var r = this.levels, n = 0; n < r.length && !(t < r[n].distance); n++)
      ;
    return r.splice(n, 0, { distance: t, object: e }), this.add(e), this;
  },
  getCurrentLevel: function() {
    return this._currentLevel;
  },
  getObjectForDistance: function(e) {
    var t = this.levels;
    if (t.length > 0) {
      for (var r = 1, n = t.length; r < n && !(e < t[r].distance); r++)
        ;
      return t[r - 1].object;
    }
    return null;
  },
  raycast: function(e, t) {
    var r = this.levels;
    if (r.length > 0) {
      _v1$4.setFromMatrixPosition(this.matrixWorld);
      var n = e.ray.origin.distanceTo(_v1$4);
      this.getObjectForDistance(n).raycast(e, t);
    }
  },
  update: function(e) {
    var t = this.levels;
    if (t.length > 1) {
      _v1$4.setFromMatrixPosition(e.matrixWorld), _v2$2.setFromMatrixPosition(this.matrixWorld);
      var r = _v1$4.distanceTo(_v2$2) / e.zoom;
      t[0].object.visible = !0;
      for (var n = 1, a = t.length; n < a && r >= t[n].distance; n++)
        t[n - 1].object.visible = !1, t[n].object.visible = !0;
      for (this._currentLevel = n - 1; n < a; n++)
        t[n].object.visible = !1;
    }
  },
  toJSON: function(e) {
    var t = Object3D.prototype.toJSON.call(this, e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    for (var r = this.levels, n = 0, a = r.length; n < a; n++) {
      var o = r[n];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance
      });
    }
    return t;
  }
});
function SkinnedMesh(e, t) {
  e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Mesh.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Matrix4(), this.bindMatrixInverse = new Matrix4();
}
SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: SkinnedMesh,
  isSkinnedMesh: !0,
  bind: function(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t);
  },
  pose: function() {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function() {
    for (var e = new Vector4(), t = this.geometry.attributes.skinWeight, r = 0, n = t.count; r < n; r++) {
      e.x = t.getX(r), e.y = t.getY(r), e.z = t.getZ(r), e.w = t.getW(r);
      var a = 1 / e.manhattanLength();
      a !== 1 / 0 ? e.multiplyScalar(a) : e.set(1, 0, 0, 0), t.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  },
  updateMatrixWorld: function(e) {
    Mesh.prototype.updateMatrixWorld.call(this, e), this.bindMode === "attached" ? this.bindMatrixInverse.getInverse(this.matrixWorld) : this.bindMode === "detached" ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  },
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  },
  boneTransform: function() {
    var e = new Vector3(), t = new Vector4(), r = new Vector4(), n = new Vector3(), a = new Matrix4();
    return function(o, s) {
      var l = this.skeleton, c = this.geometry;
      t.fromBufferAttribute(c.attributes.skinIndex, o), r.fromBufferAttribute(c.attributes.skinWeight, o), e.fromBufferAttribute(c.attributes.position, o).applyMatrix4(this.bindMatrix), s.set(0, 0, 0);
      for (var u = 0; u < 4; u++) {
        var h = r.getComponent(u);
        if (h !== 0) {
          var f = t.getComponent(u);
          a.multiplyMatrices(l.bones[f].matrixWorld, l.boneInverses[f]), s.addScaledVector(n.copy(e).applyMatrix4(a), h);
        }
      }
      return s.applyMatrix4(this.bindMatrixInverse);
    };
  }()
});
var _offsetMatrix = new Matrix4(), _identityMatrix = new Matrix4();
function Skeleton(e, t) {
  if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(this.bones.length * 16), this.frame = -1, t === void 0)
    this.calculateInverses();
  else if (this.bones.length === t.length)
    this.boneInverses = t.slice(0);
  else {
    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
    for (var r = 0, n = this.bones.length; r < n; r++)
      this.boneInverses.push(new Matrix4());
  }
}
Object.assign(Skeleton.prototype, {
  calculateInverses: function() {
    this.boneInverses = [];
    for (var e = 0, t = this.bones.length; e < t; e++) {
      var r = new Matrix4();
      this.bones[e] && r.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(r);
    }
  },
  pose: function() {
    var e, t, r;
    for (t = 0, r = this.bones.length; t < r; t++)
      e = this.bones[t], e && e.matrixWorld.getInverse(this.boneInverses[t]);
    for (t = 0, r = this.bones.length; t < r; t++)
      e = this.bones[t], e && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale));
  },
  update: function() {
    for (var e = this.bones, t = this.boneInverses, r = this.boneMatrices, n = this.boneTexture, a = 0, o = e.length; a < o; a++) {
      var s = e[a] ? e[a].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(s, t[a]), _offsetMatrix.toArray(r, a * 16);
    }
    n !== void 0 && (n.needsUpdate = !0);
  },
  clone: function() {
    return new Skeleton(this.bones, this.boneInverses);
  },
  getBoneByName: function(e) {
    for (var t = 0, r = this.bones.length; t < r; t++) {
      var n = this.bones[t];
      if (n.name === e)
        return n;
    }
  },
  dispose: function() {
    this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0);
  }
});
function Bone() {
  Object3D.call(this), this.type = "Bone";
}
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Bone,
  isBone: !0
});
var _instanceLocalMatrix = new Matrix4(), _instanceWorldMatrix = new Matrix4(), _instanceIntersects = [], _mesh = new Mesh();
function InstancedMesh(e, t, r) {
  Mesh.call(this, e, t), this.instanceMatrix = new BufferAttribute(new Float32Array(r * 16), 16), this.count = r, this.frustumCulled = !1;
}
InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: InstancedMesh,
  isInstancedMesh: !0,
  getMatrixAt: function(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  },
  raycast: function(e, t) {
    var r = this.matrixWorld, n = this.count;
    if (_mesh.geometry = this.geometry, _mesh.material = this.material, _mesh.material !== void 0)
      for (var a = 0; a < n; a++) {
        this.getMatrixAt(a, _instanceLocalMatrix), _instanceWorldMatrix.multiplyMatrices(r, _instanceLocalMatrix), _mesh.matrixWorld = _instanceWorldMatrix, _mesh.raycast(e, _instanceIntersects);
        for (var o = 0, s = _instanceIntersects.length; o < s; o++) {
          var l = _instanceIntersects[o];
          l.instanceId = a, l.object = this, t.push(l);
        }
        _instanceIntersects.length = 0;
      }
  },
  setMatrixAt: function(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  },
  updateMorphTargets: function() {
  }
});
function LineBasicMaterial(e) {
  Material.call(this), this.type = "LineBasicMaterial", this.color = new Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(e);
}
LineBasicMaterial.prototype = Object.create(Material.prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = !0;
LineBasicMaterial.prototype.copy = function(e) {
  return Material.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.morphTargets = e.morphTargets, this;
};
var _start = new Vector3(), _end = new Vector3(), _inverseMatrix$1 = new Matrix4(), _ray$1 = new Ray(), _sphere$2 = new Sphere();
function Line(e, t, r) {
  r === 1 && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), Object3D.call(this), this.type = "Line", this.geometry = e !== void 0 ? e : new BufferGeometry(), this.material = t !== void 0 ? t : new LineBasicMaterial(), this.updateMorphTargets();
}
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Line,
  isLine: !0,
  computeLineDistances: function() {
    var e = this.geometry;
    if (e.isBufferGeometry)
      if (e.index === null) {
        for (var t = e.attributes.position, r = [0], n = 1, a = t.count; n < a; n++)
          _start.fromBufferAttribute(t, n - 1), _end.fromBufferAttribute(t, n), r[n] = r[n - 1], r[n] += _start.distanceTo(_end);
        e.setAttribute("lineDistance", new Float32BufferAttribute(r, 1));
      } else
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else if (e.isGeometry) {
      var o = e.vertices, r = e.lineDistances;
      r[0] = 0;
      for (var n = 1, a = o.length; n < a; n++)
        r[n] = r[n - 1], r[n] += o[n - 1].distanceTo(o[n]);
    }
    return this;
  },
  raycast: function(e, t) {
    var r = this.geometry, n = this.matrixWorld, a = e.params.Line.threshold;
    if (r.boundingSphere === null && r.computeBoundingSphere(), _sphere$2.copy(r.boundingSphere), _sphere$2.applyMatrix4(n), _sphere$2.radius += a, e.ray.intersectsSphere(_sphere$2) !== !1) {
      _inverseMatrix$1.getInverse(n), _ray$1.copy(e.ray).applyMatrix4(_inverseMatrix$1);
      var o = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = o * o, l = new Vector3(), c = new Vector3(), u = new Vector3(), h = new Vector3(), f = this && this.isLineSegments ? 2 : 1;
      if (r.isBufferGeometry) {
        var d = r.index, p = r.attributes, g = p.position.array;
        if (d !== null)
          for (var v = d.array, _ = 0, m = v.length - 1; _ < m; _ += f) {
            var y = v[_], b = v[_ + 1];
            l.fromArray(g, y * 3), c.fromArray(g, b * 3);
            var M = _ray$1.distanceSqToSegment(l, c, h, u);
            if (!(M > s)) {
              h.applyMatrix4(this.matrixWorld);
              var x = e.ray.origin.distanceTo(h);
              x < e.near || x > e.far || t.push({
                distance: x,
                // What do we want? intersection point on the ray or on the segment??
                // point: raycaster.ray.at( distance ),
                point: u.clone().applyMatrix4(this.matrixWorld),
                index: _,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
        else
          for (var _ = 0, m = g.length / 3 - 1; _ < m; _ += f) {
            l.fromArray(g, 3 * _), c.fromArray(g, 3 * _ + 3);
            var M = _ray$1.distanceSqToSegment(l, c, h, u);
            if (!(M > s)) {
              h.applyMatrix4(this.matrixWorld);
              var x = e.ray.origin.distanceTo(h);
              x < e.near || x > e.far || t.push({
                distance: x,
                // What do we want? intersection point on the ray or on the segment??
                // point: raycaster.ray.at( distance ),
                point: u.clone().applyMatrix4(this.matrixWorld),
                index: _,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
      } else if (r.isGeometry)
        for (var w = r.vertices, P = w.length, _ = 0; _ < P - 1; _ += f) {
          var M = _ray$1.distanceSqToSegment(w[_], w[_ + 1], h, u);
          if (!(M > s)) {
            h.applyMatrix4(this.matrixWorld);
            var x = e.ray.origin.distanceTo(h);
            x < e.near || x > e.far || t.push({
              distance: x,
              // What do we want? intersection point on the ray or on the segment??
              // point: raycaster.ray.at( distance ),
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: _,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
    }
  },
  updateMorphTargets: function() {
    var e = this.geometry, t, r, n;
    if (e.isBufferGeometry) {
      var a = e.morphAttributes, o = Object.keys(a);
      if (o.length > 0) {
        var s = a[o[0]];
        if (s !== void 0)
          for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, r = s.length; t < r; t++)
            n = s[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t;
      }
    } else {
      var l = e.morphTargets;
      l !== void 0 && l.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
var _start$1 = new Vector3(), _end$1 = new Vector3();
function LineSegments(e, t) {
  Line.call(this, e, t), this.type = "LineSegments";
}
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineSegments,
  isLineSegments: !0,
  computeLineDistances: function() {
    var e = this.geometry;
    if (e.isBufferGeometry)
      if (e.index === null) {
        for (var t = e.attributes.position, r = [], n = 0, a = t.count; n < a; n += 2)
          _start$1.fromBufferAttribute(t, n), _end$1.fromBufferAttribute(t, n + 1), r[n] = n === 0 ? 0 : r[n - 1], r[n + 1] = r[n] + _start$1.distanceTo(_end$1);
        e.setAttribute("lineDistance", new Float32BufferAttribute(r, 1));
      } else
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else if (e.isGeometry)
      for (var o = e.vertices, r = e.lineDistances, n = 0, a = o.length; n < a; n += 2)
        _start$1.copy(o[n]), _end$1.copy(o[n + 1]), r[n] = n === 0 ? 0 : r[n - 1], r[n + 1] = r[n] + _start$1.distanceTo(_end$1);
    return this;
  }
});
function LineLoop(e, t) {
  Line.call(this, e, t), this.type = "LineLoop";
}
LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineLoop,
  isLineLoop: !0
});
function PointsMaterial(e) {
  Material.call(this), this.type = "PointsMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e);
}
PointsMaterial.prototype = Object.create(Material.prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = !0;
PointsMaterial.prototype.copy = function(e) {
  return Material.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this;
};
var _inverseMatrix$2 = new Matrix4(), _ray$2 = new Ray(), _sphere$3 = new Sphere(), _position$1 = new Vector3();
function Points(e, t) {
  Object3D.call(this), this.type = "Points", this.geometry = e !== void 0 ? e : new BufferGeometry(), this.material = t !== void 0 ? t : new PointsMaterial(), this.updateMorphTargets();
}
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Points,
  isPoints: !0,
  raycast: function(e, t) {
    var r = this.geometry, n = this.matrixWorld, a = e.params.Points.threshold;
    if (r.boundingSphere === null && r.computeBoundingSphere(), _sphere$3.copy(r.boundingSphere), _sphere$3.applyMatrix4(n), _sphere$3.radius += a, e.ray.intersectsSphere(_sphere$3) !== !1) {
      _inverseMatrix$2.getInverse(n), _ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$2);
      var o = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = o * o;
      if (r.isBufferGeometry) {
        var l = r.index, c = r.attributes, u = c.position.array;
        if (l !== null)
          for (var h = l.array, f = 0, d = h.length; f < d; f++) {
            var p = h[f];
            _position$1.fromArray(u, p * 3), testPoint(_position$1, p, s, n, e, t, this);
          }
        else
          for (var f = 0, g = u.length / 3; f < g; f++)
            _position$1.fromArray(u, f * 3), testPoint(_position$1, f, s, n, e, t, this);
      } else
        for (var v = r.vertices, f = 0, g = v.length; f < g; f++)
          testPoint(v[f], f, s, n, e, t, this);
    }
  },
  updateMorphTargets: function() {
    var e = this.geometry, t, r, n;
    if (e.isBufferGeometry) {
      var a = e.morphAttributes, o = Object.keys(a);
      if (o.length > 0) {
        var s = a[o[0]];
        if (s !== void 0)
          for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, r = s.length; t < r; t++)
            n = s[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t;
      }
    } else {
      var l = e.morphTargets;
      l !== void 0 && l.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function testPoint(e, t, r, n, a, o, s) {
  var l = _ray$2.distanceSqToPoint(e);
  if (l < r) {
    var c = new Vector3();
    _ray$2.closestPointToPoint(e, c), c.applyMatrix4(n);
    var u = a.ray.origin.distanceTo(c);
    if (u < a.near || u > a.far) return;
    o.push({
      distance: u,
      distanceToRay: Math.sqrt(l),
      point: c,
      index: t,
      face: null,
      object: s
    });
  }
}
function VideoTexture(e, t, r, n, a, o, s, l, c) {
  Texture.call(this, e, t, r, n, a, o, s, l, c), this.format = s !== void 0 ? s : RGBFormat, this.minFilter = o !== void 0 ? o : LinearFilter, this.magFilter = a !== void 0 ? a : LinearFilter, this.generateMipmaps = !1;
}
VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
  constructor: VideoTexture,
  isVideoTexture: !0,
  update: function() {
    var e = this.image;
    e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
});
function CompressedTexture(e, t, r, n, a, o, s, l, c, u, h, f) {
  Texture.call(this, null, o, s, l, c, u, n, a, h, f), this.image = { width: t, height: r }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
}
CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = !0;
function CanvasTexture(e, t, r, n, a, o, s, l, c) {
  Texture.call(this, e, t, r, n, a, o, s, l, c), this.needsUpdate = !0;
}
CanvasTexture.prototype = Object.create(Texture.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = !0;
function DepthTexture(e, t, r, n, a, o, s, l, c, u) {
  if (u = u !== void 0 ? u : DepthFormat, u !== DepthFormat && u !== DepthStencilFormat)
    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
  r === void 0 && u === DepthFormat && (r = UnsignedShortType), r === void 0 && u === DepthStencilFormat && (r = UnsignedInt248Type), Texture.call(this, null, n, a, o, s, l, u, r, c), this.image = { width: e, height: t }, this.magFilter = s !== void 0 ? s : NearestFilter, this.minFilter = l !== void 0 ? l : NearestFilter, this.flipY = !1, this.generateMipmaps = !1;
}
DepthTexture.prototype = Object.create(Texture.prototype);
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = !0;
function WireframeGeometry(e) {
  BufferGeometry.call(this), this.type = "WireframeGeometry";
  var t = [], r, n, a, o, s, l = [0, 0], c = {}, u, h, f, d, p = ["a", "b", "c"], g;
  if (e && e.isGeometry) {
    var v = e.faces;
    for (r = 0, a = v.length; r < a; r++) {
      var _ = v[r];
      for (n = 0; n < 3; n++)
        h = _[p[n]], f = _[p[(n + 1) % 3]], l[0] = Math.min(h, f), l[1] = Math.max(h, f), d = l[0] + "," + l[1], c[d] === void 0 && (c[d] = { index1: l[0], index2: l[1] });
    }
    for (d in c)
      u = c[d], g = e.vertices[u.index1], t.push(g.x, g.y, g.z), g = e.vertices[u.index2], t.push(g.x, g.y, g.z);
  } else if (e && e.isBufferGeometry) {
    var m, y, b, M, x, w, P, V;
    if (g = new Vector3(), e.index !== null) {
      for (m = e.attributes.position, y = e.index, b = e.groups, b.length === 0 && (b = [{ start: 0, count: y.count, materialIndex: 0 }]), o = 0, s = b.length; o < s; ++o)
        for (M = b[o], x = M.start, w = M.count, r = x, a = x + w; r < a; r += 3)
          for (n = 0; n < 3; n++)
            h = y.getX(r + n), f = y.getX(r + (n + 1) % 3), l[0] = Math.min(h, f), l[1] = Math.max(h, f), d = l[0] + "," + l[1], c[d] === void 0 && (c[d] = { index1: l[0], index2: l[1] });
      for (d in c)
        u = c[d], g.fromBufferAttribute(m, u.index1), t.push(g.x, g.y, g.z), g.fromBufferAttribute(m, u.index2), t.push(g.x, g.y, g.z);
    } else
      for (m = e.attributes.position, r = 0, a = m.count / 3; r < a; r++)
        for (n = 0; n < 3; n++)
          P = 3 * r + n, g.fromBufferAttribute(m, P), t.push(g.x, g.y, g.z), V = 3 * r + (n + 1) % 3, g.fromBufferAttribute(m, V), t.push(g.x, g.y, g.z);
  }
  this.setAttribute("position", new Float32BufferAttribute(t, 3));
}
WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
WireframeGeometry.prototype.constructor = WireframeGeometry;
function ParametricGeometry(e, t, r) {
  Geometry$1.call(this), this.type = "ParametricGeometry", this.parameters = {
    func: e,
    slices: t,
    stacks: r
  }, this.fromBufferGeometry(new ParametricBufferGeometry(e, t, r)), this.mergeVertices();
}
ParametricGeometry.prototype = Object.create(Geometry$1.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
function ParametricBufferGeometry(e, t, r) {
  BufferGeometry.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
    func: e,
    slices: t,
    stacks: r
  };
  var n = [], a = [], o = [], s = [], l = 1e-5, c = new Vector3(), u = new Vector3(), h = new Vector3(), f = new Vector3(), d = new Vector3(), p, g;
  e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  var v = t + 1;
  for (p = 0; p <= r; p++) {
    var _ = p / r;
    for (g = 0; g <= t; g++) {
      var m = g / t;
      e(m, _, u), a.push(u.x, u.y, u.z), m - l >= 0 ? (e(m - l, _, h), f.subVectors(u, h)) : (e(m + l, _, h), f.subVectors(h, u)), _ - l >= 0 ? (e(m, _ - l, h), d.subVectors(u, h)) : (e(m, _ + l, h), d.subVectors(h, u)), c.crossVectors(f, d).normalize(), o.push(c.x, c.y, c.z), s.push(m, _);
    }
  }
  for (p = 0; p < r; p++)
    for (g = 0; g < t; g++) {
      var y = p * v + g, b = p * v + g + 1, M = (p + 1) * v + g + 1, x = (p + 1) * v + g;
      n.push(y, b, x), n.push(b, M, x);
    }
  this.setIndex(n), this.setAttribute("position", new Float32BufferAttribute(a, 3)), this.setAttribute("normal", new Float32BufferAttribute(o, 3)), this.setAttribute("uv", new Float32BufferAttribute(s, 2));
}
ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
function PolyhedronGeometry(e, t, r, n) {
  Geometry$1.call(this), this.type = "PolyhedronGeometry", this.parameters = {
    vertices: e,
    indices: t,
    radius: r,
    detail: n
  }, this.fromBufferGeometry(new PolyhedronBufferGeometry(e, t, r, n)), this.mergeVertices();
}
PolyhedronGeometry.prototype = Object.create(Geometry$1.prototype);
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
function PolyhedronBufferGeometry(e, t, r, n) {
  BufferGeometry.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
    vertices: e,
    indices: t,
    radius: r,
    detail: n
  }, r = r || 1, n = n || 0;
  var a = [], o = [];
  s(n), c(r), u(), this.setAttribute("position", new Float32BufferAttribute(a, 3)), this.setAttribute("normal", new Float32BufferAttribute(a.slice(), 3)), this.setAttribute("uv", new Float32BufferAttribute(o, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
  function s(m) {
    for (var y = new Vector3(), b = new Vector3(), M = new Vector3(), x = 0; x < t.length; x += 3)
      d(t[x + 0], y), d(t[x + 1], b), d(t[x + 2], M), l(y, b, M, m);
  }
  function l(m, y, b, M) {
    var x = Math.pow(2, M), w = [], P, V;
    for (P = 0; P <= x; P++) {
      w[P] = [];
      var I = m.clone().lerp(b, P / x), $ = y.clone().lerp(b, P / x), E = x - P;
      for (V = 0; V <= E; V++)
        V === 0 && P === x ? w[P][V] = I : w[P][V] = I.clone().lerp($, V / E);
    }
    for (P = 0; P < x; P++)
      for (V = 0; V < 2 * (x - P) - 1; V++) {
        var G = Math.floor(V / 2);
        V % 2 === 0 ? (f(w[P][G + 1]), f(w[P + 1][G]), f(w[P][G])) : (f(w[P][G + 1]), f(w[P + 1][G + 1]), f(w[P + 1][G]));
      }
  }
  function c(m) {
    for (var y = new Vector3(), b = 0; b < a.length; b += 3)
      y.x = a[b + 0], y.y = a[b + 1], y.z = a[b + 2], y.normalize().multiplyScalar(m), a[b + 0] = y.x, a[b + 1] = y.y, a[b + 2] = y.z;
  }
  function u() {
    for (var m = new Vector3(), y = 0; y < a.length; y += 3) {
      m.x = a[y + 0], m.y = a[y + 1], m.z = a[y + 2];
      var b = v(m) / 2 / Math.PI + 0.5, M = _(m) / Math.PI + 0.5;
      o.push(b, 1 - M);
    }
    p(), h();
  }
  function h() {
    for (var m = 0; m < o.length; m += 6) {
      var y = o[m + 0], b = o[m + 2], M = o[m + 4], x = Math.max(y, b, M), w = Math.min(y, b, M);
      x > 0.9 && w < 0.1 && (y < 0.2 && (o[m + 0] += 1), b < 0.2 && (o[m + 2] += 1), M < 0.2 && (o[m + 4] += 1));
    }
  }
  function f(m) {
    a.push(m.x, m.y, m.z);
  }
  function d(m, y) {
    var b = m * 3;
    y.x = e[b + 0], y.y = e[b + 1], y.z = e[b + 2];
  }
  function p() {
    for (var m = new Vector3(), y = new Vector3(), b = new Vector3(), M = new Vector3(), x = new Vector2(), w = new Vector2(), P = new Vector2(), V = 0, I = 0; V < a.length; V += 9, I += 6) {
      m.set(a[V + 0], a[V + 1], a[V + 2]), y.set(a[V + 3], a[V + 4], a[V + 5]), b.set(a[V + 6], a[V + 7], a[V + 8]), x.set(o[I + 0], o[I + 1]), w.set(o[I + 2], o[I + 3]), P.set(o[I + 4], o[I + 5]), M.copy(m).add(y).add(b).divideScalar(3);
      var $ = v(M);
      g(x, I + 0, m, $), g(w, I + 2, y, $), g(P, I + 4, b, $);
    }
  }
  function g(m, y, b, M) {
    M < 0 && m.x === 1 && (o[y] = m.x - 1), b.x === 0 && b.z === 0 && (o[y] = M / 2 / Math.PI + 0.5);
  }
  function v(m) {
    return Math.atan2(m.z, -m.x);
  }
  function _(m) {
    return Math.atan2(-m.y, Math.sqrt(m.x * m.x + m.z * m.z));
  }
}
PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
function TetrahedronGeometry(e, t) {
  Geometry$1.call(this), this.type = "TetrahedronGeometry", this.parameters = {
    radius: e,
    detail: t
  }, this.fromBufferGeometry(new TetrahedronBufferGeometry(e, t)), this.mergeVertices();
}
TetrahedronGeometry.prototype = Object.create(Geometry$1.prototype);
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
function TetrahedronBufferGeometry(e, t) {
  var r = [
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    1,
    -1,
    -1
  ], n = [
    2,
    1,
    0,
    0,
    3,
    2,
    1,
    3,
    0,
    2,
    3,
    1
  ];
  PolyhedronBufferGeometry.call(this, r, n, e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
    radius: e,
    detail: t
  };
}
TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
function OctahedronGeometry(e, t) {
  Geometry$1.call(this), this.type = "OctahedronGeometry", this.parameters = {
    radius: e,
    detail: t
  }, this.fromBufferGeometry(new OctahedronBufferGeometry(e, t)), this.mergeVertices();
}
OctahedronGeometry.prototype = Object.create(Geometry$1.prototype);
OctahedronGeometry.prototype.constructor = OctahedronGeometry;
function OctahedronBufferGeometry(e, t) {
  var r = [
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1
  ], n = [
    0,
    2,
    4,
    0,
    4,
    3,
    0,
    3,
    5,
    0,
    5,
    2,
    1,
    2,
    5,
    1,
    5,
    3,
    1,
    3,
    4,
    1,
    4,
    2
  ];
  PolyhedronBufferGeometry.call(this, r, n, e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
    radius: e,
    detail: t
  };
}
OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
function IcosahedronGeometry(e, t) {
  Geometry$1.call(this), this.type = "IcosahedronGeometry", this.parameters = {
    radius: e,
    detail: t
  }, this.fromBufferGeometry(new IcosahedronBufferGeometry(e, t)), this.mergeVertices();
}
IcosahedronGeometry.prototype = Object.create(Geometry$1.prototype);
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
function IcosahedronBufferGeometry(e, t) {
  var r = (1 + Math.sqrt(5)) / 2, n = [
    -1,
    r,
    0,
    1,
    r,
    0,
    -1,
    -r,
    0,
    1,
    -r,
    0,
    0,
    -1,
    r,
    0,
    1,
    r,
    0,
    -1,
    -r,
    0,
    1,
    -r,
    r,
    0,
    -1,
    r,
    0,
    1,
    -r,
    0,
    -1,
    -r,
    0,
    1
  ], a = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    0,
    10,
    11,
    1,
    5,
    9,
    5,
    11,
    4,
    11,
    10,
    2,
    10,
    7,
    6,
    7,
    1,
    8,
    3,
    9,
    4,
    3,
    4,
    2,
    3,
    2,
    6,
    3,
    6,
    8,
    3,
    8,
    9,
    4,
    9,
    5,
    2,
    4,
    11,
    6,
    2,
    10,
    8,
    6,
    7,
    9,
    8,
    1
  ];
  PolyhedronBufferGeometry.call(this, n, a, e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
    radius: e,
    detail: t
  };
}
IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
function DodecahedronGeometry(e, t) {
  Geometry$1.call(this), this.type = "DodecahedronGeometry", this.parameters = {
    radius: e,
    detail: t
  }, this.fromBufferGeometry(new DodecahedronBufferGeometry(e, t)), this.mergeVertices();
}
DodecahedronGeometry.prototype = Object.create(Geometry$1.prototype);
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
function DodecahedronBufferGeometry(e, t) {
  var r = (1 + Math.sqrt(5)) / 2, n = 1 / r, a = [
    // (±1, ±1, ±1)
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    1,
    1,
    // (0, ±1/φ, ±φ)
    0,
    -n,
    -r,
    0,
    -n,
    r,
    0,
    n,
    -r,
    0,
    n,
    r,
    // (±1/φ, ±φ, 0)
    -n,
    -r,
    0,
    -n,
    r,
    0,
    n,
    -r,
    0,
    n,
    r,
    0,
    // (±φ, 0, ±1/φ)
    -r,
    0,
    -n,
    r,
    0,
    -n,
    -r,
    0,
    n,
    r,
    0,
    n
  ], o = [
    3,
    11,
    7,
    3,
    7,
    15,
    3,
    15,
    13,
    7,
    19,
    17,
    7,
    17,
    6,
    7,
    6,
    15,
    17,
    4,
    8,
    17,
    8,
    10,
    17,
    10,
    6,
    8,
    0,
    16,
    8,
    16,
    2,
    8,
    2,
    10,
    0,
    12,
    1,
    0,
    1,
    18,
    0,
    18,
    16,
    6,
    10,
    2,
    6,
    2,
    13,
    6,
    13,
    15,
    2,
    16,
    18,
    2,
    18,
    3,
    2,
    3,
    13,
    18,
    1,
    9,
    18,
    9,
    11,
    18,
    11,
    3,
    4,
    14,
    12,
    4,
    12,
    0,
    4,
    0,
    8,
    11,
    9,
    5,
    11,
    5,
    19,
    11,
    19,
    7,
    19,
    5,
    14,
    19,
    14,
    4,
    19,
    4,
    17,
    1,
    12,
    14,
    1,
    14,
    5,
    1,
    5,
    9
  ];
  PolyhedronBufferGeometry.call(this, a, o, e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
    radius: e,
    detail: t
  };
}
DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
function TubeGeometry(e, t, r, n, a, o) {
  Geometry$1.call(this), this.type = "TubeGeometry", this.parameters = {
    path: e,
    tubularSegments: t,
    radius: r,
    radialSegments: n,
    closed: a
  }, o !== void 0 && console.warn("THREE.TubeGeometry: taper has been removed.");
  var s = new TubeBufferGeometry(e, t, r, n, a);
  this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals, this.fromBufferGeometry(s), this.mergeVertices();
}
TubeGeometry.prototype = Object.create(Geometry$1.prototype);
TubeGeometry.prototype.constructor = TubeGeometry;
function TubeBufferGeometry(e, t, r, n, a) {
  BufferGeometry.call(this), this.type = "TubeBufferGeometry", this.parameters = {
    path: e,
    tubularSegments: t,
    radius: r,
    radialSegments: n,
    closed: a
  }, t = t || 64, r = r || 1, n = n || 8, a = a || !1;
  var o = e.computeFrenetFrames(t, a);
  this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
  var s = new Vector3(), l = new Vector3(), c = new Vector2(), u = new Vector3(), h, f, d = [], p = [], g = [], v = [];
  _(), this.setIndex(v), this.setAttribute("position", new Float32BufferAttribute(d, 3)), this.setAttribute("normal", new Float32BufferAttribute(p, 3)), this.setAttribute("uv", new Float32BufferAttribute(g, 2));
  function _() {
    for (h = 0; h < t; h++)
      m(h);
    m(a === !1 ? t : 0), b(), y();
  }
  function m(M) {
    u = e.getPointAt(M / t, u);
    var x = o.normals[M], w = o.binormals[M];
    for (f = 0; f <= n; f++) {
      var P = f / n * Math.PI * 2, V = Math.sin(P), I = -Math.cos(P);
      l.x = I * x.x + V * w.x, l.y = I * x.y + V * w.y, l.z = I * x.z + V * w.z, l.normalize(), p.push(l.x, l.y, l.z), s.x = u.x + r * l.x, s.y = u.y + r * l.y, s.z = u.z + r * l.z, d.push(s.x, s.y, s.z);
    }
  }
  function y() {
    for (f = 1; f <= t; f++)
      for (h = 1; h <= n; h++) {
        var M = (n + 1) * (f - 1) + (h - 1), x = (n + 1) * f + (h - 1), w = (n + 1) * f + h, P = (n + 1) * (f - 1) + h;
        v.push(M, x, P), v.push(x, w, P);
      }
  }
  function b() {
    for (h = 0; h <= t; h++)
      for (f = 0; f <= n; f++)
        c.x = h / t, c.y = f / n, g.push(c.x, c.y);
  }
}
TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
TubeBufferGeometry.prototype.toJSON = function() {
  var e = BufferGeometry.prototype.toJSON.call(this);
  return e.path = this.parameters.path.toJSON(), e;
};
function TorusKnotGeometry(e, t, r, n, a, o, s) {
  Geometry$1.call(this), this.type = "TorusKnotGeometry", this.parameters = {
    radius: e,
    tube: t,
    tubularSegments: r,
    radialSegments: n,
    p: a,
    q: o
  }, s !== void 0 && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new TorusKnotBufferGeometry(e, t, r, n, a, o)), this.mergeVertices();
}
TorusKnotGeometry.prototype = Object.create(Geometry$1.prototype);
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
function TorusKnotBufferGeometry(e, t, r, n, a, o) {
  BufferGeometry.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
    radius: e,
    tube: t,
    tubularSegments: r,
    radialSegments: n,
    p: a,
    q: o
  }, e = e || 1, t = t || 0.4, r = Math.floor(r) || 64, n = Math.floor(n) || 8, a = a || 2, o = o || 3;
  var s = [], l = [], c = [], u = [], h, f, d = new Vector3(), p = new Vector3(), g = new Vector3(), v = new Vector3(), _ = new Vector3(), m = new Vector3(), y = new Vector3();
  for (h = 0; h <= r; ++h) {
    var b = h / r * a * Math.PI * 2;
    for (E(b, a, o, e, g), E(b + 0.01, a, o, e, v), m.subVectors(v, g), y.addVectors(v, g), _.crossVectors(m, y), y.crossVectors(_, m), _.normalize(), y.normalize(), f = 0; f <= n; ++f) {
      var M = f / n * Math.PI * 2, x = -t * Math.cos(M), w = t * Math.sin(M);
      d.x = g.x + (x * y.x + w * _.x), d.y = g.y + (x * y.y + w * _.y), d.z = g.z + (x * y.z + w * _.z), l.push(d.x, d.y, d.z), p.subVectors(d, g).normalize(), c.push(p.x, p.y, p.z), u.push(h / r), u.push(f / n);
    }
  }
  for (f = 1; f <= r; f++)
    for (h = 1; h <= n; h++) {
      var P = (n + 1) * (f - 1) + (h - 1), V = (n + 1) * f + (h - 1), I = (n + 1) * f + h, $ = (n + 1) * (f - 1) + h;
      s.push(P, V, $), s.push(V, I, $);
    }
  this.setIndex(s), this.setAttribute("position", new Float32BufferAttribute(l, 3)), this.setAttribute("normal", new Float32BufferAttribute(c, 3)), this.setAttribute("uv", new Float32BufferAttribute(u, 2));
  function E(G, O, W, B, q) {
    var te = Math.cos(G), ne = Math.sin(G), Q = W / O * G, ae = Math.cos(Q);
    q.x = B * (2 + ae) * 0.5 * te, q.y = B * (2 + ae) * ne * 0.5, q.z = B * Math.sin(Q) * 0.5;
  }
}
TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
function TorusGeometry(e, t, r, n, a) {
  Geometry$1.call(this), this.type = "TorusGeometry", this.parameters = {
    radius: e,
    tube: t,
    radialSegments: r,
    tubularSegments: n,
    arc: a
  }, this.fromBufferGeometry(new TorusBufferGeometry(e, t, r, n, a)), this.mergeVertices();
}
TorusGeometry.prototype = Object.create(Geometry$1.prototype);
TorusGeometry.prototype.constructor = TorusGeometry;
function TorusBufferGeometry(e, t, r, n, a) {
  BufferGeometry.call(this), this.type = "TorusBufferGeometry", this.parameters = {
    radius: e,
    tube: t,
    radialSegments: r,
    tubularSegments: n,
    arc: a
  }, e = e || 1, t = t || 0.4, r = Math.floor(r) || 8, n = Math.floor(n) || 6, a = a || Math.PI * 2;
  var o = [], s = [], l = [], c = [], u = new Vector3(), h = new Vector3(), f = new Vector3(), d, p;
  for (d = 0; d <= r; d++)
    for (p = 0; p <= n; p++) {
      var g = p / n * a, v = d / r * Math.PI * 2;
      h.x = (e + t * Math.cos(v)) * Math.cos(g), h.y = (e + t * Math.cos(v)) * Math.sin(g), h.z = t * Math.sin(v), s.push(h.x, h.y, h.z), u.x = e * Math.cos(g), u.y = e * Math.sin(g), f.subVectors(h, u).normalize(), l.push(f.x, f.y, f.z), c.push(p / n), c.push(d / r);
    }
  for (d = 1; d <= r; d++)
    for (p = 1; p <= n; p++) {
      var _ = (n + 1) * d + p - 1, m = (n + 1) * (d - 1) + p - 1, y = (n + 1) * (d - 1) + p, b = (n + 1) * d + p;
      o.push(_, m, b), o.push(m, y, b);
    }
  this.setIndex(o), this.setAttribute("position", new Float32BufferAttribute(s, 3)), this.setAttribute("normal", new Float32BufferAttribute(l, 3)), this.setAttribute("uv", new Float32BufferAttribute(c, 2));
}
TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
var Earcut = {
  triangulate: function(e, t, r) {
    r = r || 2;
    var n = t && t.length, a = n ? t[0] * r : e.length, o = linkedList(e, 0, a, r, !0), s = [];
    if (!o || o.next === o.prev) return s;
    var l, c, u, h, f, d, p;
    if (n && (o = eliminateHoles(e, t, o, r)), e.length > 80 * r) {
      l = u = e[0], c = h = e[1];
      for (var g = r; g < a; g += r)
        f = e[g], d = e[g + 1], f < l && (l = f), d < c && (c = d), f > u && (u = f), d > h && (h = d);
      p = Math.max(u - l, h - c), p = p !== 0 ? 1 / p : 0;
    }
    return earcutLinked(o, s, r, l, c, p), s;
  }
};
function linkedList(e, t, r, n, a) {
  var o, s;
  if (a === signedArea(e, t, r, n) > 0)
    for (o = t; o < r; o += n) s = insertNode(o, e[o], e[o + 1], s);
  else
    for (o = r - n; o >= t; o -= n) s = insertNode(o, e[o], e[o + 1], s);
  return s && equals(s, s.next) && (removeNode(s), s = s.next), s;
}
function filterPoints(e, t) {
  if (!e) return e;
  t || (t = e);
  var r = e, n;
  do
    if (n = !1, !r.steiner && (equals(r, r.next) || area(r.prev, r, r.next) === 0)) {
      if (removeNode(r), r = t = r.prev, r === r.next) break;
      n = !0;
    } else
      r = r.next;
  while (n || r !== t);
  return t;
}
function earcutLinked(e, t, r, n, a, o, s) {
  if (e) {
    !s && o && indexCurve(e, n, a, o);
    for (var l = e, c, u; e.prev !== e.next; ) {
      if (c = e.prev, u = e.next, o ? isEarHashed(e, n, a, o) : isEar(e)) {
        t.push(c.i / r), t.push(e.i / r), t.push(u.i / r), removeNode(e), e = u.next, l = u.next;
        continue;
      }
      if (e = u, e === l) {
        s ? s === 1 ? (e = cureLocalIntersections(filterPoints(e), t, r), earcutLinked(e, t, r, n, a, o, 2)) : s === 2 && splitEarcut(e, t, r, n, a, o) : earcutLinked(filterPoints(e), t, r, n, a, o, 1);
        break;
      }
    }
  }
}
function isEar(e) {
  var t = e.prev, r = e, n = e.next;
  if (area(t, r, n) >= 0) return !1;
  for (var a = e.next.next; a !== e.prev; ) {
    if (pointInTriangle(t.x, t.y, r.x, r.y, n.x, n.y, a.x, a.y) && area(a.prev, a, a.next) >= 0) return !1;
    a = a.next;
  }
  return !0;
}
function isEarHashed(e, t, r, n) {
  var a = e.prev, o = e, s = e.next;
  if (area(a, o, s) >= 0) return !1;
  for (var l = a.x < o.x ? a.x < s.x ? a.x : s.x : o.x < s.x ? o.x : s.x, c = a.y < o.y ? a.y < s.y ? a.y : s.y : o.y < s.y ? o.y : s.y, u = a.x > o.x ? a.x > s.x ? a.x : s.x : o.x > s.x ? o.x : s.x, h = a.y > o.y ? a.y > s.y ? a.y : s.y : o.y > s.y ? o.y : s.y, f = zOrder(l, c, t, r, n), d = zOrder(u, h, t, r, n), p = e.prevZ, g = e.nextZ; p && p.z >= f && g && g.z <= d; ) {
    if (p !== e.prev && p !== e.next && pointInTriangle(a.x, a.y, o.x, o.y, s.x, s.y, p.x, p.y) && area(p.prev, p, p.next) >= 0 || (p = p.prevZ, g !== e.prev && g !== e.next && pointInTriangle(a.x, a.y, o.x, o.y, s.x, s.y, g.x, g.y) && area(g.prev, g, g.next) >= 0)) return !1;
    g = g.nextZ;
  }
  for (; p && p.z >= f; ) {
    if (p !== e.prev && p !== e.next && pointInTriangle(a.x, a.y, o.x, o.y, s.x, s.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
    p = p.prevZ;
  }
  for (; g && g.z <= d; ) {
    if (g !== e.prev && g !== e.next && pointInTriangle(a.x, a.y, o.x, o.y, s.x, s.y, g.x, g.y) && area(g.prev, g, g.next) >= 0) return !1;
    g = g.nextZ;
  }
  return !0;
}
function cureLocalIntersections(e, t, r) {
  var n = e;
  do {
    var a = n.prev, o = n.next.next;
    !equals(a, o) && intersects(a, n, n.next, o) && locallyInside(a, o) && locallyInside(o, a) && (t.push(a.i / r), t.push(n.i / r), t.push(o.i / r), removeNode(n), removeNode(n.next), n = e = o), n = n.next;
  } while (n !== e);
  return filterPoints(n);
}
function splitEarcut(e, t, r, n, a, o) {
  var s = e;
  do {
    for (var l = s.next.next; l !== s.prev; ) {
      if (s.i !== l.i && isValidDiagonal(s, l)) {
        var c = splitPolygon(s, l);
        s = filterPoints(s, s.next), c = filterPoints(c, c.next), earcutLinked(s, t, r, n, a, o), earcutLinked(c, t, r, n, a, o);
        return;
      }
      l = l.next;
    }
    s = s.next;
  } while (s !== e);
}
function eliminateHoles(e, t, r, n) {
  var a = [], o, s, l, c, u;
  for (o = 0, s = t.length; o < s; o++)
    l = t[o] * n, c = o < s - 1 ? t[o + 1] * n : e.length, u = linkedList(e, l, c, n, !1), u === u.next && (u.steiner = !0), a.push(getLeftmost(u));
  for (a.sort(compareX), o = 0; o < a.length; o++)
    eliminateHole(a[o], r), r = filterPoints(r, r.next);
  return r;
}
function compareX(e, t) {
  return e.x - t.x;
}
function eliminateHole(e, t) {
  if (t = findHoleBridge(e, t), t) {
    var r = splitPolygon(t, e);
    filterPoints(t, t.next), filterPoints(r, r.next);
  }
}
function findHoleBridge(e, t) {
  var r = t, n = e.x, a = e.y, o = -1 / 0, s;
  do {
    if (a <= r.y && a >= r.next.y && r.next.y !== r.y) {
      var l = r.x + (a - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
      if (l <= n && l > o) {
        if (o = l, l === n) {
          if (a === r.y) return r;
          if (a === r.next.y) return r.next;
        }
        s = r.x < r.next.x ? r : r.next;
      }
    }
    r = r.next;
  } while (r !== t);
  if (!s) return null;
  if (n === o) return s;
  var c = s, u = s.x, h = s.y, f = 1 / 0, d;
  r = s;
  do
    n >= r.x && r.x >= u && n !== r.x && pointInTriangle(a < h ? n : o, a, u, h, a < h ? o : n, a, r.x, r.y) && (d = Math.abs(a - r.y) / (n - r.x), locallyInside(r, e) && (d < f || d === f && (r.x > s.x || r.x === s.x && sectorContainsSector(s, r))) && (s = r, f = d)), r = r.next;
  while (r !== c);
  return s;
}
function sectorContainsSector(e, t) {
  return area(e.prev, e, t.prev) < 0 && area(t.next, e, e.next) < 0;
}
function indexCurve(e, t, r, n) {
  var a = e;
  do
    a.z === null && (a.z = zOrder(a.x, a.y, t, r, n)), a.prevZ = a.prev, a.nextZ = a.next, a = a.next;
  while (a !== e);
  a.prevZ.nextZ = null, a.prevZ = null, sortLinked(a);
}
function sortLinked(e) {
  var t, r, n, a, o, s, l, c, u = 1;
  do {
    for (r = e, e = null, o = null, s = 0; r; ) {
      for (s++, n = r, l = 0, t = 0; t < u && (l++, n = n.nextZ, !!n); t++)
        ;
      for (c = u; l > 0 || c > 0 && n; )
        l !== 0 && (c === 0 || !n || r.z <= n.z) ? (a = r, r = r.nextZ, l--) : (a = n, n = n.nextZ, c--), o ? o.nextZ = a : e = a, a.prevZ = o, o = a;
      r = n;
    }
    o.nextZ = null, u *= 2;
  } while (s > 1);
  return e;
}
function zOrder(e, t, r, n, a) {
  return e = 32767 * (e - r) * a, t = 32767 * (t - n) * a, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e | t << 1;
}
function getLeftmost(e) {
  var t = e, r = e;
  do
    (t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next;
  while (t !== e);
  return r;
}
function pointInTriangle(e, t, r, n, a, o, s, l) {
  return (a - s) * (t - l) - (e - s) * (o - l) >= 0 && (e - s) * (n - l) - (r - s) * (t - l) >= 0 && (r - s) * (o - l) - (a - s) * (n - l) >= 0;
}
function isValidDiagonal(e, t) {
  return e.next.i !== t.i && e.prev.i !== t.i && !intersectsPolygon(e, t) && // dones't intersect other edges
  (locallyInside(e, t) && locallyInside(t, e) && middleInside(e, t) && // locally visible
  (area(e.prev, e, t.prev) || area(e, t.prev, t)) || // does not create opposite-facing sectors
  equals(e, t) && area(e.prev, e, e.next) > 0 && area(t.prev, t, t.next) > 0);
}
function area(e, t, r) {
  return (t.y - e.y) * (r.x - t.x) - (t.x - e.x) * (r.y - t.y);
}
function equals(e, t) {
  return e.x === t.x && e.y === t.y;
}
function intersects(e, t, r, n) {
  var a = sign(area(e, t, r)), o = sign(area(e, t, n)), s = sign(area(r, n, e)), l = sign(area(r, n, t));
  return !!(a !== o && s !== l || a === 0 && onSegment(e, r, t) || o === 0 && onSegment(e, n, t) || s === 0 && onSegment(r, e, n) || l === 0 && onSegment(r, t, n));
}
function onSegment(e, t, r) {
  return t.x <= Math.max(e.x, r.x) && t.x >= Math.min(e.x, r.x) && t.y <= Math.max(e.y, r.y) && t.y >= Math.min(e.y, r.y);
}
function sign(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}
function intersectsPolygon(e, t) {
  var r = e;
  do {
    if (r.i !== e.i && r.next.i !== e.i && r.i !== t.i && r.next.i !== t.i && intersects(r, r.next, e, t)) return !0;
    r = r.next;
  } while (r !== e);
  return !1;
}
function locallyInside(e, t) {
  return area(e.prev, e, e.next) < 0 ? area(e, t, e.next) >= 0 && area(e, e.prev, t) >= 0 : area(e, t, e.prev) < 0 || area(e, e.next, t) < 0;
}
function middleInside(e, t) {
  var r = e, n = !1, a = (e.x + t.x) / 2, o = (e.y + t.y) / 2;
  do
    r.y > o != r.next.y > o && r.next.y !== r.y && a < (r.next.x - r.x) * (o - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;
  while (r !== e);
  return n;
}
function splitPolygon(e, t) {
  var r = new Node(e.i, e.x, e.y), n = new Node(t.i, t.x, t.y), a = e.next, o = t.prev;
  return e.next = t, t.prev = e, r.next = a, a.prev = r, n.next = r, r.prev = n, o.next = n, n.prev = o, n;
}
function insertNode(e, t, r, n) {
  var a = new Node(e, t, r);
  return n ? (a.next = n.next, a.prev = n, n.next.prev = a, n.next = a) : (a.prev = a, a.next = a), a;
}
function removeNode(e) {
  e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);
}
function Node(e, t, r) {
  this.i = e, this.x = t, this.y = r, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function signedArea(e, t, r, n) {
  for (var a = 0, o = t, s = r - n; o < r; o += n)
    a += (e[s] - e[o]) * (e[o + 1] + e[s + 1]), s = o;
  return a;
}
var ShapeUtils = {
  // calculate area of the contour polygon
  area: function(e) {
    for (var t = e.length, r = 0, n = t - 1, a = 0; a < t; n = a++)
      r += e[n].x * e[a].y - e[a].x * e[n].y;
    return r * 0.5;
  },
  isClockWise: function(e) {
    return ShapeUtils.area(e) < 0;
  },
  triangulateShape: function(e, t) {
    var r = [], n = [], a = [];
    removeDupEndPts(e), addContour(r, e);
    var o = e.length;
    t.forEach(removeDupEndPts);
    for (var s = 0; s < t.length; s++)
      n.push(o), o += t[s].length, addContour(r, t[s]);
    for (var l = Earcut.triangulate(r, n), s = 0; s < l.length; s += 3)
      a.push(l.slice(s, s + 3));
    return a;
  }
};
function removeDupEndPts(e) {
  var t = e.length;
  t > 2 && e[t - 1].equals(e[0]) && e.pop();
}
function addContour(e, t) {
  for (var r = 0; r < t.length; r++)
    e.push(t[r].x), e.push(t[r].y);
}
function ExtrudeGeometry(e, t) {
  Geometry$1.call(this), this.type = "ExtrudeGeometry", this.parameters = {
    shapes: e,
    options: t
  }, this.fromBufferGeometry(new ExtrudeBufferGeometry(e, t)), this.mergeVertices();
}
ExtrudeGeometry.prototype = Object.create(Geometry$1.prototype);
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
ExtrudeGeometry.prototype.toJSON = function() {
  var e = Geometry$1.prototype.toJSON.call(this), t = this.parameters.shapes, r = this.parameters.options;
  return toJSON(t, r, e);
};
function ExtrudeBufferGeometry(e, t) {
  BufferGeometry.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
    shapes: e,
    options: t
  }, e = Array.isArray(e) ? e : [e];
  for (var r = this, n = [], a = [], o = 0, s = e.length; o < s; o++) {
    var l = e[o];
    c(l);
  }
  this.setAttribute("position", new Float32BufferAttribute(n, 3)), this.setAttribute("uv", new Float32BufferAttribute(a, 2)), this.computeVertexNormals();
  function c(u) {
    var h = [], f = t.curveSegments !== void 0 ? t.curveSegments : 12, d = t.steps !== void 0 ? t.steps : 1, p = t.depth !== void 0 ? t.depth : 100, g = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, v = t.bevelThickness !== void 0 ? t.bevelThickness : 6, _ = t.bevelSize !== void 0 ? t.bevelSize : v - 2, m = t.bevelOffset !== void 0 ? t.bevelOffset : 0, y = t.bevelSegments !== void 0 ? t.bevelSegments : 3, b = t.extrudePath, M = t.UVGenerator !== void 0 ? t.UVGenerator : WorldUVGenerator;
    t.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), p = t.amount);
    var x, w = !1, P, V, I, $;
    b && (x = b.getSpacedPoints(d), w = !0, g = !1, P = b.computeFrenetFrames(d, !1), V = new Vector3(), I = new Vector3(), $ = new Vector3()), g || (y = 0, v = 0, _ = 0, m = 0);
    var E, G, O, W = u.extractPoints(f), B = W.shape, q = W.holes, te = !ShapeUtils.isClockWise(B);
    if (te)
      for (B = B.reverse(), G = 0, O = q.length; G < O; G++)
        E = q[G], ShapeUtils.isClockWise(E) && (q[G] = E.reverse());
    var ne = ShapeUtils.triangulateShape(B, q), Q = B;
    for (G = 0, O = q.length; G < O; G++)
      E = q[G], B = B.concat(E);
    function ae(he, de, ve) {
      return de || console.error("THREE.ExtrudeGeometry: vec does not exist"), de.clone().multiplyScalar(ve).add(he);
    }
    var oe, _e, A, L, D, S = B.length, H, z = ne.length;
    function N(he, de, ve) {
      var xe, k, pe, me = he.x - de.x, Ce = he.y - de.y, ge = ve.x - he.x, Re = ve.y - he.y, De = me * me + Ce * Ce, Oe = me * Re - Ce * ge;
      if (Math.abs(Oe) > Number.EPSILON) {
        var He = Math.sqrt(De), Pe = Math.sqrt(ge * ge + Re * Re), Ne = de.x - Ce / He, Ve = de.y + me / He, We = ve.x - Re / Pe, je = ve.y + ge / Pe, Je = ((We - Ne) * Re - (je - Ve) * ge) / (me * Re - Ce * ge);
        xe = Ne + me * Je - he.x, k = Ve + Ce * Je - he.y;
        var Xe = xe * xe + k * k;
        if (Xe <= 2)
          return new Vector2(xe, k);
        pe = Math.sqrt(Xe / 2);
      } else {
        var R = !1;
        me > Number.EPSILON ? ge > Number.EPSILON && (R = !0) : me < -Number.EPSILON ? ge < -Number.EPSILON && (R = !0) : Math.sign(Ce) === Math.sign(Re) && (R = !0), R ? (xe = -Ce, k = me, pe = Math.sqrt(De)) : (xe = me, k = Ce, pe = Math.sqrt(De / 2));
      }
      return new Vector2(xe / pe, k / pe);
    }
    for (var F = [], U = 0, j = Q.length, K = j - 1, Y = U + 1; U < j; U++, K++, Y++)
      K === j && (K = 0), Y === j && (Y = 0), F[U] = N(Q[U], Q[K], Q[Y]);
    var re = [], le, T = F.concat();
    for (G = 0, O = q.length; G < O; G++) {
      for (E = q[G], le = [], U = 0, j = E.length, K = j - 1, Y = U + 1; U < j; U++, K++, Y++)
        K === j && (K = 0), Y === j && (Y = 0), le[U] = N(E[U], E[K], E[Y]);
      re.push(le), T = T.concat(le);
    }
    for (oe = 0; oe < y; oe++) {
      for (A = oe / y, L = v * Math.cos(A * Math.PI / 2), _e = _ * Math.sin(A * Math.PI / 2) + m, U = 0, j = Q.length; U < j; U++)
        D = ae(Q[U], F[U], _e), se(D.x, D.y, -L);
      for (G = 0, O = q.length; G < O; G++)
        for (E = q[G], le = re[G], U = 0, j = E.length; U < j; U++)
          D = ae(E[U], le[U], _e), se(D.x, D.y, -L);
    }
    for (_e = _ + m, U = 0; U < S; U++)
      D = g ? ae(B[U], T[U], _e) : B[U], w ? (I.copy(P.normals[0]).multiplyScalar(D.x), V.copy(P.binormals[0]).multiplyScalar(D.y), $.copy(x[0]).add(I).add(V), se($.x, $.y, $.z)) : se(D.x, D.y, 0);
    var C;
    for (C = 1; C <= d; C++)
      for (U = 0; U < S; U++)
        D = g ? ae(B[U], T[U], _e) : B[U], w ? (I.copy(P.normals[C]).multiplyScalar(D.x), V.copy(P.binormals[C]).multiplyScalar(D.y), $.copy(x[C]).add(I).add(V), se($.x, $.y, $.z)) : se(D.x, D.y, p / d * C);
    for (oe = y - 1; oe >= 0; oe--) {
      for (A = oe / y, L = v * Math.cos(A * Math.PI / 2), _e = _ * Math.sin(A * Math.PI / 2) + m, U = 0, j = Q.length; U < j; U++)
        D = ae(Q[U], F[U], _e), se(D.x, D.y, p + L);
      for (G = 0, O = q.length; G < O; G++)
        for (E = q[G], le = re[G], U = 0, j = E.length; U < j; U++)
          D = ae(E[U], le[U], _e), w ? se(D.x, D.y + x[d - 1].y, x[d - 1].x + L) : se(D.x, D.y, p + L);
    }
    ie(), Z();
    function ie() {
      var he = n.length / 3;
      if (g) {
        var de = 0, ve = S * de;
        for (U = 0; U < z; U++)
          H = ne[U], ue(H[2] + ve, H[1] + ve, H[0] + ve);
        for (de = d + y * 2, ve = S * de, U = 0; U < z; U++)
          H = ne[U], ue(H[0] + ve, H[1] + ve, H[2] + ve);
      } else {
        for (U = 0; U < z; U++)
          H = ne[U], ue(H[2], H[1], H[0]);
        for (U = 0; U < z; U++)
          H = ne[U], ue(H[0] + S * d, H[1] + S * d, H[2] + S * d);
      }
      r.addGroup(he, n.length / 3 - he, 0);
    }
    function Z() {
      var he = n.length / 3, de = 0;
      for (ce(Q, de), de += Q.length, G = 0, O = q.length; G < O; G++)
        E = q[G], ce(E, de), de += E.length;
      r.addGroup(he, n.length / 3 - he, 1);
    }
    function ce(he, de) {
      var ve, xe;
      for (U = he.length; --U >= 0; ) {
        ve = U, xe = U - 1, xe < 0 && (xe = he.length - 1);
        var k = 0, pe = d + y * 2;
        for (k = 0; k < pe; k++) {
          var me = S * k, Ce = S * (k + 1), ge = de + ve + me, Re = de + xe + me, De = de + xe + Ce, Oe = de + ve + Ce;
          Le(ge, Re, De, Oe);
        }
      }
    }
    function se(he, de, ve) {
      h.push(he), h.push(de), h.push(ve);
    }
    function ue(he, de, ve) {
      Me(he), Me(de), Me(ve);
      var xe = n.length / 3, k = M.generateTopUV(r, n, xe - 3, xe - 2, xe - 1);
      ye(k[0]), ye(k[1]), ye(k[2]);
    }
    function Le(he, de, ve, xe) {
      Me(he), Me(de), Me(xe), Me(de), Me(ve), Me(xe);
      var k = n.length / 3, pe = M.generateSideWallUV(r, n, k - 6, k - 3, k - 2, k - 1);
      ye(pe[0]), ye(pe[1]), ye(pe[3]), ye(pe[1]), ye(pe[2]), ye(pe[3]);
    }
    function Me(he) {
      n.push(h[he * 3 + 0]), n.push(h[he * 3 + 1]), n.push(h[he * 3 + 2]);
    }
    function ye(he) {
      a.push(he.x), a.push(he.y);
    }
  }
}
ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
ExtrudeBufferGeometry.prototype.toJSON = function() {
  var e = BufferGeometry.prototype.toJSON.call(this), t = this.parameters.shapes, r = this.parameters.options;
  return toJSON(t, r, e);
};
var WorldUVGenerator = {
  generateTopUV: function(e, t, r, n, a) {
    var o = t[r * 3], s = t[r * 3 + 1], l = t[n * 3], c = t[n * 3 + 1], u = t[a * 3], h = t[a * 3 + 1];
    return [
      new Vector2(o, s),
      new Vector2(l, c),
      new Vector2(u, h)
    ];
  },
  generateSideWallUV: function(e, t, r, n, a, o) {
    var s = t[r * 3], l = t[r * 3 + 1], c = t[r * 3 + 2], u = t[n * 3], h = t[n * 3 + 1], f = t[n * 3 + 2], d = t[a * 3], p = t[a * 3 + 1], g = t[a * 3 + 2], v = t[o * 3], _ = t[o * 3 + 1], m = t[o * 3 + 2];
    return Math.abs(l - h) < 0.01 ? [
      new Vector2(s, 1 - c),
      new Vector2(u, 1 - f),
      new Vector2(d, 1 - g),
      new Vector2(v, 1 - m)
    ] : [
      new Vector2(l, 1 - c),
      new Vector2(h, 1 - f),
      new Vector2(p, 1 - g),
      new Vector2(_, 1 - m)
    ];
  }
};
function toJSON(e, t, r) {
  if (r.shapes = [], Array.isArray(e))
    for (var n = 0, a = e.length; n < a; n++) {
      var o = e[n];
      r.shapes.push(o.uuid);
    }
  else
    r.shapes.push(e.uuid);
  return t.extrudePath !== void 0 && (r.options.extrudePath = t.extrudePath.toJSON()), r;
}
function TextGeometry(e, t) {
  Geometry$1.call(this), this.type = "TextGeometry", this.parameters = {
    text: e,
    parameters: t
  }, this.fromBufferGeometry(new TextBufferGeometry(e, t)), this.mergeVertices();
}
TextGeometry.prototype = Object.create(Geometry$1.prototype);
TextGeometry.prototype.constructor = TextGeometry;
function TextBufferGeometry(e, t) {
  t = t || {};
  var r = t.font;
  if (!(r && r.isFont))
    return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Geometry$1();
  var n = r.generateShapes(e, t.size);
  t.depth = t.height !== void 0 ? t.height : 50, t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = !1), ExtrudeBufferGeometry.call(this, n, t), this.type = "TextBufferGeometry";
}
TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
TextBufferGeometry.prototype.constructor = TextBufferGeometry;
function SphereGeometry(e, t, r, n, a, o, s) {
  Geometry$1.call(this), this.type = "SphereGeometry", this.parameters = {
    radius: e,
    widthSegments: t,
    heightSegments: r,
    phiStart: n,
    phiLength: a,
    thetaStart: o,
    thetaLength: s
  }, this.fromBufferGeometry(new SphereBufferGeometry(e, t, r, n, a, o, s)), this.mergeVertices();
}
SphereGeometry.prototype = Object.create(Geometry$1.prototype);
SphereGeometry.prototype.constructor = SphereGeometry;
function SphereBufferGeometry(e, t, r, n, a, o, s) {
  BufferGeometry.call(this), this.type = "SphereBufferGeometry", this.parameters = {
    radius: e,
    widthSegments: t,
    heightSegments: r,
    phiStart: n,
    phiLength: a,
    thetaStart: o,
    thetaLength: s
  }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), r = Math.max(2, Math.floor(r) || 6), n = n !== void 0 ? n : 0, a = a !== void 0 ? a : Math.PI * 2, o = o !== void 0 ? o : 0, s = s !== void 0 ? s : Math.PI;
  var l = Math.min(o + s, Math.PI), c, u, h = 0, f = [], d = new Vector3(), p = new Vector3(), g = [], v = [], _ = [], m = [];
  for (u = 0; u <= r; u++) {
    var y = [], b = u / r, M = 0;
    for (u == 0 && o == 0 ? M = 0.5 / t : u == r && l == Math.PI && (M = -0.5 / t), c = 0; c <= t; c++) {
      var x = c / t;
      d.x = -e * Math.cos(n + x * a) * Math.sin(o + b * s), d.y = e * Math.cos(o + b * s), d.z = e * Math.sin(n + x * a) * Math.sin(o + b * s), v.push(d.x, d.y, d.z), p.copy(d).normalize(), _.push(p.x, p.y, p.z), m.push(x + M, 1 - b), y.push(h++);
    }
    f.push(y);
  }
  for (u = 0; u < r; u++)
    for (c = 0; c < t; c++) {
      var w = f[u][c + 1], P = f[u][c], V = f[u + 1][c], I = f[u + 1][c + 1];
      (u !== 0 || o > 0) && g.push(w, P, I), (u !== r - 1 || l < Math.PI) && g.push(P, V, I);
    }
  this.setIndex(g), this.setAttribute("position", new Float32BufferAttribute(v, 3)), this.setAttribute("normal", new Float32BufferAttribute(_, 3)), this.setAttribute("uv", new Float32BufferAttribute(m, 2));
}
SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
function RingGeometry(e, t, r, n, a, o) {
  Geometry$1.call(this), this.type = "RingGeometry", this.parameters = {
    innerRadius: e,
    outerRadius: t,
    thetaSegments: r,
    phiSegments: n,
    thetaStart: a,
    thetaLength: o
  }, this.fromBufferGeometry(new RingBufferGeometry(e, t, r, n, a, o)), this.mergeVertices();
}
RingGeometry.prototype = Object.create(Geometry$1.prototype);
RingGeometry.prototype.constructor = RingGeometry;
function RingBufferGeometry(e, t, r, n, a, o) {
  BufferGeometry.call(this), this.type = "RingBufferGeometry", this.parameters = {
    innerRadius: e,
    outerRadius: t,
    thetaSegments: r,
    phiSegments: n,
    thetaStart: a,
    thetaLength: o
  }, e = e || 0.5, t = t || 1, a = a !== void 0 ? a : 0, o = o !== void 0 ? o : Math.PI * 2, r = r !== void 0 ? Math.max(3, r) : 8, n = n !== void 0 ? Math.max(1, n) : 1;
  var s = [], l = [], c = [], u = [], h, f = e, d = (t - e) / n, p = new Vector3(), g = new Vector2(), v, _;
  for (v = 0; v <= n; v++) {
    for (_ = 0; _ <= r; _++)
      h = a + _ / r * o, p.x = f * Math.cos(h), p.y = f * Math.sin(h), l.push(p.x, p.y, p.z), c.push(0, 0, 1), g.x = (p.x / t + 1) / 2, g.y = (p.y / t + 1) / 2, u.push(g.x, g.y);
    f += d;
  }
  for (v = 0; v < n; v++) {
    var m = v * (r + 1);
    for (_ = 0; _ < r; _++) {
      h = _ + m;
      var y = h, b = h + r + 1, M = h + r + 2, x = h + 1;
      s.push(y, b, x), s.push(b, M, x);
    }
  }
  this.setIndex(s), this.setAttribute("position", new Float32BufferAttribute(l, 3)), this.setAttribute("normal", new Float32BufferAttribute(c, 3)), this.setAttribute("uv", new Float32BufferAttribute(u, 2));
}
RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
RingBufferGeometry.prototype.constructor = RingBufferGeometry;
function LatheGeometry(e, t, r, n) {
  Geometry$1.call(this), this.type = "LatheGeometry", this.parameters = {
    points: e,
    segments: t,
    phiStart: r,
    phiLength: n
  }, this.fromBufferGeometry(new LatheBufferGeometry(e, t, r, n)), this.mergeVertices();
}
LatheGeometry.prototype = Object.create(Geometry$1.prototype);
LatheGeometry.prototype.constructor = LatheGeometry;
function LatheBufferGeometry(e, t, r, n) {
  BufferGeometry.call(this), this.type = "LatheBufferGeometry", this.parameters = {
    points: e,
    segments: t,
    phiStart: r,
    phiLength: n
  }, t = Math.floor(t) || 12, r = r || 0, n = n || Math.PI * 2, n = MathUtils.clamp(n, 0, Math.PI * 2);
  var a = [], o = [], s = [], l, c = 1 / t, u = new Vector3(), h = new Vector2(), f, d;
  for (f = 0; f <= t; f++) {
    var p = r + f * c * n, g = Math.sin(p), v = Math.cos(p);
    for (d = 0; d <= e.length - 1; d++)
      u.x = e[d].x * g, u.y = e[d].y, u.z = e[d].x * v, o.push(u.x, u.y, u.z), h.x = f / t, h.y = d / (e.length - 1), s.push(h.x, h.y);
  }
  for (f = 0; f < t; f++)
    for (d = 0; d < e.length - 1; d++) {
      l = d + f * e.length;
      var _ = l, m = l + e.length, y = l + e.length + 1, b = l + 1;
      a.push(_, m, b), a.push(m, y, b);
    }
  if (this.setIndex(a), this.setAttribute("position", new Float32BufferAttribute(o, 3)), this.setAttribute("uv", new Float32BufferAttribute(s, 2)), this.computeVertexNormals(), n === Math.PI * 2) {
    var M = this.attributes.normal.array, x = new Vector3(), w = new Vector3(), P = new Vector3();
    for (l = t * e.length * 3, f = 0, d = 0; f < e.length; f++, d += 3)
      x.x = M[d + 0], x.y = M[d + 1], x.z = M[d + 2], w.x = M[l + d + 0], w.y = M[l + d + 1], w.z = M[l + d + 2], P.addVectors(x, w).normalize(), M[d + 0] = M[l + d + 0] = P.x, M[d + 1] = M[l + d + 1] = P.y, M[d + 2] = M[l + d + 2] = P.z;
  }
}
LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
function ShapeGeometry(e, t) {
  Geometry$1.call(this), this.type = "ShapeGeometry", typeof t == "object" && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
    shapes: e,
    curveSegments: t
  }, this.fromBufferGeometry(new ShapeBufferGeometry(e, t)), this.mergeVertices();
}
ShapeGeometry.prototype = Object.create(Geometry$1.prototype);
ShapeGeometry.prototype.constructor = ShapeGeometry;
ShapeGeometry.prototype.toJSON = function() {
  var e = Geometry$1.prototype.toJSON.call(this), t = this.parameters.shapes;
  return toJSON$1(t, e);
};
function ShapeBufferGeometry(e, t) {
  BufferGeometry.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
    shapes: e,
    curveSegments: t
  }, t = t || 12;
  var r = [], n = [], a = [], o = [], s = 0, l = 0;
  if (Array.isArray(e) === !1)
    u(e);
  else
    for (var c = 0; c < e.length; c++)
      u(e[c]), this.addGroup(s, l, c), s += l, l = 0;
  this.setIndex(r), this.setAttribute("position", new Float32BufferAttribute(n, 3)), this.setAttribute("normal", new Float32BufferAttribute(a, 3)), this.setAttribute("uv", new Float32BufferAttribute(o, 2));
  function u(h) {
    var f, d, p, g = n.length / 3, v = h.extractPoints(t), _ = v.shape, m = v.holes;
    for (ShapeUtils.isClockWise(_) === !1 && (_ = _.reverse()), f = 0, d = m.length; f < d; f++)
      p = m[f], ShapeUtils.isClockWise(p) === !0 && (m[f] = p.reverse());
    var y = ShapeUtils.triangulateShape(_, m);
    for (f = 0, d = m.length; f < d; f++)
      p = m[f], _ = _.concat(p);
    for (f = 0, d = _.length; f < d; f++) {
      var b = _[f];
      n.push(b.x, b.y, 0), a.push(0, 0, 1), o.push(b.x, b.y);
    }
    for (f = 0, d = y.length; f < d; f++) {
      var M = y[f], x = M[0] + g, w = M[1] + g, P = M[2] + g;
      r.push(x, w, P), l += 3;
    }
  }
}
ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
ShapeBufferGeometry.prototype.toJSON = function() {
  var e = BufferGeometry.prototype.toJSON.call(this), t = this.parameters.shapes;
  return toJSON$1(t, e);
};
function toJSON$1(e, t) {
  if (t.shapes = [], Array.isArray(e))
    for (var r = 0, n = e.length; r < n; r++) {
      var a = e[r];
      t.shapes.push(a.uuid);
    }
  else
    t.shapes.push(e.uuid);
  return t;
}
function EdgesGeometry(e, t) {
  BufferGeometry.call(this), this.type = "EdgesGeometry", this.parameters = {
    thresholdAngle: t
  }, t = t !== void 0 ? t : 1;
  var r = [], n = Math.cos(MathUtils.DEG2RAD * t), a = [0, 0], o = {}, s, l, c, u = ["a", "b", "c"], h;
  e.isBufferGeometry ? (h = new Geometry$1(), h.fromBufferGeometry(e)) : h = e.clone(), h.mergeVertices(), h.computeFaceNormals();
  for (var f = h.vertices, d = h.faces, p = 0, g = d.length; p < g; p++)
    for (var v = d[p], _ = 0; _ < 3; _++)
      s = v[u[_]], l = v[u[(_ + 1) % 3]], a[0] = Math.min(s, l), a[1] = Math.max(s, l), c = a[0] + "," + a[1], o[c] === void 0 ? o[c] = { index1: a[0], index2: a[1], face1: p, face2: void 0 } : o[c].face2 = p;
  for (c in o) {
    var m = o[c];
    if (m.face2 === void 0 || d[m.face1].normal.dot(d[m.face2].normal) <= n) {
      var y = f[m.index1];
      r.push(y.x, y.y, y.z), y = f[m.index2], r.push(y.x, y.y, y.z);
    }
  }
  this.setAttribute("position", new Float32BufferAttribute(r, 3));
}
EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
EdgesGeometry.prototype.constructor = EdgesGeometry;
function CylinderGeometry(e, t, r, n, a, o, s, l) {
  Geometry$1.call(this), this.type = "CylinderGeometry", this.parameters = {
    radiusTop: e,
    radiusBottom: t,
    height: r,
    radialSegments: n,
    heightSegments: a,
    openEnded: o,
    thetaStart: s,
    thetaLength: l
  }, this.fromBufferGeometry(new CylinderBufferGeometry(e, t, r, n, a, o, s, l)), this.mergeVertices();
}
CylinderGeometry.prototype = Object.create(Geometry$1.prototype);
CylinderGeometry.prototype.constructor = CylinderGeometry;
function CylinderBufferGeometry(e, t, r, n, a, o, s, l) {
  BufferGeometry.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
    radiusTop: e,
    radiusBottom: t,
    height: r,
    radialSegments: n,
    heightSegments: a,
    openEnded: o,
    thetaStart: s,
    thetaLength: l
  };
  var c = this;
  e = e !== void 0 ? e : 1, t = t !== void 0 ? t : 1, r = r || 1, n = Math.floor(n) || 8, a = Math.floor(a) || 1, o = o !== void 0 ? o : !1, s = s !== void 0 ? s : 0, l = l !== void 0 ? l : Math.PI * 2;
  var u = [], h = [], f = [], d = [], p = 0, g = [], v = r / 2, _ = 0;
  m(), o === !1 && (e > 0 && y(!0), t > 0 && y(!1)), this.setIndex(u), this.setAttribute("position", new Float32BufferAttribute(h, 3)), this.setAttribute("normal", new Float32BufferAttribute(f, 3)), this.setAttribute("uv", new Float32BufferAttribute(d, 2));
  function m() {
    var b, M, x = new Vector3(), w = new Vector3(), P = 0, V = (t - e) / r;
    for (M = 0; M <= a; M++) {
      var I = [], $ = M / a, E = $ * (t - e) + e;
      for (b = 0; b <= n; b++) {
        var G = b / n, O = G * l + s, W = Math.sin(O), B = Math.cos(O);
        w.x = E * W, w.y = -$ * r + v, w.z = E * B, h.push(w.x, w.y, w.z), x.set(W, V, B).normalize(), f.push(x.x, x.y, x.z), d.push(G, 1 - $), I.push(p++);
      }
      g.push(I);
    }
    for (b = 0; b < n; b++)
      for (M = 0; M < a; M++) {
        var q = g[M][b], te = g[M + 1][b], ne = g[M + 1][b + 1], Q = g[M][b + 1];
        u.push(q, te, Q), u.push(te, ne, Q), P += 6;
      }
    c.addGroup(_, P, 0), _ += P;
  }
  function y(b) {
    var M, x, w, P = new Vector2(), V = new Vector3(), I = 0, $ = b === !0 ? e : t, E = b === !0 ? 1 : -1;
    for (x = p, M = 1; M <= n; M++)
      h.push(0, v * E, 0), f.push(0, E, 0), d.push(0.5, 0.5), p++;
    for (w = p, M = 0; M <= n; M++) {
      var G = M / n, O = G * l + s, W = Math.cos(O), B = Math.sin(O);
      V.x = $ * B, V.y = v * E, V.z = $ * W, h.push(V.x, V.y, V.z), f.push(0, E, 0), P.x = W * 0.5 + 0.5, P.y = B * 0.5 * E + 0.5, d.push(P.x, P.y), p++;
    }
    for (M = 0; M < n; M++) {
      var q = x + M, te = w + M;
      b === !0 ? u.push(te, te + 1, q) : u.push(te + 1, te, q), I += 3;
    }
    c.addGroup(_, I, b === !0 ? 1 : 2), _ += I;
  }
}
CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
function ConeGeometry(e, t, r, n, a, o, s) {
  CylinderGeometry.call(this, 0, e, t, r, n, a, o, s), this.type = "ConeGeometry", this.parameters = {
    radius: e,
    height: t,
    radialSegments: r,
    heightSegments: n,
    openEnded: a,
    thetaStart: o,
    thetaLength: s
  };
}
ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
ConeGeometry.prototype.constructor = ConeGeometry;
function ConeBufferGeometry(e, t, r, n, a, o, s) {
  CylinderBufferGeometry.call(this, 0, e, t, r, n, a, o, s), this.type = "ConeBufferGeometry", this.parameters = {
    radius: e,
    height: t,
    radialSegments: r,
    heightSegments: n,
    openEnded: a,
    thetaStart: o,
    thetaLength: s
  };
}
ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
function CircleGeometry(e, t, r, n) {
  Geometry$1.call(this), this.type = "CircleGeometry", this.parameters = {
    radius: e,
    segments: t,
    thetaStart: r,
    thetaLength: n
  }, this.fromBufferGeometry(new CircleBufferGeometry(e, t, r, n)), this.mergeVertices();
}
CircleGeometry.prototype = Object.create(Geometry$1.prototype);
CircleGeometry.prototype.constructor = CircleGeometry;
function CircleBufferGeometry(e, t, r, n) {
  BufferGeometry.call(this), this.type = "CircleBufferGeometry", this.parameters = {
    radius: e,
    segments: t,
    thetaStart: r,
    thetaLength: n
  }, e = e || 1, t = t !== void 0 ? Math.max(3, t) : 8, r = r !== void 0 ? r : 0, n = n !== void 0 ? n : Math.PI * 2;
  var a = [], o = [], s = [], l = [], c, u, h = new Vector3(), f = new Vector2();
  for (o.push(0, 0, 0), s.push(0, 0, 1), l.push(0.5, 0.5), u = 0, c = 3; u <= t; u++, c += 3) {
    var d = r + u / t * n;
    h.x = e * Math.cos(d), h.y = e * Math.sin(d), o.push(h.x, h.y, h.z), s.push(0, 0, 1), f.x = (o[c] / e + 1) / 2, f.y = (o[c + 1] / e + 1) / 2, l.push(f.x, f.y);
  }
  for (c = 1; c <= t; c++)
    a.push(c, c + 1, 0);
  this.setIndex(a), this.setAttribute("position", new Float32BufferAttribute(o, 3)), this.setAttribute("normal", new Float32BufferAttribute(s, 3)), this.setAttribute("uv", new Float32BufferAttribute(l, 2));
}
CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
var Geometries = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WireframeGeometry,
  ParametricGeometry,
  ParametricBufferGeometry,
  TetrahedronGeometry,
  TetrahedronBufferGeometry,
  OctahedronGeometry,
  OctahedronBufferGeometry,
  IcosahedronGeometry,
  IcosahedronBufferGeometry,
  DodecahedronGeometry,
  DodecahedronBufferGeometry,
  PolyhedronGeometry,
  PolyhedronBufferGeometry,
  TubeGeometry,
  TubeBufferGeometry,
  TorusKnotGeometry,
  TorusKnotBufferGeometry,
  TorusGeometry,
  TorusBufferGeometry,
  TextGeometry,
  TextBufferGeometry,
  SphereGeometry,
  SphereBufferGeometry,
  RingGeometry,
  RingBufferGeometry,
  PlaneGeometry,
  PlaneBufferGeometry,
  LatheGeometry,
  LatheBufferGeometry,
  ShapeGeometry,
  ShapeBufferGeometry,
  ExtrudeGeometry,
  ExtrudeBufferGeometry,
  EdgesGeometry,
  ConeGeometry,
  ConeBufferGeometry,
  CylinderGeometry,
  CylinderBufferGeometry,
  CircleGeometry,
  CircleBufferGeometry,
  BoxGeometry,
  BoxBufferGeometry
});
function ShadowMaterial(e) {
  Material.call(this), this.type = "ShadowMaterial", this.color = new Color(0), this.transparent = !0, this.setValues(e);
}
ShadowMaterial.prototype = Object.create(Material.prototype);
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = !0;
ShadowMaterial.prototype.copy = function(e) {
  return Material.prototype.copy.call(this, e), this.color.copy(e.color), this;
};
function RawShaderMaterial(e) {
  ShaderMaterial.call(this, e), this.type = "RawShaderMaterial";
}
RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = !0;
function MeshStandardMaterial(e) {
  Material.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Color(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(e);
}
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = !0;
MeshStandardMaterial.prototype.copy = function(e) {
  return Material.prototype.copy.call(this, e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.vertexTangents = e.vertexTangents, this;
};
function MeshPhysicalMaterial(e) {
  MeshStandardMaterial.call(this), this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2(1, 1), this.clearcoatNormalMap = null, this.reflectivity = 0.5, this.sheen = null, this.transparency = 0, this.setValues(e);
}
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = !0;
MeshPhysicalMaterial.prototype.copy = function(e) {
  return MeshStandardMaterial.prototype.copy.call(this, e), this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.reflectivity = e.reflectivity, e.sheen ? this.sheen = (this.sheen || new Color()).copy(e.sheen) : this.sheen = null, this.transparency = e.transparency, this;
};
function MeshPhongMaterial(e) {
  Material.call(this), this.type = "MeshPhongMaterial", this.color = new Color(16777215), this.specular = new Color(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
}
MeshPhongMaterial.prototype = Object.create(Material.prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = !0;
MeshPhongMaterial.prototype.copy = function(e) {
  return Material.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
};
function MeshToonMaterial(e) {
  Material.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Color(16777215), this.specular = new Color(1118481), this.shininess = 30, this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
}
MeshToonMaterial.prototype = Object.create(Material.prototype);
MeshToonMaterial.prototype.constructor = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = !0;
MeshToonMaterial.prototype.copy = function(e) {
  return Material.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
};
function MeshNormalMaterial(e) {
  Material.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
}
MeshNormalMaterial.prototype = Object.create(Material.prototype);
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = !0;
MeshNormalMaterial.prototype.copy = function(e) {
  return Material.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
};
function MeshLambertMaterial(e) {
  Material.call(this), this.type = "MeshLambertMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
}
MeshLambertMaterial.prototype = Object.create(Material.prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = !0;
MeshLambertMaterial.prototype.copy = function(e) {
  return Material.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
};
function MeshMatcapMaterial(e) {
  Material.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Color(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e);
}
MeshMatcapMaterial.prototype = Object.create(Material.prototype);
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = !0;
MeshMatcapMaterial.prototype.copy = function(e) {
  return Material.prototype.copy.call(this, e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this;
};
function LineDashedMaterial(e) {
  LineBasicMaterial.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
}
LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = !0;
LineDashedMaterial.prototype.copy = function(e) {
  return LineBasicMaterial.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
};
var Materials = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ShadowMaterial,
  SpriteMaterial,
  RawShaderMaterial,
  ShaderMaterial,
  PointsMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshPhongMaterial,
  MeshToonMaterial,
  MeshNormalMaterial,
  MeshLambertMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshBasicMaterial,
  MeshMatcapMaterial,
  LineDashedMaterial,
  LineBasicMaterial,
  Material
}), AnimationUtils = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function(e, t, r) {
    return AnimationUtils.isTypedArray(e) ? new e.constructor(e.subarray(t, r !== void 0 ? r : e.length)) : e.slice(t, r);
  },
  // converts an array to a specific type
  convertArray: function(e, t, r) {
    return !e || // let 'undefined' and 'null' pass
    !r && e.constructor === t ? e : typeof t.BYTES_PER_ELEMENT == "number" ? new t(e) : Array.prototype.slice.call(e);
  },
  isTypedArray: function(e) {
    return ArrayBuffer.isView(e) && !(e instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function(e) {
    function t(o, s) {
      return e[o] - e[s];
    }
    for (var r = e.length, n = new Array(r), a = 0; a !== r; ++a) n[a] = a;
    return n.sort(t), n;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function(e, t, r) {
    for (var n = e.length, a = new e.constructor(n), o = 0, s = 0; s !== n; ++o)
      for (var l = r[o] * t, c = 0; c !== t; ++c)
        a[s++] = e[l + c];
    return a;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function(e, t, r, n) {
    for (var a = 1, o = e[0]; o !== void 0 && o[n] === void 0; )
      o = e[a++];
    if (o !== void 0) {
      var s = o[n];
      if (s !== void 0)
        if (Array.isArray(s))
          do
            s = o[n], s !== void 0 && (t.push(o.time), r.push.apply(r, s)), o = e[a++];
          while (o !== void 0);
        else if (s.toArray !== void 0)
          do
            s = o[n], s !== void 0 && (t.push(o.time), s.toArray(r, r.length)), o = e[a++];
          while (o !== void 0);
        else
          do
            s = o[n], s !== void 0 && (t.push(o.time), r.push(s)), o = e[a++];
          while (o !== void 0);
    }
  },
  subclip: function(e, t, r, n, a) {
    a = a || 30;
    var o = e.clone();
    o.name = t;
    for (var s = [], l = 0; l < o.tracks.length; ++l) {
      for (var c = o.tracks[l], u = c.getValueSize(), h = [], f = [], d = 0; d < c.times.length; ++d) {
        var p = c.times[d] * a;
        if (!(p < r || p >= n)) {
          h.push(c.times[d]);
          for (var g = 0; g < u; ++g)
            f.push(c.values[d * u + g]);
        }
      }
      h.length !== 0 && (c.times = AnimationUtils.convertArray(h, c.times.constructor), c.values = AnimationUtils.convertArray(f, c.values.constructor), s.push(c));
    }
    o.tracks = s;
    for (var v = 1 / 0, l = 0; l < o.tracks.length; ++l)
      v > o.tracks[l].times[0] && (v = o.tracks[l].times[0]);
    for (var l = 0; l < o.tracks.length; ++l)
      o.tracks[l].shift(-1 * v);
    return o.resetDuration(), o;
  },
  makeClipAdditive: function(e, t, r, n) {
    t === void 0 && (t = 0), r === void 0 && (r = e), (n === void 0 || n <= 0) && (n = 30);
    for (var a = e.tracks.length, o = t / n, s = 0; s < a; ++s) {
      var l = r.tracks[s], c = l.ValueTypeName;
      if (!(c === "bool" || c === "string")) {
        var u = e.tracks.find(function(M) {
          return M.name === l.name && M.ValueTypeName === c;
        });
        if (u !== void 0) {
          var h = l.getValueSize(), f = l.times.length - 1, d;
          if (o <= l.times[0])
            d = AnimationUtils.arraySlice(l.values, 0, l.valueSize);
          else if (o >= l.times[f]) {
            var p = f * h;
            d = AnimationUtils.arraySlice(l.values, p);
          } else {
            var g = l.createInterpolant();
            g.evaluate(o), d = g.resultBuffer;
          }
          if (c === "quaternion") {
            var v = new Quaternion(
              d[0],
              d[1],
              d[2],
              d[3]
            ).normalize().conjugate();
            v.toArray(d);
          }
          for (var _ = u.times.length, m = 0; m < _; ++m) {
            var y = m * h;
            if (c === "quaternion")
              Quaternion.multiplyQuaternionsFlat(
                u.values,
                y,
                d,
                0,
                u.values,
                y
              );
            else
              for (var b = 0; b < h; ++b)
                u.values[y + b] -= d[b];
          }
        }
      }
    }
    return e.blendMode = AdditiveAnimationBlendMode, e;
  }
};
function Interpolant(e, t, r, n) {
  this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = n !== void 0 ? n : new t.constructor(r), this.sampleValues = t, this.valueSize = r;
}
Object.assign(Interpolant.prototype, {
  evaluate: function(e) {
    var t = this.parameterPositions, r = this._cachedIndex, n = t[r], a = t[r - 1];
    e: {
      t: {
        var o;
        r: {
          n: if (!(e < n)) {
            for (var s = r + 2; ; ) {
              if (n === void 0) {
                if (e < a) break n;
                return r = t.length, this._cachedIndex = r, this.afterEnd_(r - 1, e, a);
              }
              if (r === s) break;
              if (a = n, n = t[++r], e < n)
                break t;
            }
            o = t.length;
            break r;
          }
          if (!(e >= a)) {
            var l = t[1];
            e < l && (r = 2, a = l);
            for (var s = r - 2; ; ) {
              if (a === void 0)
                return this._cachedIndex = 0, this.beforeStart_(0, e, n);
              if (r === s) break;
              if (n = a, a = t[--r - 1], e >= a)
                break t;
            }
            o = r, r = 0;
            break r;
          }
          break e;
        }
        for (; r < o; ) {
          var c = r + o >>> 1;
          e < t[c] ? o = c : r = c + 1;
        }
        if (n = t[r], a = t[r - 1], a === void 0)
          return this._cachedIndex = 0, this.beforeStart_(0, e, n);
        if (n === void 0)
          return r = t.length, this._cachedIndex = r, this.afterEnd_(r - 1, a, e);
      }
      this._cachedIndex = r, this.intervalChanged_(r, a, n);
    }
    return this.interpolate_(r, a, e, n);
  },
  settings: null,
  // optional, subclass-specific settings structure
  // Note: The indirection allows central control of many interpolants.
  // --- Protected interface
  DefaultSettings_: {},
  getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function(e) {
    for (var t = this.resultBuffer, r = this.sampleValues, n = this.valueSize, a = e * n, o = 0; o !== n; ++o)
      t[o] = r[a + o];
    return t;
  },
  // Template methods for derived classes:
  interpolate_: function() {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function() {
  }
});
Object.assign(Interpolant.prototype, {
  //( 0, t, t0 ), returns this.resultBuffer
  beforeStart_: Interpolant.prototype.copySampleValue_,
  //( N-1, tN-1, t ), returns this.resultBuffer
  afterEnd_: Interpolant.prototype.copySampleValue_
});
function CubicInterpolant(e, t, r, n) {
  Interpolant.call(this, e, t, r, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0;
}
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: CubicInterpolant,
  DefaultSettings_: {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  },
  intervalChanged_: function(e, t, r) {
    var n = this.parameterPositions, a = e - 2, o = e + 1, s = n[a], l = n[o];
    if (s === void 0)
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          a = e, s = 2 * t - r;
          break;
        case WrapAroundEnding:
          a = n.length - 2, s = t + n[a] - n[a + 1];
          break;
        default:
          a = e, s = r;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          o = e, l = 2 * r - t;
          break;
        case WrapAroundEnding:
          o = 1, l = r + n[1] - n[0];
          break;
        default:
          o = e - 1, l = t;
      }
    var c = (r - t) * 0.5, u = this.valueSize;
    this._weightPrev = c / (t - s), this._weightNext = c / (l - r), this._offsetPrev = a * u, this._offsetNext = o * u;
  },
  interpolate_: function(e, t, r, n) {
    for (var a = this.resultBuffer, o = this.sampleValues, s = this.valueSize, l = e * s, c = l - s, u = this._offsetPrev, h = this._offsetNext, f = this._weightPrev, d = this._weightNext, p = (r - t) / (n - t), g = p * p, v = g * p, _ = -f * v + 2 * f * g - f * p, m = (1 + f) * v + (-1.5 - 2 * f) * g + (-0.5 + f) * p + 1, y = (-1 - d) * v + (1.5 + d) * g + 0.5 * p, b = d * v - d * g, M = 0; M !== s; ++M)
      a[M] = _ * o[u + M] + m * o[c + M] + y * o[l + M] + b * o[h + M];
    return a;
  }
});
function LinearInterpolant(e, t, r, n) {
  Interpolant.call(this, e, t, r, n);
}
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: LinearInterpolant,
  interpolate_: function(e, t, r, n) {
    for (var a = this.resultBuffer, o = this.sampleValues, s = this.valueSize, l = e * s, c = l - s, u = (r - t) / (n - t), h = 1 - u, f = 0; f !== s; ++f)
      a[f] = o[c + f] * h + o[l + f] * u;
    return a;
  }
});
function DiscreteInterpolant(e, t, r, n) {
  Interpolant.call(this, e, t, r, n);
}
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: DiscreteInterpolant,
  interpolate_: function(e) {
    return this.copySampleValue_(e - 1);
  }
});
function KeyframeTrack(e, t, r, n) {
  if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
  if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
  this.name = e, this.times = AnimationUtils.convertArray(t, this.TimeBufferType), this.values = AnimationUtils.convertArray(r, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
}
Object.assign(KeyframeTrack, {
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  toJSON: function(e) {
    var t = e.constructor, r;
    if (t.toJSON !== void 0)
      r = t.toJSON(e);
    else {
      r = {
        name: e.name,
        times: AnimationUtils.convertArray(e.times, Array),
        values: AnimationUtils.convertArray(e.values, Array)
      };
      var n = e.getInterpolation();
      n !== e.DefaultInterpolation && (r.interpolation = n);
    }
    return r.type = e.ValueTypeName, r;
  }
});
Object.assign(KeyframeTrack.prototype, {
  constructor: KeyframeTrack,
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodDiscrete: function(e) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), e);
  },
  InterpolantFactoryMethodLinear: function(e) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), e);
  },
  InterpolantFactoryMethodSmooth: function(e) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), e);
  },
  setInterpolation: function(e) {
    var t;
    switch (e) {
      case InterpolateDiscrete:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      var r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return this.createInterpolant = t, this;
  },
  getInterpolation: function() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  },
  getValueSize: function() {
    return this.values.length / this.times.length;
  },
  // move all keyframes either forwards or backwards in time
  shift: function(e) {
    if (e !== 0)
      for (var t = this.times, r = 0, n = t.length; r !== n; ++r)
        t[r] += e;
    return this;
  },
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale: function(e) {
    if (e !== 1)
      for (var t = this.times, r = 0, n = t.length; r !== n; ++r)
        t[r] *= e;
    return this;
  },
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim: function(e, t) {
    for (var r = this.times, n = r.length, a = 0, o = n - 1; a !== n && r[a] < e; )
      ++a;
    for (; o !== -1 && r[o] > t; )
      --o;
    if (++o, a !== 0 || o !== n) {
      a >= o && (o = Math.max(o, 1), a = o - 1);
      var s = this.getValueSize();
      this.times = AnimationUtils.arraySlice(r, a, o), this.values = AnimationUtils.arraySlice(this.values, a * s, o * s);
    }
    return this;
  },
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate: function() {
    var e = !0, t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    var r = this.times, n = this.values, a = r.length;
    a === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    for (var o = null, s = 0; s !== a; s++) {
      var l = r[s];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, s, l), e = !1;
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, s, l, o), e = !1;
        break;
      }
      o = l;
    }
    if (n !== void 0 && AnimationUtils.isTypedArray(n))
      for (var s = 0, c = n.length; s !== c; ++s) {
        var u = n[s];
        if (isNaN(u)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, s, u), e = !1;
          break;
        }
      }
    return e;
  },
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize: function() {
    for (var e = AnimationUtils.arraySlice(this.times), t = AnimationUtils.arraySlice(this.values), r = this.getValueSize(), n = this.getInterpolation() === InterpolateSmooth, a = 1, o = e.length - 1, s = 1; s < o; ++s) {
      var l = !1, c = e[s], u = e[s + 1];
      if (c !== u && (s !== 1 || c !== c[0]))
        if (n)
          l = !0;
        else
          for (var h = s * r, f = h - r, d = h + r, p = 0; p !== r; ++p) {
            var g = t[h + p];
            if (g !== t[f + p] || g !== t[d + p]) {
              l = !0;
              break;
            }
          }
      if (l) {
        if (s !== a) {
          e[a] = e[s];
          for (var v = s * r, _ = a * r, p = 0; p !== r; ++p)
            t[_ + p] = t[v + p];
        }
        ++a;
      }
    }
    if (o > 0) {
      e[a] = e[o];
      for (var v = o * r, _ = a * r, p = 0; p !== r; ++p)
        t[_ + p] = t[v + p];
      ++a;
    }
    return a !== e.length ? (this.times = AnimationUtils.arraySlice(e, 0, a), this.values = AnimationUtils.arraySlice(t, 0, a * r)) : (this.times = e, this.values = t), this;
  },
  clone: function() {
    var e = AnimationUtils.arraySlice(this.times, 0), t = AnimationUtils.arraySlice(this.values, 0), r = this.constructor, n = new r(this.name, e, t);
    return n.createInterpolant = this.createInterpolant, n;
  }
});
function BooleanKeyframeTrack(e, t, r) {
  KeyframeTrack.call(this, e, t, r);
}
BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: BooleanKeyframeTrack,
  ValueTypeName: "bool",
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
  // Note: Actually this track could have a optimized / compressed
  // representation of a single value and a custom interpolant that
  // computes "firstValue ^ isOdd( index )".
});
function ColorKeyframeTrack(e, t, r, n) {
  KeyframeTrack.call(this, e, t, r, n);
}
ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: ColorKeyframeTrack,
  ValueTypeName: "color"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
  // Note: Very basic implementation and nothing special yet.
  // However, this is the place for color space parameterization.
});
function NumberKeyframeTrack(e, t, r, n) {
  KeyframeTrack.call(this, e, t, r, n);
}
NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: NumberKeyframeTrack,
  ValueTypeName: "number"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
});
function QuaternionLinearInterpolant(e, t, r, n) {
  Interpolant.call(this, e, t, r, n);
}
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: QuaternionLinearInterpolant,
  interpolate_: function(e, t, r, n) {
    for (var a = this.resultBuffer, o = this.sampleValues, s = this.valueSize, l = e * s, c = (r - t) / (n - t), u = l + s; l !== u; l += 4)
      Quaternion.slerpFlat(a, 0, o, l - s, o, l, c);
    return a;
  }
});
function QuaternionKeyframeTrack(e, t, r, n) {
  KeyframeTrack.call(this, e, t, r, n);
}
QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: QuaternionKeyframeTrack,
  ValueTypeName: "quaternion",
  // ValueBufferType is inherited
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodLinear: function(e) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), e);
  },
  InterpolantFactoryMethodSmooth: void 0
  // not yet implemented
});
function StringKeyframeTrack(e, t, r, n) {
  KeyframeTrack.call(this, e, t, r, n);
}
StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: StringKeyframeTrack,
  ValueTypeName: "string",
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
});
function VectorKeyframeTrack(e, t, r, n) {
  KeyframeTrack.call(this, e, t, r, n);
}
VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: VectorKeyframeTrack,
  ValueTypeName: "vector"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
});
function AnimationClip(e, t, r, n) {
  this.name = e, this.tracks = r, this.duration = t !== void 0 ? t : -1, this.blendMode = n !== void 0 ? n : NormalAnimationBlendMode, this.uuid = MathUtils.generateUUID(), this.duration < 0 && this.resetDuration();
}
function getTrackTypeForValueTypeName(e) {
  switch (e.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
}
function parseKeyframeTrack(e) {
  if (e.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  var t = getTrackTypeForValueTypeName(e.type);
  if (e.times === void 0) {
    var r = [], n = [];
    AnimationUtils.flattenJSON(e.keys, r, n, "value"), e.times = r, e.values = n;
  }
  return t.parse !== void 0 ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation);
}
Object.assign(AnimationClip, {
  parse: function(e) {
    for (var t = [], r = e.tracks, n = 1 / (e.fps || 1), a = 0, o = r.length; a !== o; ++a)
      t.push(parseKeyframeTrack(r[a]).scale(n));
    return new AnimationClip(e.name, e.duration, t, e.blendMode);
  },
  toJSON: function(e) {
    for (var t = [], r = e.tracks, n = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    }, a = 0, o = r.length; a !== o; ++a)
      t.push(KeyframeTrack.toJSON(r[a]));
    return n;
  },
  CreateFromMorphTargetSequence: function(e, t, r, n) {
    for (var a = t.length, o = [], s = 0; s < a; s++) {
      var l = [], c = [];
      l.push(
        (s + a - 1) % a,
        s,
        (s + 1) % a
      ), c.push(0, 1, 0);
      var u = AnimationUtils.getKeyframeOrder(l);
      l = AnimationUtils.sortedArray(l, 1, u), c = AnimationUtils.sortedArray(c, 1, u), !n && l[0] === 0 && (l.push(a), c.push(c[0])), o.push(
        new NumberKeyframeTrack(
          ".morphTargetInfluences[" + t[s].name + "]",
          l,
          c
        ).scale(1 / r)
      );
    }
    return new AnimationClip(e, -1, o);
  },
  findByName: function(e, t) {
    var r = e;
    if (!Array.isArray(e)) {
      var n = e;
      r = n.geometry && n.geometry.animations || n.animations;
    }
    for (var a = 0; a < r.length; a++)
      if (r[a].name === t)
        return r[a];
    return null;
  },
  CreateClipsFromMorphTargetSequences: function(e, t, r) {
    for (var n = {}, a = /^([\w-]*?)([\d]+)$/, o = 0, s = e.length; o < s; o++) {
      var l = e[o], c = l.name.match(a);
      if (c && c.length > 1) {
        var u = c[1], h = n[u];
        h || (n[u] = h = []), h.push(l);
      }
    }
    var f = [];
    for (var u in n)
      f.push(AnimationClip.CreateFromMorphTargetSequence(u, n[u], t, r));
    return f;
  },
  // parse the animation.hierarchy format
  parseAnimation: function(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    for (var r = function(M, x, w, P, V) {
      if (w.length !== 0) {
        var I = [], $ = [];
        AnimationUtils.flattenJSON(w, I, $, P), I.length !== 0 && V.push(new M(x, I, $));
      }
    }, n = [], a = e.name || "default", o = e.length || -1, s = e.fps || 30, l = e.blendMode, c = e.hierarchy || [], u = 0; u < c.length; u++) {
      var h = c[u].keys;
      if (!(!h || h.length === 0))
        if (h[0].morphTargets) {
          for (var f = {}, d = 0; d < h.length; d++)
            if (h[d].morphTargets)
              for (var p = 0; p < h[d].morphTargets.length; p++)
                f[h[d].morphTargets[p]] = -1;
          for (var g in f) {
            for (var v = [], _ = [], p = 0; p !== h[d].morphTargets.length; ++p) {
              var m = h[d];
              v.push(m.time), _.push(m.morphTarget === g ? 1 : 0);
            }
            n.push(new NumberKeyframeTrack(".morphTargetInfluence[" + g + "]", v, _));
          }
          o = f.length * (s || 1);
        } else {
          var y = ".bones[" + t[u].name + "]";
          r(
            VectorKeyframeTrack,
            y + ".position",
            h,
            "pos",
            n
          ), r(
            QuaternionKeyframeTrack,
            y + ".quaternion",
            h,
            "rot",
            n
          ), r(
            VectorKeyframeTrack,
            y + ".scale",
            h,
            "scl",
            n
          );
        }
    }
    if (n.length === 0)
      return null;
    var b = new AnimationClip(a, o, n, l);
    return b;
  }
});
Object.assign(AnimationClip.prototype, {
  resetDuration: function() {
    for (var e = this.tracks, t = 0, r = 0, n = e.length; r !== n; ++r) {
      var a = this.tracks[r];
      t = Math.max(t, a.times[a.times.length - 1]);
    }
    return this.duration = t, this;
  },
  trim: function() {
    for (var e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  },
  validate: function() {
    for (var e = !0, t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  },
  optimize: function() {
    for (var e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  },
  clone: function() {
    for (var e = [], t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new AnimationClip(this.name, this.duration, e, this.blendMode);
  }
});
var Cache = {
  enabled: !1,
  files: {},
  add: function(e, t) {
    this.enabled !== !1 && (this.files[e] = t);
  },
  get: function(e) {
    if (this.enabled !== !1)
      return this.files[e];
  },
  remove: function(e) {
    delete this.files[e];
  },
  clear: function() {
    this.files = {};
  }
};
function LoadingManager(e, t, r) {
  var n = this, a = !1, o = 0, s = 0, l = void 0, c = [];
  this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = r, this.itemStart = function(u) {
    s++, a === !1 && n.onStart !== void 0 && n.onStart(u, o, s), a = !0;
  }, this.itemEnd = function(u) {
    o++, n.onProgress !== void 0 && n.onProgress(u, o, s), o === s && (a = !1, n.onLoad !== void 0 && n.onLoad());
  }, this.itemError = function(u) {
    n.onError !== void 0 && n.onError(u);
  }, this.resolveURL = function(u) {
    return l ? l(u) : u;
  }, this.setURLModifier = function(u) {
    return l = u, this;
  }, this.addHandler = function(u, h) {
    return c.push(u, h), this;
  }, this.removeHandler = function(u) {
    var h = c.indexOf(u);
    return h !== -1 && c.splice(h, 2), this;
  }, this.getHandler = function(u) {
    for (var h = 0, f = c.length; h < f; h += 2) {
      var d = c[h], p = c[h + 1];
      if (d.global && (d.lastIndex = 0), d.test(u))
        return p;
    }
    return null;
  };
}
var DefaultLoadingManager = new LoadingManager();
function Loader(e) {
  this.manager = e !== void 0 ? e : DefaultLoadingManager, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = "", this.requestHeader = {};
}
Object.assign(Loader.prototype, {
  load: function() {
  },
  loadAsync: function(e, t) {
    var r = this;
    return new Promise(function(n, a) {
      r.load(e, n, t, a);
    });
  },
  parse: function() {
  },
  setCrossOrigin: function(e) {
    return this.crossOrigin = e, this;
  },
  setPath: function(e) {
    return this.path = e, this;
  },
  setResourcePath: function(e) {
    return this.resourcePath = e, this;
  },
  setRequestHeader: function(e) {
    return this.requestHeader = e, this;
  }
});
var loading = {};
function FileLoader(e) {
  Loader.call(this, e);
}
FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FileLoader,
  load: function(e, t, r, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    var a = this, o = Cache.get(e);
    if (o !== void 0)
      return a.manager.itemStart(e), setTimeout(function() {
        t && t(o), a.manager.itemEnd(e);
      }, 0), o;
    if (loading[e] !== void 0) {
      loading[e].push({
        onLoad: t,
        onProgress: r,
        onError: n
      });
      return;
    }
    var s = /^data:(.*?)(;base64)?,(.*)$/, l = e.match(s);
    if (l) {
      var c = l[1], u = !!l[2], h = l[3];
      h = decodeURIComponent(h), u && (h = atob(h));
      try {
        var f, d = (this.responseType || "").toLowerCase();
        switch (d) {
          case "arraybuffer":
          case "blob":
            for (var p = new Uint8Array(h.length), g = 0; g < h.length; g++)
              p[g] = h.charCodeAt(g);
            d === "blob" ? f = new Blob([p.buffer], { type: c }) : f = p.buffer;
            break;
          case "document":
            var v = new DOMParser();
            f = v.parseFromString(h, c);
            break;
          case "json":
            f = JSON.parse(h);
            break;
          default:
            f = h;
            break;
        }
        setTimeout(function() {
          t && t(f), a.manager.itemEnd(e);
        }, 0);
      } catch (y) {
        setTimeout(function() {
          n && n(y), a.manager.itemError(e), a.manager.itemEnd(e);
        }, 0);
      }
    } else {
      loading[e] = [], loading[e].push({
        onLoad: t,
        onProgress: r,
        onError: n
      });
      var _ = new XMLHttpRequest();
      _.open("GET", e, !0), _.addEventListener("load", function(y) {
        var b = this.response, M = loading[e];
        if (delete loading[e], this.status === 200 || this.status === 0) {
          this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), Cache.add(e, b);
          for (var x = 0, w = M.length; x < w; x++) {
            var P = M[x];
            P.onLoad && P.onLoad(b);
          }
          a.manager.itemEnd(e);
        } else {
          for (var x = 0, w = M.length; x < w; x++) {
            var P = M[x];
            P.onError && P.onError(y);
          }
          a.manager.itemError(e), a.manager.itemEnd(e);
        }
      }, !1), _.addEventListener("progress", function(y) {
        for (var b = loading[e], M = 0, x = b.length; M < x; M++) {
          var w = b[M];
          w.onProgress && w.onProgress(y);
        }
      }, !1), _.addEventListener("error", function(y) {
        var b = loading[e];
        delete loading[e];
        for (var M = 0, x = b.length; M < x; M++) {
          var w = b[M];
          w.onError && w.onError(y);
        }
        a.manager.itemError(e), a.manager.itemEnd(e);
      }, !1), _.addEventListener("abort", function(y) {
        var b = loading[e];
        delete loading[e];
        for (var M = 0, x = b.length; M < x; M++) {
          var w = b[M];
          w.onError && w.onError(y);
        }
        a.manager.itemError(e), a.manager.itemEnd(e);
      }, !1), this.responseType !== void 0 && (_.responseType = this.responseType), this.withCredentials !== void 0 && (_.withCredentials = this.withCredentials), _.overrideMimeType && _.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (var m in this.requestHeader)
        _.setRequestHeader(m, this.requestHeader[m]);
      _.send(null);
    }
    return a.manager.itemStart(e), _;
  },
  setResponseType: function(e) {
    return this.responseType = e, this;
  },
  setWithCredentials: function(e) {
    return this.withCredentials = e, this;
  },
  setMimeType: function(e) {
    return this.mimeType = e, this;
  }
});
function AnimationLoader(e) {
  Loader.call(this, e);
}
AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: AnimationLoader,
  load: function(e, t, r, n) {
    var a = this, o = new FileLoader(a.manager);
    o.setPath(a.path), o.load(e, function(s) {
      try {
        t(a.parse(JSON.parse(s)));
      } catch (l) {
        n ? n(l) : console.error(l), a.manager.itemError(e);
      }
    }, r, n);
  },
  parse: function(e) {
    for (var t = [], r = 0; r < e.length; r++) {
      var n = AnimationClip.parse(e[r]);
      t.push(n);
    }
    return t;
  }
});
function CompressedTextureLoader(e) {
  Loader.call(this, e);
}
CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CompressedTextureLoader,
  load: function(e, t, r, n) {
    var a = this, o = [], s = new CompressedTexture();
    s.image = o;
    var l = new FileLoader(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer");
    function c(d) {
      l.load(e[d], function(p) {
        var g = a.parse(p, !0);
        o[d] = {
          width: g.width,
          height: g.height,
          format: g.format,
          mipmaps: g.mipmaps
        }, u += 1, u === 6 && (g.mipmapCount === 1 && (s.minFilter = LinearFilter), s.format = g.format, s.needsUpdate = !0, t && t(s));
      }, r, n);
    }
    if (Array.isArray(e))
      for (var u = 0, h = 0, f = e.length; h < f; ++h)
        c(h);
    else
      l.load(e, function(d) {
        var p = a.parse(d, !0);
        if (p.isCubemap)
          for (var g = p.mipmaps.length / p.mipmapCount, v = 0; v < g; v++) {
            o[v] = { mipmaps: [] };
            for (var _ = 0; _ < p.mipmapCount; _++)
              o[v].mipmaps.push(p.mipmaps[v * p.mipmapCount + _]), o[v].format = p.format, o[v].width = p.width, o[v].height = p.height;
          }
        else
          s.image.width = p.width, s.image.height = p.height, s.mipmaps = p.mipmaps;
        p.mipmapCount === 1 && (s.minFilter = LinearFilter), s.format = p.format, s.needsUpdate = !0, t && t(s);
      }, r, n);
    return s;
  }
});
function DataTextureLoader(e) {
  Loader.call(this, e);
}
DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: DataTextureLoader,
  load: function(e, t, r, n) {
    var a = this, o = new DataTexture(), s = new FileLoader(this.manager);
    return s.setResponseType("arraybuffer"), s.setPath(this.path), s.load(e, function(l) {
      var c = a.parse(l);
      c && (c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width, o.image.height = c.height, o.image.data = c.data), o.wrapS = c.wrapS !== void 0 ? c.wrapS : ClampToEdgeWrapping, o.wrapT = c.wrapT !== void 0 ? c.wrapT : ClampToEdgeWrapping, o.magFilter = c.magFilter !== void 0 ? c.magFilter : LinearFilter, o.minFilter = c.minFilter !== void 0 ? c.minFilter : LinearFilter, o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.format !== void 0 && (o.format = c.format), c.type !== void 0 && (o.type = c.type), c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps, o.minFilter = LinearMipmapLinearFilter), c.mipmapCount === 1 && (o.minFilter = LinearFilter), o.needsUpdate = !0, t && t(o, c));
    }, r, n), o;
  }
});
function ImageLoader(e) {
  Loader.call(this, e);
}
ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageLoader,
  load: function(e, t, r, n) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    var a = this, o = Cache.get(e);
    if (o !== void 0)
      return a.manager.itemStart(e), setTimeout(function() {
        t && t(o), a.manager.itemEnd(e);
      }, 0), o;
    var s = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function l() {
      s.removeEventListener("load", l, !1), s.removeEventListener("error", c, !1), Cache.add(e, this), t && t(this), a.manager.itemEnd(e);
    }
    function c(u) {
      s.removeEventListener("load", l, !1), s.removeEventListener("error", c, !1), n && n(u), a.manager.itemError(e), a.manager.itemEnd(e);
    }
    return s.addEventListener("load", l, !1), s.addEventListener("error", c, !1), e.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (s.crossOrigin = this.crossOrigin), a.manager.itemStart(e), s.src = e, s;
  }
});
function CubeTextureLoader(e) {
  Loader.call(this, e);
}
CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CubeTextureLoader,
  load: function(e, t, r, n) {
    var a = new CubeTexture(), o = new ImageLoader(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    var s = 0;
    function l(u) {
      o.load(e[u], function(h) {
        a.images[u] = h, s++, s === 6 && (a.needsUpdate = !0, t && t(a));
      }, void 0, n);
    }
    for (var c = 0; c < e.length; ++c)
      l(c);
    return a;
  }
});
function TextureLoader(e) {
  Loader.call(this, e);
}
TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: TextureLoader,
  load: function(e, t, r, n) {
    var a = new Texture(), o = new ImageLoader(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(s) {
      a.image = s;
      var l = e.search(/\.jpe?g($|\?)/i) > 0 || e.search(/^data\:image\/jpeg/) === 0;
      a.format = l ? RGBFormat : RGBAFormat, a.needsUpdate = !0, t !== void 0 && t(a);
    }, r, n), a;
  }
});
function Curve() {
  this.type = "Curve", this.arcLengthDivisions = 200;
}
Object.assign(Curve.prototype, {
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint: function() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  },
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt: function(e, t) {
    var r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  },
  // Get sequence of points using getPoint( t )
  getPoints: function(e) {
    e === void 0 && (e = 5);
    for (var t = [], r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return t;
  },
  // Get sequence of points using getPointAt( u )
  getSpacedPoints: function(e) {
    e === void 0 && (e = 5);
    for (var t = [], r = 0; r <= e; r++)
      t.push(this.getPointAt(r / e));
    return t;
  },
  // Get total curve arc length
  getLength: function() {
    var e = this.getLengths();
    return e[e.length - 1];
  },
  // Get list of cumulative segment lengths
  getLengths: function(e) {
    if (e === void 0 && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    var t = [], r, n = this.getPoint(0), a, o = 0;
    for (t.push(0), a = 1; a <= e; a++)
      r = this.getPoint(a / e), o += r.distanceTo(n), t.push(o), n = r;
    return this.cacheArcLengths = t, t;
  },
  updateArcLengths: function() {
    this.needsUpdate = !0, this.getLengths();
  },
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping: function(e, t) {
    var r = this.getLengths(), n = 0, a = r.length, o;
    t ? o = t : o = e * r[a - 1];
    for (var s = 0, l = a - 1, c; s <= l; )
      if (n = Math.floor(s + (l - s) / 2), c = r[n] - o, c < 0)
        s = n + 1;
      else if (c > 0)
        l = n - 1;
      else {
        l = n;
        break;
      }
    if (n = l, r[n] === o)
      return n / (a - 1);
    var u = r[n], h = r[n + 1], f = h - u, d = (o - u) / f, p = (n + d) / (a - 1);
    return p;
  },
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent: function(e, t) {
    var r = 1e-4, n = e - r, a = e + r;
    n < 0 && (n = 0), a > 1 && (a = 1);
    var o = this.getPoint(n), s = this.getPoint(a), l = t || (o.isVector2 ? new Vector2() : new Vector3());
    return l.copy(s).sub(o).normalize(), l;
  },
  getTangentAt: function(e, t) {
    var r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  },
  computeFrenetFrames: function(e, t) {
    var r = new Vector3(), n = [], a = [], o = [], s = new Vector3(), l = new Matrix4(), c, u, h;
    for (c = 0; c <= e; c++)
      u = c / e, n[c] = this.getTangentAt(u, new Vector3()), n[c].normalize();
    a[0] = new Vector3(), o[0] = new Vector3();
    var f = Number.MAX_VALUE, d = Math.abs(n[0].x), p = Math.abs(n[0].y), g = Math.abs(n[0].z);
    for (d <= f && (f = d, r.set(1, 0, 0)), p <= f && (f = p, r.set(0, 1, 0)), g <= f && r.set(0, 0, 1), s.crossVectors(n[0], r).normalize(), a[0].crossVectors(n[0], s), o[0].crossVectors(n[0], a[0]), c = 1; c <= e; c++)
      a[c] = a[c - 1].clone(), o[c] = o[c - 1].clone(), s.crossVectors(n[c - 1], n[c]), s.length() > Number.EPSILON && (s.normalize(), h = Math.acos(MathUtils.clamp(n[c - 1].dot(n[c]), -1, 1)), a[c].applyMatrix4(l.makeRotationAxis(s, h))), o[c].crossVectors(n[c], a[c]);
    if (t === !0)
      for (h = Math.acos(MathUtils.clamp(a[0].dot(a[e]), -1, 1)), h /= e, n[0].dot(s.crossVectors(a[0], a[e])) > 0 && (h = -h), c = 1; c <= e; c++)
        a[c].applyMatrix4(l.makeRotationAxis(n[c], h * c)), o[c].crossVectors(n[c], a[c]);
    return {
      tangents: n,
      normals: a,
      binormals: o
    };
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  },
  toJSON: function() {
    var e = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  },
  fromJSON: function(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
});
function EllipseCurve(e, t, r, n, a, o, s, l) {
  Curve.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = r || 1, this.yRadius = n || 1, this.aStartAngle = a || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = s || !1, this.aRotation = l || 0;
}
EllipseCurve.prototype = Object.create(Curve.prototype);
EllipseCurve.prototype.constructor = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = !0;
EllipseCurve.prototype.getPoint = function(e, t) {
  for (var r = t || new Vector2(), n = Math.PI * 2, a = this.aEndAngle - this.aStartAngle, o = Math.abs(a) < Number.EPSILON; a < 0; ) a += n;
  for (; a > n; ) a -= n;
  a < Number.EPSILON && (o ? a = 0 : a = n), this.aClockwise === !0 && !o && (a === n ? a = -n : a = a - n);
  var s = this.aStartAngle + e * a, l = this.aX + this.xRadius * Math.cos(s), c = this.aY + this.yRadius * Math.sin(s);
  if (this.aRotation !== 0) {
    var u = Math.cos(this.aRotation), h = Math.sin(this.aRotation), f = l - this.aX, d = c - this.aY;
    l = f * u - d * h + this.aX, c = f * h + d * u + this.aY;
  }
  return r.set(l, c);
};
EllipseCurve.prototype.copy = function(e) {
  return Curve.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
};
EllipseCurve.prototype.toJSON = function() {
  var e = Curve.prototype.toJSON.call(this);
  return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
};
EllipseCurve.prototype.fromJSON = function(e) {
  return Curve.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
};
function ArcCurve(e, t, r, n, a, o) {
  EllipseCurve.call(this, e, t, r, r, n, a, o), this.type = "ArcCurve";
}
ArcCurve.prototype = Object.create(EllipseCurve.prototype);
ArcCurve.prototype.constructor = ArcCurve;
ArcCurve.prototype.isArcCurve = !0;
function CubicPoly() {
  var e = 0, t = 0, r = 0, n = 0;
  function a(o, s, l, c) {
    e = o, t = l, r = -3 * o + 3 * s - 2 * l - c, n = 2 * o - 2 * s + l + c;
  }
  return {
    initCatmullRom: function(o, s, l, c, u) {
      a(s, l, u * (l - o), u * (c - s));
    },
    initNonuniformCatmullRom: function(o, s, l, c, u, h, f) {
      var d = (s - o) / u - (l - o) / (u + h) + (l - s) / h, p = (l - s) / h - (c - s) / (h + f) + (c - l) / f;
      d *= h, p *= h, a(s, l, d, p);
    },
    calc: function(o) {
      var s = o * o, l = s * o;
      return e + t * o + r * s + n * l;
    }
  };
}
var tmp = new Vector3(), px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
function CatmullRomCurve3(e, t, r, n) {
  Curve.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = r || "centripetal", this.tension = n || 0.5;
}
CatmullRomCurve3.prototype = Object.create(Curve.prototype);
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = !0;
CatmullRomCurve3.prototype.getPoint = function(e, t) {
  var r = t || new Vector3(), n = this.points, a = n.length, o = (a - (this.closed ? 0 : 1)) * e, s = Math.floor(o), l = o - s;
  this.closed ? s += s > 0 ? 0 : (Math.floor(Math.abs(s) / a) + 1) * a : l === 0 && s === a - 1 && (s = a - 2, l = 1);
  var c, u, h, f;
  if (this.closed || s > 0 ? c = n[(s - 1) % a] : (tmp.subVectors(n[0], n[1]).add(n[0]), c = tmp), u = n[s % a], h = n[(s + 1) % a], this.closed || s + 2 < a ? f = n[(s + 2) % a] : (tmp.subVectors(n[a - 1], n[a - 2]).add(n[a - 1]), f = tmp), this.curveType === "centripetal" || this.curveType === "chordal") {
    var d = this.curveType === "chordal" ? 0.5 : 0.25, p = Math.pow(c.distanceToSquared(u), d), g = Math.pow(u.distanceToSquared(h), d), v = Math.pow(h.distanceToSquared(f), d);
    g < 1e-4 && (g = 1), p < 1e-4 && (p = g), v < 1e-4 && (v = g), px.initNonuniformCatmullRom(c.x, u.x, h.x, f.x, p, g, v), py.initNonuniformCatmullRom(c.y, u.y, h.y, f.y, p, g, v), pz.initNonuniformCatmullRom(c.z, u.z, h.z, f.z, p, g, v);
  } else this.curveType === "catmullrom" && (px.initCatmullRom(c.x, u.x, h.x, f.x, this.tension), py.initCatmullRom(c.y, u.y, h.y, f.y, this.tension), pz.initCatmullRom(c.z, u.z, h.z, f.z, this.tension));
  return r.set(
    px.calc(l),
    py.calc(l),
    pz.calc(l)
  ), r;
};
CatmullRomCurve3.prototype.copy = function(e) {
  Curve.prototype.copy.call(this, e), this.points = [];
  for (var t = 0, r = e.points.length; t < r; t++) {
    var n = e.points[t];
    this.points.push(n.clone());
  }
  return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
};
CatmullRomCurve3.prototype.toJSON = function() {
  var e = Curve.prototype.toJSON.call(this);
  e.points = [];
  for (var t = 0, r = this.points.length; t < r; t++) {
    var n = this.points[t];
    e.points.push(n.toArray());
  }
  return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
};
CatmullRomCurve3.prototype.fromJSON = function(e) {
  Curve.prototype.fromJSON.call(this, e), this.points = [];
  for (var t = 0, r = e.points.length; t < r; t++) {
    var n = e.points[t];
    this.points.push(new Vector3().fromArray(n));
  }
  return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
};
function CatmullRom(e, t, r, n, a) {
  var o = (n - t) * 0.5, s = (a - r) * 0.5, l = e * e, c = e * l;
  return (2 * r - 2 * n + o + s) * c + (-3 * r + 3 * n - 2 * o - s) * l + o * e + r;
}
function QuadraticBezierP0(e, t) {
  var r = 1 - e;
  return r * r * t;
}
function QuadraticBezierP1(e, t) {
  return 2 * (1 - e) * e * t;
}
function QuadraticBezierP2(e, t) {
  return e * e * t;
}
function QuadraticBezier(e, t, r, n) {
  return QuadraticBezierP0(e, t) + QuadraticBezierP1(e, r) + QuadraticBezierP2(e, n);
}
function CubicBezierP0(e, t) {
  var r = 1 - e;
  return r * r * r * t;
}
function CubicBezierP1(e, t) {
  var r = 1 - e;
  return 3 * r * r * e * t;
}
function CubicBezierP2(e, t) {
  return 3 * (1 - e) * e * e * t;
}
function CubicBezierP3(e, t) {
  return e * e * e * t;
}
function CubicBezier(e, t, r, n, a) {
  return CubicBezierP0(e, t) + CubicBezierP1(e, r) + CubicBezierP2(e, n) + CubicBezierP3(e, a);
}
function CubicBezierCurve(e, t, r, n) {
  Curve.call(this), this.type = "CubicBezierCurve", this.v0 = e || new Vector2(), this.v1 = t || new Vector2(), this.v2 = r || new Vector2(), this.v3 = n || new Vector2();
}
CubicBezierCurve.prototype = Object.create(Curve.prototype);
CubicBezierCurve.prototype.constructor = CubicBezierCurve;
CubicBezierCurve.prototype.isCubicBezierCurve = !0;
CubicBezierCurve.prototype.getPoint = function(e, t) {
  var r = t || new Vector2(), n = this.v0, a = this.v1, o = this.v2, s = this.v3;
  return r.set(
    CubicBezier(e, n.x, a.x, o.x, s.x),
    CubicBezier(e, n.y, a.y, o.y, s.y)
  ), r;
};
CubicBezierCurve.prototype.copy = function(e) {
  return Curve.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
};
CubicBezierCurve.prototype.toJSON = function() {
  var e = Curve.prototype.toJSON.call(this);
  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
};
CubicBezierCurve.prototype.fromJSON = function(e) {
  return Curve.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
};
function CubicBezierCurve3(e, t, r, n) {
  Curve.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new Vector3(), this.v1 = t || new Vector3(), this.v2 = r || new Vector3(), this.v3 = n || new Vector3();
}
CubicBezierCurve3.prototype = Object.create(Curve.prototype);
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = !0;
CubicBezierCurve3.prototype.getPoint = function(e, t) {
  var r = t || new Vector3(), n = this.v0, a = this.v1, o = this.v2, s = this.v3;
  return r.set(
    CubicBezier(e, n.x, a.x, o.x, s.x),
    CubicBezier(e, n.y, a.y, o.y, s.y),
    CubicBezier(e, n.z, a.z, o.z, s.z)
  ), r;
};
CubicBezierCurve3.prototype.copy = function(e) {
  return Curve.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
};
CubicBezierCurve3.prototype.toJSON = function() {
  var e = Curve.prototype.toJSON.call(this);
  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
};
CubicBezierCurve3.prototype.fromJSON = function(e) {
  return Curve.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
};
function LineCurve(e, t) {
  Curve.call(this), this.type = "LineCurve", this.v1 = e || new Vector2(), this.v2 = t || new Vector2();
}
LineCurve.prototype = Object.create(Curve.prototype);
LineCurve.prototype.constructor = LineCurve;
LineCurve.prototype.isLineCurve = !0;
LineCurve.prototype.getPoint = function(e, t) {
  var r = t || new Vector2();
  return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
};
LineCurve.prototype.getPointAt = function(e, t) {
  return this.getPoint(e, t);
};
LineCurve.prototype.getTangent = function(e, t) {
  var r = t || new Vector2(), r = r.copy(this.v2).sub(this.v1).normalize();
  return r;
};
LineCurve.prototype.copy = function(e) {
  return Curve.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
};
LineCurve.prototype.toJSON = function() {
  var e = Curve.prototype.toJSON.call(this);
  return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
};
LineCurve.prototype.fromJSON = function(e) {
  return Curve.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
};
function LineCurve3(e, t) {
  Curve.call(this), this.type = "LineCurve3", this.v1 = e || new Vector3(), this.v2 = t || new Vector3();
}
LineCurve3.prototype = Object.create(Curve.prototype);
LineCurve3.prototype.constructor = LineCurve3;
LineCurve3.prototype.isLineCurve3 = !0;
LineCurve3.prototype.getPoint = function(e, t) {
  var r = t || new Vector3();
  return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
};
LineCurve3.prototype.getPointAt = function(e, t) {
  return this.getPoint(e, t);
};
LineCurve3.prototype.copy = function(e) {
  return Curve.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
};
LineCurve3.prototype.toJSON = function() {
  var e = Curve.prototype.toJSON.call(this);
  return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
};
LineCurve3.prototype.fromJSON = function(e) {
  return Curve.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
};
function QuadraticBezierCurve(e, t, r) {
  Curve.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new Vector2(), this.v1 = t || new Vector2(), this.v2 = r || new Vector2();
}
QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = !0;
QuadraticBezierCurve.prototype.getPoint = function(e, t) {
  var r = t || new Vector2(), n = this.v0, a = this.v1, o = this.v2;
  return r.set(
    QuadraticBezier(e, n.x, a.x, o.x),
    QuadraticBezier(e, n.y, a.y, o.y)
  ), r;
};
QuadraticBezierCurve.prototype.copy = function(e) {
  return Curve.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
};
QuadraticBezierCurve.prototype.toJSON = function() {
  var e = Curve.prototype.toJSON.call(this);
  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
};
QuadraticBezierCurve.prototype.fromJSON = function(e) {
  return Curve.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
};
function QuadraticBezierCurve3(e, t, r) {
  Curve.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new Vector3(), this.v1 = t || new Vector3(), this.v2 = r || new Vector3();
}
QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = !0;
QuadraticBezierCurve3.prototype.getPoint = function(e, t) {
  var r = t || new Vector3(), n = this.v0, a = this.v1, o = this.v2;
  return r.set(
    QuadraticBezier(e, n.x, a.x, o.x),
    QuadraticBezier(e, n.y, a.y, o.y),
    QuadraticBezier(e, n.z, a.z, o.z)
  ), r;
};
QuadraticBezierCurve3.prototype.copy = function(e) {
  return Curve.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
};
QuadraticBezierCurve3.prototype.toJSON = function() {
  var e = Curve.prototype.toJSON.call(this);
  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
};
QuadraticBezierCurve3.prototype.fromJSON = function(e) {
  return Curve.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
};
function SplineCurve(e) {
  Curve.call(this), this.type = "SplineCurve", this.points = e || [];
}
SplineCurve.prototype = Object.create(Curve.prototype);
SplineCurve.prototype.constructor = SplineCurve;
SplineCurve.prototype.isSplineCurve = !0;
SplineCurve.prototype.getPoint = function(e, t) {
  var r = t || new Vector2(), n = this.points, a = (n.length - 1) * e, o = Math.floor(a), s = a - o, l = n[o === 0 ? o : o - 1], c = n[o], u = n[o > n.length - 2 ? n.length - 1 : o + 1], h = n[o > n.length - 3 ? n.length - 1 : o + 2];
  return r.set(
    CatmullRom(s, l.x, c.x, u.x, h.x),
    CatmullRom(s, l.y, c.y, u.y, h.y)
  ), r;
};
SplineCurve.prototype.copy = function(e) {
  Curve.prototype.copy.call(this, e), this.points = [];
  for (var t = 0, r = e.points.length; t < r; t++) {
    var n = e.points[t];
    this.points.push(n.clone());
  }
  return this;
};
SplineCurve.prototype.toJSON = function() {
  var e = Curve.prototype.toJSON.call(this);
  e.points = [];
  for (var t = 0, r = this.points.length; t < r; t++) {
    var n = this.points[t];
    e.points.push(n.toArray());
  }
  return e;
};
SplineCurve.prototype.fromJSON = function(e) {
  Curve.prototype.fromJSON.call(this, e), this.points = [];
  for (var t = 0, r = e.points.length; t < r; t++) {
    var n = e.points[t];
    this.points.push(new Vector2().fromArray(n));
  }
  return this;
};
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
function CurvePath() {
  Curve.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
}
CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
  constructor: CurvePath,
  add: function(e) {
    this.curves.push(e);
  },
  closePath: function() {
    var e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new LineCurve(t, e));
  },
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint: function(e) {
    for (var t = e * this.getLength(), r = this.getCurveLengths(), n = 0; n < r.length; ) {
      if (r[n] >= t) {
        var a = r[n] - t, o = this.curves[n], s = o.getLength(), l = s === 0 ? 0 : 1 - a / s;
        return o.getPointAt(l);
      }
      n++;
    }
    return null;
  },
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength: function() {
    var e = this.getCurveLengths();
    return e[e.length - 1];
  },
  // cacheLengths must be recalculated.
  updateArcLengths: function() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  },
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths: function() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    for (var e = [], t = 0, r = 0, n = this.curves.length; r < n; r++)
      t += this.curves[r].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  },
  getSpacedPoints: function(e) {
    e === void 0 && (e = 40);
    for (var t = [], r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  },
  getPoints: function(e) {
    e = e || 12;
    for (var t = [], r, n = 0, a = this.curves; n < a.length; n++)
      for (var o = a[n], s = o && o.isEllipseCurve ? e * 2 : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? e * o.points.length : e, l = o.getPoints(s), c = 0; c < l.length; c++) {
        var u = l[c];
        r && r.equals(u) || (t.push(u), r = u);
      }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  },
  copy: function(e) {
    Curve.prototype.copy.call(this, e), this.curves = [];
    for (var t = 0, r = e.curves.length; t < r; t++) {
      var n = e.curves[t];
      this.curves.push(n.clone());
    }
    return this.autoClose = e.autoClose, this;
  },
  toJSON: function() {
    var e = Curve.prototype.toJSON.call(this);
    e.autoClose = this.autoClose, e.curves = [];
    for (var t = 0, r = this.curves.length; t < r; t++) {
      var n = this.curves[t];
      e.curves.push(n.toJSON());
    }
    return e;
  },
  fromJSON: function(e) {
    Curve.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
    for (var t = 0, r = e.curves.length; t < r; t++) {
      var n = e.curves[t];
      this.curves.push(new Curves[n.type]().fromJSON(n));
    }
    return this;
  }
});
function Path(e) {
  CurvePath.call(this), this.type = "Path", this.currentPoint = new Vector2(), e && this.setFromPoints(e);
}
Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
  constructor: Path,
  setFromPoints: function(e) {
    this.moveTo(e[0].x, e[0].y);
    for (var t = 1, r = e.length; t < r; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  },
  moveTo: function(e, t) {
    return this.currentPoint.set(e, t), this;
  },
  lineTo: function(e, t) {
    var r = new LineCurve(this.currentPoint.clone(), new Vector2(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  },
  quadraticCurveTo: function(e, t, r, n) {
    var a = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2(e, t),
      new Vector2(r, n)
    );
    return this.curves.push(a), this.currentPoint.set(r, n), this;
  },
  bezierCurveTo: function(e, t, r, n, a, o) {
    var s = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2(e, t),
      new Vector2(r, n),
      new Vector2(a, o)
    );
    return this.curves.push(s), this.currentPoint.set(a, o), this;
  },
  splineThru: function(e) {
    var t = [this.currentPoint.clone()].concat(e), r = new SplineCurve(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  },
  arc: function(e, t, r, n, a, o) {
    var s = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(
      e + s,
      t + l,
      r,
      n,
      a,
      o
    ), this;
  },
  absarc: function(e, t, r, n, a, o) {
    return this.absellipse(e, t, r, r, n, a, o), this;
  },
  ellipse: function(e, t, r, n, a, o, s, l) {
    var c = this.currentPoint.x, u = this.currentPoint.y;
    return this.absellipse(e + c, t + u, r, n, a, o, s, l), this;
  },
  absellipse: function(e, t, r, n, a, o, s, l) {
    var c = new EllipseCurve(e, t, r, n, a, o, s, l);
    if (this.curves.length > 0) {
      var u = c.getPoint(0);
      u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
    }
    this.curves.push(c);
    var h = c.getPoint(1);
    return this.currentPoint.copy(h), this;
  },
  copy: function(e) {
    return CurvePath.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this;
  },
  toJSON: function() {
    var e = CurvePath.prototype.toJSON.call(this);
    return e.currentPoint = this.currentPoint.toArray(), e;
  },
  fromJSON: function(e) {
    return CurvePath.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this;
  }
});
function Shape$1(e) {
  Path.call(this, e), this.uuid = MathUtils.generateUUID(), this.type = "Shape", this.holes = [];
}
Shape$1.prototype = Object.assign(Object.create(Path.prototype), {
  constructor: Shape$1,
  getPointsHoles: function(e) {
    for (var t = [], r = 0, n = this.holes.length; r < n; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  },
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints: function(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  },
  copy: function(e) {
    Path.prototype.copy.call(this, e), this.holes = [];
    for (var t = 0, r = e.holes.length; t < r; t++) {
      var n = e.holes[t];
      this.holes.push(n.clone());
    }
    return this;
  },
  toJSON: function() {
    var e = Path.prototype.toJSON.call(this);
    e.uuid = this.uuid, e.holes = [];
    for (var t = 0, r = this.holes.length; t < r; t++) {
      var n = this.holes[t];
      e.holes.push(n.toJSON());
    }
    return e;
  },
  fromJSON: function(e) {
    Path.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
    for (var t = 0, r = e.holes.length; t < r; t++) {
      var n = e.holes[t];
      this.holes.push(new Path().fromJSON(n));
    }
    return this;
  }
});
function Light(e, t) {
  Object3D.call(this), this.type = "Light", this.color = new Color(e), this.intensity = t !== void 0 ? t : 1, this.receiveShadow = void 0;
}
Light.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Light,
  isLight: !0,
  copy: function(e) {
    return Object3D.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this;
  },
  toJSON: function(e) {
    var t = Object3D.prototype.toJSON.call(this, e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
});
function HemisphereLight(e, t, r) {
  Light.call(this, e, r), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.groundColor = new Color(t);
}
HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: HemisphereLight,
  isHemisphereLight: !0,
  copy: function(e) {
    return Light.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this;
  }
});
function LightShadow(e) {
  this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new Vector2(512, 512), this.map = null, this.mapPass = null, this.matrix = new Matrix4(), this._frustum = new Frustum(), this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [
    new Vector4(0, 0, 1, 1)
  ];
}
Object.assign(LightShadow.prototype, {
  _projScreenMatrix: new Matrix4(),
  _lightPositionWorld: new Vector3(),
  _lookTarget: new Vector3(),
  getViewportCount: function() {
    return this._viewportCount;
  },
  getFrustum: function() {
    return this._frustum;
  },
  updateMatrices: function(e) {
    var t = this.camera, r = this.matrix, n = this._projScreenMatrix, a = this._lookTarget, o = this._lightPositionWorld;
    o.setFromMatrixPosition(e.matrixWorld), t.position.copy(o), a.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(a), t.updateMatrixWorld(), n.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(n), r.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), r.multiply(t.projectionMatrix), r.multiply(t.matrixWorldInverse);
  },
  getViewport: function(e) {
    return this._viewports[e];
  },
  getFrameExtents: function() {
    return this._frameExtents;
  },
  copy: function(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    var e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
});
function SpotLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
}
SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: SpotLightShadow,
  isSpotLightShadow: !0,
  updateMatrices: function(e) {
    var t = this.camera, r = MathUtils.RAD2DEG * 2 * e.angle, n = this.mapSize.width / this.mapSize.height, a = e.distance || t.far;
    (r !== t.fov || n !== t.aspect || a !== t.far) && (t.fov = r, t.aspect = n, t.far = a, t.updateProjectionMatrix()), LightShadow.prototype.updateMatrices.call(this, e);
  }
});
function SpotLight(e, t, r, n, a, o) {
  Light.call(this, e, t), this.type = "SpotLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D(), Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * Math.PI;
    },
    set: function(s) {
      this.intensity = s / Math.PI;
    }
  }), this.distance = r !== void 0 ? r : 0, this.angle = n !== void 0 ? n : Math.PI / 3, this.penumbra = a !== void 0 ? a : 0, this.decay = o !== void 0 ? o : 1, this.shadow = new SpotLightShadow();
}
SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: SpotLight,
  isSpotLight: !0,
  copy: function(e) {
    return Light.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
});
function PointLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500)), this._frameExtents = new Vector2(4, 2), this._viewportCount = 6, this._viewports = [
    // These viewports map a cube-map onto a 2D texture with the
    // following orientation:
    //
    //  xzXZ
    //   y Y
    //
    // X - Positive x direction
    // x - Negative x direction
    // Y - Positive y direction
    // y - Negative y direction
    // Z - Positive z direction
    // z - Negative z direction
    // positive X
    new Vector4(2, 1, 1, 1),
    // negative X
    new Vector4(0, 1, 1, 1),
    // positive Z
    new Vector4(3, 1, 1, 1),
    // negative Z
    new Vector4(1, 1, 1, 1),
    // positive Y
    new Vector4(3, 0, 1, 1),
    // negative Y
    new Vector4(1, 0, 1, 1)
  ], this._cubeDirections = [
    new Vector3(1, 0, 0),
    new Vector3(-1, 0, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1),
    new Vector3(0, 1, 0),
    new Vector3(0, -1, 0)
  ], this._cubeUps = [
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1)
  ];
}
PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: PointLightShadow,
  isPointLightShadow: !0,
  updateMatrices: function(e, t) {
    t === void 0 && (t = 0);
    var r = this.camera, n = this.matrix, a = this._lightPositionWorld, o = this._lookTarget, s = this._projScreenMatrix;
    a.setFromMatrixPosition(e.matrixWorld), r.position.copy(a), o.copy(r.position), o.add(this._cubeDirections[t]), r.up.copy(this._cubeUps[t]), r.lookAt(o), r.updateMatrixWorld(), n.makeTranslation(-a.x, -a.y, -a.z), s.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(s);
  }
});
function PointLight(e, t, r, n) {
  Light.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * 4 * Math.PI;
    },
    set: function(a) {
      this.intensity = a / (4 * Math.PI);
    }
  }), this.distance = r !== void 0 ? r : 0, this.decay = n !== void 0 ? n : 1, this.shadow = new PointLightShadow();
}
PointLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: PointLight,
  isPointLight: !0,
  copy: function(e) {
    return Light.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
});
function OrthographicCamera(e, t, r, n, a, o) {
  Camera$1.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e !== void 0 ? e : -1, this.right = t !== void 0 ? t : 1, this.top = r !== void 0 ? r : 1, this.bottom = n !== void 0 ? n : -1, this.near = a !== void 0 ? a : 0.1, this.far = o !== void 0 ? o : 2e3, this.updateProjectionMatrix();
}
OrthographicCamera.prototype = Object.assign(Object.create(Camera$1.prototype), {
  constructor: OrthographicCamera,
  isOrthographicCamera: !0,
  copy: function(e, t) {
    return Camera$1.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  },
  setViewOffset: function(e, t, r, n, a, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = n, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    var e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), r = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2, a = r - e, o = r + e, s = n + t, l = n - t;
    if (this.view !== null && this.view.enabled) {
      var c = (this.right - this.left) / this.view.fullWidth / this.zoom, u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      a += c * this.view.offsetX, o = a + c * this.view.width, s -= u * this.view.offsetY, l = s - u * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(a, o, s, l, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function(e) {
    var t = Object3D.prototype.toJSON.call(this, e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
});
function DirectionalLightShadow() {
  LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
}
DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: DirectionalLightShadow,
  isDirectionalLightShadow: !0,
  updateMatrices: function(e) {
    LightShadow.prototype.updateMatrices.call(this, e);
  }
});
function DirectionalLight(e, t) {
  Light.call(this, e, t), this.type = "DirectionalLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D(), this.shadow = new DirectionalLightShadow();
}
DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: DirectionalLight,
  isDirectionalLight: !0,
  copy: function(e) {
    return Light.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
});
function AmbientLight(e, t) {
  Light.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0;
}
AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: AmbientLight,
  isAmbientLight: !0
});
function RectAreaLight(e, t, r, n) {
  Light.call(this, e, t), this.type = "RectAreaLight", this.width = r !== void 0 ? r : 10, this.height = n !== void 0 ? n : 10;
}
RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: RectAreaLight,
  isRectAreaLight: !0,
  copy: function(e) {
    return Light.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this;
  },
  toJSON: function(e) {
    var t = Light.prototype.toJSON.call(this, e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
});
function SphericalHarmonics3() {
  this.coefficients = [];
  for (var e = 0; e < 9; e++)
    this.coefficients.push(new Vector3());
}
Object.assign(SphericalHarmonics3.prototype, {
  isSphericalHarmonics3: !0,
  set: function(e) {
    for (var t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  },
  zero: function() {
    for (var e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  },
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt: function(e, t) {
    var r = e.x, n = e.y, a = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.282095), t.addScaledVector(o[1], 0.488603 * n), t.addScaledVector(o[2], 0.488603 * a), t.addScaledVector(o[3], 0.488603 * r), t.addScaledVector(o[4], 1.092548 * (r * n)), t.addScaledVector(o[5], 1.092548 * (n * a)), t.addScaledVector(o[6], 0.315392 * (3 * a * a - 1)), t.addScaledVector(o[7], 1.092548 * (r * a)), t.addScaledVector(o[8], 0.546274 * (r * r - n * n)), t;
  },
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt: function(e, t) {
    var r = e.x, n = e.y, a = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.886227), t.addScaledVector(o[1], 2 * 0.511664 * n), t.addScaledVector(o[2], 2 * 0.511664 * a), t.addScaledVector(o[3], 2 * 0.511664 * r), t.addScaledVector(o[4], 2 * 0.429043 * r * n), t.addScaledVector(o[5], 2 * 0.429043 * n * a), t.addScaledVector(o[6], 0.743125 * a * a - 0.247708), t.addScaledVector(o[7], 2 * 0.429043 * r * a), t.addScaledVector(o[8], 0.429043 * (r * r - n * n)), t;
  },
  add: function(e) {
    for (var t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  },
  addScaledSH: function(e, t) {
    for (var r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], t);
    return this;
  },
  scale: function(e) {
    for (var t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  },
  lerp: function(e, t) {
    for (var r = 0; r < 9; r++)
      this.coefficients[r].lerp(e.coefficients[r], t);
    return this;
  },
  equals: function(e) {
    for (var t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  },
  copy: function(e) {
    return this.set(e.coefficients);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  fromArray: function(e, t) {
    t === void 0 && (t = 0);
    for (var r = this.coefficients, n = 0; n < 9; n++)
      r[n].fromArray(e, t + n * 3);
    return this;
  },
  toArray: function(e, t) {
    e === void 0 && (e = []), t === void 0 && (t = 0);
    for (var r = this.coefficients, n = 0; n < 9; n++)
      r[n].toArray(e, t + n * 3);
    return e;
  }
});
Object.assign(SphericalHarmonics3, {
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  getBasisAt: function(e, t) {
    var r = e.x, n = e.y, a = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * n, t[2] = 0.488603 * a, t[3] = 0.488603 * r, t[4] = 1.092548 * r * n, t[5] = 1.092548 * n * a, t[6] = 0.315392 * (3 * a * a - 1), t[7] = 1.092548 * r * a, t[8] = 0.546274 * (r * r - n * n);
  }
});
function LightProbe(e, t) {
  Light.call(this, void 0, t), this.type = "LightProbe", this.sh = e !== void 0 ? e : new SphericalHarmonics3();
}
LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: LightProbe,
  isLightProbe: !0,
  copy: function(e) {
    return Light.prototype.copy.call(this, e), this.sh.copy(e.sh), this;
  },
  fromJSON: function(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  },
  toJSON: function(e) {
    var t = Light.prototype.toJSON.call(this, e);
    return t.object.sh = this.sh.toArray(), t;
  }
});
function MaterialLoader(e) {
  Loader.call(this, e), this.textures = {};
}
MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: MaterialLoader,
  load: function(e, t, r, n) {
    var a = this, o = new FileLoader(a.manager);
    o.setPath(a.path), o.load(e, function(s) {
      try {
        t(a.parse(JSON.parse(s)));
      } catch (l) {
        n ? n(l) : console.error(l), a.manager.itemError(e);
      }
    }, r, n);
  },
  parse: function(e) {
    var t = this.textures;
    function r(c) {
      return t[c] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", c), t[c];
    }
    var n = new Materials[e.type]();
    if (e.uuid !== void 0 && (n.uuid = e.uuid), e.name !== void 0 && (n.name = e.name), e.color !== void 0 && n.color.setHex(e.color), e.roughness !== void 0 && (n.roughness = e.roughness), e.metalness !== void 0 && (n.metalness = e.metalness), e.sheen !== void 0 && (n.sheen = new Color().setHex(e.sheen)), e.emissive !== void 0 && n.emissive.setHex(e.emissive), e.specular !== void 0 && n.specular.setHex(e.specular), e.shininess !== void 0 && (n.shininess = e.shininess), e.clearcoat !== void 0 && (n.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = e.clearcoatRoughness), e.fog !== void 0 && (n.fog = e.fog), e.flatShading !== void 0 && (n.flatShading = e.flatShading), e.blending !== void 0 && (n.blending = e.blending), e.combine !== void 0 && (n.combine = e.combine), e.side !== void 0 && (n.side = e.side), e.opacity !== void 0 && (n.opacity = e.opacity), e.transparent !== void 0 && (n.transparent = e.transparent), e.alphaTest !== void 0 && (n.alphaTest = e.alphaTest), e.depthTest !== void 0 && (n.depthTest = e.depthTest), e.depthWrite !== void 0 && (n.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (n.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (n.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (n.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (n.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (n.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (n.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (n.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (n.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (n.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (n.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (n.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (n.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (n.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (n.rotation = e.rotation), e.linewidth !== 1 && (n.linewidth = e.linewidth), e.dashSize !== void 0 && (n.dashSize = e.dashSize), e.gapSize !== void 0 && (n.gapSize = e.gapSize), e.scale !== void 0 && (n.scale = e.scale), e.polygonOffset !== void 0 && (n.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (n.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (n.polygonOffsetUnits = e.polygonOffsetUnits), e.skinning !== void 0 && (n.skinning = e.skinning), e.morphTargets !== void 0 && (n.morphTargets = e.morphTargets), e.morphNormals !== void 0 && (n.morphNormals = e.morphNormals), e.dithering !== void 0 && (n.dithering = e.dithering), e.vertexTangents !== void 0 && (n.vertexTangents = e.vertexTangents), e.visible !== void 0 && (n.visible = e.visible), e.toneMapped !== void 0 && (n.toneMapped = e.toneMapped), e.userData !== void 0 && (n.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? n.vertexColors = e.vertexColors > 0 : n.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (var a in e.uniforms) {
        var o = e.uniforms[a];
        switch (n.uniforms[a] = {}, o.type) {
          case "t":
            n.uniforms[a].value = r(o.value);
            break;
          case "c":
            n.uniforms[a].value = new Color().setHex(o.value);
            break;
          case "v2":
            n.uniforms[a].value = new Vector2().fromArray(o.value);
            break;
          case "v3":
            n.uniforms[a].value = new Vector3().fromArray(o.value);
            break;
          case "v4":
            n.uniforms[a].value = new Vector4().fromArray(o.value);
            break;
          case "m3":
            n.uniforms[a].value = new Matrix3().fromArray(o.value);
          case "m4":
            n.uniforms[a].value = new Matrix4().fromArray(o.value);
            break;
          default:
            n.uniforms[a].value = o.value;
        }
      }
    if (e.defines !== void 0 && (n.defines = e.defines), e.vertexShader !== void 0 && (n.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (n.fragmentShader = e.fragmentShader), e.extensions !== void 0)
      for (var s in e.extensions)
        n.extensions[s] = e.extensions[s];
    if (e.shading !== void 0 && (n.flatShading = e.shading === 1), e.size !== void 0 && (n.size = e.size), e.sizeAttenuation !== void 0 && (n.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (n.map = r(e.map)), e.matcap !== void 0 && (n.matcap = r(e.matcap)), e.alphaMap !== void 0 && (n.alphaMap = r(e.alphaMap)), e.bumpMap !== void 0 && (n.bumpMap = r(e.bumpMap)), e.bumpScale !== void 0 && (n.bumpScale = e.bumpScale), e.normalMap !== void 0 && (n.normalMap = r(e.normalMap)), e.normalMapType !== void 0 && (n.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      var l = e.normalScale;
      Array.isArray(l) === !1 && (l = [l, l]), n.normalScale = new Vector2().fromArray(l);
    }
    return e.displacementMap !== void 0 && (n.displacementMap = r(e.displacementMap)), e.displacementScale !== void 0 && (n.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (n.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (n.roughnessMap = r(e.roughnessMap)), e.metalnessMap !== void 0 && (n.metalnessMap = r(e.metalnessMap)), e.emissiveMap !== void 0 && (n.emissiveMap = r(e.emissiveMap)), e.emissiveIntensity !== void 0 && (n.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (n.specularMap = r(e.specularMap)), e.envMap !== void 0 && (n.envMap = r(e.envMap)), e.envMapIntensity !== void 0 && (n.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (n.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (n.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (n.lightMap = r(e.lightMap)), e.lightMapIntensity !== void 0 && (n.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (n.aoMap = r(e.aoMap)), e.aoMapIntensity !== void 0 && (n.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (n.gradientMap = r(e.gradientMap)), e.clearcoatMap !== void 0 && (n.clearcoatMap = r(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (n.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (n.clearcoatNormalMap = r(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (n.clearcoatNormalScale = new Vector2().fromArray(e.clearcoatNormalScale)), n;
  },
  setTextures: function(e) {
    return this.textures = e, this;
  }
});
var LoaderUtils = {
  decodeText: function(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    for (var t = "", r = 0, n = e.length; r < n; r++)
      t += String.fromCharCode(e[r]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  },
  extractUrlBase: function(e) {
    var t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.substr(0, t + 1);
  }
};
function InstancedBufferGeometry() {
  BufferGeometry.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
}
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
  constructor: InstancedBufferGeometry,
  isInstancedBufferGeometry: !0,
  copy: function(e) {
    return BufferGeometry.prototype.copy.call(this, e), this.instanceCount = e.instanceCount, this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    var e = BufferGeometry.prototype.toJSON.call(this);
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
});
function InstancedBufferAttribute(e, t, r, n) {
  typeof r == "number" && (n = r, r = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), BufferAttribute.call(this, e, t, r), this.meshPerAttribute = n || 1;
}
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
  constructor: InstancedBufferAttribute,
  isInstancedBufferAttribute: !0,
  copy: function(e) {
    return BufferAttribute.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this;
  },
  toJSON: function() {
    var e = BufferAttribute.prototype.toJSON.call(this);
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
});
function BufferGeometryLoader(e) {
  Loader.call(this, e);
}
BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: BufferGeometryLoader,
  load: function(e, t, r, n) {
    var a = this, o = new FileLoader(a.manager);
    o.setPath(a.path), o.load(e, function(s) {
      try {
        t(a.parse(JSON.parse(s)));
      } catch (l) {
        n ? n(l) : console.error(l), a.manager.itemError(e);
      }
    }, r, n);
  },
  parse: function(e) {
    var t = e.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry(), r = e.data.index;
    if (r !== void 0) {
      var n = new TYPED_ARRAYS[r.type](r.array);
      t.setIndex(new BufferAttribute(n, 1));
    }
    var a = e.data.attributes;
    for (var o in a) {
      var s = a[o], n = new TYPED_ARRAYS[s.type](s.array), l = s.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute, c = new l(n, s.itemSize, s.normalized);
      s.name !== void 0 && (c.name = s.name), t.setAttribute(o, c);
    }
    var u = e.data.morphAttributes;
    if (u)
      for (var o in u) {
        for (var h = u[o], f = [], d = 0, p = h.length; d < p; d++) {
          var s = h[d], n = new TYPED_ARRAYS[s.type](s.array), c = new BufferAttribute(n, s.itemSize, s.normalized);
          s.name !== void 0 && (c.name = s.name), f.push(c);
        }
        t.morphAttributes[o] = f;
      }
    var g = e.data.morphTargetsRelative;
    g && (t.morphTargetsRelative = !0);
    var v = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (v !== void 0)
      for (var d = 0, _ = v.length; d !== _; ++d) {
        var m = v[d];
        t.addGroup(m.start, m.count, m.materialIndex);
      }
    var y = e.data.boundingSphere;
    if (y !== void 0) {
      var b = new Vector3();
      y.center !== void 0 && b.fromArray(y.center), t.boundingSphere = new Sphere(b, y.radius);
    }
    return e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t;
  }
});
var TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  // Workaround for IE11 pre KB2929437. See #11440
  Uint8ClampedArray: typeof Uint8ClampedArray < "u" ? Uint8ClampedArray : Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function ObjectLoader(e) {
  Loader.call(this, e);
}
ObjectLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ObjectLoader,
  load: function(e, t, r, n) {
    var a = this, o = this.path === "" ? LoaderUtils.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    var s = new FileLoader(a.manager);
    s.setPath(this.path), s.load(e, function(l) {
      var c = null;
      try {
        c = JSON.parse(l);
      } catch (h) {
        n !== void 0 && n(h), console.error("THREE:ObjectLoader: Can't parse " + e + ".", h.message);
        return;
      }
      var u = c.metadata;
      if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      a.parse(c, t);
    }, r, n);
  },
  parse: function(e, t) {
    var r = this.parseShape(e.shapes), n = this.parseGeometries(e.geometries, r), a = this.parseImages(e.images, function() {
      t !== void 0 && t(l);
    }), o = this.parseTextures(e.textures, a), s = this.parseMaterials(e.materials, o), l = this.parseObject(e.object, n, s);
    return e.animations && (l.animations = this.parseAnimations(e.animations)), (e.images === void 0 || e.images.length === 0) && t !== void 0 && t(l), l;
  },
  parseShape: function(e) {
    var t = {};
    if (e !== void 0)
      for (var r = 0, n = e.length; r < n; r++) {
        var a = new Shape$1().fromJSON(e[r]);
        t[a.uuid] = a;
      }
    return t;
  },
  parseGeometries: function(e, t) {
    var r = {};
    if (e !== void 0)
      for (var n = new BufferGeometryLoader(), a = 0, o = e.length; a < o; a++) {
        var s, l = e[a];
        switch (l.type) {
          case "PlaneGeometry":
          case "PlaneBufferGeometry":
            s = new Geometries[l.type](
              l.width,
              l.height,
              l.widthSegments,
              l.heightSegments
            );
            break;
          case "BoxGeometry":
          case "BoxBufferGeometry":
          case "CubeGeometry":
            s = new Geometries[l.type](
              l.width,
              l.height,
              l.depth,
              l.widthSegments,
              l.heightSegments,
              l.depthSegments
            );
            break;
          case "CircleGeometry":
          case "CircleBufferGeometry":
            s = new Geometries[l.type](
              l.radius,
              l.segments,
              l.thetaStart,
              l.thetaLength
            );
            break;
          case "CylinderGeometry":
          case "CylinderBufferGeometry":
            s = new Geometries[l.type](
              l.radiusTop,
              l.radiusBottom,
              l.height,
              l.radialSegments,
              l.heightSegments,
              l.openEnded,
              l.thetaStart,
              l.thetaLength
            );
            break;
          case "ConeGeometry":
          case "ConeBufferGeometry":
            s = new Geometries[l.type](
              l.radius,
              l.height,
              l.radialSegments,
              l.heightSegments,
              l.openEnded,
              l.thetaStart,
              l.thetaLength
            );
            break;
          case "SphereGeometry":
          case "SphereBufferGeometry":
            s = new Geometries[l.type](
              l.radius,
              l.widthSegments,
              l.heightSegments,
              l.phiStart,
              l.phiLength,
              l.thetaStart,
              l.thetaLength
            );
            break;
          case "DodecahedronGeometry":
          case "DodecahedronBufferGeometry":
          case "IcosahedronGeometry":
          case "IcosahedronBufferGeometry":
          case "OctahedronGeometry":
          case "OctahedronBufferGeometry":
          case "TetrahedronGeometry":
          case "TetrahedronBufferGeometry":
            s = new Geometries[l.type](
              l.radius,
              l.detail
            );
            break;
          case "RingGeometry":
          case "RingBufferGeometry":
            s = new Geometries[l.type](
              l.innerRadius,
              l.outerRadius,
              l.thetaSegments,
              l.phiSegments,
              l.thetaStart,
              l.thetaLength
            );
            break;
          case "TorusGeometry":
          case "TorusBufferGeometry":
            s = new Geometries[l.type](
              l.radius,
              l.tube,
              l.radialSegments,
              l.tubularSegments,
              l.arc
            );
            break;
          case "TorusKnotGeometry":
          case "TorusKnotBufferGeometry":
            s = new Geometries[l.type](
              l.radius,
              l.tube,
              l.tubularSegments,
              l.radialSegments,
              l.p,
              l.q
            );
            break;
          case "TubeGeometry":
          case "TubeBufferGeometry":
            s = new Geometries[l.type](
              new Curves[l.path.type]().fromJSON(l.path),
              l.tubularSegments,
              l.radius,
              l.radialSegments,
              l.closed
            );
            break;
          case "LatheGeometry":
          case "LatheBufferGeometry":
            s = new Geometries[l.type](
              l.points,
              l.segments,
              l.phiStart,
              l.phiLength
            );
            break;
          case "PolyhedronGeometry":
          case "PolyhedronBufferGeometry":
            s = new Geometries[l.type](
              l.vertices,
              l.indices,
              l.radius,
              l.details
            );
            break;
          case "ShapeGeometry":
          case "ShapeBufferGeometry":
            for (var f = [], c = 0, u = l.shapes.length; c < u; c++) {
              var h = t[l.shapes[c]];
              f.push(h);
            }
            s = new Geometries[l.type](
              f,
              l.curveSegments
            );
            break;
          case "ExtrudeGeometry":
          case "ExtrudeBufferGeometry":
            for (var f = [], c = 0, u = l.shapes.length; c < u; c++) {
              var h = t[l.shapes[c]];
              f.push(h);
            }
            var d = l.options.extrudePath;
            d !== void 0 && (l.options.extrudePath = new Curves[d.type]().fromJSON(d)), s = new Geometries[l.type](
              f,
              l.options
            );
            break;
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            s = n.parse(l);
            break;
          case "Geometry":
            console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
            break;
          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + l.type + '"');
            continue;
        }
        s.uuid = l.uuid, l.name !== void 0 && (s.name = l.name), s.isBufferGeometry === !0 && l.userData !== void 0 && (s.userData = l.userData), r[l.uuid] = s;
      }
    return r;
  },
  parseMaterials: function(e, t) {
    var r = {}, n = {};
    if (e !== void 0) {
      var a = new MaterialLoader();
      a.setTextures(t);
      for (var o = 0, s = e.length; o < s; o++) {
        var l = e[o];
        if (l.type === "MultiMaterial") {
          for (var c = [], u = 0; u < l.materials.length; u++) {
            var h = l.materials[u];
            r[h.uuid] === void 0 && (r[h.uuid] = a.parse(h)), c.push(r[h.uuid]);
          }
          n[l.uuid] = c;
        } else
          r[l.uuid] === void 0 && (r[l.uuid] = a.parse(l)), n[l.uuid] = r[l.uuid];
      }
    }
    return n;
  },
  parseAnimations: function(e) {
    for (var t = [], r = 0; r < e.length; r++) {
      var n = e[r], a = AnimationClip.parse(n);
      n.uuid !== void 0 && (a.uuid = n.uuid), t.push(a);
    }
    return t;
  },
  parseImages: function(e, t) {
    var r = this, n = {};
    function a(v) {
      return r.manager.itemStart(v), s.load(v, function() {
        r.manager.itemEnd(v);
      }, void 0, function() {
        r.manager.itemError(v), r.manager.itemEnd(v);
      });
    }
    if (e !== void 0 && e.length > 0) {
      var o = new LoadingManager(t), s = new ImageLoader(o);
      s.setCrossOrigin(this.crossOrigin);
      for (var l = 0, c = e.length; l < c; l++) {
        var u = e[l], h = u.url;
        if (Array.isArray(h)) {
          n[u.uuid] = [];
          for (var f = 0, d = h.length; f < d; f++) {
            var p = h[f], g = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : r.resourcePath + p;
            n[u.uuid].push(a(g));
          }
        } else {
          var g = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u.url) ? u.url : r.resourcePath + u.url;
          n[u.uuid] = a(g);
        }
      }
    }
    return n;
  },
  parseTextures: function(e, t) {
    function r(c, u) {
      return typeof c == "number" ? c : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", c), u[c]);
    }
    var n = {};
    if (e !== void 0)
      for (var a = 0, o = e.length; a < o; a++) {
        var s = e[a];
        s.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), t[s.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", s.image);
        var l;
        Array.isArray(t[s.image]) ? l = new CubeTexture(t[s.image]) : l = new Texture(t[s.image]), l.needsUpdate = !0, l.uuid = s.uuid, s.name !== void 0 && (l.name = s.name), s.mapping !== void 0 && (l.mapping = r(s.mapping, TEXTURE_MAPPING)), s.offset !== void 0 && l.offset.fromArray(s.offset), s.repeat !== void 0 && l.repeat.fromArray(s.repeat), s.center !== void 0 && l.center.fromArray(s.center), s.rotation !== void 0 && (l.rotation = s.rotation), s.wrap !== void 0 && (l.wrapS = r(s.wrap[0], TEXTURE_WRAPPING), l.wrapT = r(s.wrap[1], TEXTURE_WRAPPING)), s.format !== void 0 && (l.format = s.format), s.type !== void 0 && (l.type = s.type), s.encoding !== void 0 && (l.encoding = s.encoding), s.minFilter !== void 0 && (l.minFilter = r(s.minFilter, TEXTURE_FILTER)), s.magFilter !== void 0 && (l.magFilter = r(s.magFilter, TEXTURE_FILTER)), s.anisotropy !== void 0 && (l.anisotropy = s.anisotropy), s.flipY !== void 0 && (l.flipY = s.flipY), s.premultiplyAlpha !== void 0 && (l.premultiplyAlpha = s.premultiplyAlpha), s.unpackAlignment !== void 0 && (l.unpackAlignment = s.unpackAlignment), n[s.uuid] = l;
      }
    return n;
  },
  parseObject: function(e, t, r) {
    var n;
    function a(_) {
      return t[_] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", _), t[_];
    }
    function o(_) {
      if (_ !== void 0) {
        if (Array.isArray(_)) {
          for (var m = [], y = 0, b = _.length; y < b; y++) {
            var M = _[y];
            r[M] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", M), m.push(r[M]);
          }
          return m;
        }
        return r[_] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", _), r[_];
      }
    }
    switch (e.type) {
      case "Scene":
        n = new Scene$1(), e.background !== void 0 && Number.isInteger(e.background) && (n.background = new Color(e.background)), e.fog !== void 0 && (e.fog.type === "Fog" ? n.fog = new Fog(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (n.fog = new FogExp2(e.fog.color, e.fog.density)));
        break;
      case "PerspectiveCamera":
        n = new PerspectiveCamera(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (n.focus = e.focus), e.zoom !== void 0 && (n.zoom = e.zoom), e.filmGauge !== void 0 && (n.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (n.filmOffset = e.filmOffset), e.view !== void 0 && (n.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        n = new OrthographicCamera(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (n.zoom = e.zoom), e.view !== void 0 && (n.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        n = new AmbientLight(e.color, e.intensity);
        break;
      case "DirectionalLight":
        n = new DirectionalLight(e.color, e.intensity);
        break;
      case "PointLight":
        n = new PointLight(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        n = new RectAreaLight(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        n = new SpotLight(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        n = new HemisphereLight(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        n = new LightProbe().fromJSON(e);
        break;
      case "SkinnedMesh":
        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
      case "Mesh":
        var s = a(e.geometry), l = o(e.material);
        n = new Mesh(s, l);
        break;
      case "InstancedMesh":
        var s = a(e.geometry), l = o(e.material), c = e.count, u = e.instanceMatrix;
        n = new InstancedMesh(s, l, c), n.instanceMatrix = new BufferAttribute(new Float32Array(u.array), 16);
        break;
      case "LOD":
        n = new LOD();
        break;
      case "Line":
        n = new Line(a(e.geometry), o(e.material), e.mode);
        break;
      case "LineLoop":
        n = new LineLoop(a(e.geometry), o(e.material));
        break;
      case "LineSegments":
        n = new LineSegments(a(e.geometry), o(e.material));
        break;
      case "PointCloud":
      case "Points":
        n = new Points(a(e.geometry), o(e.material));
        break;
      case "Sprite":
        n = new Sprite(o(e.material));
        break;
      case "Group":
        n = new Group();
        break;
      default:
        n = new Object3D();
    }
    if (n.uuid = e.uuid, e.name !== void 0 && (n.name = e.name), e.matrix !== void 0 ? (n.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (n.matrixAutoUpdate = e.matrixAutoUpdate), n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (e.position !== void 0 && n.position.fromArray(e.position), e.rotation !== void 0 && n.rotation.fromArray(e.rotation), e.quaternion !== void 0 && n.quaternion.fromArray(e.quaternion), e.scale !== void 0 && n.scale.fromArray(e.scale)), e.castShadow !== void 0 && (n.castShadow = e.castShadow), e.receiveShadow !== void 0 && (n.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (n.shadow.bias = e.shadow.bias), e.shadow.radius !== void 0 && (n.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && n.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (n.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (n.visible = e.visible), e.frustumCulled !== void 0 && (n.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (n.renderOrder = e.renderOrder), e.userData !== void 0 && (n.userData = e.userData), e.layers !== void 0 && (n.layers.mask = e.layers), e.children !== void 0)
      for (var h = e.children, f = 0; f < h.length; f++)
        n.add(this.parseObject(h[f], t, r));
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (n.autoUpdate = e.autoUpdate);
      for (var d = e.levels, p = 0; p < d.length; p++) {
        var g = d[p], v = n.getObjectByProperty("uuid", g.object);
        v !== void 0 && n.addLevel(v, g.distance);
      }
    }
    return n;
  }
});
var TEXTURE_MAPPING = {
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  SphericalReflectionMapping,
  CubeUVReflectionMapping,
  CubeUVRefractionMapping
}, TEXTURE_WRAPPING = {
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping
}, TEXTURE_FILTER = {
  NearestFilter,
  NearestMipmapNearestFilter,
  NearestMipmapLinearFilter,
  LinearFilter,
  LinearMipmapNearestFilter,
  LinearMipmapLinearFilter
};
function ImageBitmapLoader(e) {
  typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Loader.call(this, e), this.options = void 0;
}
ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageBitmapLoader,
  setOptions: function(t) {
    return this.options = t, this;
  },
  load: function(e, t, r, n) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    var a = this, o = Cache.get(e);
    if (o !== void 0)
      return a.manager.itemStart(e), setTimeout(function() {
        t && t(o), a.manager.itemEnd(e);
      }, 0), o;
    fetch(e).then(function(s) {
      return s.blob();
    }).then(function(s) {
      return a.options === void 0 ? createImageBitmap(s) : createImageBitmap(s, a.options);
    }).then(function(s) {
      Cache.add(e, s), t && t(s), a.manager.itemEnd(e);
    }).catch(function(s) {
      n && n(s), a.manager.itemError(e), a.manager.itemEnd(e);
    }), a.manager.itemStart(e);
  }
});
function ShapePath() {
  this.type = "ShapePath", this.color = new Color(), this.subPaths = [], this.currentPath = null;
}
Object.assign(ShapePath.prototype, {
  moveTo: function(e, t) {
    return this.currentPath = new Path(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  },
  lineTo: function(e, t) {
    return this.currentPath.lineTo(e, t), this;
  },
  quadraticCurveTo: function(e, t, r, n) {
    return this.currentPath.quadraticCurveTo(e, t, r, n), this;
  },
  bezierCurveTo: function(e, t, r, n, a, o) {
    return this.currentPath.bezierCurveTo(e, t, r, n, a, o), this;
  },
  splineThru: function(e) {
    return this.currentPath.splineThru(e), this;
  },
  toShapes: function(e, t) {
    function r(B) {
      for (var q = [], te = 0, ne = B.length; te < ne; te++) {
        var Q = B[te], ae = new Shape$1();
        ae.curves = Q.curves, q.push(ae);
      }
      return q;
    }
    function n(B, q) {
      for (var te = q.length, ne = !1, Q = te - 1, ae = 0; ae < te; Q = ae++) {
        var oe = q[Q], _e = q[ae], A = _e.x - oe.x, L = _e.y - oe.y;
        if (Math.abs(L) > Number.EPSILON) {
          if (L < 0 && (oe = q[ae], A = -A, _e = q[Q], L = -L), B.y < oe.y || B.y > _e.y) continue;
          if (B.y === oe.y) {
            if (B.x === oe.x) return !0;
          } else {
            var D = L * (B.x - oe.x) - A * (B.y - oe.y);
            if (D === 0) return !0;
            if (D < 0) continue;
            ne = !ne;
          }
        } else {
          if (B.y !== oe.y) continue;
          if (_e.x <= B.x && B.x <= oe.x || oe.x <= B.x && B.x <= _e.x) return !0;
        }
      }
      return ne;
    }
    var a = ShapeUtils.isClockWise, o = this.subPaths;
    if (o.length === 0) return [];
    if (t === !0) return r(o);
    var s, l, c, u = [];
    if (o.length === 1)
      return l = o[0], c = new Shape$1(), c.curves = l.curves, u.push(c), u;
    var h = !a(o[0].getPoints());
    h = e ? !h : h;
    var f = [], d = [], p = [], g = 0, v;
    d[g] = void 0, p[g] = [];
    for (var _ = 0, m = o.length; _ < m; _++)
      l = o[_], v = l.getPoints(), s = a(v), s = e ? !s : s, s ? (!h && d[g] && g++, d[g] = { s: new Shape$1(), p: v }, d[g].s.curves = l.curves, h && g++, p[g] = []) : p[g].push({ h: l, p: v[0] });
    if (!d[0]) return r(o);
    if (d.length > 1) {
      for (var y = !1, b = [], M = 0, x = d.length; M < x; M++)
        f[M] = [];
      for (var M = 0, x = d.length; M < x; M++)
        for (var w = p[M], P = 0; P < w.length; P++) {
          for (var V = w[P], I = !0, $ = 0; $ < d.length; $++)
            n(V.p, d[$].p) && (M !== $ && b.push({ froms: M, tos: $, hole: P }), I ? (I = !1, f[$].push(V)) : y = !0);
          I && f[M].push(V);
        }
      b.length > 0 && (y || (p = f));
    }
    for (var E, _ = 0, G = d.length; _ < G; _++) {
      c = d[_].s, u.push(c), E = p[_];
      for (var O = 0, W = E.length; O < W; O++)
        c.holes.push(E[O].h);
    }
    return u;
  }
});
function Font(e) {
  this.type = "Font", this.data = e;
}
Object.assign(Font.prototype, {
  isFont: !0,
  generateShapes: function(e, t) {
    t === void 0 && (t = 100);
    for (var r = [], n = createPaths(e, t, this.data), a = 0, o = n.length; a < o; a++)
      Array.prototype.push.apply(r, n[a].toShapes());
    return r;
  }
});
function createPaths(e, t, r) {
  for (var n = Array.from ? Array.from(e) : String(e).split(""), a = t / r.resolution, o = (r.boundingBox.yMax - r.boundingBox.yMin + r.underlineThickness) * a, s = [], l = 0, c = 0, u = 0; u < n.length; u++) {
    var h = n[u];
    if (h === `
`)
      l = 0, c -= o;
    else {
      var f = createPath(h, a, l, c, r);
      l += f.offsetX, s.push(f.path);
    }
  }
  return s;
}
function createPath(e, t, r, n, a) {
  var o = a.glyphs[e] || a.glyphs["?"];
  if (!o) {
    console.error('THREE.Font: character "' + e + '" does not exists in font family ' + a.familyName + ".");
    return;
  }
  var s = new ShapePath(), l, c, u, h, f, d, p, g;
  if (o.o)
    for (var v = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), _ = 0, m = v.length; _ < m; ) {
      var y = v[_++];
      switch (y) {
        case "m":
          l = v[_++] * t + r, c = v[_++] * t + n, s.moveTo(l, c);
          break;
        case "l":
          l = v[_++] * t + r, c = v[_++] * t + n, s.lineTo(l, c);
          break;
        case "q":
          u = v[_++] * t + r, h = v[_++] * t + n, f = v[_++] * t + r, d = v[_++] * t + n, s.quadraticCurveTo(f, d, u, h);
          break;
        case "b":
          u = v[_++] * t + r, h = v[_++] * t + n, f = v[_++] * t + r, d = v[_++] * t + n, p = v[_++] * t + r, g = v[_++] * t + n, s.bezierCurveTo(f, d, p, g, u, h);
          break;
      }
    }
  return { offsetX: o.ha * t, path: s };
}
function FontLoader(e) {
  Loader.call(this, e);
}
FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FontLoader,
  load: function(e, t, r, n) {
    var a = this, o = new FileLoader(this.manager);
    o.setPath(this.path), o.load(e, function(s) {
      var l;
      try {
        l = JSON.parse(s);
      } catch {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), l = JSON.parse(s.substring(65, s.length - 2));
      }
      var c = a.parse(l);
      t && t(c);
    }, r, n);
  },
  parse: function(e) {
    return new Font(e);
  }
});
var _context, AudioContext = {
  getContext: function() {
    return _context === void 0 && (_context = new (window.AudioContext || window.webkitAudioContext)()), _context;
  },
  setContext: function(e) {
    _context = e;
  }
};
function AudioLoader(e) {
  Loader.call(this, e);
}
AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: AudioLoader,
  load: function(e, t, r, n) {
    var a = this, o = new FileLoader(a.manager);
    o.setResponseType("arraybuffer"), o.setPath(a.path), o.load(e, function(s) {
      try {
        var l = s.slice(0), c = AudioContext.getContext();
        c.decodeAudioData(l, function(u) {
          t(u);
        });
      } catch (u) {
        n ? n(u) : console.error(u), a.manager.itemError(e);
      }
    }, r, n);
  }
});
function HemisphereLightProbe(e, t, r) {
  LightProbe.call(this, void 0, r);
  var n = new Color().set(e), a = new Color().set(t), o = new Vector3(n.r, n.g, n.b), s = new Vector3(a.r, a.g, a.b), l = Math.sqrt(Math.PI), c = l * Math.sqrt(0.75);
  this.sh.coefficients[0].copy(o).add(s).multiplyScalar(l), this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(c);
}
HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
  constructor: HemisphereLightProbe,
  isHemisphereLightProbe: !0,
  copy: function(e) {
    return LightProbe.prototype.copy.call(this, e), this;
  },
  toJSON: function(e) {
    var t = LightProbe.prototype.toJSON.call(this, e);
    return t;
  }
});
function AmbientLightProbe(e, t) {
  LightProbe.call(this, void 0, t);
  var r = new Color().set(e);
  this.sh.coefficients[0].set(r.r, r.g, r.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}
AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
  constructor: AmbientLightProbe,
  isAmbientLightProbe: !0,
  copy: function(e) {
    return LightProbe.prototype.copy.call(this, e), this;
  },
  toJSON: function(e) {
    var t = LightProbe.prototype.toJSON.call(this, e);
    return t;
  }
});
var _eyeRight = new Matrix4(), _eyeLeft = new Matrix4();
function StereoCamera() {
  this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new PerspectiveCamera(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new PerspectiveCamera(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
    focus: null,
    fov: null,
    aspect: null,
    near: null,
    far: null,
    zoom: null,
    eyeSep: null
  };
}
Object.assign(StereoCamera.prototype, {
  update: function(e) {
    var t = this._cache, r = t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep;
    if (r) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep;
      var n = e.projectionMatrix.clone(), a = t.eyeSep / 2, o = a * t.near / t.focus, s = t.near * Math.tan(MathUtils.DEG2RAD * t.fov * 0.5) / t.zoom, l, c;
      _eyeLeft.elements[12] = -a, _eyeRight.elements[12] = a, l = -s * t.aspect + o, c = s * t.aspect + o, n.elements[0] = 2 * t.near / (c - l), n.elements[8] = (c + l) / (c - l), this.cameraL.projectionMatrix.copy(n), l = -s * t.aspect - o, c = s * t.aspect - o, n.elements[0] = 2 * t.near / (c - l), n.elements[8] = (c + l) / (c - l), this.cameraR.projectionMatrix.copy(n);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(_eyeLeft), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(_eyeRight);
  }
});
function Clock(e) {
  this.autoStart = e !== void 0 ? e : !0, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
}
Object.assign(Clock.prototype, {
  start: function() {
    this.startTime = (typeof performance > "u" ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  },
  stop: function() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  },
  getElapsedTime: function() {
    return this.getDelta(), this.elapsedTime;
  },
  getDelta: function() {
    var e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      var t = (typeof performance > "u" ? Date : performance).now();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
});
var _position$2 = new Vector3(), _quaternion$3 = new Quaternion(), _scale$1 = new Vector3(), _orientation = new Vector3();
function AudioListener() {
  Object3D.call(this), this.type = "AudioListener", this.context = AudioContext.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Clock();
}
AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: AudioListener,
  getInput: function() {
    return this.gain;
  },
  removeFilter: function() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  },
  getFilter: function() {
    return this.filter;
  },
  setFilter: function(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  },
  getMasterVolume: function() {
    return this.gain.gain.value;
  },
  setMasterVolume: function(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  },
  updateMatrixWorld: function(e) {
    Object3D.prototype.updateMatrixWorld.call(this, e);
    var t = this.context.listener, r = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1), _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3), t.positionX) {
      var n = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(_position$2.x, n), t.positionY.linearRampToValueAtTime(_position$2.y, n), t.positionZ.linearRampToValueAtTime(_position$2.z, n), t.forwardX.linearRampToValueAtTime(_orientation.x, n), t.forwardY.linearRampToValueAtTime(_orientation.y, n), t.forwardZ.linearRampToValueAtTime(_orientation.z, n), t.upX.linearRampToValueAtTime(r.x, n), t.upY.linearRampToValueAtTime(r.y, n), t.upZ.linearRampToValueAtTime(r.z, n);
    } else
      t.setPosition(_position$2.x, _position$2.y, _position$2.z), t.setOrientation(_orientation.x, _orientation.y, _orientation.z, r.x, r.y, r.z);
  }
});
function Audio$1(e) {
  Object3D.call(this), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this.filters = [];
}
Audio$1.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Audio$1,
  getOutput: function() {
    return this.gain;
  },
  setNodeSource: function(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  },
  setMediaElementSource: function(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  },
  setMediaStreamSource: function(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  },
  setBuffer: function(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  },
  play: function(e) {
    if (e === void 0 && (e = 0), this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    var t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  },
  pause: function() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  },
  stop: function() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
  },
  connect: function() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (var e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this;
  },
  disconnect: function() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (var e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else
      this.source.disconnect(this.getOutput());
    return this;
  },
  getFilters: function() {
    return this.filters;
  },
  setFilters: function(e) {
    return e || (e = []), this.isPlaying === !0 ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this;
  },
  setDetune: function(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  },
  getDetune: function() {
    return this.detune;
  },
  getFilter: function() {
    return this.getFilters()[0];
  },
  setFilter: function(e) {
    return this.setFilters(e ? [e] : []);
  },
  setPlaybackRate: function(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  },
  getPlaybackRate: function() {
    return this.playbackRate;
  },
  onEnded: function() {
    this.isPlaying = !1;
  },
  getLoop: function() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  },
  setLoop: function(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  },
  setLoopStart: function(e) {
    return this.loopStart = e, this;
  },
  setLoopEnd: function(e) {
    return this.loopEnd = e, this;
  },
  getVolume: function() {
    return this.gain.gain.value;
  },
  setVolume: function(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
});
var _position$3 = new Vector3(), _quaternion$4 = new Quaternion(), _scale$2 = new Vector3(), _orientation$1 = new Vector3();
function PositionalAudio(e) {
  Audio$1.call(this, e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
}
PositionalAudio.prototype = Object.assign(Object.create(Audio$1.prototype), {
  constructor: PositionalAudio,
  getOutput: function() {
    return this.panner;
  },
  getRefDistance: function() {
    return this.panner.refDistance;
  },
  setRefDistance: function(e) {
    return this.panner.refDistance = e, this;
  },
  getRolloffFactor: function() {
    return this.panner.rolloffFactor;
  },
  setRolloffFactor: function(e) {
    return this.panner.rolloffFactor = e, this;
  },
  getDistanceModel: function() {
    return this.panner.distanceModel;
  },
  setDistanceModel: function(e) {
    return this.panner.distanceModel = e, this;
  },
  getMaxDistance: function() {
    return this.panner.maxDistance;
  },
  setMaxDistance: function(e) {
    return this.panner.maxDistance = e, this;
  },
  setDirectionalCone: function(e, t, r) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = r, this;
  },
  updateMatrixWorld: function(e) {
    if (Object3D.prototype.updateMatrixWorld.call(this, e), !(this.hasPlaybackControl === !0 && this.isPlaying === !1)) {
      this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2), _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);
      var t = this.panner;
      if (t.positionX) {
        var r = this.context.currentTime + this.listener.timeDelta;
        t.positionX.linearRampToValueAtTime(_position$3.x, r), t.positionY.linearRampToValueAtTime(_position$3.y, r), t.positionZ.linearRampToValueAtTime(_position$3.z, r), t.orientationX.linearRampToValueAtTime(_orientation$1.x, r), t.orientationY.linearRampToValueAtTime(_orientation$1.y, r), t.orientationZ.linearRampToValueAtTime(_orientation$1.z, r);
      } else
        t.setPosition(_position$3.x, _position$3.y, _position$3.z), t.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
    }
  }
});
function AudioAnalyser(e, t) {
  this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t !== void 0 ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
}
Object.assign(AudioAnalyser.prototype, {
  getFrequencyData: function() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  },
  getAverageFrequency: function() {
    for (var e = 0, t = this.getFrequencyData(), r = 0; r < t.length; r++)
      e += t[r];
    return e / t.length;
  }
});
function PropertyMixer(e, t, r) {
  this.binding = e, this.valueSize = r;
  var n, a, o;
  switch (t) {
    case "quaternion":
      n = this._slerp, a = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(r * 6), this._workIndex = 5;
      break;
    case "string":
    case "bool":
      n = this._select, a = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(r * 5);
      break;
    default:
      n = this._lerp, a = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(r * 5);
  }
  this._mixBufferRegion = n, this._mixBufferRegionAdditive = a, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
}
Object.assign(PropertyMixer.prototype, {
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate: function(e, t) {
    var r = this.buffer, n = this.valueSize, a = e * n + n, o = this.cumulativeWeight;
    if (o === 0) {
      for (var s = 0; s !== n; ++s)
        r[a + s] = r[s];
      o = t;
    } else {
      o += t;
      var l = t / o;
      this._mixBufferRegion(r, a, 0, l, n);
    }
    this.cumulativeWeight = o;
  },
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive: function(e) {
    var t = this.buffer, r = this.valueSize, n = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, n, 0, e, r), this.cumulativeWeightAdditive += e;
  },
  // apply the state of 'accu<i>' to the binding when accus differ
  apply: function(e) {
    var t = this.valueSize, r = this.buffer, n = e * t + t, a = this.cumulativeWeight, o = this.cumulativeWeightAdditive, s = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, a < 1) {
      var l = t * this._origIndex;
      this._mixBufferRegion(
        r,
        n,
        l,
        1 - a,
        t
      );
    }
    o > 0 && this._mixBufferRegionAdditive(r, n, this._addIndex * t, 1, t);
    for (var c = t, u = t + t; c !== u; ++c)
      if (r[c] !== r[c + t]) {
        s.setValue(r, n);
        break;
      }
  },
  // remember the state of the bound property and copy it to both accus
  saveOriginalState: function() {
    var e = this.binding, t = this.buffer, r = this.valueSize, n = r * this._origIndex;
    e.getValue(t, n);
    for (var a = r, o = n; a !== o; ++a)
      t[a] = t[n + a % r];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  },
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState: function() {
    var e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  },
  _setAdditiveIdentityNumeric: function() {
    for (var e = this._addIndex * this.valueSize, t = e + this.valueSize, r = e; r < t; r++)
      this.buffer[r] = 0;
  },
  _setAdditiveIdentityQuaternion: function() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * 4 + 3] = 1;
  },
  _setAdditiveIdentityOther: function() {
    for (var e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize, r = 0; r < this.valueSize; r++)
      this.buffer[t + r] = this.buffer[e + r];
  },
  // mix functions
  _select: function(e, t, r, n, a) {
    if (n >= 0.5)
      for (var o = 0; o !== a; ++o)
        e[t + o] = e[r + o];
  },
  _slerp: function(e, t, r, n) {
    Quaternion.slerpFlat(e, t, e, t, e, r, n);
  },
  _slerpAdditive: function(e, t, r, n, a) {
    var o = this._workIndex * a;
    Quaternion.multiplyQuaternionsFlat(e, o, e, t, e, r), Quaternion.slerpFlat(e, t, e, t, e, o, n);
  },
  _lerp: function(e, t, r, n, a) {
    for (var o = 1 - n, s = 0; s !== a; ++s) {
      var l = t + s;
      e[l] = e[l] * o + e[r + s] * n;
    }
  },
  _lerpAdditive: function(e, t, r, n, a) {
    for (var o = 0; o !== a; ++o) {
      var s = t + o;
      e[s] = e[s] + e[r + o] * n;
    }
  }
});
var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/", _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g"), _wordChar = "[^" + _RESERVED_CHARS_RE + "]", _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]", _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar), _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot), _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar), _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar), _trackRe = new RegExp(
  "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
), _supportedObjectNames = ["material", "materials", "bones"];
function Composite(e, t, r) {
  var n = r || PropertyBinding.parseTrackName(t);
  this._targetGroup = e, this._bindings = e.subscribe_(t, n);
}
Object.assign(Composite.prototype, {
  getValue: function(e, t) {
    this.bind();
    var r = this._targetGroup.nCachedObjects_, n = this._bindings[r];
    n !== void 0 && n.getValue(e, t);
  },
  setValue: function(e, t) {
    for (var r = this._bindings, n = this._targetGroup.nCachedObjects_, a = r.length; n !== a; ++n)
      r[n].setValue(e, t);
  },
  bind: function() {
    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].bind();
  },
  unbind: function() {
    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].unbind();
  }
});
function PropertyBinding(e, t, r) {
  this.path = t, this.parsedPath = r || PropertyBinding.parseTrackName(t), this.node = PropertyBinding.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e;
}
Object.assign(PropertyBinding, {
  Composite,
  create: function(e, t, r) {
    return e && e.isAnimationObjectGroup ? new PropertyBinding.Composite(e, t, r) : new PropertyBinding(e, t, r);
  },
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  sanitizeNodeName: function(e) {
    return e.replace(/\s/g, "_").replace(_reservedRe, "");
  },
  parseTrackName: function(e) {
    var t = _trackRe.exec(e);
    if (!t)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    var r = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, n = r.nodeName && r.nodeName.lastIndexOf(".");
    if (n !== void 0 && n !== -1) {
      var a = r.nodeName.substring(n + 1);
      _supportedObjectNames.indexOf(a) !== -1 && (r.nodeName = r.nodeName.substring(0, n), r.objectName = a);
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return r;
  },
  findNode: function(e, t) {
    if (!t || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      var r = e.skeleton.getBoneByName(t);
      if (r !== void 0)
        return r;
    }
    if (e.children) {
      var n = function(o) {
        for (var s = 0; s < o.length; s++) {
          var l = o[s];
          if (l.name === t || l.uuid === t)
            return l;
          var c = n(l.children);
          if (c) return c;
        }
        return null;
      }, a = n(e.children);
      if (a)
        return a;
    }
    return null;
  }
});
Object.assign(PropertyBinding.prototype, {
  // prototype, continued
  // these are used to "bind" a nonexistent property
  _getValue_unavailable: function() {
  },
  _setValue_unavailable: function() {
  },
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [
    function(t, r) {
      t[r] = this.node[this.propertyName];
    },
    function(t, r) {
      for (var n = this.resolvedProperty, a = 0, o = n.length; a !== o; ++a)
        t[r++] = n[a];
    },
    function(t, r) {
      t[r] = this.resolvedProperty[this.propertyIndex];
    },
    function(t, r) {
      this.resolvedProperty.toArray(t, r);
    }
  ],
  SetterByBindingTypeAndVersioning: [
    [
      // Direct
      function(t, r) {
        this.targetObject[this.propertyName] = t[r];
      },
      function(t, r) {
        this.targetObject[this.propertyName] = t[r], this.targetObject.needsUpdate = !0;
      },
      function(t, r) {
        this.targetObject[this.propertyName] = t[r], this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // EntireArray
      function(t, r) {
        for (var n = this.resolvedProperty, a = 0, o = n.length; a !== o; ++a)
          n[a] = t[r++];
      },
      function(t, r) {
        for (var n = this.resolvedProperty, a = 0, o = n.length; a !== o; ++a)
          n[a] = t[r++];
        this.targetObject.needsUpdate = !0;
      },
      function(t, r) {
        for (var n = this.resolvedProperty, a = 0, o = n.length; a !== o; ++a)
          n[a] = t[r++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // ArrayElement
      function(t, r) {
        this.resolvedProperty[this.propertyIndex] = t[r];
      },
      function(t, r) {
        this.resolvedProperty[this.propertyIndex] = t[r], this.targetObject.needsUpdate = !0;
      },
      function(t, r) {
        this.resolvedProperty[this.propertyIndex] = t[r], this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ],
    [
      // HasToFromArray
      function(t, r) {
        this.resolvedProperty.fromArray(t, r);
      },
      function(t, r) {
        this.resolvedProperty.fromArray(t, r), this.targetObject.needsUpdate = !0;
      },
      function(t, r) {
        this.resolvedProperty.fromArray(t, r), this.targetObject.matrixWorldNeedsUpdate = !0;
      }
    ]
  ],
  getValue: function(t, r) {
    this.bind(), this.getValue(t, r);
  },
  setValue: function(t, r) {
    this.bind(), this.setValue(t, r);
  },
  // create getter / setter pair for a property in the scene graph
  bind: function() {
    var e = this.node, t = this.parsedPath, r = t.objectName, n = t.propertyName, a = t.propertyIndex;
    if (e || (e = PropertyBinding.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (r) {
      var o = t.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (var s = 0; s < e.length; s++)
            if (e[s].name === o) {
              o = s;
              break;
            }
          break;
        default:
          if (e[r] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[r];
      }
      if (o !== void 0) {
        if (e[o] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[o];
      }
    }
    var l = e[n];
    if (l === void 0) {
      var c = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + n + " but it wasn't found.", e);
      return;
    }
    var u = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? u = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (u = this.Versioning.MatrixWorldNeedsUpdate);
    var h = this.BindingType.Direct;
    if (a !== void 0) {
      if (n === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (e.geometry.isBufferGeometry) {
          if (!e.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          e.morphTargetDictionary[a] !== void 0 && (a = e.morphTargetDictionary[a]);
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      h = this.BindingType.ArrayElement, this.resolvedProperty = l, this.propertyIndex = a;
    } else l.fromArray !== void 0 && l.toArray !== void 0 ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = l) : Array.isArray(l) ? (h = this.BindingType.EntireArray, this.resolvedProperty = l) : this.propertyName = n;
    this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][u];
  },
  unbind: function() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
});
Object.assign(PropertyBinding.prototype, {
  // initial state of these methods that calls 'bind'
  _getValue_unbound: PropertyBinding.prototype.getValue,
  _setValue_unbound: PropertyBinding.prototype.setValue
});
function AnimationObjectGroup() {
  this.uuid = MathUtils.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
  var e = {};
  this._indicesByUUID = e;
  for (var t = 0, r = arguments.length; t !== r; ++t)
    e[arguments[t].uuid] = t;
  this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
  var n = this;
  this.stats = {
    objects: {
      get total() {
        return n._objects.length;
      },
      get inUse() {
        return this.total - n.nCachedObjects_;
      }
    },
    get bindingsPerObject() {
      return n._bindings.length;
    }
  };
}
Object.assign(AnimationObjectGroup.prototype, {
  isAnimationObjectGroup: !0,
  add: function() {
    for (var e = this._objects, t = e.length, r = this.nCachedObjects_, n = this._indicesByUUID, a = this._paths, o = this._parsedPaths, s = this._bindings, l = s.length, c = void 0, u = 0, h = arguments.length; u !== h; ++u) {
      var f = arguments[u], d = f.uuid, p = n[d];
      if (p === void 0) {
        p = t++, n[d] = p, e.push(f);
        for (var g = 0, v = l; g !== v; ++g)
          s[g].push(new PropertyBinding(f, a[g], o[g]));
      } else if (p < r) {
        c = e[p];
        var _ = --r, m = e[_];
        n[m.uuid] = p, e[p] = m, n[d] = _, e[_] = f;
        for (var g = 0, v = l; g !== v; ++g) {
          var y = s[g], b = y[_], M = y[p];
          y[p] = b, M === void 0 && (M = new PropertyBinding(f, a[g], o[g])), y[_] = M;
        }
      } else e[p] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = r;
  },
  remove: function() {
    for (var e = this._objects, t = this.nCachedObjects_, r = this._indicesByUUID, n = this._bindings, a = n.length, o = 0, s = arguments.length; o !== s; ++o) {
      var l = arguments[o], c = l.uuid, u = r[c];
      if (u !== void 0 && u >= t) {
        var h = t++, f = e[h];
        r[f.uuid] = u, e[u] = f, r[c] = h, e[h] = l;
        for (var d = 0, p = a; d !== p; ++d) {
          var g = n[d], v = g[h], _ = g[u];
          g[u] = v, g[h] = _;
        }
      }
    }
    this.nCachedObjects_ = t;
  },
  // remove & forget
  uncache: function() {
    for (var e = this._objects, t = e.length, r = this.nCachedObjects_, n = this._indicesByUUID, a = this._bindings, o = a.length, s = 0, l = arguments.length; s !== l; ++s) {
      var c = arguments[s], u = c.uuid, h = n[u];
      if (h !== void 0)
        if (delete n[u], h < r) {
          var f = --r, d = e[f], p = --t, g = e[p];
          n[d.uuid] = h, e[h] = d, n[g.uuid] = f, e[f] = g, e.pop();
          for (var v = 0, _ = o; v !== _; ++v) {
            var m = a[v], y = m[f], b = m[p];
            m[h] = y, m[f] = b, m.pop();
          }
        } else {
          var p = --t, g = e[p];
          n[g.uuid] = h, e[h] = g, e.pop();
          for (var v = 0, _ = o; v !== _; ++v) {
            var m = a[v];
            m[h] = m[p], m.pop();
          }
        }
    }
    this.nCachedObjects_ = r;
  },
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_: function(e, t) {
    var r = this._bindingsIndicesByPath, n = r[e], a = this._bindings;
    if (n !== void 0) return a[n];
    var o = this._paths, s = this._parsedPaths, l = this._objects, c = l.length, u = this.nCachedObjects_, h = new Array(c);
    n = a.length, r[e] = n, o.push(e), s.push(t), a.push(h);
    for (var f = u, d = l.length; f !== d; ++f) {
      var p = l[f];
      h[f] = new PropertyBinding(p, e, t);
    }
    return h;
  },
  unsubscribe_: function(e) {
    var t = this._bindingsIndicesByPath, r = t[e];
    if (r !== void 0) {
      var n = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length - 1, l = o[s], c = e[s];
      t[c] = r, o[r] = l, o.pop(), a[r] = a[s], a.pop(), n[r] = n[s], n.pop();
    }
  }
});
function AnimationAction(e, t, r, n) {
  this._mixer = e, this._clip = t, this._localRoot = r || null, this.blendMode = n || t.blendMode;
  for (var a = t.tracks, o = a.length, s = new Array(o), l = {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  }, c = 0; c !== o; ++c) {
    var u = a[c].createInterpolant(null);
    s[c] = u, u.settings = l;
  }
  this._interpolantSettings = l, this._interpolants = s, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = LoopRepeat, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
}
Object.assign(AnimationAction.prototype, {
  // State & Scheduling
  play: function() {
    return this._mixer._activateAction(this), this;
  },
  stop: function() {
    return this._mixer._deactivateAction(this), this.reset();
  },
  reset: function() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  },
  isRunning: function() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  },
  // return true when play has been called
  isScheduled: function() {
    return this._mixer._isActiveAction(this);
  },
  startAt: function(e) {
    return this._startTime = e, this;
  },
  setLoop: function(e, t) {
    return this.loop = e, this.repetitions = t, this;
  },
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight: function(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  },
  // return the weight considering fading and .enabled
  getEffectiveWeight: function() {
    return this._effectiveWeight;
  },
  fadeIn: function(e) {
    return this._scheduleFading(e, 0, 1);
  },
  fadeOut: function(e) {
    return this._scheduleFading(e, 1, 0);
  },
  crossFadeFrom: function(e, t, r) {
    if (e.fadeOut(t), this.fadeIn(t), r) {
      var n = this._clip.duration, a = e._clip.duration, o = a / n, s = n / a;
      e.warp(1, o, t), this.warp(s, 1, t);
    }
    return this;
  },
  crossFadeTo: function(e, t, r) {
    return e.crossFadeFrom(this, t, r);
  },
  stopFading: function() {
    var e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  },
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale: function(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  },
  // return the time scale considering warping and .paused
  getEffectiveTimeScale: function() {
    return this._effectiveTimeScale;
  },
  setDuration: function(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  },
  syncWith: function(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  },
  halt: function(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  },
  warp: function(e, t, r) {
    var n = this._mixer, a = n.time, o = this._timeScaleInterpolant, s = this.timeScale;
    o === null && (o = n._lendControlInterpolant(), this._timeScaleInterpolant = o);
    var l = o.parameterPositions, c = o.sampleValues;
    return l[0] = a, l[1] = a + r, c[0] = e / s, c[1] = t / s, this;
  },
  stopWarping: function() {
    var e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  },
  // Object Accessors
  getMixer: function() {
    return this._mixer;
  },
  getClip: function() {
    return this._clip;
  },
  getRoot: function() {
    return this._localRoot || this._mixer._root;
  },
  // Interna
  _update: function(e, t, r, n) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    var a = this._startTime;
    if (a !== null) {
      var o = (e - a) * r;
      if (o < 0 || r === 0)
        return;
      this._startTime = null, t = r * o;
    }
    t *= this._updateTimeScale(e);
    var s = this._updateTime(t), l = this._updateWeight(e);
    if (l > 0) {
      var c = this._interpolants, u = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (var h = 0, f = c.length; h !== f; ++h)
            c[h].evaluate(s), u[h].accumulateAdditive(l);
          break;
        case NormalAnimationBlendMode:
        default:
          for (var h = 0, f = c.length; h !== f; ++h)
            c[h].evaluate(s), u[h].accumulate(n, l);
      }
    }
  },
  _updateWeight: function(e) {
    var t = 0;
    if (this.enabled) {
      t = this.weight;
      var r = this._weightInterpolant;
      if (r !== null) {
        var n = r.evaluate(e)[0];
        t *= n, e > r.parameterPositions[1] && (this.stopFading(), n === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  },
  _updateTimeScale: function(e) {
    var t = 0;
    if (!this.paused) {
      t = this.timeScale;
      var r = this._timeScaleInterpolant;
      if (r !== null) {
        var n = r.evaluate(e)[0];
        t *= n, e > r.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  },
  _updateTime: function(e) {
    var t = this.time + e, r = this._clip.duration, n = this.loop, a = this._loopCount, o = n === LoopPingPong;
    if (e === 0)
      return a === -1 ? t : o && (a & 1) === 1 ? r - t : t;
    if (n === LoopOnce) {
      a === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (t >= r)
          t = r;
        else if (t < 0)
          t = 0;
        else {
          this.time = t;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = t, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (a === -1 && (e >= 0 ? (a = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), t >= r || t < 0) {
        var s = Math.floor(t / r);
        t -= r * s, a += Math.abs(s);
        var l = this.repetitions - a;
        if (l <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = e > 0 ? r : 0, this.time = t, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (l === 1) {
            var c = e < 0;
            this._setEndings(c, !c, o);
          } else
            this._setEndings(!1, !1, o);
          this._loopCount = a, this.time = t, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: s
          });
        }
      } else
        this.time = t;
      if (o && (a & 1) === 1)
        return r - t;
    }
    return t;
  },
  _setEndings: function(e, t, r) {
    var n = this._interpolantSettings;
    r ? (n.endingStart = ZeroSlopeEnding, n.endingEnd = ZeroSlopeEnding) : (e ? n.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding : n.endingStart = WrapAroundEnding, t ? n.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding : n.endingEnd = WrapAroundEnding);
  },
  _scheduleFading: function(e, t, r) {
    var n = this._mixer, a = n.time, o = this._weightInterpolant;
    o === null && (o = n._lendControlInterpolant(), this._weightInterpolant = o);
    var s = o.parameterPositions, l = o.sampleValues;
    return s[0] = a, l[0] = t, s[1] = a + e, l[1] = r, this;
  }
});
function AnimationMixer(e) {
  this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
}
AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher$1.prototype), {
  constructor: AnimationMixer,
  _bindAction: function(e, t) {
    var r = e._localRoot || this._root, n = e._clip.tracks, a = n.length, o = e._propertyBindings, s = e._interpolants, l = r.uuid, c = this._bindingsByRootAndName, u = c[l];
    u === void 0 && (u = {}, c[l] = u);
    for (var h = 0; h !== a; ++h) {
      var f = n[h], d = f.name, p = u[d];
      if (p !== void 0)
        o[h] = p;
      else {
        if (p = o[h], p !== void 0) {
          p._cacheIndex === null && (++p.referenceCount, this._addInactiveBinding(p, l, d));
          continue;
        }
        var g = t && t._propertyBindings[h].binding.parsedPath;
        p = new PropertyMixer(
          PropertyBinding.create(r, d, g),
          f.ValueTypeName,
          f.getValueSize()
        ), ++p.referenceCount, this._addInactiveBinding(p, l, d), o[h] = p;
      }
      s[h].resultBuffer = p.buffer;
    }
  },
  _activateAction: function(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        var t = (e._localRoot || this._root).uuid, r = e._clip.uuid, n = this._actionsByClip[r];
        this._bindAction(
          e,
          n && n.knownActions[0]
        ), this._addInactiveAction(e, r, t);
      }
      for (var a = e._propertyBindings, o = 0, s = a.length; o !== s; ++o) {
        var l = a[o];
        l.useCount++ === 0 && (this._lendBinding(l), l.saveOriginalState());
      }
      this._lendAction(e);
    }
  },
  _deactivateAction: function(e) {
    if (this._isActiveAction(e)) {
      for (var t = e._propertyBindings, r = 0, n = t.length; r !== n; ++r) {
        var a = t[r];
        --a.useCount === 0 && (a.restoreOriginalState(), this._takeBackBinding(a));
      }
      this._takeBackAction(e);
    }
  },
  // Memory manager
  _initMemoryManager: function() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    var e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  },
  // Memory management for AnimationAction objects
  _isActiveAction: function(e) {
    var t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  },
  _addInactiveAction: function(e, t, r) {
    var n = this._actions, a = this._actionsByClip, o = a[t];
    if (o === void 0)
      o = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, a[t] = o;
    else {
      var s = o.knownActions;
      e._byClipCacheIndex = s.length, s.push(e);
    }
    e._cacheIndex = n.length, n.push(e), o.actionByRoot[r] = e;
  },
  _removeInactiveAction: function(e) {
    var t = this._actions, r = t[t.length - 1], n = e._cacheIndex;
    r._cacheIndex = n, t[n] = r, t.pop(), e._cacheIndex = null;
    var a = e._clip.uuid, o = this._actionsByClip, s = o[a], l = s.knownActions, c = l[l.length - 1], u = e._byClipCacheIndex;
    c._byClipCacheIndex = u, l[u] = c, l.pop(), e._byClipCacheIndex = null;
    var h = s.actionByRoot, f = (e._localRoot || this._root).uuid;
    delete h[f], l.length === 0 && delete o[a], this._removeInactiveBindingsForAction(e);
  },
  _removeInactiveBindingsForAction: function(e) {
    for (var t = e._propertyBindings, r = 0, n = t.length; r !== n; ++r) {
      var a = t[r];
      --a.referenceCount === 0 && this._removeInactiveBinding(a);
    }
  },
  _lendAction: function(e) {
    var t = this._actions, r = e._cacheIndex, n = this._nActiveActions++, a = t[n];
    e._cacheIndex = n, t[n] = e, a._cacheIndex = r, t[r] = a;
  },
  _takeBackAction: function(e) {
    var t = this._actions, r = e._cacheIndex, n = --this._nActiveActions, a = t[n];
    e._cacheIndex = n, t[n] = e, a._cacheIndex = r, t[r] = a;
  },
  // Memory management for PropertyMixer objects
  _addInactiveBinding: function(e, t, r) {
    var n = this._bindingsByRootAndName, a = n[t], o = this._bindings;
    a === void 0 && (a = {}, n[t] = a), a[r] = e, e._cacheIndex = o.length, o.push(e);
  },
  _removeInactiveBinding: function(e) {
    var t = this._bindings, r = e.binding, n = r.rootNode.uuid, a = r.path, o = this._bindingsByRootAndName, s = o[n], l = t[t.length - 1], c = e._cacheIndex;
    l._cacheIndex = c, t[c] = l, t.pop(), delete s[a], Object.keys(s).length === 0 && delete o[n];
  },
  _lendBinding: function(e) {
    var t = this._bindings, r = e._cacheIndex, n = this._nActiveBindings++, a = t[n];
    e._cacheIndex = n, t[n] = e, a._cacheIndex = r, t[r] = a;
  },
  _takeBackBinding: function(e) {
    var t = this._bindings, r = e._cacheIndex, n = --this._nActiveBindings, a = t[n];
    e._cacheIndex = n, t[n] = e, a._cacheIndex = r, t[r] = a;
  },
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant: function() {
    var e = this._controlInterpolants, t = this._nActiveControlInterpolants++, r = e[t];
    return r === void 0 && (r = new LinearInterpolant(
      new Float32Array(2),
      new Float32Array(2),
      1,
      this._controlInterpolantsResultBuffer
    ), r.__cacheIndex = t, e[t] = r), r;
  },
  _takeBackControlInterpolant: function(e) {
    var t = this._controlInterpolants, r = e.__cacheIndex, n = --this._nActiveControlInterpolants, a = t[n];
    e.__cacheIndex = n, t[n] = e, a.__cacheIndex = r, t[r] = a;
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction: function(e, t, r) {
    var n = t || this._root, a = n.uuid, o = typeof e == "string" ? AnimationClip.findByName(n, e) : e, s = o !== null ? o.uuid : e, l = this._actionsByClip[s], c = null;
    if (r === void 0 && (o !== null ? r = o.blendMode : r = NormalAnimationBlendMode), l !== void 0) {
      var u = l.actionByRoot[a];
      if (u !== void 0 && u.blendMode === r)
        return u;
      c = l.knownActions[0], o === null && (o = c._clip);
    }
    if (o === null) return null;
    var h = new AnimationAction(this, o, t, r);
    return this._bindAction(h, c), this._addInactiveAction(h, s, a), h;
  },
  // get an existing action
  existingAction: function(e, t) {
    var r = t || this._root, n = r.uuid, a = typeof e == "string" ? AnimationClip.findByName(r, e) : e, o = a ? a.uuid : e, s = this._actionsByClip[o];
    return s !== void 0 && s.actionByRoot[n] || null;
  },
  // deactivates all previously scheduled actions
  stopAllAction: function() {
    for (var e = this._actions, t = this._nActiveActions, r = t - 1; r >= 0; --r)
      e[r].stop();
    return this;
  },
  // advance the time and update apply the animation
  update: function(e) {
    e *= this.timeScale;
    for (var t = this._actions, r = this._nActiveActions, n = this.time += e, a = Math.sign(e), o = this._accuIndex ^= 1, s = 0; s !== r; ++s) {
      var l = t[s];
      l._update(n, e, a, o);
    }
    for (var c = this._bindings, u = this._nActiveBindings, s = 0; s !== u; ++s)
      c[s].apply(o);
    return this;
  },
  // Allows you to seek to a specific time in an animation.
  setTime: function(e) {
    this.time = 0;
    for (var t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  },
  // return this mixer's root target object
  getRoot: function() {
    return this._root;
  },
  // free all resources specific to a particular clip
  uncacheClip: function(e) {
    var t = this._actions, r = e.uuid, n = this._actionsByClip, a = n[r];
    if (a !== void 0) {
      for (var o = a.knownActions, s = 0, l = o.length; s !== l; ++s) {
        var c = o[s];
        this._deactivateAction(c);
        var u = c._cacheIndex, h = t[t.length - 1];
        c._cacheIndex = null, c._byClipCacheIndex = null, h._cacheIndex = u, t[u] = h, t.pop(), this._removeInactiveBindingsForAction(c);
      }
      delete n[r];
    }
  },
  // free all resources specific to a particular root target object
  uncacheRoot: function(e) {
    var t = e.uuid, r = this._actionsByClip;
    for (var n in r) {
      var a = r[n].actionByRoot, o = a[t];
      o !== void 0 && (this._deactivateAction(o), this._removeInactiveAction(o));
    }
    var s = this._bindingsByRootAndName, l = s[t];
    if (l !== void 0)
      for (var c in l) {
        var u = l[c];
        u.restoreOriginalState(), this._removeInactiveBinding(u);
      }
  },
  // remove a targeted clip from the cache
  uncacheAction: function(e, t) {
    var r = this.existingAction(e, t);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
});
function Uniform(e) {
  typeof e == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e;
}
Uniform.prototype.clone = function() {
  return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
};
function InstancedInterleavedBuffer(e, t, r) {
  InterleavedBuffer.call(this, e, t), this.meshPerAttribute = r || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
  constructor: InstancedInterleavedBuffer,
  isInstancedInterleavedBuffer: !0,
  copy: function(e) {
    return InterleavedBuffer.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
});
function Raycaster$1(e, t, r, n) {
  this.ray = new Ray(e, t), this.near = r || 0, this.far = n || 1 / 0, this.camera = null, this.layers = new Layers(), this.params = {
    Mesh: {},
    Line: { threshold: 1 },
    LOD: {},
    Points: { threshold: 1 },
    Sprite: {}
  }, Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points;
      }
    }
  });
}
function ascSort(e, t) {
  return e.distance - t.distance;
}
function intersectObject(e, t, r, n) {
  if (e.layers.test(t.layers) && e.raycast(t, r), n === !0)
    for (var a = e.children, o = 0, s = a.length; o < s; o++)
      intersectObject(a[o], t, r, !0);
}
Object.assign(Raycaster$1.prototype, {
  set: function(e, t) {
    this.ray.set(e, t);
  },
  setFromCamera: function(e, t) {
    t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type.");
  },
  intersectObject: function(e, t, r) {
    var n = r || [];
    return intersectObject(e, this, n, t), n.sort(ascSort), n;
  },
  intersectObjects: function(e, t, r) {
    var n = r || [];
    if (Array.isArray(e) === !1)
      return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n;
    for (var a = 0, o = e.length; a < o; a++)
      intersectObject(e[a], this, n, t);
    return n.sort(ascSort), n;
  }
});
function Spherical(e, t, r) {
  return this.radius = e !== void 0 ? e : 1, this.phi = t !== void 0 ? t : 0, this.theta = r !== void 0 ? r : 0, this;
}
Object.assign(Spherical.prototype, {
  set: function(e, t, r) {
    return this.radius = e, this.phi = t, this.theta = r, this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  },
  // restrict phi to be betwee EPS and PI-EPS
  makeSafe: function() {
    var e = 1e-6;
    return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this;
  },
  setFromVector3: function(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  },
  setFromCartesianCoords: function(e, t, r) {
    return this.radius = Math.sqrt(e * e + t * t + r * r), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, r), this.phi = Math.acos(MathUtils.clamp(t / this.radius, -1, 1))), this;
  }
});
function Cylindrical(e, t, r) {
  return this.radius = e !== void 0 ? e : 1, this.theta = t !== void 0 ? t : 0, this.y = r !== void 0 ? r : 0, this;
}
Object.assign(Cylindrical.prototype, {
  set: function(e, t, r) {
    return this.radius = e, this.theta = t, this.y = r, this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  },
  setFromVector3: function(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  },
  setFromCartesianCoords: function(e, t, r) {
    return this.radius = Math.sqrt(e * e + r * r), this.theta = Math.atan2(e, r), this.y = t, this;
  }
});
var _vector$7 = new Vector2();
function Box2(e, t) {
  this.min = e !== void 0 ? e : new Vector2(1 / 0, 1 / 0), this.max = t !== void 0 ? t : new Vector2(-1 / 0, -1 / 0);
}
Object.assign(Box2.prototype, {
  set: function(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  },
  setFromPoints: function(e) {
    this.makeEmpty();
    for (var t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  },
  setFromCenterAndSize: function(e, t) {
    var r = _vector$7.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  },
  makeEmpty: function() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  },
  isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  getCenter: function(e) {
    return e === void 0 && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new Vector2()), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function(e) {
    return e === void 0 && (console.warn("THREE.Box2: .getSize() target is now required"), e = new Vector2()), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  },
  expandByPoint: function(e) {
    return this.min.min(e), this.max.max(e), this;
  },
  expandByVector: function(e) {
    return this.min.sub(e), this.max.add(e), this;
  },
  expandByScalar: function(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  },
  containsPoint: function(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  },
  containsBox: function(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  },
  getParameter: function(e, t) {
    return t === void 0 && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new Vector2()), t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  },
  intersectsBox: function(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  },
  clampPoint: function(e, t) {
    return t === void 0 && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new Vector2()), t.copy(e).clamp(this.min, this.max);
  },
  distanceToPoint: function(e) {
    var t = _vector$7.copy(e).clamp(this.min, this.max);
    return t.sub(e).length();
  },
  intersect: function(e) {
    return this.min.max(e.min), this.max.min(e.max), this;
  },
  union: function(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  },
  translate: function(e) {
    return this.min.add(e), this.max.add(e), this;
  },
  equals: function(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
});
var _startP = new Vector3(), _startEnd = new Vector3();
function Line3(e, t) {
  this.start = e !== void 0 ? e : new Vector3(), this.end = t !== void 0 ? t : new Vector3();
}
Object.assign(Line3.prototype, {
  set: function(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  },
  getCenter: function(e) {
    return e === void 0 && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new Vector3()), e.addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function(e) {
    return e === void 0 && (console.warn("THREE.Line3: .delta() target is now required"), e = new Vector3()), e.subVectors(this.end, this.start);
  },
  distanceSq: function() {
    return this.start.distanceToSquared(this.end);
  },
  distance: function() {
    return this.start.distanceTo(this.end);
  },
  at: function(e, t) {
    return t === void 0 && (console.warn("THREE.Line3: .at() target is now required"), t = new Vector3()), this.delta(t).multiplyScalar(e).add(this.start);
  },
  closestPointToPointParameter: function(e, t) {
    _startP.subVectors(e, this.start), _startEnd.subVectors(this.end, this.start);
    var r = _startEnd.dot(_startEnd), n = _startEnd.dot(_startP), a = n / r;
    return t && (a = MathUtils.clamp(a, 0, 1)), a;
  },
  closestPointToPoint: function(e, t, r) {
    var n = this.closestPointToPointParameter(e, t);
    return r === void 0 && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), r = new Vector3()), this.delta(r).multiplyScalar(n).add(this.start);
  },
  applyMatrix4: function(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  },
  equals: function(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
});
function ImmediateRenderObject(e) {
  Object3D.call(this), this.material = e, this.render = function() {
  }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
}
ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = !0;
var _vector$8 = new Vector3();
function SpotLightHelper(e, t) {
  Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
  for (var r = new BufferGeometry(), n = [
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    -1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    -1,
    1
  ], a = 0, o = 1, s = 32; a < s; a++, o++) {
    var l = a / s * Math.PI * 2, c = o / s * Math.PI * 2;
    n.push(
      Math.cos(l),
      Math.sin(l),
      1,
      Math.cos(c),
      Math.sin(c),
      1
    );
  }
  r.setAttribute("position", new Float32BufferAttribute(n, 3));
  var u = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
  this.cone = new LineSegments(r, u), this.add(this.cone), this.update();
}
SpotLightHelper.prototype = Object.create(Object3D.prototype);
SpotLightHelper.prototype.constructor = SpotLightHelper;
SpotLightHelper.prototype.dispose = function() {
  this.cone.geometry.dispose(), this.cone.material.dispose();
};
SpotLightHelper.prototype.update = function() {
  this.light.updateMatrixWorld();
  var e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
  this.cone.scale.set(t, t, e), _vector$8.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(_vector$8), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
};
var _vector$9 = new Vector3(), _boneMatrix = new Matrix4(), _matrixWorldInv = new Matrix4();
function getBoneList(e) {
  var t = [];
  e && e.isBone && t.push(e);
  for (var r = 0; r < e.children.length; r++)
    t.push.apply(t, getBoneList(e.children[r]));
  return t;
}
function SkeletonHelper(e) {
  for (var t = getBoneList(e), r = new BufferGeometry(), n = [], a = [], o = new Color(0, 0, 1), s = new Color(0, 1, 0), l = 0; l < t.length; l++) {
    var c = t[l];
    c.parent && c.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), a.push(o.r, o.g, o.b), a.push(s.r, s.g, s.b));
  }
  r.setAttribute("position", new Float32BufferAttribute(n, 3)), r.setAttribute("color", new Float32BufferAttribute(a, 3));
  var u = new LineBasicMaterial({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
  LineSegments.call(this, r, u), this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
}
SkeletonHelper.prototype = Object.create(LineSegments.prototype);
SkeletonHelper.prototype.constructor = SkeletonHelper;
SkeletonHelper.prototype.isSkeletonHelper = !0;
SkeletonHelper.prototype.updateMatrixWorld = function(e) {
  var t = this.bones, r = this.geometry, n = r.getAttribute("position");
  _matrixWorldInv.getInverse(this.root.matrixWorld);
  for (var a = 0, o = 0; a < t.length; a++) {
    var s = t[a];
    s.parent && s.parent.isBone && (_boneMatrix.multiplyMatrices(_matrixWorldInv, s.matrixWorld), _vector$9.setFromMatrixPosition(_boneMatrix), n.setXYZ(o, _vector$9.x, _vector$9.y, _vector$9.z), _boneMatrix.multiplyMatrices(_matrixWorldInv, s.parent.matrixWorld), _vector$9.setFromMatrixPosition(_boneMatrix), n.setXYZ(o + 1, _vector$9.x, _vector$9.y, _vector$9.z), o += 2);
  }
  r.getAttribute("position").needsUpdate = !0, Object3D.prototype.updateMatrixWorld.call(this, e);
};
function PointLightHelper(e, t, r) {
  this.light = e, this.light.updateMatrixWorld(), this.color = r;
  var n = new SphereBufferGeometry(t, 4, 2), a = new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 });
  Mesh.call(this, n, a), this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
}
PointLightHelper.prototype = Object.create(Mesh.prototype);
PointLightHelper.prototype.constructor = PointLightHelper;
PointLightHelper.prototype.dispose = function() {
  this.geometry.dispose(), this.material.dispose();
};
PointLightHelper.prototype.update = function() {
  this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
};
var _vector$a = new Vector3(), _color1 = new Color(), _color2 = new Color();
function HemisphereLightHelper(e, t, r) {
  Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r;
  var n = new OctahedronBufferGeometry(t);
  n.rotateY(Math.PI * 0.5), this.material = new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
  var a = n.getAttribute("position"), o = new Float32Array(a.count * 3);
  n.setAttribute("color", new BufferAttribute(o, 3)), this.add(new Mesh(n, this.material)), this.update();
}
HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
HemisphereLightHelper.prototype.dispose = function() {
  this.children[0].geometry.dispose(), this.children[0].material.dispose();
};
HemisphereLightHelper.prototype.update = function() {
  var e = this.children[0];
  if (this.color !== void 0)
    this.material.color.set(this.color);
  else {
    var t = e.geometry.getAttribute("color");
    _color1.copy(this.light.color), _color2.copy(this.light.groundColor);
    for (var r = 0, n = t.count; r < n; r++) {
      var a = r < n / 2 ? _color1 : _color2;
      t.setXYZ(r, a.r, a.g, a.b);
    }
    t.needsUpdate = !0;
  }
  e.lookAt(_vector$a.setFromMatrixPosition(this.light.matrixWorld).negate());
};
function GridHelper(e, t, r, n) {
  e = e || 10, t = t || 10, r = new Color(r !== void 0 ? r : 4473924), n = new Color(n !== void 0 ? n : 8947848);
  for (var a = t / 2, o = e / t, s = e / 2, l = [], c = [], u = 0, h = 0, f = -s; u <= t; u++, f += o) {
    l.push(-s, 0, f, s, 0, f), l.push(f, 0, -s, f, 0, s);
    var d = u === a ? r : n;
    d.toArray(c, h), h += 3, d.toArray(c, h), h += 3, d.toArray(c, h), h += 3, d.toArray(c, h), h += 3;
  }
  var p = new BufferGeometry();
  p.setAttribute("position", new Float32BufferAttribute(l, 3)), p.setAttribute("color", new Float32BufferAttribute(c, 3));
  var g = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
  LineSegments.call(this, p, g), this.type = "GridHelper";
}
GridHelper.prototype = Object.assign(Object.create(LineSegments.prototype), {
  constructor: GridHelper,
  copy: function(e) {
    return LineSegments.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function PolarGridHelper(e, t, r, n, a, o) {
  e = e || 10, t = t || 16, r = r || 8, n = n || 64, a = new Color(a !== void 0 ? a : 4473924), o = new Color(o !== void 0 ? o : 8947848);
  var s = [], l = [], c, u, h, f, d, p, g;
  for (f = 0; f <= t; f++)
    h = f / t * (Math.PI * 2), c = Math.sin(h) * e, u = Math.cos(h) * e, s.push(0, 0, 0), s.push(c, 0, u), g = f & 1 ? a : o, l.push(g.r, g.g, g.b), l.push(g.r, g.g, g.b);
  for (f = 0; f <= r; f++)
    for (g = f & 1 ? a : o, p = e - e / r * f, d = 0; d < n; d++)
      h = d / n * (Math.PI * 2), c = Math.sin(h) * p, u = Math.cos(h) * p, s.push(c, 0, u), l.push(g.r, g.g, g.b), h = (d + 1) / n * (Math.PI * 2), c = Math.sin(h) * p, u = Math.cos(h) * p, s.push(c, 0, u), l.push(g.r, g.g, g.b);
  var v = new BufferGeometry();
  v.setAttribute("position", new Float32BufferAttribute(s, 3)), v.setAttribute("color", new Float32BufferAttribute(l, 3));
  var _ = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
  LineSegments.call(this, v, _), this.type = "PolarGridHelper";
}
PolarGridHelper.prototype = Object.create(LineSegments.prototype);
PolarGridHelper.prototype.constructor = PolarGridHelper;
var _v1$5 = new Vector3(), _v2$3 = new Vector3(), _v3$1 = new Vector3();
function DirectionalLightHelper(e, t, r) {
  Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, t === void 0 && (t = 1);
  var n = new BufferGeometry();
  n.setAttribute("position", new Float32BufferAttribute([
    -t,
    t,
    0,
    t,
    t,
    0,
    t,
    -t,
    0,
    -t,
    -t,
    0,
    -t,
    t,
    0
  ], 3));
  var a = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
  this.lightPlane = new Line(n, a), this.add(this.lightPlane), n = new BufferGeometry(), n.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Line(n, a), this.add(this.targetLine), this.update();
}
DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
DirectionalLightHelper.prototype.dispose = function() {
  this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
};
DirectionalLightHelper.prototype.update = function() {
  _v1$5.setFromMatrixPosition(this.light.matrixWorld), _v2$3.setFromMatrixPosition(this.light.target.matrixWorld), _v3$1.subVectors(_v2$3, _v1$5), this.lightPlane.lookAt(_v2$3), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(_v2$3), this.targetLine.scale.z = _v3$1.length();
};
var _vector$b = new Vector3(), _camera = new Camera$1();
function CameraHelper(e) {
  var t = new BufferGeometry(), r = new LineBasicMaterial({ color: 16777215, vertexColors: !0, toneMapped: !1 }), n = [], a = [], o = {}, s = new Color(16755200), l = new Color(16711680), c = new Color(43775), u = new Color(16777215), h = new Color(3355443);
  f("n1", "n2", s), f("n2", "n4", s), f("n4", "n3", s), f("n3", "n1", s), f("f1", "f2", s), f("f2", "f4", s), f("f4", "f3", s), f("f3", "f1", s), f("n1", "f1", s), f("n2", "f2", s), f("n3", "f3", s), f("n4", "f4", s), f("p", "n1", l), f("p", "n2", l), f("p", "n3", l), f("p", "n4", l), f("u1", "u2", c), f("u2", "u3", c), f("u3", "u1", c), f("c", "t", u), f("p", "c", h), f("cn1", "cn2", h), f("cn3", "cn4", h), f("cf1", "cf2", h), f("cf3", "cf4", h);
  function f(p, g, v) {
    d(p, v), d(g, v);
  }
  function d(p, g) {
    n.push(0, 0, 0), a.push(g.r, g.g, g.b), o[p] === void 0 && (o[p] = []), o[p].push(n.length / 3 - 1);
  }
  t.setAttribute("position", new Float32BufferAttribute(n, 3)), t.setAttribute("color", new Float32BufferAttribute(a, 3)), LineSegments.call(this, t, r), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
}
CameraHelper.prototype = Object.create(LineSegments.prototype);
CameraHelper.prototype.constructor = CameraHelper;
CameraHelper.prototype.update = function() {
  var e = this.geometry, t = this.pointMap, r = 1, n = 1;
  _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), setPoint("c", t, e, _camera, 0, 0, -1), setPoint("t", t, e, _camera, 0, 0, 1), setPoint("n1", t, e, _camera, -r, -n, -1), setPoint("n2", t, e, _camera, r, -n, -1), setPoint("n3", t, e, _camera, -r, n, -1), setPoint("n4", t, e, _camera, r, n, -1), setPoint("f1", t, e, _camera, -r, -n, 1), setPoint("f2", t, e, _camera, r, -n, 1), setPoint("f3", t, e, _camera, -r, n, 1), setPoint("f4", t, e, _camera, r, n, 1), setPoint("u1", t, e, _camera, r * 0.7, n * 1.1, -1), setPoint("u2", t, e, _camera, -r * 0.7, n * 1.1, -1), setPoint("u3", t, e, _camera, 0, n * 2, -1), setPoint("cf1", t, e, _camera, -r, 0, 1), setPoint("cf2", t, e, _camera, r, 0, 1), setPoint("cf3", t, e, _camera, 0, -n, 1), setPoint("cf4", t, e, _camera, 0, n, 1), setPoint("cn1", t, e, _camera, -r, 0, -1), setPoint("cn2", t, e, _camera, r, 0, -1), setPoint("cn3", t, e, _camera, 0, -n, -1), setPoint("cn4", t, e, _camera, 0, n, -1), e.getAttribute("position").needsUpdate = !0;
};
function setPoint(e, t, r, n, a, o, s) {
  _vector$b.set(a, o, s).unproject(n);
  var l = t[e];
  if (l !== void 0)
    for (var c = r.getAttribute("position"), u = 0, h = l.length; u < h; u++)
      c.setXYZ(l[u], _vector$b.x, _vector$b.y, _vector$b.z);
}
var _box$3 = new Box3();
function BoxHelper(e, t) {
  this.object = e, t === void 0 && (t = 16776960);
  var r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = new Float32Array(8 * 3), a = new BufferGeometry();
  a.setIndex(new BufferAttribute(r, 1)), a.setAttribute("position", new BufferAttribute(n, 3)), LineSegments.call(this, a, new LineBasicMaterial({ color: t, toneMapped: !1 })), this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
}
BoxHelper.prototype = Object.create(LineSegments.prototype);
BoxHelper.prototype.constructor = BoxHelper;
BoxHelper.prototype.update = function(e) {
  if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && _box$3.setFromObject(this.object), !_box$3.isEmpty()) {
    var t = _box$3.min, r = _box$3.max, n = this.geometry.attributes.position, a = n.array;
    a[0] = r.x, a[1] = r.y, a[2] = r.z, a[3] = t.x, a[4] = r.y, a[5] = r.z, a[6] = t.x, a[7] = t.y, a[8] = r.z, a[9] = r.x, a[10] = t.y, a[11] = r.z, a[12] = r.x, a[13] = r.y, a[14] = t.z, a[15] = t.x, a[16] = r.y, a[17] = t.z, a[18] = t.x, a[19] = t.y, a[20] = t.z, a[21] = r.x, a[22] = t.y, a[23] = t.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
};
BoxHelper.prototype.setFromObject = function(e) {
  return this.object = e, this.update(), this;
};
BoxHelper.prototype.copy = function(e) {
  return LineSegments.prototype.copy.call(this, e), this.object = e.object, this;
};
BoxHelper.prototype.clone = function() {
  return new this.constructor().copy(this);
};
function Box3Helper(e, t) {
  this.type = "Box3Helper", this.box = e, t = t || 16776960;
  var r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], a = new BufferGeometry();
  a.setIndex(new BufferAttribute(r, 1)), a.setAttribute("position", new Float32BufferAttribute(n, 3)), LineSegments.call(this, a, new LineBasicMaterial({ color: t, toneMapped: !1 })), this.type = "Box3Helper", this.geometry.computeBoundingSphere();
}
Box3Helper.prototype = Object.create(LineSegments.prototype);
Box3Helper.prototype.constructor = Box3Helper;
Box3Helper.prototype.updateMatrixWorld = function(e) {
  var t = this.box;
  t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), Object3D.prototype.updateMatrixWorld.call(this, e));
};
function PlaneHelper(e, t, r) {
  this.plane = e, this.size = t === void 0 ? 1 : t;
  var n = r !== void 0 ? r : 16776960, a = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], o = new BufferGeometry();
  o.setAttribute("position", new Float32BufferAttribute(a, 3)), o.computeBoundingSphere(), Line.call(this, o, new LineBasicMaterial({ color: n, toneMapped: !1 })), this.type = "PlaneHelper";
  var s = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], l = new BufferGeometry();
  l.setAttribute("position", new Float32BufferAttribute(s, 3)), l.computeBoundingSphere(), this.add(new Mesh(l, new MeshBasicMaterial({ color: n, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
}
PlaneHelper.prototype = Object.create(Line.prototype);
PlaneHelper.prototype.constructor = PlaneHelper;
PlaneHelper.prototype.updateMatrixWorld = function(e) {
  var t = -this.plane.constant;
  Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, t), this.children[0].material.side = t < 0 ? BackSide : FrontSide, this.lookAt(this.plane.normal), Object3D.prototype.updateMatrixWorld.call(this, e);
};
var _axis = new Vector3(), _lineGeometry, _coneGeometry;
function ArrowHelper(e, t, r, n, a, o) {
  Object3D.call(this), this.type = "ArrowHelper", e === void 0 && (e = new Vector3(0, 0, 1)), t === void 0 && (t = new Vector3(0, 0, 0)), r === void 0 && (r = 1), n === void 0 && (n = 16776960), a === void 0 && (a = 0.2 * r), o === void 0 && (o = 0.2 * a), _lineGeometry === void 0 && (_lineGeometry = new BufferGeometry(), _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3)), _coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1), _coneGeometry.translate(0, -0.5, 0)), this.position.copy(t), this.line = new Line(_lineGeometry, new LineBasicMaterial({ color: n, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color: n, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(r, a, o);
}
ArrowHelper.prototype = Object.create(Object3D.prototype);
ArrowHelper.prototype.constructor = ArrowHelper;
ArrowHelper.prototype.setDirection = function(e) {
  if (e.y > 0.99999)
    this.quaternion.set(0, 0, 0, 1);
  else if (e.y < -0.99999)
    this.quaternion.set(1, 0, 0, 0);
  else {
    _axis.set(e.z, 0, -e.x).normalize();
    var t = Math.acos(e.y);
    this.quaternion.setFromAxisAngle(_axis, t);
  }
};
ArrowHelper.prototype.setLength = function(e, t, r) {
  t === void 0 && (t = 0.2 * e), r === void 0 && (r = 0.2 * t), this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(r, t, r), this.cone.position.y = e, this.cone.updateMatrix();
};
ArrowHelper.prototype.setColor = function(e) {
  this.line.material.color.set(e), this.cone.material.color.set(e);
};
ArrowHelper.prototype.copy = function(e) {
  return Object3D.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
};
ArrowHelper.prototype.clone = function() {
  return new this.constructor().copy(this);
};
function AxesHelper(e) {
  e = e || 1;
  var t = [
    0,
    0,
    0,
    e,
    0,
    0,
    0,
    0,
    0,
    0,
    e,
    0,
    0,
    0,
    0,
    0,
    0,
    e
  ], r = [
    1,
    0,
    0,
    1,
    0.6,
    0,
    0,
    1,
    0,
    0.6,
    1,
    0,
    0,
    0,
    1,
    0,
    0.6,
    1
  ], n = new BufferGeometry();
  n.setAttribute("position", new Float32BufferAttribute(t, 3)), n.setAttribute("color", new Float32BufferAttribute(r, 3));
  var a = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
  LineSegments.call(this, n, a), this.type = "AxesHelper";
}
AxesHelper.prototype = Object.create(LineSegments.prototype);
AxesHelper.prototype.constructor = AxesHelper;
var LOD_MIN = 4, LOD_MAX = 8, SIZE_MAX = Math.pow(2, LOD_MAX), EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length, MAX_SAMPLES = 20, ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
}, _flatCamera = new OrthographicCamera(), { _lodPlanes, _sizeLods, _sigmas } = _createPlanes(), _oldTarget = null, PHI = (1 + Math.sqrt(5)) / 2, INV_PHI = 1 / PHI, _axisDirections = [
  new Vector3(1, 1, 1),
  new Vector3(-1, 1, 1),
  new Vector3(1, 1, -1),
  new Vector3(-1, 1, -1),
  new Vector3(0, PHI, INV_PHI),
  new Vector3(0, PHI, -INV_PHI),
  new Vector3(INV_PHI, 0, PHI),
  new Vector3(-INV_PHI, 0, PHI),
  new Vector3(PHI, INV_PHI, 0),
  new Vector3(-PHI, INV_PHI, 0)
];
function PMREMGenerator(e) {
  this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = _getBlurShader(MAX_SAMPLES), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial);
}
PMREMGenerator.prototype = {
  constructor: PMREMGenerator,
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene: function(e, t = 0, r = 0.1, n = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    var a = this._allocateTargets();
    return this._sceneToCubeUV(e, r, n, a), t > 0 && this._blur(a, 0, 0, t), this._applyPMREM(a), this._cleanup(a), a;
  },
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular: function(e) {
    return e.magFilter = NearestFilter, e.minFilter = NearestFilter, e.generateMipmaps = !1, this.fromCubemap(e);
  },
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap: function(e) {
    _oldTarget = this._renderer.getRenderTarget();
    var t = this._allocateTargets(e);
    return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t;
  },
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader: function() {
    this._cubemapShader === null && (this._cubemapShader = _getCubemapShader(), this._compileMaterial(this._cubemapShader));
  },
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader: function() {
    this._equirectShader === null && (this._equirectShader = _getEquirectShader(), this._compileMaterial(this._equirectShader));
  },
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose: function() {
    this._blurMaterial.dispose(), this._cubemapShader !== null && this._cubemapShader.dispose(), this._equirectShader !== null && this._equirectShader.dispose();
    for (var e = 0; e < _lodPlanes.length; e++)
      _lodPlanes[e].dispose();
  },
  // private interface
  _cleanup: function(e) {
    this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(_oldTarget), e.scissorTest = !1, e.setSize(e.width, e.height);
  },
  _allocateTargets: function(e) {
    var t = {
      magFilter: NearestFilter,
      minFilter: NearestFilter,
      generateMipmaps: !1,
      type: UnsignedByteType,
      format: RGBEFormat,
      encoding: _isLDR(e) ? e.encoding : RGBEEncoding,
      depthBuffer: !1,
      stencilBuffer: !1
    }, r = _createRenderTarget(t);
    return r.depthBuffer = !e, this._pingPongRenderTarget = _createRenderTarget(t), r;
  },
  _compileMaterial: function(e) {
    var t = new Mesh(_lodPlanes[0], e);
    this._renderer.compile(t, _flatCamera);
  },
  _sceneToCubeUV: function(e, t, r, n) {
    var a = 90, o = 1, s = new PerspectiveCamera(a, o, t, r), l = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], u = this._renderer, h = u.outputEncoding, f = u.toneMapping, d = u.toneMappingExposure, p = u.getClearColor(), g = u.getClearAlpha();
    u.toneMapping = LinearToneMapping, u.toneMappingExposure = 1, u.outputEncoding = LinearEncoding;
    var v = e.background;
    if (v && v.isColor) {
      v.convertSRGBToLinear();
      var _ = Math.max(v.r, v.g, v.b), m = Math.min(Math.max(Math.ceil(Math.log2(_)), -128), 127);
      v = v.multiplyScalar(Math.pow(2, -m));
      var y = (m + 128) / 255;
      u.setClearColor(v, y), e.background = null;
    }
    for (var b = 0; b < 6; b++) {
      var M = b % 3;
      M == 0 ? (s.up.set(0, l[b], 0), s.lookAt(c[b], 0, 0)) : M == 1 ? (s.up.set(0, 0, l[b]), s.lookAt(0, c[b], 0)) : (s.up.set(0, l[b], 0), s.lookAt(0, 0, c[b])), _setViewport(
        n,
        M * SIZE_MAX,
        b > 2 ? SIZE_MAX : 0,
        SIZE_MAX,
        SIZE_MAX
      ), u.setRenderTarget(n), u.render(e, s);
    }
    u.toneMapping = f, u.toneMappingExposure = d, u.outputEncoding = h, u.setClearColor(p, g);
  },
  _textureToCubeUV: function(e, t) {
    var r = this._renderer;
    e.isCubeTexture ? this._cubemapShader == null && (this._cubemapShader = _getCubemapShader()) : this._equirectShader == null && (this._equirectShader = _getEquirectShader());
    var n = e.isCubeTexture ? this._cubemapShader : this._equirectShader, a = new Mesh(_lodPlanes[0], n), o = n.uniforms;
    o.envMap.value = e, e.isCubeTexture || o.texelSize.value.set(1 / e.image.width, 1 / e.image.height), o.inputEncoding.value = ENCODINGS[e.encoding], o.outputEncoding.value = ENCODINGS[t.texture.encoding], _setViewport(t, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX), r.setRenderTarget(t), r.render(a, _flatCamera);
  },
  _applyPMREM: function(e) {
    var t = this._renderer, r = t.autoClear;
    t.autoClear = !1;
    for (var n = 1; n < TOTAL_LODS; n++) {
      var a = Math.sqrt(_sigmas[n] * _sigmas[n] - _sigmas[n - 1] * _sigmas[n - 1]), o = _axisDirections[(n - 1) % _axisDirections.length];
      this._blur(e, n - 1, n, a, o);
    }
    t.autoClear = r;
  },
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur: function(e, t, r, n, a) {
    var o = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      o,
      t,
      r,
      n,
      "latitudinal",
      a
    ), this._halfBlur(
      o,
      e,
      r,
      r,
      n,
      "longitudinal",
      a
    );
  },
  _halfBlur: function(e, t, r, n, a, o, s) {
    var l = this._renderer, c = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    var u = 3, h = new Mesh(_lodPlanes[n], c), f = c.uniforms, d = _sizeLods[r] - 1, p = isFinite(a) ? Math.PI / (2 * d) : 2 * Math.PI / (2 * MAX_SAMPLES - 1), g = a / p, v = isFinite(a) ? 1 + Math.floor(u * g) : MAX_SAMPLES;
    v > MAX_SAMPLES && console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${MAX_SAMPLES}`);
    for (var _ = [], m = 0, y = 0; y < MAX_SAMPLES; ++y) {
      var x = y / g, b = Math.exp(-x * x / 2);
      _.push(b), y == 0 ? m += b : y < v && (m += 2 * b);
    }
    for (var y = 0; y < _.length; y++)
      _[y] = _[y] / m;
    f.envMap.value = e.texture, f.samples.value = v, f.weights.value = _, f.latitudinal.value = o === "latitudinal", s && (f.poleAxis.value = s), f.dTheta.value = p, f.mipInt.value = LOD_MAX - r, f.inputEncoding.value = ENCODINGS[e.texture.encoding], f.outputEncoding.value = ENCODINGS[e.texture.encoding];
    var M = _sizeLods[n], x = 3 * Math.max(0, SIZE_MAX - 2 * M), w = (n === 0 ? 0 : 2 * SIZE_MAX) + 2 * M * (n > LOD_MAX - LOD_MIN ? n - LOD_MAX + LOD_MIN : 0);
    _setViewport(t, x, w, 3 * M, 2 * M), l.setRenderTarget(t), l.render(h, _flatCamera);
  }
};
function _isLDR(e) {
  return e === void 0 || e.type !== UnsignedByteType ? !1 : e.encoding === LinearEncoding || e.encoding === sRGBEncoding || e.encoding === GammaEncoding;
}
function _createPlanes() {
  for (var e = [], t = [], r = [], n = LOD_MAX, a = 0; a < TOTAL_LODS; a++) {
    var o = Math.pow(2, n);
    t.push(o);
    var s = 1 / o;
    a > LOD_MAX - LOD_MIN ? s = EXTRA_LOD_SIGMA[a - LOD_MAX + LOD_MIN - 1] : a == 0 && (s = 0), r.push(s);
    for (var l = 1 / (o - 1), c = -l / 2, u = 1 + l / 2, h = [c, c, u, c, u, u, c, c, u, u, c, u], f = 6, d = 6, p = 3, g = 2, v = 1, _ = new Float32Array(p * d * f), m = new Float32Array(g * d * f), y = new Float32Array(v * d * f), b = 0; b < f; b++) {
      var M = b % 3 * 2 / 3 - 1, x = b > 2 ? 0 : -1, w = [
        M,
        x,
        0,
        M + 2 / 3,
        x,
        0,
        M + 2 / 3,
        x + 1,
        0,
        M,
        x,
        0,
        M + 2 / 3,
        x + 1,
        0,
        M,
        x + 1,
        0
      ];
      _.set(w, p * d * b), m.set(h, g * d * b);
      var P = [b, b, b, b, b, b];
      y.set(P, v * d * b);
    }
    var V = new BufferGeometry();
    V.setAttribute("position", new BufferAttribute(_, p)), V.setAttribute("uv", new BufferAttribute(m, g)), V.setAttribute("faceIndex", new BufferAttribute(y, v)), e.push(V), n > LOD_MIN && n--;
  }
  return { _lodPlanes: e, _sizeLods: t, _sigmas: r };
}
function _createRenderTarget(e) {
  var t = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, e);
  return t.texture.mapping = CubeUVReflectionMapping, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t;
}
function _setViewport(e, t, r, n, a) {
  e.viewport.set(t, r, n, a), e.scissor.set(t, r, n, a);
}
function _getBlurShader(e) {
  var t = new Float32Array(e), r = new Vector3(0, 1, 0), n = new RawShaderMaterial({
    defines: { n: e },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: t },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
      inputEncoding: { value: ENCODINGS[LinearEncoding] },
      outputEncoding: { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform int samples;
uniform float weights[n];
uniform bool latitudinal;
uniform float dTheta;
uniform float mipInt;
uniform vec3 poleAxis;

${_getEncodings()}

#define ENVMAP_TYPE_CUBE_UV
#include <cube_uv_reflection_fragment>

vec3 getSample(float theta, vec3 axis) {
	float cosTheta = cos(theta);
	// Rodrigues' axis-angle rotation
	vec3 sampleDirection = vOutputDirection * cosTheta
		+ cross(axis, vOutputDirection) * sin(theta)
		+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);
	return bilinearCubeUV(envMap, sampleDirection, mipInt);
}

void main() {
	vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);
	if (all(equal(axis, vec3(0.0))))
		axis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);
	axis = normalize(axis);
	gl_FragColor = vec4(0.0);
	gl_FragColor.rgb += weights[0] * getSample(0.0, axis);
	for (int i = 1; i < n; i++) {
		if (i >= samples)
			break;
		float theta = dTheta * float(i);
		gl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);
		gl_FragColor.rgb += weights[i] * getSample(theta, axis);
	}
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1
  });
  return n.type = "SphericalGaussianBlur", n;
}
function _getEquirectShader() {
  var e = new Vector2(1, 1), t = new RawShaderMaterial({
    uniforms: {
      envMap: { value: null },
      texelSize: { value: e },
      inputEncoding: { value: ENCODINGS[LinearEncoding] },
      outputEncoding: { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform vec2 texelSize;

${_getEncodings()}

#include <common>

void main() {
	gl_FragColor = vec4(0.0);
	vec3 outputDirection = normalize(vOutputDirection);
	vec2 uv = equirectUv( outputDirection );
	vec2 f = fract(uv / texelSize - 0.5);
	uv -= f * texelSize;
	vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x += texelSize.x;
	vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.y += texelSize.y;
	vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x -= texelSize.x;
	vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	vec3 tm = mix(tl, tr, f.x);
	vec3 bm = mix(bl, br, f.x);
	gl_FragColor.rgb = mix(tm, bm, f.y);
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1
  });
  return t.type = "EquirectangularToCubeUV", t;
}
function _getCubemapShader() {
  var e = new RawShaderMaterial({
    uniforms: {
      envMap: { value: null },
      inputEncoding: { value: ENCODINGS[LinearEncoding] },
      outputEncoding: { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform samplerCube envMap;

${_getEncodings()}

void main() {
	gl_FragColor = vec4(0.0);
	gl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1
  });
  return e.type = "CubemapToCubeUV", e;
}
function _getCommonVertexShader() {
  return `
precision mediump float;
precision mediump int;
attribute vec3 position;
attribute vec2 uv;
attribute float faceIndex;
varying vec3 vOutputDirection;

// RH coordinate system; PMREM face-indexing convention
vec3 getDirection(vec2 uv, float face) {
	uv = 2.0 * uv - 1.0;
	vec3 direction = vec3(uv, 1.0);
	if (face == 0.0) {
		direction = direction.zyx; // ( 1, v, u ) pos x
	} else if (face == 1.0) {
		direction = direction.xzy;
		direction.xz *= -1.0; // ( -u, 1, -v ) pos y
	} else if (face == 2.0) {
		direction.x *= -1.0; // ( -u, v, 1 ) pos z
	} else if (face == 3.0) {
		direction = direction.zyx;
		direction.xz *= -1.0; // ( -1, v, -u ) neg x
	} else if (face == 4.0) {
		direction = direction.xzy;
		direction.xy *= -1.0; // ( -u, -1, v ) neg y
	} else if (face == 5.0) {
		direction.z *= -1.0; // ( u, v, -1 ) neg z
	}
	return direction;
}

void main() {
	vOutputDirection = getDirection(uv, faceIndex);
	gl_Position = vec4( position, 1.0 );
}
	`;
}
function _getEncodings() {
  return `
uniform int inputEncoding;
uniform int outputEncoding;

#include <encodings_pars_fragment>

vec4 inputTexelToLinear(vec4 value){
	if(inputEncoding == 0){
		return value;
	}else if(inputEncoding == 1){
		return sRGBToLinear(value);
	}else if(inputEncoding == 2){
		return RGBEToLinear(value);
	}else if(inputEncoding == 3){
		return RGBMToLinear(value, 7.0);
	}else if(inputEncoding == 4){
		return RGBMToLinear(value, 16.0);
	}else if(inputEncoding == 5){
		return RGBDToLinear(value, 256.0);
	}else{
		return GammaToLinear(value, 2.2);
	}
}

vec4 linearToOutputTexel(vec4 value){
	if(outputEncoding == 0){
		return value;
	}else if(outputEncoding == 1){
		return LinearTosRGB(value);
	}else if(outputEncoding == 2){
		return LinearToRGBE(value);
	}else if(outputEncoding == 3){
		return LinearToRGBM(value, 7.0);
	}else if(outputEncoding == 4){
		return LinearToRGBM(value, 16.0);
	}else if(outputEncoding == 5){
		return LinearToRGBD(value, 256.0);
	}else{
		return LinearToGamma(value, 2.2);
	}
}

vec4 envMapTexelToLinear(vec4 color) {
	return inputTexelToLinear(color);
}
	`;
}
function Face4(e, t, r, n, a, o, s) {
  return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new Face3(e, t, r, a, o, s);
}
var LineStrip = 0, LinePieces = 1, NoColors = 0, FaceColors = 1, VertexColors = 2;
function MeshFaceMaterial(e) {
  return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e;
}
function MultiMaterial(e) {
  return e === void 0 && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function() {
    return e.slice();
  }, e;
}
function PointCloud(e, t) {
  return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Points(e, t);
}
function Particle(e) {
  return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Sprite(e);
}
function ParticleSystem(e, t) {
  return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Points(e, t);
}
function PointCloudMaterial(e) {
  return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new PointsMaterial(e);
}
function ParticleBasicMaterial(e) {
  return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new PointsMaterial(e);
}
function ParticleSystemMaterial(e) {
  return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new PointsMaterial(e);
}
function Vertex(e, t, r) {
  return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Vector3(e, t, r);
}
function DynamicBufferAttribute(e, t) {
  return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new BufferAttribute(e, t).setUsage(DynamicDrawUsage);
}
function Int8Attribute(e, t) {
  return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Int8BufferAttribute(e, t);
}
function Uint8Attribute(e, t) {
  return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Uint8BufferAttribute(e, t);
}
function Uint8ClampedAttribute(e, t) {
  return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Uint8ClampedBufferAttribute(e, t);
}
function Int16Attribute(e, t) {
  return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Int16BufferAttribute(e, t);
}
function Uint16Attribute(e, t) {
  return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Uint16BufferAttribute(e, t);
}
function Int32Attribute(e, t) {
  return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Int32BufferAttribute(e, t);
}
function Uint32Attribute(e, t) {
  return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Uint32BufferAttribute(e, t);
}
function Float32Attribute(e, t) {
  return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Float32BufferAttribute(e, t);
}
function Float64Attribute(e, t) {
  return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Float64BufferAttribute(e, t);
}
Curve.create = function(e, t) {
  return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Curve.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e;
};
Object.assign(CurvePath.prototype, {
  createPointsGeometry: function(e) {
    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    var t = this.getPoints(e);
    return this.createGeometry(t);
  },
  createSpacedPointsGeometry: function(e) {
    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    var t = this.getSpacedPoints(e);
    return this.createGeometry(t);
  },
  createGeometry: function(e) {
    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    for (var t = new Geometry$1(), r = 0, n = e.length; r < n; r++) {
      var a = e[r];
      t.vertices.push(new Vector3(a.x, a.y, a.z || 0));
    }
    return t;
  }
});
Object.assign(Path.prototype, {
  fromPoints: function(e) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e);
  }
});
function ClosedSplineCurve3(e) {
  console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), CatmullRomCurve3.call(this, e), this.type = "catmullrom", this.closed = !0;
}
ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
function SplineCurve3(e) {
  console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), CatmullRomCurve3.call(this, e), this.type = "catmullrom";
}
SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
function Spline(e) {
  console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), CatmullRomCurve3.call(this, e), this.type = "catmullrom";
}
Spline.prototype = Object.create(CatmullRomCurve3.prototype);
Object.assign(Spline.prototype, {
  initFromArray: function() {
    console.error("THREE.Spline: .initFromArray() has been removed.");
  },
  getControlPointsArray: function() {
    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
  },
  reparametrizeByArcLength: function() {
    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
  }
});
function AxisHelper(e) {
  return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new AxesHelper(e);
}
function BoundingBoxHelper(e, t) {
  return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new BoxHelper(e, t);
}
function EdgesHelper(e, t) {
  return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new LineSegments(new EdgesGeometry(e.geometry), new LineBasicMaterial({ color: t !== void 0 ? t : 16777215 }));
}
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
function WireframeHelper(e, t) {
  return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new LineSegments(new WireframeGeometry(e.geometry), new LineBasicMaterial({ color: t !== void 0 ? t : 16777215 }));
}
Object.assign(Loader.prototype, {
  extractUrlBase: function(e) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), LoaderUtils.extractUrlBase(e);
  }
});
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
function XHRLoader(e) {
  return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new FileLoader(e);
}
function BinaryTextureLoader(e) {
  return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new DataTextureLoader(e);
}
Object.assign(ObjectLoader.prototype, {
  setTexturePath: function(e) {
    return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e);
  }
});
Object.assign(Box2.prototype, {
  center: function(e) {
    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e);
  },
  empty: function() {
    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  },
  isIntersectionBox: function(e) {
    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e);
  },
  size: function(e) {
    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e);
  }
});
Object.assign(Box3.prototype, {
  center: function(e) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e);
  },
  empty: function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  },
  isIntersectionBox: function(e) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e);
  },
  isIntersectionSphere: function(e) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e);
  },
  size: function(e) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e);
  }
});
Object.assign(Sphere.prototype, {
  empty: function() {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  }
});
Frustum.prototype.setFromMatrix = function(e) {
  return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e);
};
Line3.prototype.center = function(e) {
  return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e);
};
Object.assign(MathUtils, {
  random16: function() {
    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random();
  },
  nearestPowerOfTwo: function(e) {
    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), MathUtils.floorPowerOfTwo(e);
  },
  nextPowerOfTwo: function(e) {
    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), MathUtils.ceilPowerOfTwo(e);
  }
});
Object.assign(Matrix3.prototype, {
  flattenToArrayOffset: function(e, t) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t);
  },
  multiplyVector3: function(e) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  },
  applyToBufferAttribute: function(e) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  }
});
Object.assign(Matrix4.prototype, {
  extractPosition: function(e) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e);
  },
  flattenToArrayOffset: function(e, t) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t);
  },
  getPosition: function() {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new Vector3().setFromMatrixColumn(this, 3);
  },
  setRotationFromQuaternion: function(e) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e);
  },
  multiplyToArray: function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  },
  multiplyVector3: function(e) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
  },
  multiplyVector4: function(e) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  },
  rotateAxis: function(e) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this);
  },
  crossVector: function(e) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
  },
  translate: function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  },
  rotateX: function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  },
  rotateY: function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  },
  rotateZ: function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  },
  rotateByAxis: function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  },
  applyToBufferAttribute: function(e) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  },
  makeFrustum: function(e, t, r, n, a, o) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, n, r, a, o);
  }
});
Plane.prototype.isIntersectionLine = function(e) {
  return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e);
};
Quaternion.prototype.multiplyVector3 = function(e) {
  return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this);
};
Object.assign(Ray.prototype, {
  isIntersectionBox: function(e) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e);
  },
  isIntersectionPlane: function(e) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e);
  },
  isIntersectionSphere: function(e) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e);
  }
});
Object.assign(Triangle.prototype, {
  area: function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
  },
  barycoordFromPoint: function(e, t) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t);
  },
  midpoint: function(e) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e);
  },
  normal: function(e) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e);
  },
  plane: function(e) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e);
  }
});
Object.assign(Triangle, {
  barycoordFromPoint: function(e, t, r, n, a) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Triangle.getBarycoord(e, t, r, n, a);
  },
  normal: function(e, t, r, n) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Triangle.getNormal(e, t, r, n);
  }
});
Object.assign(Shape$1.prototype, {
  extractAllPoints: function(e) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e);
  },
  extrude: function(e) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new ExtrudeGeometry(this, e);
  },
  makeGeometry: function(e) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ShapeGeometry(this, e);
  }
});
Object.assign(Vector2.prototype, {
  fromAttribute: function(e, t, r) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, r);
  },
  distanceToManhattan: function(e) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(Vector3.prototype, {
  setEulerFromRotationMatrix: function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  },
  setEulerFromQuaternion: function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  },
  getPositionFromMatrix: function(e) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e);
  },
  getScaleFromMatrix: function(e) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e);
  },
  getColumnFromMatrix: function(e, t) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e);
  },
  applyProjection: function(e) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e);
  },
  fromAttribute: function(e, t, r) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, r);
  },
  distanceToManhattan: function(e) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(Vector4.prototype, {
  fromAttribute: function(e, t, r) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, r);
  },
  lengthManhattan: function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
});
Object.assign(Geometry$1.prototype, {
  computeTangents: function() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  },
  computeLineDistances: function() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  },
  applyMatrix: function(e) {
    return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e);
  }
});
Object.assign(Object3D.prototype, {
  getChildByName: function(e) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e);
  },
  renderDepth: function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  },
  translate: function(e, t) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e);
  },
  getWorldRotation: function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  },
  applyMatrix: function(e) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e);
  }
});
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
    },
    set: function(e) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Object.assign(Mesh.prototype, {
  setDrawMode: function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  }
});
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function() {
      return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
Object.defineProperties(LOD.prototype, {
  objects: {
    get: function() {
      return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
    }
  }
});
Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
  get: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
  set: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
  get: function() {
    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions;
  },
  set: function(e) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e;
  }
});
PerspectiveCamera.prototype.setLens = function(e, t) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), t !== void 0 && (this.filmGauge = t), this.setFocalLength(e);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e;
    }
  },
  shadowCameraLeft: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e;
    }
  },
  shadowCameraRight: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e;
    }
  },
  shadowCameraTop: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e;
    }
  },
  shadowCameraBottom: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e;
    }
  },
  shadowCameraNear: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e;
    }
  },
  shadowCameraFar: {
    set: function(e) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(e) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(e) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e;
    }
  },
  shadowMapHeight: {
    set: function(e) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
    }
  },
  dynamic: {
    get: function() {
      return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(DynamicDrawUsage);
    }
  }
});
Object.assign(BufferAttribute.prototype, {
  setDynamic: function(e) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(e === !0 ? DynamicDrawUsage : StaticDrawUsage), this;
  },
  copyIndicesArray: function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  },
  setArray: function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }
});
Object.assign(BufferGeometry.prototype, {
  addIndex: function(e) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e);
  },
  addAttribute: function(e, t) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), !(t && t.isBufferAttribute) && !(t && t.isInterleavedBufferAttribute) ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new BufferAttribute(arguments[1], arguments[2]))) : e === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t);
  },
  addDrawCall: function(e, t, r) {
    r !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t);
  },
  clearDrawCalls: function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
  },
  computeTangents: function() {
    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
  },
  computeOffsets: function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  },
  removeAttribute: function(e) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e);
  },
  applyMatrix: function(e) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e);
  }
});
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
    }
  },
  offsets: {
    get: function() {
      return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
    }
  }
});
Object.defineProperties(InstancedBufferGeometry.prototype, {
  maxInstancedCount: {
    get: function() {
      return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount;
    },
    set: function(e) {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = e;
    }
  }
});
Object.defineProperties(Raycaster$1.prototype, {
  linePrecision: {
    get: function() {
      return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold;
    },
    set: function(e) {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = e;
    }
  }
});
Object.defineProperties(InterleavedBuffer.prototype, {
  dynamic: {
    get: function() {
      return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === DynamicDrawUsage;
    },
    set: function(e) {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(e);
    }
  }
});
Object.assign(InterleavedBuffer.prototype, {
  setDynamic: function(e) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(e === !0 ? DynamicDrawUsage : StaticDrawUsage), this;
  },
  setArray: function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }
});
Object.assign(ExtrudeBufferGeometry.prototype, {
  getArrays: function() {
    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
  },
  addShapeList: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
  },
  addShape: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
  }
});
Object.defineProperties(Uniform.prototype, {
  dynamic: {
    set: function() {
      console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
    }
  },
  onUpdate: {
    value: function() {
      return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
    }
  }
});
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      return console.warn("THREE.Material: .wrapRGB has been removed."), new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(e) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = e === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
    },
    set: function(e) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e;
    }
  }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
  metal: {
    get: function() {
      return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1;
    },
    set: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
    },
    set: function(e) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e;
    }
  }
});
Object.assign(WebGLRenderer$1.prototype, {
  clearTarget: function(e, t, r, n) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, r, n);
  },
  animate: function(e) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e);
  },
  getCurrentRenderTarget: function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
  },
  getMaxAnisotropy: function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
  },
  getPrecision: function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
  },
  resetGLState: function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
  },
  supportsFloatTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
  },
  supportsHalfFloatTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
  },
  supportsStandardDerivatives: function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
  },
  supportsCompressedTextureS3TC: function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
  },
  supportsCompressedTexturePVRTC: function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
  },
  supportsBlendMinMax: function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
  },
  supportsVertexTextures: function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
  },
  supportsInstancedArrays: function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
  },
  enableScissorTest: function(e) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e);
  },
  initMaterial: function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  },
  addPrePlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  },
  addPostPlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  },
  updateShadowMap: function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  },
  setFaceCulling: function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  },
  allocTextureUnit: function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  },
  setTexture: function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  },
  setTexture2D: function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  },
  setTextureCube: function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  },
  getActiveMipMapLevel: function() {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
  }
});
Object.defineProperties(WebGLRenderer$1.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
    }
  },
  vr: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
    }
  },
  gammaInput: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = e === !0 ? sRGBEncoding : LinearEncoding;
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
function WebGLRenderTargetCube(e, t, r) {
  return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new WebGLCubeRenderTarget(e, r);
}
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e;
    }
  },
  wrapT: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e;
    }
  },
  magFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e;
    }
  },
  minFilter: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e;
    }
  },
  anisotropy: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e;
    }
  },
  offset: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e;
    }
  },
  repeat: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e;
    }
  },
  format: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e;
    }
  },
  type: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e;
    }
  },
  generateMipmaps: {
    get: function() {
      return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
    },
    set: function(e) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e;
    }
  }
});
Object.defineProperties(Audio$1.prototype, {
  load: {
    value: function(e) {
      console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
      var t = this, r = new AudioLoader();
      return r.load(e, function(n) {
        t.setBuffer(n);
      }), this;
    }
  },
  startTime: {
    set: function() {
      console.warn("THREE.Audio: .startTime is now .play( delay ).");
    }
  }
});
AudioAnalyser.prototype.getData = function() {
  return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
};
CubeCamera.prototype.updateCubeMap = function(e, t) {
  return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t);
};
var GeometryUtils = {
  merge: function(e, t, r) {
    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
    var n;
    t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), n = t.matrix, t = t.geometry), e.merge(t, n, r);
  },
  center: function(e) {
    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center();
  }
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(e, t, r, n) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  var a = new TextureLoader();
  a.setCrossOrigin(this.crossOrigin);
  var o = a.load(e, r, void 0, n);
  return t && (o.mapping = t), o;
};
ImageUtils.loadTextureCube = function(e, t, r, n) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  var a = new CubeTextureLoader();
  a.setCrossOrigin(this.crossOrigin);
  var o = a.load(e, r, void 0, n);
  return t && (o.mapping = t), o;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
function CanvasRenderer() {
  console.error("THREE.CanvasRenderer has been removed");
}
function JSONLoader() {
  console.error("THREE.JSONLoader has been removed.");
}
var SceneUtils = {
  createMultiMaterialObject: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  },
  detach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  },
  attach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  }
};
function LensFlare() {
  console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: REVISION
} }));
const THREE$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping,
  AddEquation,
  AddOperation,
  AdditiveAnimationBlendMode,
  AdditiveBlending,
  AlphaFormat,
  AlwaysDepth,
  AlwaysStencilFunc,
  AmbientLight,
  AmbientLightProbe,
  AnimationClip,
  AnimationLoader,
  AnimationMixer,
  AnimationObjectGroup,
  AnimationUtils,
  ArcCurve,
  ArrayCamera,
  ArrowHelper,
  Audio: Audio$1,
  AudioAnalyser,
  AudioContext,
  AudioListener,
  AudioLoader,
  AxesHelper,
  AxisHelper,
  BackSide,
  BasicDepthPacking,
  BasicShadowMap,
  BinaryTextureLoader,
  Bone,
  BooleanKeyframeTrack,
  BoundingBoxHelper,
  Box2,
  Box3,
  Box3Helper,
  BoxBufferGeometry,
  BoxGeometry,
  BoxHelper,
  BufferAttribute,
  BufferGeometry,
  BufferGeometryLoader,
  ByteType,
  Cache,
  Camera: Camera$1,
  CameraHelper,
  CanvasRenderer,
  CanvasTexture,
  CatmullRomCurve3,
  CineonToneMapping,
  CircleBufferGeometry,
  CircleGeometry,
  ClampToEdgeWrapping,
  Clock,
  ClosedSplineCurve3,
  Color,
  ColorKeyframeTrack,
  CompressedTexture,
  CompressedTextureLoader,
  ConeBufferGeometry,
  ConeGeometry,
  CubeCamera,
  CubeGeometry: BoxGeometry,
  CubeReflectionMapping,
  CubeRefractionMapping,
  CubeTexture,
  CubeTextureLoader,
  CubeUVReflectionMapping,
  CubeUVRefractionMapping,
  CubicBezierCurve,
  CubicBezierCurve3,
  CubicInterpolant,
  CullFaceBack,
  CullFaceFront,
  CullFaceFrontBack,
  CullFaceNone,
  Curve,
  CurvePath,
  CustomBlending,
  CylinderBufferGeometry,
  CylinderGeometry,
  Cylindrical,
  DataTexture,
  DataTexture2DArray,
  DataTexture3D,
  DataTextureLoader,
  DecrementStencilOp,
  DecrementWrapStencilOp,
  DefaultLoadingManager,
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  DirectionalLight,
  DirectionalLightHelper,
  DirectionalLightShadow,
  DiscreteInterpolant,
  DodecahedronBufferGeometry,
  DodecahedronGeometry,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  DynamicBufferAttribute,
  DynamicCopyUsage,
  DynamicDrawUsage,
  DynamicReadUsage,
  EdgesGeometry,
  EdgesHelper,
  EllipseCurve,
  EqualDepth,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  Euler,
  EventDispatcher: EventDispatcher$1,
  ExtrudeBufferGeometry,
  ExtrudeGeometry,
  Face3,
  Face4,
  FaceColors,
  FileLoader,
  FlatShading,
  Float32Attribute,
  Float32BufferAttribute,
  Float64Attribute,
  Float64BufferAttribute,
  FloatType,
  Fog,
  FogExp2,
  Font,
  FontLoader,
  FrontFaceDirectionCCW,
  FrontFaceDirectionCW,
  FrontSide,
  Frustum,
  GammaEncoding,
  Geometry: Geometry$1,
  GeometryUtils,
  GreaterDepth,
  GreaterEqualDepth,
  GreaterEqualStencilFunc,
  GreaterStencilFunc,
  GridHelper,
  Group,
  HalfFloatType,
  HemisphereLight,
  HemisphereLightHelper,
  HemisphereLightProbe,
  IcosahedronBufferGeometry,
  IcosahedronGeometry,
  ImageBitmapLoader,
  ImageLoader,
  ImageUtils,
  ImmediateRenderObject,
  IncrementStencilOp,
  IncrementWrapStencilOp,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  InstancedMesh,
  Int16Attribute,
  Int16BufferAttribute,
  Int32Attribute,
  Int32BufferAttribute,
  Int8Attribute,
  Int8BufferAttribute,
  IntType,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  InterpolateSmooth,
  InvertStencilOp,
  JSONLoader,
  KeepStencilOp,
  KeyframeTrack,
  LOD,
  LatheBufferGeometry,
  LatheGeometry,
  Layers,
  LensFlare,
  LessDepth,
  LessEqualDepth,
  LessEqualStencilFunc,
  LessStencilFunc,
  Light,
  LightProbe,
  LightShadow,
  Line,
  Line3,
  LineBasicMaterial,
  LineCurve,
  LineCurve3,
  LineDashedMaterial,
  LineLoop,
  LinePieces,
  LineSegments,
  LineStrip,
  LinearEncoding,
  LinearFilter,
  LinearInterpolant,
  LinearMipMapLinearFilter,
  LinearMipMapNearestFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LinearToneMapping,
  Loader,
  LoaderUtils,
  LoadingManager,
  LogLuvEncoding,
  LoopOnce,
  LoopPingPong,
  LoopRepeat,
  LuminanceAlphaFormat,
  LuminanceFormat,
  MOUSE,
  Material,
  MaterialLoader,
  Math: MathUtils,
  MathUtils,
  Matrix3,
  Matrix4,
  MaxEquation,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshFaceMaterial,
  MeshLambertMaterial,
  MeshMatcapMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  MinEquation,
  MirroredRepeatWrapping,
  MixOperation,
  MultiMaterial,
  MultiplyBlending,
  MultiplyOperation,
  NearestFilter,
  NearestMipMapLinearFilter,
  NearestMipMapNearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NeverDepth,
  NeverStencilFunc,
  NoBlending,
  NoColors,
  NoToneMapping,
  NormalAnimationBlendMode,
  NormalBlending,
  NotEqualDepth,
  NotEqualStencilFunc,
  NumberKeyframeTrack,
  Object3D,
  ObjectLoader,
  ObjectSpaceNormalMap,
  OctahedronBufferGeometry,
  OctahedronGeometry,
  OneFactor,
  OneMinusDstAlphaFactor,
  OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor,
  OrthographicCamera,
  PCFShadowMap,
  PCFSoftShadowMap,
  PMREMGenerator,
  ParametricBufferGeometry,
  ParametricGeometry,
  Particle,
  ParticleBasicMaterial,
  ParticleSystem,
  ParticleSystemMaterial,
  Path,
  PerspectiveCamera,
  Plane,
  PlaneBufferGeometry,
  PlaneGeometry,
  PlaneHelper,
  PointCloud,
  PointCloudMaterial,
  PointLight,
  PointLightHelper,
  Points,
  PointsMaterial,
  PolarGridHelper,
  PolyhedronBufferGeometry,
  PolyhedronGeometry,
  PositionalAudio,
  PropertyBinding,
  PropertyMixer,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  Quaternion,
  QuaternionKeyframeTrack,
  QuaternionLinearInterpolant,
  REVISION,
  RGBADepthPacking,
  RGBAFormat,
  RGBAIntegerFormat,
  RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format,
  RGBDEncoding,
  RGBEEncoding,
  RGBEFormat,
  RGBFormat,
  RGBIntegerFormat,
  RGBM16Encoding,
  RGBM7Encoding,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGFormat,
  RGIntegerFormat,
  RawShaderMaterial,
  Ray,
  Raycaster: Raycaster$1,
  RectAreaLight,
  RedFormat,
  RedIntegerFormat,
  ReinhardToneMapping,
  RepeatWrapping,
  ReplaceStencilOp,
  ReverseSubtractEquation,
  RingBufferGeometry,
  RingGeometry,
  SRGB8_ALPHA8_ASTC_10x10_Format,
  SRGB8_ALPHA8_ASTC_10x5_Format,
  SRGB8_ALPHA8_ASTC_10x6_Format,
  SRGB8_ALPHA8_ASTC_10x8_Format,
  SRGB8_ALPHA8_ASTC_12x10_Format,
  SRGB8_ALPHA8_ASTC_12x12_Format,
  SRGB8_ALPHA8_ASTC_4x4_Format,
  SRGB8_ALPHA8_ASTC_5x4_Format,
  SRGB8_ALPHA8_ASTC_5x5_Format,
  SRGB8_ALPHA8_ASTC_6x5_Format,
  SRGB8_ALPHA8_ASTC_6x6_Format,
  SRGB8_ALPHA8_ASTC_8x5_Format,
  SRGB8_ALPHA8_ASTC_8x6_Format,
  SRGB8_ALPHA8_ASTC_8x8_Format,
  Scene: Scene$1,
  SceneUtils,
  ShaderChunk,
  ShaderLib,
  ShaderMaterial,
  ShadowMaterial,
  Shape: Shape$1,
  ShapeBufferGeometry,
  ShapeGeometry,
  ShapePath,
  ShapeUtils,
  ShortType,
  Skeleton,
  SkeletonHelper,
  SkinnedMesh,
  SmoothShading,
  Sphere,
  SphereBufferGeometry,
  SphereGeometry,
  Spherical,
  SphericalHarmonics3,
  SphericalReflectionMapping,
  Spline,
  SplineCurve,
  SplineCurve3,
  SpotLight,
  SpotLightHelper,
  SpotLightShadow,
  Sprite,
  SpriteMaterial,
  SrcAlphaFactor,
  SrcAlphaSaturateFactor,
  SrcColorFactor,
  StaticCopyUsage,
  StaticDrawUsage,
  StaticReadUsage,
  StereoCamera,
  StreamCopyUsage,
  StreamDrawUsage,
  StreamReadUsage,
  StringKeyframeTrack,
  SubtractEquation,
  SubtractiveBlending,
  TOUCH,
  TangentSpaceNormalMap,
  TetrahedronBufferGeometry,
  TetrahedronGeometry,
  TextBufferGeometry,
  TextGeometry,
  Texture,
  TextureLoader,
  TorusBufferGeometry,
  TorusGeometry,
  TorusKnotBufferGeometry,
  TorusKnotGeometry,
  Triangle,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  TrianglesDrawMode,
  TubeBufferGeometry,
  TubeGeometry,
  UVMapping,
  Uint16Attribute,
  Uint16BufferAttribute,
  Uint32Attribute,
  Uint32BufferAttribute,
  Uint8Attribute,
  Uint8BufferAttribute,
  Uint8ClampedAttribute,
  Uint8ClampedBufferAttribute,
  Uncharted2ToneMapping,
  Uniform,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedInt248Type,
  UnsignedIntType,
  UnsignedShort4444Type,
  UnsignedShort5551Type,
  UnsignedShort565Type,
  UnsignedShortType,
  VSMShadowMap,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  Vertex,
  VertexColors,
  VideoTexture,
  WebGLCubeRenderTarget,
  WebGLMultisampleRenderTarget,
  WebGLRenderTarget,
  WebGLRenderTargetCube,
  WebGLRenderer: WebGLRenderer$1,
  WebGLUtils,
  WireframeGeometry,
  WireframeHelper,
  WrapAroundEnding,
  XHRLoader,
  ZeroCurvatureEnding,
  ZeroFactor,
  ZeroSlopeEnding,
  ZeroStencilOp,
  sRGBEncoding
}, Symbol.toStringTag, { value: "Module" }));
function getName(e) {
  return e.name;
}
function queryKey(e) {
  for (var t = [], r = 0; r < e.length; r++) {
    var n = e[r];
    if (typeof n == "object") {
      var a = n.operator === "not" ? "!" : n.operator;
      t.push(a + getName(n.Component));
    } else
      t.push(getName(n));
  }
  return t.sort().join("-");
}
const hasWindow = typeof window < "u", now = hasWindow && typeof window.performance < "u" ? performance.now.bind(performance) : Date.now.bind(Date);
class SystemManager {
  constructor(t) {
    this._systems = [], this._executeSystems = [], this.world = t, this.lastExecutedSystem = null;
  }
  registerSystem(t, r) {
    if (!t.isSystem)
      throw new Error(
        `System '${t.name}' does not extend 'System' class`
      );
    if (this.getSystem(t) !== void 0)
      return console.warn(`System '${t.getName()}' already registered.`), this;
    var n = new t(this.world, r);
    return n.init && n.init(r), n.order = this._systems.length, this._systems.push(n), n.execute && (this._executeSystems.push(n), this.sortSystems()), this;
  }
  unregisterSystem(t) {
    let r = this.getSystem(t);
    return r === void 0 ? (console.warn(
      `Can unregister system '${t.getName()}'. It doesn't exist.`
    ), this) : (this._systems.splice(this._systems.indexOf(r), 1), r.execute && this._executeSystems.splice(this._executeSystems.indexOf(r), 1), this);
  }
  sortSystems() {
    this._executeSystems.sort((t, r) => t.priority - r.priority || t.order - r.order);
  }
  getSystem(t) {
    return this._systems.find((r) => r instanceof t);
  }
  getSystems() {
    return this._systems;
  }
  removeSystem(t) {
    var r = this._systems.indexOf(t);
    ~r && this._systems.splice(r, 1);
  }
  executeSystem(t, r, n) {
    if (t.initialized && t.canExecute()) {
      let a = now();
      t.execute(r, n), t.executeTime = now() - a, this.lastExecutedSystem = t, t.clearEvents();
    }
  }
  stop() {
    this._executeSystems.forEach((t) => t.stop());
  }
  execute(t, r, n) {
    this._executeSystems.forEach(
      (a) => (n || a.enabled) && this.executeSystem(a, t, r)
    );
  }
  stats() {
    for (var t = {
      numSystems: this._systems.length,
      systems: {}
    }, r = 0; r < this._systems.length; r++) {
      var n = this._systems[r], a = t.systems[n.getName()] = {
        queries: {},
        executeTime: n.executeTime
      };
      for (var o in n.ctx)
        a.queries[o] = n.ctx[o].stats();
    }
    return t;
  }
}
class ObjectPool {
  // @todo Add initial size
  constructor(t, r) {
    this.freeList = [], this.count = 0, this.T = t, this.isObjectPool = !0, typeof r < "u" && this.expand(r);
  }
  acquire() {
    this.freeList.length <= 0 && this.expand(Math.round(this.count * 0.2) + 1);
    var t = this.freeList.pop();
    return t;
  }
  release(t) {
    t.reset(), this.freeList.push(t);
  }
  expand(t) {
    for (var r = 0; r < t; r++) {
      var n = new this.T();
      n._pool = this, this.freeList.push(n);
    }
    this.count += t;
  }
  totalSize() {
    return this.count;
  }
  totalFree() {
    return this.freeList.length;
  }
  totalUsed() {
    return this.count - this.freeList.length;
  }
}
class EventDispatcher {
  constructor() {
    this._listeners = {}, this.stats = {
      fired: 0,
      handled: 0
    };
  }
  /**
   * Add an event listener
   * @param {String} eventName Name of the event to listen
   * @param {Function} listener Callback to trigger when the event is fired
   */
  addEventListener(t, r) {
    let n = this._listeners;
    n[t] === void 0 && (n[t] = []), n[t].indexOf(r) === -1 && n[t].push(r);
  }
  /**
   * Check if an event listener is already added to the list of listeners
   * @param {String} eventName Name of the event to check
   * @param {Function} listener Callback for the specified event
   */
  hasEventListener(t, r) {
    return this._listeners[t] !== void 0 && this._listeners[t].indexOf(r) !== -1;
  }
  /**
   * Remove an event listener
   * @param {String} eventName Name of the event to remove
   * @param {Function} listener Callback for the specified event
   */
  removeEventListener(t, r) {
    var n = this._listeners[t];
    if (n !== void 0) {
      var a = n.indexOf(r);
      a !== -1 && n.splice(a, 1);
    }
  }
  /**
   * Dispatch an event
   * @param {String} eventName Name of the event to dispatch
   * @param {Entity} entity (Optional) Entity to emit
   * @param {Component} component
   */
  dispatchEvent(t, r, n) {
    this.stats.fired++;
    var a = this._listeners[t];
    if (a !== void 0)
      for (var o = a.slice(0), s = 0; s < o.length; s++)
        o[s].call(this, r, n);
  }
  /**
   * Reset stats counters
   */
  resetCounters() {
    this.stats.fired = this.stats.handled = 0;
  }
}
class Query {
  /**
   * @param {Array(Component)} Components List of types of components to query
   */
  constructor(t, r) {
    if (this.Components = [], this.NotComponents = [], t.forEach((o) => {
      typeof o == "object" ? this.NotComponents.push(o.Component) : this.Components.push(o);
    }), this.Components.length === 0)
      throw new Error("Can't create a query without components");
    this.entities = [], this.eventDispatcher = new EventDispatcher(), this.reactive = !1, this.key = queryKey(t);
    for (var n = 0; n < r._entities.length; n++) {
      var a = r._entities[n];
      this.match(a) && (a.queries.push(this), this.entities.push(a));
    }
  }
  /**
   * Add entity to this query
   * @param {Entity} entity
   */
  addEntity(t) {
    t.queries.push(this), this.entities.push(t), this.eventDispatcher.dispatchEvent(Query.prototype.ENTITY_ADDED, t);
  }
  /**
   * Remove entity from this query
   * @param {Entity} entity
   */
  removeEntity(t) {
    let r = this.entities.indexOf(t);
    ~r && (this.entities.splice(r, 1), r = t.queries.indexOf(this), t.queries.splice(r, 1), this.eventDispatcher.dispatchEvent(
      Query.prototype.ENTITY_REMOVED,
      t
    ));
  }
  match(t) {
    return t.hasAllComponents(this.Components) && !t.hasAnyComponents(this.NotComponents);
  }
  toJSON() {
    return {
      key: this.key,
      reactive: this.reactive,
      components: {
        included: this.Components.map((t) => t.name),
        not: this.NotComponents.map((t) => t.name)
      },
      numEntities: this.entities.length
    };
  }
  /**
   * Return stats for this query
   */
  stats() {
    return {
      numComponents: this.Components.length,
      numEntities: this.entities.length
    };
  }
}
Query.prototype.ENTITY_ADDED = "Query#ENTITY_ADDED";
Query.prototype.ENTITY_REMOVED = "Query#ENTITY_REMOVED";
Query.prototype.COMPONENT_CHANGED = "Query#COMPONENT_CHANGED";
class QueryManager {
  constructor(t) {
    this._world = t, this._queries = {};
  }
  onEntityRemoved(t) {
    for (var r in this._queries) {
      var n = this._queries[r];
      t.queries.indexOf(n) !== -1 && n.removeEntity(t);
    }
  }
  /**
   * Callback when a component is added to an entity
   * @param {Entity} entity Entity that just got the new component
   * @param {Component} Component Component added to the entity
   */
  onEntityComponentAdded(t, r) {
    for (var n in this._queries) {
      var a = this._queries[n];
      if (~a.NotComponents.indexOf(r) && ~a.entities.indexOf(t)) {
        a.removeEntity(t);
        continue;
      }
      !~a.Components.indexOf(r) || !a.match(t) || ~a.entities.indexOf(t) || a.addEntity(t);
    }
  }
  /**
   * Callback when a component is removed from an entity
   * @param {Entity} entity Entity to remove the component from
   * @param {Component} Component Component to remove from the entity
   */
  onEntityComponentRemoved(t, r) {
    for (var n in this._queries) {
      var a = this._queries[n];
      if (~a.NotComponents.indexOf(r) && !~a.entities.indexOf(t) && a.match(t)) {
        a.addEntity(t);
        continue;
      }
      if (~a.Components.indexOf(r) && ~a.entities.indexOf(t) && !a.match(t)) {
        a.removeEntity(t);
        continue;
      }
    }
  }
  /**
   * Get a query for the specified components
   * @param {Component} Components Components that the query should have
   */
  getQuery(t) {
    var r = queryKey(t), n = this._queries[r];
    return n || (this._queries[r] = n = new Query(t, this._world)), n;
  }
  /**
   * Return some stats from this class
   */
  stats() {
    var t = {};
    for (var r in this._queries)
      t[r] = this._queries[r].stats();
    return t;
  }
}
let Component$1 = class {
  constructor(t) {
    if (t !== !1) {
      const r = this.constructor.schema;
      for (const n in r)
        if (t && t.hasOwnProperty(n))
          this[n] = t[n];
        else {
          const a = r[n];
          if (a.hasOwnProperty("default"))
            this[n] = a.type.clone(a.default);
          else {
            const o = a.type;
            this[n] = o.clone(o.default);
          }
        }
    }
    this._pool = null;
  }
  copy(t) {
    const r = this.constructor.schema;
    for (const n in r) {
      const a = r[n];
      t.hasOwnProperty(n) && (this[n] = a.type.copy(t[n], this[n]));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  reset() {
    const t = this.constructor.schema;
    for (const r in t) {
      const n = t[r];
      if (n.hasOwnProperty("default"))
        this[r] = n.type.copy(n.default, this[r]);
      else {
        const a = n.type;
        this[r] = a.copy(a.default, this[r]);
      }
    }
  }
  dispose() {
    this._pool && this._pool.release(this);
  }
  getName() {
    return this.constructor.getName();
  }
};
Component$1.schema = {};
Component$1.isComponent = !0;
Component$1.getName = function() {
  return this.displayName || this.name;
};
class SystemStateComponent extends Component$1 {
}
SystemStateComponent.isSystemStateComponent = !0;
class EntityPool extends ObjectPool {
  constructor(t, r, n) {
    super(r, void 0), this.entityManager = t, typeof n < "u" && this.expand(n);
  }
  expand(t) {
    for (var r = 0; r < t; r++) {
      var n = new this.T(this.entityManager);
      n._pool = this, this.freeList.push(n);
    }
    this.count += t;
  }
}
class EntityManager {
  constructor(t) {
    this.world = t, this.componentsManager = t.componentsManager, this._entities = [], this._nextEntityId = 0, this._entitiesByNames = {}, this._queryManager = new QueryManager(this), this.eventDispatcher = new EventDispatcher(), this._entityPool = new EntityPool(
      this,
      this.world.options.entityClass,
      this.world.options.entityPoolSize
    ), this.entitiesWithComponentsToRemove = [], this.entitiesToRemove = [], this.deferredRemovalEnabled = !0;
  }
  getEntityByName(t) {
    return this._entitiesByNames[t];
  }
  /**
   * Create a new entity
   */
  createEntity(t) {
    var r = this._entityPool.acquire();
    return r.alive = !0, r.name = t || "", t && (this._entitiesByNames[t] ? console.warn(`Entity name '${t}' already exist`) : this._entitiesByNames[t] = r), this._entities.push(r), this.eventDispatcher.dispatchEvent(ENTITY_CREATED, r), r;
  }
  // COMPONENTS
  /**
   * Add a component to an entity
   * @param {Entity} entity Entity where the component will be added
   * @param {Component} Component Component to be added to the entity
   * @param {Object} values Optional values to replace the default attributes
   */
  entityAddComponent(t, r, n) {
    if (typeof r._typeId > "u" && !this.world.componentsManager._ComponentsMap[r._typeId])
      throw new Error(
        `Attempted to add unregistered component "${r.getName()}"`
      );
    if (~t._ComponentTypes.indexOf(r)) {
      console.warn(
        "Component type already exists on entity.",
        t,
        r.getName()
      );
      return;
    }
    t._ComponentTypes.push(r), r.__proto__ === SystemStateComponent && t.numStateComponents++;
    var a = this.world.componentsManager.getComponentsPool(
      r
    ), o = a ? a.acquire() : new r(n);
    a && n && o.copy(n), t._components[r._typeId] = o, this._queryManager.onEntityComponentAdded(t, r), this.world.componentsManager.componentAddedToEntity(r), this.eventDispatcher.dispatchEvent(COMPONENT_ADDED, t, r);
  }
  /**
   * Remove a component from an entity
   * @param {Entity} entity Entity which will get removed the component
   * @param {*} Component Component to remove from the entity
   * @param {Bool} immediately If you want to remove the component immediately instead of deferred (Default is false)
   */
  entityRemoveComponent(t, r, n) {
    var a = t._ComponentTypes.indexOf(r);
    ~a && (this.eventDispatcher.dispatchEvent(COMPONENT_REMOVE, t, r), n ? this._entityRemoveComponentSync(t, r, a) : (t._ComponentTypesToRemove.length === 0 && this.entitiesWithComponentsToRemove.push(t), t._ComponentTypes.splice(a, 1), t._ComponentTypesToRemove.push(r), t._componentsToRemove[r._typeId] = t._components[r._typeId], delete t._components[r._typeId]), this._queryManager.onEntityComponentRemoved(t, r), r.__proto__ === SystemStateComponent && (t.numStateComponents--, t.numStateComponents === 0 && !t.alive && t.remove()));
  }
  _entityRemoveComponentSync(t, r, n) {
    t._ComponentTypes.splice(n, 1);
    var a = t._components[r._typeId];
    delete t._components[r._typeId], a.dispose(), this.world.componentsManager.componentRemovedFromEntity(r);
  }
  /**
   * Remove all the components from an entity
   * @param {Entity} entity Entity from which the components will be removed
   */
  entityRemoveAllComponents(t, r) {
    let n = t._ComponentTypes;
    for (let a = n.length - 1; a >= 0; a--)
      n[a].__proto__ !== SystemStateComponent && this.entityRemoveComponent(t, n[a], r);
  }
  /**
   * Remove the entity from this manager. It will clear also its components
   * @param {Entity} entity Entity to remove from the manager
   * @param {Bool} immediately If you want to remove the component immediately instead of deferred (Default is false)
   */
  removeEntity(t, r) {
    var n = this._entities.indexOf(t);
    if (!~n) throw new Error("Tried to remove entity not in list");
    t.alive = !1, t.numStateComponents === 0 && (this.eventDispatcher.dispatchEvent(ENTITY_REMOVED, t), this._queryManager.onEntityRemoved(t), r === !0 ? this._releaseEntity(t, n) : this.entitiesToRemove.push(t)), this.entityRemoveAllComponents(t, r);
  }
  _releaseEntity(t, r) {
    this._entities.splice(r, 1), this._entitiesByNames[t.name] && delete this._entitiesByNames[t.name], t._pool.release(t);
  }
  /**
   * Remove all entities from this manager
   */
  removeAllEntities() {
    for (var t = this._entities.length - 1; t >= 0; t--)
      this.removeEntity(this._entities[t]);
  }
  processDeferredRemoval() {
    if (this.deferredRemovalEnabled) {
      for (let r = 0; r < this.entitiesToRemove.length; r++) {
        let n = this.entitiesToRemove[r], a = this._entities.indexOf(n);
        this._releaseEntity(n, a);
      }
      this.entitiesToRemove.length = 0;
      for (let r = 0; r < this.entitiesWithComponentsToRemove.length; r++) {
        let n = this.entitiesWithComponentsToRemove[r];
        for (; n._ComponentTypesToRemove.length > 0; ) {
          let a = n._ComponentTypesToRemove.pop();
          var t = n._componentsToRemove[a._typeId];
          delete n._componentsToRemove[a._typeId], t.dispose(), this.world.componentsManager.componentRemovedFromEntity(a);
        }
      }
      this.entitiesWithComponentsToRemove.length = 0;
    }
  }
  /**
   * Get a query based on a list of components
   * @param {Array(Component)} Components List of components that will form the query
   */
  queryComponents(t) {
    return this._queryManager.getQuery(t);
  }
  // EXTRAS
  /**
   * Return number of entities
   */
  count() {
    return this._entities.length;
  }
  /**
   * Return some stats
   */
  stats() {
    var t = {
      numEntities: this._entities.length,
      numQueries: Object.keys(this._queryManager._queries).length,
      queries: this._queryManager.stats(),
      numComponentPool: Object.keys(this.componentsManager._componentPool).length,
      componentPool: {},
      eventDispatcher: this.eventDispatcher.stats
    };
    for (var r in this.componentsManager._componentPool) {
      var n = this.componentsManager._componentPool[r];
      t.componentPool[r] = {
        used: n.totalUsed(),
        size: n.count
      };
    }
    return t;
  }
}
const ENTITY_CREATED = "EntityManager#ENTITY_CREATE", ENTITY_REMOVED = "EntityManager#ENTITY_REMOVED", COMPONENT_ADDED = "EntityManager#COMPONENT_ADDED", COMPONENT_REMOVE = "EntityManager#COMPONENT_REMOVE";
class ComponentManager {
  constructor() {
    this.Components = [], this._ComponentsMap = {}, this._componentPool = {}, this.numComponents = {}, this.nextComponentId = 0;
  }
  registerComponent(t, r) {
    if (this.Components.indexOf(t) !== -1) {
      console.warn(
        `Component type: '${t.getName()}' already registered.`
      );
      return;
    }
    const n = t.schema;
    if (!n)
      throw new Error(
        `Component "${t.getName()}" has no schema property.`
      );
    for (const a in n)
      if (!n[a].type)
        throw new Error(
          `Invalid schema for component "${t.getName()}". Missing type for "${a}" property.`
        );
    t._typeId = this.nextComponentId++, this.Components.push(t), this._ComponentsMap[t._typeId] = t, this.numComponents[t._typeId] = 0, r === void 0 ? r = new ObjectPool(t) : r === !1 && (r = void 0), this._componentPool[t._typeId] = r;
  }
  componentAddedToEntity(t) {
    this.numComponents[t._typeId]++;
  }
  componentRemovedFromEntity(t) {
    this.numComponents[t._typeId]--;
  }
  getComponentsPool(t) {
    return this._componentPool[t._typeId];
  }
}
const Version = "0.3.1";
class Entity {
  constructor(t) {
    this._entityManager = t || null, this.id = t._nextEntityId++, this._ComponentTypes = [], this._components = {}, this._componentsToRemove = {}, this.queries = [], this._ComponentTypesToRemove = [], this.alive = !1, this.numStateComponents = 0;
  }
  // COMPONENTS
  getComponent(t, r) {
    var n = this._components[t._typeId];
    return !n && r === !0 && (n = this._componentsToRemove[t._typeId]), n;
  }
  getRemovedComponent(t) {
    return this._componentsToRemove[t._typeId];
  }
  getComponents() {
    return this._components;
  }
  getComponentsToRemove() {
    return this._componentsToRemove;
  }
  getComponentTypes() {
    return this._ComponentTypes;
  }
  getMutableComponent(t) {
    for (var r = this._components[t._typeId], n = 0; n < this.queries.length; n++) {
      var a = this.queries[n];
      a.reactive && a.Components.indexOf(t) !== -1 && a.eventDispatcher.dispatchEvent(
        Query.prototype.COMPONENT_CHANGED,
        this,
        r
      );
    }
    return r;
  }
  addComponent(t, r) {
    return this._entityManager.entityAddComponent(this, t, r), this;
  }
  removeComponent(t, r) {
    return this._entityManager.entityRemoveComponent(this, t, r), this;
  }
  hasComponent(t, r) {
    return !!~this._ComponentTypes.indexOf(t) || r === !0 && this.hasRemovedComponent(t);
  }
  hasRemovedComponent(t) {
    return !!~this._ComponentTypesToRemove.indexOf(t);
  }
  hasAllComponents(t) {
    for (var r = 0; r < t.length; r++)
      if (!this.hasComponent(t[r])) return !1;
    return !0;
  }
  hasAnyComponents(t) {
    for (var r = 0; r < t.length; r++)
      if (this.hasComponent(t[r])) return !0;
    return !1;
  }
  removeAllComponents(t) {
    return this._entityManager.entityRemoveAllComponents(this, t);
  }
  copy(t) {
    for (var r in t._components) {
      var n = t._components[r];
      this.addComponent(n.constructor);
      var a = this.getComponent(n.constructor);
      a.copy(n);
    }
    return this;
  }
  clone() {
    return new Entity(this._entityManager).copy(this);
  }
  reset() {
    this.id = this._entityManager._nextEntityId++, this._ComponentTypes.length = 0, this.queries.length = 0;
    for (var t in this._components)
      delete this._components[t];
  }
  remove(t) {
    return this._entityManager.removeEntity(this, t);
  }
}
const DEFAULT_OPTIONS = {
  entityPoolSize: 0,
  entityClass: Entity
};
class World {
  constructor(t = {}) {
    if (this.options = Object.assign({}, DEFAULT_OPTIONS, t), this.componentsManager = new ComponentManager(this), this.entityManager = new EntityManager(this), this.systemManager = new SystemManager(this), this.enabled = !0, this.eventQueues = {}, hasWindow && typeof CustomEvent < "u") {
      var r = new CustomEvent("ecsy-world-created", {
        detail: { world: this, version: Version }
      });
      window.dispatchEvent(r);
    }
    this.lastTime = now();
  }
  registerComponent(t, r) {
    return this.componentsManager.registerComponent(t, r), this;
  }
  registerSystem(t, r) {
    return this.systemManager.registerSystem(t, r), this;
  }
  unregisterSystem(t) {
    return this.systemManager.unregisterSystem(t), this;
  }
  getSystem(t) {
    return this.systemManager.getSystem(t);
  }
  getSystems() {
    return this.systemManager.getSystems();
  }
  execute(t, r) {
    t || (r = now(), t = r - this.lastTime, this.lastTime = r), this.enabled && (this.systemManager.execute(t, r), this.entityManager.processDeferredRemoval());
  }
  stop() {
    this.enabled = !1;
  }
  play() {
    this.enabled = !0;
  }
  createEntity(t) {
    return this.entityManager.createEntity(t);
  }
  stats() {
    var t = {
      entities: this.entityManager.stats(),
      system: this.systemManager.stats()
    };
    console.log(JSON.stringify(t, null, 2));
  }
}
class System {
  canExecute() {
    if (this._mandatoryQueries.length === 0) return !0;
    for (let r = 0; r < this._mandatoryQueries.length; r++) {
      var t = this._mandatoryQueries[r];
      if (t.entities.length === 0)
        return !1;
    }
    return !0;
  }
  getName() {
    return this.constructor.getName();
  }
  constructor(t, r) {
    if (this.world = t, this.enabled = !0, this._queries = {}, this.queries = {}, this.priority = 0, this.executeTime = 0, r && r.priority && (this.priority = r.priority), this._mandatoryQueries = [], this.initialized = !0, this.constructor.queries)
      for (var n in this.constructor.queries) {
        var a = this.constructor.queries[n], o = a.components;
        if (!o || o.length === 0)
          throw new Error("'components' attribute can't be empty in a query");
        var s = this.world.entityManager.queryComponents(o);
        this._queries[n] = s, a.mandatory === !0 && this._mandatoryQueries.push(s), this.queries[n] = {
          results: s.entities
        };
        var l = ["added", "removed", "changed"];
        const c = {
          added: Query.prototype.ENTITY_ADDED,
          removed: Query.prototype.ENTITY_REMOVED,
          changed: Query.prototype.COMPONENT_CHANGED
          // Query.prototype.ENTITY_CHANGED
        };
        a.listen && l.forEach((u) => {
          if (this.execute || console.warn(
            `System '${this.getName()}' has defined listen events (${l.join(
              ", "
            )}) for query '${n}' but it does not implement the 'execute' method.`
          ), a.listen[u]) {
            let h = a.listen[u];
            if (u === "changed") {
              if (s.reactive = !0, h === !0) {
                let f = this.queries[n][u] = [];
                s.eventDispatcher.addEventListener(
                  Query.prototype.COMPONENT_CHANGED,
                  (d) => {
                    f.indexOf(d) === -1 && f.push(d);
                  }
                );
              } else if (Array.isArray(h)) {
                let f = this.queries[n][u] = [];
                s.eventDispatcher.addEventListener(
                  Query.prototype.COMPONENT_CHANGED,
                  (d, p) => {
                    h.indexOf(p.constructor) !== -1 && f.indexOf(d) === -1 && f.push(d);
                  }
                );
              }
            } else {
              let f = this.queries[n][u] = [];
              s.eventDispatcher.addEventListener(
                c[u],
                (d) => {
                  f.indexOf(d) === -1 && f.push(d);
                }
              );
            }
          }
        });
      }
  }
  stop() {
    this.executeTime = 0, this.enabled = !1;
  }
  play() {
    this.enabled = !0;
  }
  // @question rename to clear queues?
  clearEvents() {
    for (let r in this.queries) {
      var t = this.queries[r];
      if (t.added && (t.added.length = 0), t.removed && (t.removed.length = 0), t.changed)
        if (Array.isArray(t.changed))
          t.changed.length = 0;
        else
          for (let n in t.changed)
            t.changed[n].length = 0;
    }
  }
  toJSON() {
    var t = {
      name: this.getName(),
      enabled: this.enabled,
      executeTime: this.executeTime,
      priority: this.priority,
      queries: {}
    };
    if (this.constructor.queries) {
      var r = this.constructor.queries;
      for (let n in r) {
        let a = this.queries[n], o = r[n], s = t.queries[n] = {
          key: this._queries[n].key
        };
        s.mandatory = o.mandatory === !0, s.reactive = o.listen && (o.listen.added === !0 || o.listen.removed === !0 || o.listen.changed === !0 || Array.isArray(o.listen.changed)), s.reactive && (s.listen = {}, ["added", "removed", "changed"].forEach((c) => {
          a[c] && (s.listen[c] = {
            entities: a[c].length
          });
        }));
      }
    }
    return t;
  }
}
System.isSystem = !0;
System.getName = function() {
  return this.displayName || this.name;
};
function Not(e) {
  return {
    operator: "not",
    Component: e
  };
}
class TagComponent extends Component$1 {
  constructor() {
    super(!1);
  }
}
TagComponent.isTagComponent = !0;
const copyValue = (e) => e, cloneValue = (e) => e, copyArray = (e, t) => {
  if (!e)
    return e;
  if (!t)
    return e.slice();
  t.length = 0;
  for (let r = 0; r < e.length; r++)
    t.push(e[r]);
  return t;
}, cloneArray = (e) => e && e.slice(), copyJSON = (e) => JSON.parse(JSON.stringify(e)), cloneJSON = (e) => JSON.parse(JSON.stringify(e)), copyCopyable = (e, t) => e && (t ? t.copy(e) : e.clone()), cloneClonable = (e) => e && e.clone();
function createType(e) {
  var t = ["name", "default", "copy", "clone"], r = t.filter((n) => !e.hasOwnProperty(n));
  if (r.length > 0)
    throw new Error(
      `createType expects a type definition with the following properties: ${r.join(
        ", "
      )}`
    );
  return e.isType = !0, e;
}
const Types = {
  Number: createType({
    name: "Number",
    default: 0,
    copy: copyValue,
    clone: cloneValue
  }),
  Boolean: createType({
    name: "Boolean",
    default: !1,
    copy: copyValue,
    clone: cloneValue
  }),
  String: createType({
    name: "String",
    default: "",
    copy: copyValue,
    clone: cloneValue
  }),
  Array: createType({
    name: "Array",
    default: [],
    copy: copyArray,
    clone: cloneArray
  }),
  Ref: createType({
    name: "Ref",
    default: void 0,
    copy: copyValue,
    clone: cloneValue
  }),
  JSON: createType({
    name: "JSON",
    default: null,
    copy: copyJSON,
    clone: cloneJSON
  })
};
function generateId(e) {
  for (var t = "", r = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", n = r.length, a = 0; a < e; a++)
    t += r.charAt(Math.floor(Math.random() * n));
  return t;
}
function injectScript(e, t) {
  var r = document.createElement("script");
  r.src = e, r.onload = t, (document.head || document.documentElement).appendChild(r);
}
function hookConsoleAndErrors(e) {
  var t = ["error", "warning", "log"];
  t.forEach((r) => {
    if (typeof console[r] == "function") {
      var n = console[r].bind(console);
      console[r] = (...a) => (e.send({
        method: "console",
        type: r,
        args: JSON.stringify(a)
      }), n.apply(null, a));
    }
  }), window.addEventListener("error", (r) => {
    e.send({
      method: "error",
      error: JSON.stringify({
        message: r.error.message,
        stack: r.error.stack
      })
    });
  });
}
function includeRemoteIdHTML(e) {
  let t = document.createElement("div");
  return t.style.cssText = `
    align-items: center;
    background-color: #333;
    color: #aaa;
    display:flex;
    font-family: Arial;
    font-size: 1.1em;
    height: 40px;
    justify-content: center;
    left: 0;
    opacity: 0.9;
    position: absolute;
    right: 0;
    text-align: center;
    top: 0;
  `, t.innerHTML = `Open ECSY devtools to connect to this page using the code:&nbsp;<b style="color: #fff">${e}</b>&nbsp;<button onClick="generateNewCode()">Generate new code</button>`, document.body.appendChild(t), t;
}
function enableRemoteDevtools(remoteId) {
  if (!hasWindow) {
    console.warn("Remote devtools not available outside the browser");
    return;
  }
  window.generateNewCode = () => {
    window.localStorage.clear(), remoteId = generateId(6), window.localStorage.setItem("ecsyRemoteId", remoteId), window.location.reload(!1);
  }, remoteId = remoteId || window.localStorage.getItem("ecsyRemoteId"), remoteId || (remoteId = generateId(6), window.localStorage.setItem("ecsyRemoteId", remoteId));
  let infoDiv = includeRemoteIdHTML(remoteId);
  window.__ECSY_REMOTE_DEVTOOLS_INJECTED = !0, window.__ECSY_REMOTE_DEVTOOLS = {};
  let Version = "", worldsBeforeLoading = [], onWorldCreated = (e) => {
    var t = e.detail.world;
    Version = e.detail.version, worldsBeforeLoading.push(t);
  };
  window.addEventListener("ecsy-world-created", onWorldCreated);
  let onLoaded = () => {
    var peer = new Peer(remoteId);
    peer.on("open", () => {
      peer.on("connection", (connection) => {
        window.__ECSY_REMOTE_DEVTOOLS.connection = connection, connection.on("open", function() {
          infoDiv.innerHTML = "Connected", connection.on("data", function(data) {
            if (data.type === "init") {
              var script = document.createElement("script");
              script.setAttribute("type", "text/javascript"), script.onload = () => {
                script.parentNode.removeChild(script), window.removeEventListener(
                  "ecsy-world-created",
                  onWorldCreated
                ), worldsBeforeLoading.forEach((e) => {
                  var t = new CustomEvent("ecsy-world-created", {
                    detail: { world: e, version: Version }
                  });
                  window.dispatchEvent(t);
                });
              }, script.innerHTML = data.script, (document.head || document.documentElement).appendChild(script), script.onload(), hookConsoleAndErrors(connection);
            } else if (data.type === "executeScript") {
              let value = eval(data.script);
              data.returnEval && connection.send({
                method: "evalReturn",
                value
              });
            }
          });
        });
      });
    });
  };
  injectScript(
    "https://cdn.jsdelivr.net/npm/peerjs@0.3.20/dist/peer.min.js",
    onLoaded
  );
}
hasWindow && new URLSearchParams(window.location.search).has("enable-remote-devtools") && enableRemoteDevtools();
class Object3DComponent extends Component$1 {
}
Object3DComponent.schema = {
  value: { default: null, type: Types.Ref }
};
class ECSYThreeEntity extends Entity {
  addObject3DComponent(t, r) {
    return t.entity = this, this.addComponent(Object3DComponent, { value: t }), this._entityManager.world.object3DInflator.inflate(this, t), r && r.hasComponent(Object3DComponent) && r.getObject3D().add(t), this;
  }
  removeObject3DComponent(t = !0) {
    const r = this.getComponent(Object3DComponent, !0).value;
    t && r.parent && r.parent.remove(r), this.removeComponent(Object3DComponent), this._entityManager.world.object3DInflator.deflate(this, r), r.entity = null;
  }
  remove(t) {
    if (this.hasComponent(Object3DComponent)) {
      const r = this.getObject3D();
      r.traverse((n) => {
        n.entity && this._entityManager.removeEntity(n.entity, t), n.entity = null;
      }), r.parent && r.parent.remove(r);
    }
    this._entityManager.removeEntity(this, t);
  }
  getObject3D() {
    return this.getComponent(Object3DComponent).value;
  }
}
class SceneTagComponent extends TagComponent {
}
class CameraTagComponent extends TagComponent {
}
class MeshTagComponent extends TagComponent {
}
const defaultObject3DInflator = {
  inflate: (e, t) => {
    t.isMesh ? e.addComponent(MeshTagComponent) : t.isScene ? e.addComponent(SceneTagComponent) : t.isCamera && e.addComponent(CameraTagComponent);
  },
  deflate: (e, t) => {
    t.isMesh ? e.removeComponent(MeshTagComponent) : t.isScene ? e.removeComponent(SceneTagComponent) : t.isCamera && e.removeComponent(CameraTagComponent);
  }
};
class ECSYThreeWorld extends World {
  constructor(t) {
    super(Object.assign({}, { entityClass: ECSYThreeEntity }, t)), this.object3DInflator = defaultObject3DInflator;
  }
}
const Vector3Type = createType({
  name: "Vector3",
  default: new Vector3(),
  copy: copyCopyable,
  clone: cloneClonable
}), ThreeTypes = {
  Vector3Type
};
class Active extends TagComponent {
}
class Animation extends Component$1 {
}
Animation.schema = {
  animations: { default: [], type: Types.Array },
  duration: { default: -1, type: Types.Number }
};
class Camera extends Component$1 {
}
Camera.schema = {
  fov: { default: 45, type: Types.Number },
  aspect: { default: 1, type: Types.Number },
  near: { default: 0.1, type: Types.Number },
  far: { default: 1e3, type: Types.Number },
  layers: { default: 0, type: Types.Number },
  handleResize: { default: !0, type: Types.Boolean }
};
class CameraRig extends Component$1 {
}
CameraRig.schema = {
  leftHand: { default: null, type: Types.Ref },
  rightHand: { default: null, type: Types.Ref },
  camera: { default: null, type: Types.Ref }
};
class Colliding extends Component$1 {
}
Colliding.schema = {
  collidingWith: { default: [], type: Types.Array },
  collidingFrame: { default: 0, type: Types.Number }
};
class CollisionStart extends TagComponent {
}
class CollisionStop extends TagComponent {
}
class Draggable extends Component$1 {
}
Draggable.schema = {
  value: { default: !1, type: Types.Boolean }
};
class Dragging extends TagComponent {
}
class Geometry extends Component$1 {
}
Geometry.schema = {
  primitive: { default: "box", type: Types.String },
  width: { default: 0, type: Types.Number },
  height: { default: 0, type: Types.Number },
  depth: { default: 0, type: Types.Number }
};
let GLTFLoader$1 = class extends Component$1 {
};
GLTFLoader$1.schema = {
  url: { default: "", type: Types.String },
  receiveShadow: { default: !1, type: Types.Boolean },
  castShadow: { default: !1, type: Types.Boolean },
  envMapOverride: { default: null, type: Types.Ref },
  append: { default: !0, type: Types.Boolean },
  onLoaded: { default: null, type: Types.Ref },
  parent: { default: null, type: Types.Ref }
};
class GLTFModel extends Component$1 {
}
GLTFModel.schema = {
  value: { default: null, type: Types.Ref }
};
class InputState extends Component$1 {
}
InputState.schema = {
  vrcontrollers: { default: /* @__PURE__ */ new Map(), type: Types.Ref },
  keyboard: { default: {}, type: Types.Ref },
  mouse: { default: {}, type: Types.Ref },
  gamepads: { default: {}, type: Types.Ref }
};
class Parent extends Component$1 {
}
Parent.schema = {
  value: { default: null, type: Types.Ref }
};
class ParentObject3D extends Component$1 {
}
ParentObject3D.schema = {
  value: { default: null, type: Types.Ref }
};
class Play extends TagComponent {
}
class Position extends Component$1 {
}
Position.schema = {
  value: { default: new Vector3(), type: Vector3Type }
};
class RenderPass extends Component$1 {
}
RenderPass.schema = {
  scene: { default: null, type: Types.Ref },
  camera: { default: null, type: Types.Ref }
};
class RigidBody extends Component$1 {
}
RigidBody.schema = {
  object: { default: null, type: Types.Ref },
  weight: { default: 0, type: Types.Number },
  restitution: { default: 1, type: Types.Number },
  friction: { default: 1, type: Types.Number },
  linearDamping: { default: 0, type: Types.Number },
  angularDamping: { default: 0, type: Types.Number },
  linearVelocity: { default: { x: 0, y: 0, z: 0 }, type: Types.Ref }
};
class Rotation extends Component$1 {
}
Rotation.schema = {
  // @fixme
  rotation: { default: new Vector3(), type: Vector3Type }
};
class Scale extends Component$1 {
}
Scale.schema = {
  // @fixme
  value: { default: new Vector3(), type: Vector3Type }
};
class Scene extends Component$1 {
}
Scene.schema = {
  value: { default: null, type: Types.Ref }
};
class Shape extends Component$1 {
}
Shape.schema = {
  primitive: { default: "", type: Types.String },
  width: { default: 0, type: Types.Number },
  height: { default: 0, type: Types.Number },
  depth: { default: 0, type: Types.Number },
  radius: { default: 0, type: Types.Number }
};
class SkyBox extends Component$1 {
}
SkyBox.schema = {
  textureUrl: { default: null, type: Types.String },
  type: { default: 0, type: Types.Number }
};
class Sound extends Component$1 {
}
Sound.schema = {
  sound: { default: null, type: Types.Ref },
  url: { default: "", type: Types.String }
};
class Stop extends TagComponent {
}
class Text extends Component$1 {
}
Text.schema = {
  text: { default: "", type: Types.String },
  textAlign: { default: "left", type: Types.String },
  // ['left', 'right', 'center']
  anchor: { default: "center", type: Types.String },
  // ['left', 'right', 'center', 'align']
  baseline: { default: "center", type: Types.String },
  // ['top', 'center', 'bottom']
  color: { default: "#FFF", type: Types.String },
  font: { default: "", type: Types.String },
  //"https://code.cdn.mozilla.net/fonts/ttf/ZillaSlab-SemiBold.ttf"
  fontSize: { default: 0.2, type: Types.Number },
  letterSpacing: { default: 0, type: Types.Number },
  lineHeight: { default: 0, type: Types.Number },
  maxWidth: { default: 1 / 0, type: Types.Number },
  overflowWrap: { default: "normal", type: Types.String },
  // ['normal', 'break-word']
  whiteSpace: { default: "normal", type: Types.String },
  // ['normal', 'nowrap']
  opacity: { default: 1, type: Types.Number }
};
class Transform extends Component$1 {
}
Transform.schema = {
  position: { default: new Vector3(), type: Vector3Type },
  rotation: { default: new Vector3(), type: Vector3Type }
};
class Visible extends Component$1 {
}
Visible.schema = {
  value: { default: !0, type: Types.Boolean }
};
class VRController extends Component$1 {
}
VRController.schema = {
  id: { default: 0, type: Types.Number },
  controller: { default: null, type: Types.Ref }
};
class VRControllerBasicBehaviour extends Component$1 {
}
VRControllerBasicBehaviour.schema = {
  select: { default: null, type: Types.Ref },
  selectstart: { default: null, type: Types.Ref },
  selectend: { default: null, type: Types.Ref },
  connected: { default: null, type: Types.Ref },
  disconnected: { default: null, type: Types.Ref },
  squeeze: { default: null, type: Types.Ref },
  squeezestart: { default: null, type: Types.Ref },
  squeezeend: { default: null, type: Types.Ref }
};
class WebGLRenderer extends Component$1 {
}
WebGLRenderer.schema = {
  vr: { default: !1, type: Types.Boolean },
  ar: { default: !1, type: Types.Boolean },
  antialias: { default: !0, type: Types.Boolean },
  handleResize: { default: !0, type: Types.Boolean },
  shadowMap: { default: !0, type: Types.Boolean },
  animationLoop: { default: null, type: Types.Ref }
};
class ControllerConnected extends TagComponent {
}
class OnObject3DAdded extends Component$1 {
}
OnObject3DAdded.schema = {
  callback: { default: null, type: Types.Ref }
};
class UpdateAspectOnResizeTag extends TagComponent {
}
var VRButton = {
  createButton: function(e, t) {
    t && console.error('THREE.VRButton: The "options" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.');
    function r() {
      var c = null;
      function u(f) {
        f.addEventListener("end", h), e.xr.setSession(f), s.textContent = "EXIT VR", c = f;
      }
      function h() {
        c.removeEventListener("end", h), s.textContent = "ENTER VR", c = null;
      }
      s.style.display = "", s.style.cursor = "pointer", s.style.left = "calc(50% - 50px)", s.style.width = "100px", s.textContent = "ENTER VR", s.onmouseenter = function() {
        s.style.opacity = "1.0";
      }, s.onmouseleave = function() {
        s.style.opacity = "0.5";
      }, s.onclick = function() {
        if (c === null) {
          var f = { optionalFeatures: ["local-floor", "bounded-floor"] };
          navigator.xr.requestSession("immersive-vr", f).then(u);
        } else
          c.end();
      };
    }
    function n() {
      s.style.display = "", s.style.cursor = "auto", s.style.left = "calc(50% - 75px)", s.style.width = "150px", s.onmouseenter = null, s.onmouseleave = null, s.onclick = null;
    }
    function a() {
      n(), s.textContent = "VR NOT SUPPORTED";
    }
    function o(c) {
      c.style.position = "absolute", c.style.bottom = "20px", c.style.padding = "12px 6px", c.style.border = "1px solid #fff", c.style.borderRadius = "4px", c.style.background = "rgba(0,0,0,0.1)", c.style.color = "#fff", c.style.font = "normal 13px sans-serif", c.style.textAlign = "center", c.style.opacity = "0.5", c.style.outline = "none", c.style.zIndex = "999";
    }
    if ("xr" in navigator) {
      var s = document.createElement("button");
      return s.style.display = "none", o(s), navigator.xr.isSessionSupported("immersive-vr").then(function(c) {
        c ? r() : a();
      }), s;
    } else {
      var l = document.createElement("a");
      return window.isSecureContext === !1 ? (l.href = document.location.href.replace(/^http:/, "https:"), l.innerHTML = "WEBXR NEEDS HTTPS") : (l.href = "https://immersiveweb.dev/", l.innerHTML = "WEBXR NOT AVAILABLE"), l.style.left = "calc(50% - 90px)", l.style.width = "180px", l.style.textDecoration = "none", o(l), l;
    }
  }
}, ARButton = {
  createButton: function(e, t = {}) {
    function r() {
      var c = null;
      function u(f) {
        f.addEventListener("end", h), e.xr.setReferenceSpaceType("local"), e.xr.setSession(f), s.textContent = "STOP AR", c = f;
      }
      function h() {
        c.removeEventListener("end", h), s.textContent = "START AR", c = null;
      }
      s.style.display = "", s.style.cursor = "pointer", s.style.left = "calc(50% - 50px)", s.style.width = "100px", s.textContent = "START AR", s.onmouseenter = function() {
        s.style.opacity = "1.0";
      }, s.onmouseleave = function() {
        s.style.opacity = "0.5";
      }, s.onclick = function() {
        c === null ? navigator.xr.requestSession("immersive-ar", t).then(u) : c.end();
      };
    }
    function n() {
      s.style.display = "", s.style.cursor = "auto", s.style.left = "calc(50% - 75px)", s.style.width = "150px", s.onmouseenter = null, s.onmouseleave = null, s.onclick = null;
    }
    function a() {
      n(), s.textContent = "AR NOT SUPPORTED";
    }
    function o(c) {
      c.style.position = "absolute", c.style.bottom = "20px", c.style.padding = "12px 6px", c.style.border = "1px solid #fff", c.style.borderRadius = "4px", c.style.background = "rgba(0,0,0,0.1)", c.style.color = "#fff", c.style.font = "normal 13px sans-serif", c.style.textAlign = "center", c.style.opacity = "0.5", c.style.outline = "none", c.style.zIndex = "999";
    }
    if ("xr" in navigator) {
      var s = document.createElement("button");
      return s.style.display = "none", o(s), navigator.xr.isSessionSupported("immersive-ar").then(function(c) {
        c ? r() : a();
      }).catch(a), s;
    } else {
      var l = document.createElement("a");
      return window.isSecureContext === !1 ? (l.href = document.location.href.replace(/^http:/, "https:"), l.innerHTML = "WEBXR NEEDS HTTPS") : (l.href = "https://immersiveweb.dev/", l.innerHTML = "WEBXR NOT AVAILABLE"), l.style.left = "calc(50% - 90px)", l.style.width = "180px", l.style.textDecoration = "none", o(l), l;
    }
  }
};
class WebGLRendererContext extends Component$1 {
}
WebGLRendererContext.schema = {
  value: { default: null, type: Types.Ref }
};
class WebGLRendererSystem extends System {
  init() {
    this.world.registerComponent(WebGLRendererContext), window.addEventListener(
      "resize",
      () => {
        this.queries.renderers.results.forEach((t) => {
          var r = t.getMutableComponent(WebGLRenderer);
          r.width = window.innerWidth, r.height = window.innerHeight;
        });
      },
      !1
    );
  }
  execute() {
    this.queries.renderers.results.forEach((r) => {
      var n = r.getComponent(WebGLRendererContext).value;
      this.queries.renderPasses.results.forEach((a) => {
        var o = a.getComponent(RenderPass), s = o.scene.getObject3D();
        this.queries.activeCameras.results.forEach((l) => {
          var c = l.getObject3D();
          n.render(s, c);
        });
      });
    }), this.queries.uninitializedRenderers.results.forEach((r) => {
      var n = r.getComponent(WebGLRenderer), a = new WebGLRenderer$1({
        antialias: n.antialias
      });
      n.animationLoop && a.setAnimationLoop(n.animationLoop), a.setPixelRatio(window.devicePixelRatio), n.handleResize && a.setSize(window.innerWidth, window.innerHeight), a.shadowMap.enabled = n.shadowMap, document.body.appendChild(a.domElement), (n.vr || n.ar) && (a.xr.enabled = !0, n.vr && document.body.appendChild(VRButton.createButton(a)), n.ar && document.body.appendChild(ARButton.createButton(a))), r.addComponent(WebGLRendererContext, { value: a });
    }), this.queries.renderers.changed.forEach((r) => {
      var n = r.getComponent(WebGLRenderer), a = r.getComponent(WebGLRendererContext).value;
      (n.width !== a.width || n.height !== a.height) && a.setSize(n.width, n.height);
    });
  }
}
WebGLRendererSystem.queries = {
  uninitializedRenderers: {
    components: [WebGLRenderer, Not(WebGLRendererContext)]
  },
  renderers: {
    components: [WebGLRenderer, WebGLRendererContext],
    listen: {
      changed: [WebGLRenderer]
    }
  },
  renderPasses: {
    components: [RenderPass]
  },
  activeCameras: {
    components: [CameraTagComponent, Active],
    listen: {
      added: !0
    }
  }
};
class TransformSystem extends System {
  execute() {
    let t = this.queries.parent.added;
    for (var r = 0; r < t.length; r++) {
      var n = t[r];
      if (!n.alive)
        return;
      var a = n.getComponent(Parent).value;
      if (a.hasComponent(Object3DComponent)) {
        var o = a.getObject3D(), s = n.getObject3D();
        o.add(s);
      }
    }
    this.queries.parentObject3D.added.forEach((h) => {
      var f = h.getComponent(ParentObject3D).value, d = h.getObject3D();
      f.add(d);
    });
    var l = this.queries.transforms;
    for (let h = 0; h < l.added.length; h++) {
      let f = l.added[h], d = f.getComponent(Transform), p = f.getObject3D();
      p.position.copy(d.position), p.rotation.set(
        d.rotation.x,
        d.rotation.y,
        d.rotation.z
      );
    }
    for (let h = 0; h < l.changed.length; h++) {
      let f = l.changed[h];
      if (!f.alive)
        continue;
      let d = f.getComponent(Transform), p = f.getObject3D();
      p.position.copy(d.position), p.rotation.set(
        d.rotation.x,
        d.rotation.y,
        d.rotation.z
      );
    }
    let c = this.queries.positions;
    for (let h = 0; h < c.added.length; h++) {
      let f = c.added[h], d = f.getComponent(Position).value, p = f.getObject3D();
      p.position.copy(d), f.getComponent(Position).value = p.position;
    }
    let u = this.queries.scales;
    for (let h = 0; h < u.added.length; h++) {
      let f = u.added[h], d = f.getComponent(Scale).value;
      f.getObject3D().scale.copy(d);
    }
    for (let h = 0; h < u.changed.length; h++) {
      let f = u.changed[h], d = f.getComponent(Scale).value;
      f.getObject3D().scale.copy(d);
    }
  }
}
TransformSystem.queries = {
  parentObject3D: {
    components: [ParentObject3D, Object3DComponent],
    listen: {
      added: !0
    }
  },
  parent: {
    components: [Parent, Object3DComponent],
    listen: {
      added: !0
    }
  },
  transforms: {
    components: [Object3DComponent, Transform],
    listen: {
      added: !0,
      changed: [Transform]
    }
  },
  positions: {
    components: [Object3DComponent, Position],
    listen: {
      added: !0,
      changed: [Position]
    }
  },
  scales: {
    components: [Object3DComponent, Scale],
    listen: {
      added: !0,
      changed: [Scale]
    }
  }
};
class UpdateAspectOnResizeSystem extends System {
  init() {
    this.aspect = window.innerWidth / window.innerHeight, window.addEventListener(
      "resize",
      () => {
        this.aspect = window.innerWidth / window.innerHeight, console.log("resize", this.aspect);
      },
      !1
    );
  }
  execute() {
    let t = this.queries.cameras.results;
    for (let r = 0; r < t.length; r++) {
      let n = t[r].getObject3D();
      n.aspect !== this.aspect && (n.aspect = this.aspect, n.updateProjectionMatrix());
    }
  }
}
UpdateAspectOnResizeSystem.queries = {
  cameras: {
    components: [CameraTagComponent, UpdateAspectOnResizeTag, Object3DComponent]
  }
};
class OnObject3DAddedSystem extends System {
  execute() {
    const t = this.queries.entities.added;
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      n.getComponent(OnObject3DAdded).callback(n.getObject3D());
    }
  }
}
OnObject3DAddedSystem.queries = {
  entities: {
    components: [OnObject3DAdded, Object3DComponent],
    listen: {
      added: !0
    }
  }
};
function initialize(e = new ECSYThreeWorld(), t) {
  if (!(e instanceof ECSYThreeWorld))
    throw new Error(
      "The provided 'world' paremeter is not an instance of 'ECSYThreeWorld'"
    );
  if (e.registerSystem(UpdateAspectOnResizeSystem).registerSystem(TransformSystem).registerSystem(OnObject3DAddedSystem).registerSystem(WebGLRendererSystem), e.registerComponent(OnObject3DAdded).registerComponent(WebGLRenderer).registerComponent(Scene).registerComponent(Active).registerComponent(CameraRig).registerComponent(Parent).registerComponent(Object3DComponent).registerComponent(RenderPass).registerComponent(Camera).registerComponent(SceneTagComponent).registerComponent(CameraTagComponent).registerComponent(MeshTagComponent).registerComponent(UpdateAspectOnResizeTag), t = Object.assign({}, {
    vr: !1,
    defaults: !0
  }, t), !t.defaults)
    return { world: e };
  let n = t.animationLoop;
  if (!n) {
    const u = new Clock();
    n = () => {
      e.execute(u.getDelta(), u.elapsedTime);
    };
  }
  let a = e.createEntity().addComponent(Scene).addObject3DComponent(new Scene$1()), o = e.createEntity().addComponent(WebGLRenderer, {
    ar: t.ar,
    vr: t.vr,
    animationLoop: n
  });
  var s = null, l = null;
  t.ar || t.vr ? l = e.createEntity().addComponent(CameraRig).addComponent(Parent, { value: a }).addComponent(Active) : s = e.createEntity().addComponent(Camera).addComponent(UpdateAspectOnResizeTag).addObject3DComponent(
    new PerspectiveCamera(
      90,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    ),
    a
  ).addComponent(Active);
  let c = e.createEntity().addComponent(RenderPass, {
    scene: a,
    camera: s
  });
  return {
    world: e,
    entities: {
      scene: a,
      camera: s,
      cameraRig: l,
      renderer: o,
      renderPass: c
    }
  };
}
class GeometrySystem extends System {
  execute() {
    this.queries.entities.removed.forEach((t) => {
      var r = t.getRemovedComponent(Object3DComponent).value, n = t.getComponent(Parent, !0).value;
      n.getObject3D().remove(r);
    }), this.queries.entities.added.forEach((t) => {
      var r = t.getComponent(Geometry), n;
      switch (r.primitive) {
        case "torus":
          n = new TorusBufferGeometry(
            r.radius,
            r.tube,
            r.radialSegments,
            r.tubularSegments
          );
          break;
        case "sphere":
          n = new IcosahedronBufferGeometry(r.radius, 1);
          break;
        case "box":
          n = new BoxBufferGeometry(
            r.width,
            r.height,
            r.depth
          );
          break;
      }
      var a = r.primitive === "torus" ? 10066176 : Math.random() * 16777215, o = new MeshLambertMaterial({
        color: a,
        flatShading: !0
      }), s = new Mesh(n, o);
      if (s.castShadow = !0, s.receiveShadow = !0, t.hasComponent(Transform)) {
        var l = t.getComponent(Transform);
        s.position.copy(l.position), l.rotation && s.rotation.set(
          l.rotation.x,
          l.rotation.y,
          l.rotation.z
        );
      }
      t.addComponent(Object3DComponent, { value: s });
    });
  }
}
GeometrySystem.queries = {
  entities: {
    components: [Geometry],
    // @todo Transform: As optional, how to define it?
    listen: {
      added: !0,
      removed: !0
    }
  }
};
var GLTFLoader = function() {
  function e(A) {
    Loader.call(this, A), this.dracoLoader = null, this.ddsLoader = null;
  }
  e.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: e,
    load: function(A, L, D, S) {
      var H = this, z;
      this.resourcePath !== "" ? z = this.resourcePath : this.path !== "" ? z = this.path : z = LoaderUtils.extractUrlBase(A), H.manager.itemStart(A);
      var N = function(U) {
        S ? S(U) : console.error(U), H.manager.itemError(A), H.manager.itemEnd(A);
      }, F = new FileLoader(H.manager);
      F.setPath(this.path), F.setResponseType("arraybuffer"), F.setRequestHeader(this.requestHeader), H.crossOrigin === "use-credentials" && F.setWithCredentials(!0), F.load(A, function(U) {
        try {
          H.parse(U, z, function(j) {
            L(j), H.manager.itemEnd(A);
          }, N);
        } catch (j) {
          N(j);
        }
      }, D, N);
    },
    setDRACOLoader: function(A) {
      return this.dracoLoader = A, this;
    },
    setDDSLoader: function(A) {
      return this.ddsLoader = A, this;
    },
    parse: function(A, L, D, S) {
      var H, z = {};
      if (typeof A == "string")
        H = A;
      else {
        var N = LoaderUtils.decodeText(new Uint8Array(A, 0, 4));
        if (N === l) {
          try {
            z[r.KHR_BINARY_GLTF] = new h(A);
          } catch (re) {
            S && S(re);
            return;
          }
          H = z[r.KHR_BINARY_GLTF].content;
        } else
          H = LoaderUtils.decodeText(new Uint8Array(A));
      }
      var F = JSON.parse(H);
      if (F.asset === void 0 || F.asset.version[0] < 2) {
        S && S(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
        return;
      }
      if (F.extensionsUsed)
        for (var U = 0; U < F.extensionsUsed.length; ++U) {
          var j = F.extensionsUsed[U], K = F.extensionsRequired || [];
          switch (j) {
            case r.KHR_LIGHTS_PUNCTUAL:
              z[j] = new a(F);
              break;
            case r.KHR_MATERIALS_CLEARCOAT:
              z[j] = new s();
              break;
            case r.KHR_MATERIALS_UNLIT:
              z[j] = new o();
              break;
            case r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
              z[j] = new g();
              break;
            case r.KHR_DRACO_MESH_COMPRESSION:
              z[j] = new f(F, this.dracoLoader);
              break;
            case r.MSFT_TEXTURE_DDS:
              z[j] = new n(this.ddsLoader);
              break;
            case r.KHR_TEXTURE_TRANSFORM:
              z[j] = new d();
              break;
            case r.KHR_MESH_QUANTIZATION:
              z[j] = new v();
              break;
            default:
              K.indexOf(j) >= 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + j + '".');
          }
        }
      var Y = new Q(F, z, {
        path: L || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        manager: this.manager
      });
      Y.fileLoader.setRequestHeader(this.requestHeader), Y.parse(D, S);
    }
  });
  function t() {
    var A = {};
    return {
      get: function(L) {
        return A[L];
      },
      add: function(L, D) {
        A[L] = D;
      },
      remove: function(L) {
        delete A[L];
      },
      removeAll: function() {
        A = {};
      }
    };
  }
  var r = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    MSFT_TEXTURE_DDS: "MSFT_texture_dds"
  };
  function n(A) {
    if (!A)
      throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader");
    this.name = r.MSFT_TEXTURE_DDS, this.ddsLoader = A;
  }
  function a(A) {
    this.name = r.KHR_LIGHTS_PUNCTUAL;
    var L = A.extensions && A.extensions[r.KHR_LIGHTS_PUNCTUAL] || {};
    this.lightDefs = L.lights || [];
  }
  a.prototype.loadLight = function(A) {
    var L = this.lightDefs[A], D, S = new Color(16777215);
    L.color !== void 0 && S.fromArray(L.color);
    var H = L.range !== void 0 ? L.range : 0;
    switch (L.type) {
      case "directional":
        D = new DirectionalLight(S), D.target.position.set(0, 0, -1), D.add(D.target);
        break;
      case "point":
        D = new PointLight(S), D.distance = H;
        break;
      case "spot":
        D = new SpotLight(S), D.distance = H, L.spot = L.spot || {}, L.spot.innerConeAngle = L.spot.innerConeAngle !== void 0 ? L.spot.innerConeAngle : 0, L.spot.outerConeAngle = L.spot.outerConeAngle !== void 0 ? L.spot.outerConeAngle : Math.PI / 4, D.angle = L.spot.outerConeAngle, D.penumbra = 1 - L.spot.innerConeAngle / L.spot.outerConeAngle, D.target.position.set(0, 0, -1), D.add(D.target);
        break;
      default:
        throw new Error('THREE.GLTFLoader: Unexpected light type, "' + L.type + '".');
    }
    return D.position.set(0, 0, 0), D.decay = 2, L.intensity !== void 0 && (D.intensity = L.intensity), D.name = L.name || "light_" + A, Promise.resolve(D);
  };
  function o() {
    this.name = r.KHR_MATERIALS_UNLIT;
  }
  o.prototype.getMaterialType = function() {
    return MeshBasicMaterial;
  }, o.prototype.extendParams = function(A, L, D) {
    var S = [];
    A.color = new Color(1, 1, 1), A.opacity = 1;
    var H = L.pbrMetallicRoughness;
    if (H) {
      if (Array.isArray(H.baseColorFactor)) {
        var z = H.baseColorFactor;
        A.color.fromArray(z), A.opacity = z[3];
      }
      H.baseColorTexture !== void 0 && S.push(D.assignTexture(A, "map", H.baseColorTexture));
    }
    return Promise.all(S);
  };
  function s() {
    this.name = r.KHR_MATERIALS_CLEARCOAT;
  }
  s.prototype.getMaterialType = function() {
    return MeshPhysicalMaterial;
  }, s.prototype.extendParams = function(A, L, D) {
    var S = [], H = L.extensions[this.name];
    if (H.clearcoatFactor !== void 0 && (A.clearcoat = H.clearcoatFactor), H.clearcoatTexture !== void 0 && S.push(D.assignTexture(A, "clearcoatMap", H.clearcoatTexture)), H.clearcoatRoughnessFactor !== void 0 && (A.clearcoatRoughness = H.clearcoatRoughnessFactor), H.clearcoatRoughnessTexture !== void 0 && S.push(D.assignTexture(A, "clearcoatRoughnessMap", H.clearcoatRoughnessTexture)), H.clearcoatNormalTexture !== void 0 && (S.push(D.assignTexture(A, "clearcoatNormalMap", H.clearcoatNormalTexture)), H.clearcoatNormalTexture.scale !== void 0)) {
      var z = H.clearcoatNormalTexture.scale;
      A.clearcoatNormalScale = new Vector2(z, z);
    }
    return Promise.all(S);
  };
  var l = "glTF", c = 12, u = { JSON: 1313821514, BIN: 5130562 };
  function h(A) {
    this.name = r.KHR_BINARY_GLTF, this.content = null, this.body = null;
    var L = new DataView(A, 0, c);
    if (this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(A.slice(0, 4))),
      version: L.getUint32(4, !0),
      length: L.getUint32(8, !0)
    }, this.header.magic !== l)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    for (var D = new DataView(A, c), S = 0; S < D.byteLength; ) {
      var H = D.getUint32(S, !0);
      S += 4;
      var z = D.getUint32(S, !0);
      if (S += 4, z === u.JSON) {
        var N = new Uint8Array(A, c + S, H);
        this.content = LoaderUtils.decodeText(N);
      } else if (z === u.BIN) {
        var F = c + S;
        this.body = A.slice(F, F + H);
      }
      S += H;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
  function f(A, L) {
    if (!L)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = r.KHR_DRACO_MESH_COMPRESSION, this.json = A, this.dracoLoader = L, this.dracoLoader.preload();
  }
  f.prototype.decodePrimitive = function(A, L) {
    var D = this.json, S = this.dracoLoader, H = A.extensions[this.name].bufferView, z = A.extensions[this.name].attributes, N = {}, F = {}, U = {};
    for (var j in z) {
      var K = w[j] || j.toLowerCase();
      N[K] = z[j];
    }
    for (j in A.attributes) {
      var K = w[j] || j.toLowerCase();
      if (z[j] !== void 0) {
        var Y = D.accessors[A.attributes[j]], re = y[Y.componentType];
        U[K] = re, F[K] = Y.normalized === !0;
      }
    }
    return L.getDependency("bufferView", H).then(function(le) {
      return new Promise(function(T) {
        S.decodeDracoFile(le, function(C) {
          for (var ie in C.attributes) {
            var Z = C.attributes[ie], ce = F[ie];
            ce !== void 0 && (Z.normalized = ce);
          }
          T(C);
        }, N, U);
      });
    });
  };
  function d() {
    this.name = r.KHR_TEXTURE_TRANSFORM;
  }
  d.prototype.extendTexture = function(A, L) {
    return A = A.clone(), L.offset !== void 0 && A.offset.fromArray(L.offset), L.rotation !== void 0 && (A.rotation = L.rotation), L.scale !== void 0 && A.repeat.fromArray(L.scale), L.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), A.needsUpdate = !0, A;
  };
  function p(A) {
    MeshStandardMaterial.call(this), this.isGLTFSpecularGlossinessMaterial = !0;
    var L = [
      "#ifdef USE_SPECULARMAP",
      "	uniform sampler2D specularMap;",
      "#endif"
    ].join(`
`), D = [
      "#ifdef USE_GLOSSINESSMAP",
      "	uniform sampler2D glossinessMap;",
      "#endif"
    ].join(`
`), S = [
      "vec3 specularFactor = specular;",
      "#ifdef USE_SPECULARMAP",
      "	vec4 texelSpecular = texture2D( specularMap, vUv );",
      "	texelSpecular = sRGBToLinear( texelSpecular );",
      "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	specularFactor *= texelSpecular.rgb;",
      "#endif"
    ].join(`
`), H = [
      "float glossinessFactor = glossiness;",
      "#ifdef USE_GLOSSINESSMAP",
      "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
      "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	glossinessFactor *= texelGlossiness.a;",
      "#endif"
    ].join(`
`), z = [
      "PhysicalMaterial material;",
      "material.diffuseColor = diffuseColor.rgb;",
      "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
      "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
      "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.",
      "material.specularRoughness += geometryRoughness;",
      "material.specularRoughness = min( material.specularRoughness, 1.0 );",
      "material.specularColor = specularFactor.rgb;"
    ].join(`
`), N = {
      specular: { value: new Color().setHex(16777215) },
      glossiness: { value: 1 },
      specularMap: { value: null },
      glossinessMap: { value: null }
    };
    this._extraUniforms = N, this.onBeforeCompile = function(F) {
      for (var U in N)
        F.uniforms[U] = N[U];
      F.fragmentShader = F.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;"), F.fragmentShader = F.fragmentShader.replace("uniform float metalness;", "uniform float glossiness;"), F.fragmentShader = F.fragmentShader.replace("#include <roughnessmap_pars_fragment>", L), F.fragmentShader = F.fragmentShader.replace("#include <metalnessmap_pars_fragment>", D), F.fragmentShader = F.fragmentShader.replace("#include <roughnessmap_fragment>", S), F.fragmentShader = F.fragmentShader.replace("#include <metalnessmap_fragment>", H), F.fragmentShader = F.fragmentShader.replace("#include <lights_physical_fragment>", z);
    }, Object.defineProperties(
      this,
      {
        specular: {
          get: function() {
            return N.specular.value;
          },
          set: function(F) {
            N.specular.value = F;
          }
        },
        specularMap: {
          get: function() {
            return N.specularMap.value;
          },
          set: function(F) {
            N.specularMap.value = F;
          }
        },
        glossiness: {
          get: function() {
            return N.glossiness.value;
          },
          set: function(F) {
            N.glossiness.value = F;
          }
        },
        glossinessMap: {
          get: function() {
            return N.glossinessMap.value;
          },
          set: function(F) {
            N.glossinessMap.value = F, F ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_ROUGHNESSMAP = "") : (delete this.defines.USE_ROUGHNESSMAP, delete this.defines.USE_GLOSSINESSMAP);
          }
        }
      }
    ), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(A);
  }
  p.prototype = Object.create(MeshStandardMaterial.prototype), p.prototype.constructor = p, p.prototype.copy = function(A) {
    return MeshStandardMaterial.prototype.copy.call(this, A), this.specularMap = A.specularMap, this.specular.copy(A.specular), this.glossinessMap = A.glossinessMap, this.glossiness = A.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
  };
  function g() {
    return {
      name: r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
      specularGlossinessParams: [
        "color",
        "map",
        "lightMap",
        "lightMapIntensity",
        "aoMap",
        "aoMapIntensity",
        "emissive",
        "emissiveIntensity",
        "emissiveMap",
        "bumpMap",
        "bumpScale",
        "normalMap",
        "normalMapType",
        "displacementMap",
        "displacementScale",
        "displacementBias",
        "specularMap",
        "specular",
        "glossinessMap",
        "glossiness",
        "alphaMap",
        "envMap",
        "envMapIntensity",
        "refractionRatio"
      ],
      getMaterialType: function() {
        return p;
      },
      extendParams: function(A, L, D) {
        var S = L.extensions[this.name];
        A.color = new Color(1, 1, 1), A.opacity = 1;
        var H = [];
        if (Array.isArray(S.diffuseFactor)) {
          var z = S.diffuseFactor;
          A.color.fromArray(z), A.opacity = z[3];
        }
        if (S.diffuseTexture !== void 0 && H.push(D.assignTexture(A, "map", S.diffuseTexture)), A.emissive = new Color(0, 0, 0), A.glossiness = S.glossinessFactor !== void 0 ? S.glossinessFactor : 1, A.specular = new Color(1, 1, 1), Array.isArray(S.specularFactor) && A.specular.fromArray(S.specularFactor), S.specularGlossinessTexture !== void 0) {
          var N = S.specularGlossinessTexture;
          H.push(D.assignTexture(A, "glossinessMap", N)), H.push(D.assignTexture(A, "specularMap", N));
        }
        return Promise.all(H);
      },
      createMaterial: function(A) {
        var L = new p(A);
        return L.fog = !0, L.color = A.color, L.map = A.map === void 0 ? null : A.map, L.lightMap = null, L.lightMapIntensity = 1, L.aoMap = A.aoMap === void 0 ? null : A.aoMap, L.aoMapIntensity = 1, L.emissive = A.emissive, L.emissiveIntensity = 1, L.emissiveMap = A.emissiveMap === void 0 ? null : A.emissiveMap, L.bumpMap = A.bumpMap === void 0 ? null : A.bumpMap, L.bumpScale = 1, L.normalMap = A.normalMap === void 0 ? null : A.normalMap, L.normalMapType = TangentSpaceNormalMap, A.normalScale && (L.normalScale = A.normalScale), L.displacementMap = null, L.displacementScale = 1, L.displacementBias = 0, L.specularMap = A.specularMap === void 0 ? null : A.specularMap, L.specular = A.specular, L.glossinessMap = A.glossinessMap === void 0 ? null : A.glossinessMap, L.glossiness = A.glossiness, L.alphaMap = null, L.envMap = A.envMap === void 0 ? null : A.envMap, L.envMapIntensity = 1, L.refractionRatio = 0.98, L;
      }
    };
  }
  function v() {
    this.name = r.KHR_MESH_QUANTIZATION;
  }
  function _(A, L, D, S) {
    Interpolant.call(this, A, L, D, S);
  }
  _.prototype = Object.create(Interpolant.prototype), _.prototype.constructor = _, _.prototype.copySampleValue_ = function(A) {
    for (var L = this.resultBuffer, D = this.sampleValues, S = this.valueSize, H = A * S * 3 + S, z = 0; z !== S; z++)
      L[z] = D[H + z];
    return L;
  }, _.prototype.beforeStart_ = _.prototype.copySampleValue_, _.prototype.afterEnd_ = _.prototype.copySampleValue_, _.prototype.interpolate_ = function(A, L, D, S) {
    for (var H = this.resultBuffer, z = this.sampleValues, N = this.valueSize, F = N * 2, U = N * 3, j = S - L, K = (D - L) / j, Y = K * K, re = Y * K, le = A * U, T = le - U, C = -2 * re + 3 * Y, ie = re - Y, Z = 1 - C, ce = ie - Y + K, se = 0; se !== N; se++) {
      var ue = z[T + se + N], Le = z[T + se + F] * j, Me = z[le + se + N], ye = z[le + se] * j;
      H[se] = Z * ue + ce * Le + C * Me + ie * ye;
    }
    return H;
  };
  var m = {
    FLOAT: 5126,
    //FLOAT_MAT2: 35674,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
  }, y = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  }, b = {
    9728: NearestFilter,
    9729: LinearFilter,
    9984: NearestMipmapNearestFilter,
    9985: LinearMipmapNearestFilter,
    9986: NearestMipmapLinearFilter,
    9987: LinearMipmapLinearFilter
  }, M = {
    33071: ClampToEdgeWrapping,
    33648: MirroredRepeatWrapping,
    10497: RepeatWrapping
  }, x = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  }, w = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
  }, P = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
  }, V = {
    CUBICSPLINE: void 0,
    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
    // keyframe track will be initialized with a default interpolation type, then modified.
    LINEAR: InterpolateLinear,
    STEP: InterpolateDiscrete
  }, I = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
  }, $ = {
    "image/png": RGBAFormat,
    "image/jpeg": RGBFormat
  };
  function E(A, L) {
    return typeof A != "string" || A === "" ? "" : (/^https?:\/\//i.test(L) && /^\//.test(A) && (L = L.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(A) || /^data:.*,.*$/i.test(A) || /^blob:.*$/i.test(A) ? A : L + A);
  }
  function G(A) {
    return A.DefaultMaterial === void 0 && (A.DefaultMaterial = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: !1,
      depthTest: !0,
      side: FrontSide
    })), A.DefaultMaterial;
  }
  function O(A, L, D) {
    for (var S in D.extensions)
      A[S] === void 0 && (L.userData.gltfExtensions = L.userData.gltfExtensions || {}, L.userData.gltfExtensions[S] = D.extensions[S]);
  }
  function W(A, L) {
    L.extras !== void 0 && (typeof L.extras == "object" ? Object.assign(A.userData, L.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + L.extras));
  }
  function B(A, L, D) {
    for (var S = !1, H = !1, z = 0, N = L.length; z < N; z++) {
      var F = L[z];
      if (F.POSITION !== void 0 && (S = !0), F.NORMAL !== void 0 && (H = !0), S && H) break;
    }
    if (!S && !H) return Promise.resolve(A);
    for (var U = [], j = [], z = 0, N = L.length; z < N; z++) {
      var F = L[z];
      if (S) {
        var K = F.POSITION !== void 0 ? D.getDependency("accessor", F.POSITION) : A.attributes.position;
        U.push(K);
      }
      if (H) {
        var K = F.NORMAL !== void 0 ? D.getDependency("accessor", F.NORMAL) : A.attributes.normal;
        j.push(K);
      }
    }
    return Promise.all([
      Promise.all(U),
      Promise.all(j)
    ]).then(function(Y) {
      var re = Y[0], le = Y[1];
      return S && (A.morphAttributes.position = re), H && (A.morphAttributes.normal = le), A.morphTargetsRelative = !0, A;
    });
  }
  function q(A, L) {
    if (A.updateMorphTargets(), L.weights !== void 0)
      for (var D = 0, S = L.weights.length; D < S; D++)
        A.morphTargetInfluences[D] = L.weights[D];
    if (L.extras && Array.isArray(L.extras.targetNames)) {
      var H = L.extras.targetNames;
      if (A.morphTargetInfluences.length === H.length) {
        A.morphTargetDictionary = {};
        for (var D = 0, S = H.length; D < S; D++)
          A.morphTargetDictionary[H[D]] = D;
      } else
        console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
  function te(A) {
    var L = A.extensions && A.extensions[r.KHR_DRACO_MESH_COMPRESSION], D;
    return L ? D = "draco:" + L.bufferView + ":" + L.indices + ":" + ne(L.attributes) : D = A.indices + ":" + ne(A.attributes) + ":" + A.mode, D;
  }
  function ne(A) {
    for (var L = "", D = Object.keys(A).sort(), S = 0, H = D.length; S < H; S++)
      L += D[S] + ":" + A[D[S]] + ";";
    return L;
  }
  function Q(A, L, D) {
    this.json = A || {}, this.extensions = L || {}, this.options = D || {}, this.cache = new t(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.textureLoader = new TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  Q.prototype.parse = function(A, L) {
    var D = this, S = this.json, H = this.extensions;
    this.cache.removeAll(), this.markDefs(), Promise.all([
      this.getDependencies("scene"),
      this.getDependencies("animation"),
      this.getDependencies("camera")
    ]).then(function(z) {
      var N = {
        scene: z[0][S.scene || 0],
        scenes: z[0],
        animations: z[1],
        cameras: z[2],
        asset: S.asset,
        parser: D,
        userData: {}
      };
      O(H, N, S), W(N, S), A(N);
    }).catch(L);
  }, Q.prototype.markDefs = function() {
    for (var A = this.json.nodes || [], L = this.json.skins || [], D = this.json.meshes || [], S = {}, H = {}, z = 0, N = L.length; z < N; z++)
      for (var F = L[z].joints, U = 0, j = F.length; U < j; U++)
        A[F[U]].isBone = !0;
    for (var K = 0, Y = A.length; K < Y; K++) {
      var re = A[K];
      re.mesh !== void 0 && (S[re.mesh] === void 0 && (S[re.mesh] = H[re.mesh] = 0), S[re.mesh]++, re.skin !== void 0 && (D[re.mesh].isSkinnedMesh = !0));
    }
    this.json.meshReferences = S, this.json.meshUses = H;
  }, Q.prototype.getDependency = function(A, L) {
    var D = A + ":" + L, S = this.cache.get(D);
    if (!S) {
      switch (A) {
        case "scene":
          S = this.loadScene(L);
          break;
        case "node":
          S = this.loadNode(L);
          break;
        case "mesh":
          S = this.loadMesh(L);
          break;
        case "accessor":
          S = this.loadAccessor(L);
          break;
        case "bufferView":
          S = this.loadBufferView(L);
          break;
        case "buffer":
          S = this.loadBuffer(L);
          break;
        case "material":
          S = this.loadMaterial(L);
          break;
        case "texture":
          S = this.loadTexture(L);
          break;
        case "skin":
          S = this.loadSkin(L);
          break;
        case "animation":
          S = this.loadAnimation(L);
          break;
        case "camera":
          S = this.loadCamera(L);
          break;
        case "light":
          S = this.extensions[r.KHR_LIGHTS_PUNCTUAL].loadLight(L);
          break;
        default:
          throw new Error("Unknown type: " + A);
      }
      this.cache.add(D, S);
    }
    return S;
  }, Q.prototype.getDependencies = function(A) {
    var L = this.cache.get(A);
    if (!L) {
      var D = this, S = this.json[A + (A === "mesh" ? "es" : "s")] || [];
      L = Promise.all(S.map(function(H, z) {
        return D.getDependency(A, z);
      })), this.cache.add(A, L);
    }
    return L;
  }, Q.prototype.loadBuffer = function(A) {
    var L = this.json.buffers[A], D = this.fileLoader;
    if (L.type && L.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + L.type + " buffer type is not supported.");
    if (L.uri === void 0 && A === 0)
      return Promise.resolve(this.extensions[r.KHR_BINARY_GLTF].body);
    var S = this.options;
    return new Promise(function(H, z) {
      D.load(E(L.uri, S.path), H, void 0, function() {
        z(new Error('THREE.GLTFLoader: Failed to load buffer "' + L.uri + '".'));
      });
    });
  }, Q.prototype.loadBufferView = function(A) {
    var L = this.json.bufferViews[A];
    return this.getDependency("buffer", L.buffer).then(function(D) {
      var S = L.byteLength || 0, H = L.byteOffset || 0;
      return D.slice(H, H + S);
    });
  }, Q.prototype.loadAccessor = function(A) {
    var L = this, D = this.json, S = this.json.accessors[A];
    if (S.bufferView === void 0 && S.sparse === void 0)
      return Promise.resolve(null);
    var H = [];
    return S.bufferView !== void 0 ? H.push(this.getDependency("bufferView", S.bufferView)) : H.push(null), S.sparse !== void 0 && (H.push(this.getDependency("bufferView", S.sparse.indices.bufferView)), H.push(this.getDependency("bufferView", S.sparse.values.bufferView))), Promise.all(H).then(function(z) {
      var N = z[0], F = x[S.type], U = y[S.componentType], j = U.BYTES_PER_ELEMENT, K = j * F, Y = S.byteOffset || 0, re = S.bufferView !== void 0 ? D.bufferViews[S.bufferView].byteStride : void 0, le = S.normalized === !0, T, C;
      if (re && re !== K) {
        var ie = Math.floor(Y / re), Z = "InterleavedBuffer:" + S.bufferView + ":" + S.componentType + ":" + ie + ":" + S.count, ce = L.cache.get(Z);
        ce || (T = new U(N, ie * re, S.count * re / j), ce = new InterleavedBuffer(T, re / j), L.cache.add(Z, ce)), C = new InterleavedBufferAttribute(ce, F, Y % re / j, le);
      } else
        N === null ? T = new U(S.count * F) : T = new U(N, Y, S.count * F), C = new BufferAttribute(T, F, le);
      if (S.sparse !== void 0) {
        var se = x.SCALAR, ue = y[S.sparse.indices.componentType], Le = S.sparse.indices.byteOffset || 0, Me = S.sparse.values.byteOffset || 0, ye = new ue(z[1], Le, S.sparse.count * se), he = new U(z[2], Me, S.sparse.count * F);
        N !== null && (C = new BufferAttribute(C.array.slice(), C.itemSize, C.normalized));
        for (var de = 0, ve = ye.length; de < ve; de++) {
          var xe = ye[de];
          if (C.setX(xe, he[de * F]), F >= 2 && C.setY(xe, he[de * F + 1]), F >= 3 && C.setZ(xe, he[de * F + 2]), F >= 4 && C.setW(xe, he[de * F + 3]), F >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return C;
    });
  }, Q.prototype.loadTexture = function(A) {
    var L = this, D = this.json, S = this.options, H = this.textureLoader, z = self.URL || self.webkitURL, N = D.textures[A], F = N.extensions || {}, U;
    F[r.MSFT_TEXTURE_DDS] ? U = D.images[F[r.MSFT_TEXTURE_DDS].source] : U = D.images[N.source];
    var j = U.uri, K = !1;
    return U.bufferView !== void 0 && (j = L.getDependency("bufferView", U.bufferView).then(function(Y) {
      K = !0;
      var re = new Blob([Y], { type: U.mimeType });
      return j = z.createObjectURL(re), j;
    })), Promise.resolve(j).then(function(Y) {
      var re = S.manager.getHandler(Y);
      return re || (re = F[r.MSFT_TEXTURE_DDS] ? L.extensions[r.MSFT_TEXTURE_DDS].ddsLoader : H), new Promise(function(le, T) {
        re.load(E(Y, S.path), le, void 0, T);
      });
    }).then(function(Y) {
      K === !0 && z.revokeObjectURL(j), Y.flipY = !1, N.name && (Y.name = N.name), U.mimeType in $ && (Y.format = $[U.mimeType]);
      var re = D.samplers || {}, le = re[N.sampler] || {};
      return Y.magFilter = b[le.magFilter] || LinearFilter, Y.minFilter = b[le.minFilter] || LinearMipmapLinearFilter, Y.wrapS = M[le.wrapS] || RepeatWrapping, Y.wrapT = M[le.wrapT] || RepeatWrapping, L.associations.set(Y, {
        type: "textures",
        index: A
      }), Y;
    });
  }, Q.prototype.assignTexture = function(A, L, D) {
    var S = this;
    return this.getDependency("texture", D.index).then(function(H) {
      if (!H.isCompressedTexture)
        switch (L) {
          case "aoMap":
          case "emissiveMap":
          case "metalnessMap":
          case "normalMap":
          case "roughnessMap":
            H.format = RGBFormat;
            break;
        }
      if (D.texCoord !== void 0 && D.texCoord != 0 && !(L === "aoMap" && D.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + D.texCoord + " for texture " + L + " not yet supported."), S.extensions[r.KHR_TEXTURE_TRANSFORM]) {
        var z = D.extensions !== void 0 ? D.extensions[r.KHR_TEXTURE_TRANSFORM] : void 0;
        if (z) {
          var N = S.associations.get(H);
          H = S.extensions[r.KHR_TEXTURE_TRANSFORM].extendTexture(H, z), S.associations.set(H, N);
        }
      }
      A[L] = H;
    });
  }, Q.prototype.assignFinalMaterial = function(A) {
    var L = A.geometry, D = A.material, S = L.attributes.tangent !== void 0, H = L.attributes.color !== void 0, z = L.attributes.normal === void 0, N = A.isSkinnedMesh === !0, F = Object.keys(L.morphAttributes).length > 0, U = F && L.morphAttributes.normal !== void 0;
    if (A.isPoints) {
      var j = "PointsMaterial:" + D.uuid, K = this.cache.get(j);
      K || (K = new PointsMaterial(), Material.prototype.copy.call(K, D), K.color.copy(D.color), K.map = D.map, K.sizeAttenuation = !1, this.cache.add(j, K)), D = K;
    } else if (A.isLine) {
      var j = "LineBasicMaterial:" + D.uuid, Y = this.cache.get(j);
      Y || (Y = new LineBasicMaterial(), Material.prototype.copy.call(Y, D), Y.color.copy(D.color), this.cache.add(j, Y)), D = Y;
    }
    if (S || H || z || N || F) {
      var j = "ClonedMaterial:" + D.uuid + ":";
      D.isGLTFSpecularGlossinessMaterial && (j += "specular-glossiness:"), N && (j += "skinning:"), S && (j += "vertex-tangents:"), H && (j += "vertex-colors:"), z && (j += "flat-shading:"), F && (j += "morph-targets:"), U && (j += "morph-normals:");
      var re = this.cache.get(j);
      re || (re = D.clone(), N && (re.skinning = !0), S && (re.vertexTangents = !0), H && (re.vertexColors = !0), z && (re.flatShading = !0), F && (re.morphTargets = !0), U && (re.morphNormals = !0), this.cache.add(j, re), this.associations.set(re, this.associations.get(D))), D = re;
    }
    D.aoMap && L.attributes.uv2 === void 0 && L.attributes.uv !== void 0 && L.setAttribute("uv2", L.attributes.uv), D.normalScale && !S && (D.normalScale.y = -D.normalScale.y), D.clearcoatNormalScale && !S && (D.clearcoatNormalScale.y = -D.clearcoatNormalScale.y), A.material = D;
  }, Q.prototype.loadMaterial = function(A) {
    var L = this, D = this.json, S = this.extensions, H = D.materials[A], z, N = {}, F = H.extensions || {}, U = [];
    if (F[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      var j = S[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      z = j.getMaterialType(), U.push(j.extendParams(N, H, L));
    } else if (F[r.KHR_MATERIALS_UNLIT]) {
      var K = S[r.KHR_MATERIALS_UNLIT];
      z = K.getMaterialType(), U.push(K.extendParams(N, H, L));
    } else {
      z = MeshStandardMaterial;
      var Y = H.pbrMetallicRoughness || {};
      if (N.color = new Color(1, 1, 1), N.opacity = 1, Array.isArray(Y.baseColorFactor)) {
        var re = Y.baseColorFactor;
        N.color.fromArray(re), N.opacity = re[3];
      }
      Y.baseColorTexture !== void 0 && U.push(L.assignTexture(N, "map", Y.baseColorTexture)), N.metalness = Y.metallicFactor !== void 0 ? Y.metallicFactor : 1, N.roughness = Y.roughnessFactor !== void 0 ? Y.roughnessFactor : 1, Y.metallicRoughnessTexture !== void 0 && (U.push(L.assignTexture(N, "metalnessMap", Y.metallicRoughnessTexture)), U.push(L.assignTexture(N, "roughnessMap", Y.metallicRoughnessTexture)));
    }
    H.doubleSided === !0 && (N.side = DoubleSide);
    var le = H.alphaMode || I.OPAQUE;
    if (le === I.BLEND ? (N.transparent = !0, N.depthWrite = !1) : (N.transparent = !1, le === I.MASK && (N.alphaTest = H.alphaCutoff !== void 0 ? H.alphaCutoff : 0.5)), H.normalTexture !== void 0 && z !== MeshBasicMaterial && (U.push(L.assignTexture(N, "normalMap", H.normalTexture)), N.normalScale = new Vector2(1, 1), H.normalTexture.scale !== void 0 && N.normalScale.set(H.normalTexture.scale, H.normalTexture.scale)), H.occlusionTexture !== void 0 && z !== MeshBasicMaterial && (U.push(L.assignTexture(N, "aoMap", H.occlusionTexture)), H.occlusionTexture.strength !== void 0 && (N.aoMapIntensity = H.occlusionTexture.strength)), H.emissiveFactor !== void 0 && z !== MeshBasicMaterial && (N.emissive = new Color().fromArray(H.emissiveFactor)), H.emissiveTexture !== void 0 && z !== MeshBasicMaterial && U.push(L.assignTexture(N, "emissiveMap", H.emissiveTexture)), F[r.KHR_MATERIALS_CLEARCOAT]) {
      var T = S[r.KHR_MATERIALS_CLEARCOAT];
      z = T.getMaterialType(), U.push(T.extendParams(N, { extensions: F }, L));
    }
    return Promise.all(U).then(function() {
      var C;
      return z === p ? C = S[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(N) : C = new z(N), H.name && (C.name = H.name), C.map && (C.map.encoding = sRGBEncoding), C.emissiveMap && (C.emissiveMap.encoding = sRGBEncoding), W(C, H), L.associations.set(C, { type: "materials", index: A }), H.extensions && O(S, C, H), C;
    });
  };
  function ae(A, L, D) {
    var S = L.attributes, H = new Box3();
    if (S.POSITION !== void 0) {
      var z = D.json.accessors[S.POSITION], N = z.min, F = z.max;
      if (N !== void 0 && F !== void 0)
        H.set(
          new Vector3(N[0], N[1], N[2]),
          new Vector3(F[0], F[1], F[2])
        );
      else {
        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        return;
      }
    } else
      return;
    var U = L.targets;
    if (U !== void 0) {
      for (var j = new Vector3(), K = new Vector3(), Y = 0, re = U.length; Y < re; Y++) {
        var le = U[Y];
        if (le.POSITION !== void 0) {
          var z = D.json.accessors[le.POSITION], N = z.min, F = z.max;
          N !== void 0 && F !== void 0 ? (K.setX(Math.max(Math.abs(N[0]), Math.abs(F[0]))), K.setY(Math.max(Math.abs(N[1]), Math.abs(F[1]))), K.setZ(Math.max(Math.abs(N[2]), Math.abs(F[2]))), j.max(K)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
      H.expandByVector(j);
    }
    A.boundingBox = H;
    var T = new Sphere();
    H.getCenter(T.center), T.radius = H.min.distanceTo(H.max) / 2, A.boundingSphere = T;
  }
  function oe(A, L, D) {
    var S = L.attributes, H = [];
    function z(j, K) {
      return D.getDependency("accessor", j).then(function(Y) {
        A.setAttribute(K, Y);
      });
    }
    for (var N in S) {
      var F = w[N] || N.toLowerCase();
      F in A.attributes || H.push(z(S[N], F));
    }
    if (L.indices !== void 0 && !A.index) {
      var U = D.getDependency("accessor", L.indices).then(function(j) {
        A.setIndex(j);
      });
      H.push(U);
    }
    return W(A, L), ae(A, L, D), Promise.all(H).then(function() {
      return L.targets !== void 0 ? B(A, L.targets, D) : A;
    });
  }
  function _e(A, L) {
    var D = A.getIndex();
    if (D === null) {
      var S = [], H = A.getAttribute("position");
      if (H !== void 0) {
        for (var z = 0; z < H.count; z++)
          S.push(z);
        A.setIndex(S), D = A.getIndex();
      } else
        return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), A;
    }
    var N = D.count - 2, F = [];
    if (L === TriangleFanDrawMode)
      for (var z = 1; z <= N; z++)
        F.push(D.getX(0)), F.push(D.getX(z)), F.push(D.getX(z + 1));
    else
      for (var z = 0; z < N; z++)
        z % 2 === 0 ? (F.push(D.getX(z)), F.push(D.getX(z + 1)), F.push(D.getX(z + 2))) : (F.push(D.getX(z + 2)), F.push(D.getX(z + 1)), F.push(D.getX(z)));
    F.length / 3 !== N && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    var U = A.clone();
    return U.setIndex(F), U;
  }
  return Q.prototype.loadGeometries = function(A) {
    var L = this, D = this.extensions, S = this.primitiveCache;
    function H(re) {
      return D[r.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(re, L).then(function(le) {
        return oe(le, re, L);
      });
    }
    for (var z = [], N = 0, F = A.length; N < F; N++) {
      var U = A[N], j = te(U), K = S[j];
      if (K)
        z.push(K.promise);
      else {
        var Y;
        U.extensions && U.extensions[r.KHR_DRACO_MESH_COMPRESSION] ? Y = H(U) : Y = oe(new BufferGeometry(), U, L), S[j] = { primitive: U, promise: Y }, z.push(Y);
      }
    }
    return Promise.all(z);
  }, Q.prototype.loadMesh = function(A) {
    for (var L = this, D = this.json, S = D.meshes[A], H = S.primitives, z = [], N = 0, F = H.length; N < F; N++) {
      var U = H[N].material === void 0 ? G(this.cache) : this.getDependency("material", H[N].material);
      z.push(U);
    }
    return z.push(L.loadGeometries(H)), Promise.all(z).then(function(j) {
      for (var K = j.slice(0, j.length - 1), Y = j[j.length - 1], re = [], le = 0, T = Y.length; le < T; le++) {
        var C = Y[le], ie = H[le], Z, ce = K[le];
        if (ie.mode === m.TRIANGLES || ie.mode === m.TRIANGLE_STRIP || ie.mode === m.TRIANGLE_FAN || ie.mode === void 0)
          Z = S.isSkinnedMesh === !0 ? new SkinnedMesh(C, ce) : new Mesh(C, ce), Z.isSkinnedMesh === !0 && !Z.geometry.attributes.skinWeight.normalized && Z.normalizeSkinWeights(), ie.mode === m.TRIANGLE_STRIP ? Z.geometry = _e(Z.geometry, TriangleStripDrawMode) : ie.mode === m.TRIANGLE_FAN && (Z.geometry = _e(Z.geometry, TriangleFanDrawMode));
        else if (ie.mode === m.LINES)
          Z = new LineSegments(C, ce);
        else if (ie.mode === m.LINE_STRIP)
          Z = new Line(C, ce);
        else if (ie.mode === m.LINE_LOOP)
          Z = new LineLoop(C, ce);
        else if (ie.mode === m.POINTS)
          Z = new Points(C, ce);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + ie.mode);
        Object.keys(Z.geometry.morphAttributes).length > 0 && q(Z, S), Z.name = S.name || "mesh_" + A, Y.length > 1 && (Z.name += "_" + le), W(Z, S), L.assignFinalMaterial(Z), re.push(Z);
      }
      if (re.length === 1)
        return re[0];
      for (var se = new Group(), le = 0, T = re.length; le < T; le++)
        se.add(re[le]);
      return se;
    });
  }, Q.prototype.loadCamera = function(A) {
    var L, D = this.json.cameras[A], S = D[D.type];
    if (!S) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return D.type === "perspective" ? L = new PerspectiveCamera(MathUtils.radToDeg(S.yfov), S.aspectRatio || 1, S.znear || 1, S.zfar || 2e6) : D.type === "orthographic" && (L = new OrthographicCamera(-S.xmag, S.xmag, S.ymag, -S.ymag, S.znear, S.zfar)), D.name && (L.name = D.name), W(L, D), Promise.resolve(L);
  }, Q.prototype.loadSkin = function(A) {
    var L = this.json.skins[A], D = { joints: L.joints };
    return L.inverseBindMatrices === void 0 ? Promise.resolve(D) : this.getDependency("accessor", L.inverseBindMatrices).then(function(S) {
      return D.inverseBindMatrices = S, D;
    });
  }, Q.prototype.loadAnimation = function(A) {
    for (var L = this.json, D = L.animations[A], S = [], H = [], z = [], N = [], F = [], U = 0, j = D.channels.length; U < j; U++) {
      var K = D.channels[U], Y = D.samplers[K.sampler], re = K.target, le = re.node !== void 0 ? re.node : re.id, T = D.parameters !== void 0 ? D.parameters[Y.input] : Y.input, C = D.parameters !== void 0 ? D.parameters[Y.output] : Y.output;
      S.push(this.getDependency("node", le)), H.push(this.getDependency("accessor", T)), z.push(this.getDependency("accessor", C)), N.push(Y), F.push(re);
    }
    return Promise.all([
      Promise.all(S),
      Promise.all(H),
      Promise.all(z),
      Promise.all(N),
      Promise.all(F)
    ]).then(function(ie) {
      for (var Z = ie[0], ce = ie[1], se = ie[2], ue = ie[3], Le = ie[4], Me = [], ye = 0, he = Z.length; ye < he; ye++) {
        var de = Z[ye], ve = ce[ye], xe = se[ye], k = ue[ye], pe = Le[ye];
        if (de !== void 0) {
          de.updateMatrix(), de.matrixAutoUpdate = !0;
          var me;
          switch (P[pe.path]) {
            case P.weights:
              me = NumberKeyframeTrack;
              break;
            case P.rotation:
              me = QuaternionKeyframeTrack;
              break;
            case P.position:
            case P.scale:
            default:
              me = VectorKeyframeTrack;
              break;
          }
          var Ce = de.name ? de.name : de.uuid, ge = k.interpolation !== void 0 ? V[k.interpolation] : InterpolateLinear, Re = [];
          P[pe.path] === P.weights ? de.traverse(function(je) {
            je.isMesh === !0 && je.morphTargetInfluences && Re.push(je.name ? je.name : je.uuid);
          }) : Re.push(Ce);
          var De = xe.array;
          if (xe.normalized) {
            var Oe;
            if (De.constructor === Int8Array)
              Oe = 1 / 127;
            else if (De.constructor === Uint8Array)
              Oe = 1 / 255;
            else if (De.constructor == Int16Array)
              Oe = 1 / 32767;
            else if (De.constructor === Uint16Array)
              Oe = 1 / 65535;
            else
              throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
            for (var He = new Float32Array(De.length), Pe = 0, Ne = De.length; Pe < Ne; Pe++)
              He[Pe] = De[Pe] * Oe;
            De = He;
          }
          for (var Pe = 0, Ne = Re.length; Pe < Ne; Pe++) {
            var Ve = new me(
              Re[Pe] + "." + P[pe.path],
              ve.array,
              De,
              ge
            );
            k.interpolation === "CUBICSPLINE" && (Ve.createInterpolant = function(R) {
              return new _(this.times, this.values, this.getValueSize() / 3, R);
            }, Ve.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), Me.push(Ve);
          }
        }
      }
      var We = D.name ? D.name : "animation_" + A;
      return new AnimationClip(We, void 0, Me);
    });
  }, Q.prototype.loadNode = function(A) {
    var L = this.json, D = this.extensions, S = this, H = L.meshReferences, z = L.meshUses, N = L.nodes[A];
    return function() {
      var F = [];
      return N.mesh !== void 0 && F.push(S.getDependency("mesh", N.mesh).then(function(U) {
        var j;
        if (H[N.mesh] > 1) {
          var K = z[N.mesh]++;
          j = U.clone(), j.name += "_instance_" + K;
        } else
          j = U;
        return N.weights !== void 0 && j.traverse(function(Y) {
          if (Y.isMesh)
            for (var re = 0, le = N.weights.length; re < le; re++)
              Y.morphTargetInfluences[re] = N.weights[re];
        }), j;
      })), N.camera !== void 0 && F.push(S.getDependency("camera", N.camera)), N.extensions && N.extensions[r.KHR_LIGHTS_PUNCTUAL] && N.extensions[r.KHR_LIGHTS_PUNCTUAL].light !== void 0 && F.push(S.getDependency("light", N.extensions[r.KHR_LIGHTS_PUNCTUAL].light)), Promise.all(F);
    }().then(function(F) {
      var U;
      if (N.isBone === !0 ? U = new Bone() : F.length > 1 ? U = new Group() : F.length === 1 ? U = F[0] : U = new Object3D(), U !== F[0])
        for (var j = 0, K = F.length; j < K; j++)
          U.add(F[j]);
      if (N.name && (U.userData.name = N.name, U.name = PropertyBinding.sanitizeNodeName(N.name)), W(U, N), N.extensions && O(D, U, N), N.matrix !== void 0) {
        var Y = new Matrix4();
        Y.fromArray(N.matrix), U.applyMatrix4(Y);
      } else
        N.translation !== void 0 && U.position.fromArray(N.translation), N.rotation !== void 0 && U.quaternion.fromArray(N.rotation), N.scale !== void 0 && U.scale.fromArray(N.scale);
      return S.associations.set(U, { type: "nodes", index: A }), U;
    });
  }, Q.prototype.loadScene = /* @__PURE__ */ function() {
    function A(L, D, S, H) {
      var z = S.nodes[L];
      return H.getDependency("node", L).then(function(N) {
        if (z.skin === void 0) return N;
        var F;
        return H.getDependency("skin", z.skin).then(function(U) {
          F = U;
          for (var j = [], K = 0, Y = F.joints.length; K < Y; K++)
            j.push(H.getDependency("node", F.joints[K]));
          return Promise.all(j);
        }).then(function(U) {
          return N.traverse(function(j) {
            if (j.isMesh) {
              for (var K = [], Y = [], re = 0, le = U.length; re < le; re++) {
                var T = U[re];
                if (T) {
                  K.push(T);
                  var C = new Matrix4();
                  F.inverseBindMatrices !== void 0 && C.fromArray(F.inverseBindMatrices.array, re * 16), Y.push(C);
                } else
                  console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', F.joints[re]);
              }
              j.bind(new Skeleton(K, Y), j.matrixWorld);
            }
          }), N;
        });
      }).then(function(N) {
        D.add(N);
        var F = [];
        if (z.children)
          for (var U = z.children, j = 0, K = U.length; j < K; j++) {
            var Y = U[j];
            F.push(A(Y, N, S, H));
          }
        return Promise.all(F);
      });
    }
    return function(D) {
      var S = this.json, H = this.extensions, z = this.json.scenes[D], N = this, F = new Group();
      z.name && (F.name = z.name), W(F, z), z.extensions && O(H, F, z);
      for (var U = z.nodes || [], j = [], K = 0, Y = U.length; K < Y; K++)
        j.push(A(U[K], F, S, N));
      return Promise.all(j).then(function() {
        return F;
      });
    };
  }(), e;
}(), loader = new GLTFLoader();
class GLTFLoaderState extends SystemStateComponent {
}
class GLTFLoaderSystem extends System {
  init() {
    this.world.registerComponent(GLTFLoaderState).registerComponent(GLTFModel), this.loaded = [];
  }
  execute() {
    const t = this.queries.toLoad.results;
    for (; t.length; ) {
      const n = t[0];
      n.addComponent(GLTFLoaderState), loader.load(
        n.getComponent(GLTFLoader$1).url,
        (a) => this.loaded.push([n, a])
      );
    }
    for (let n = 0; n < this.loaded.length; n++) {
      const [a, o] = this.loaded[n], s = a.getComponent(GLTFLoader$1);
      o.scene.traverse(function(l) {
        l.isMesh && (l.receiveShadow = s.receiveShadow, l.castShadow = s.castShadow, s.envMapOverride && (l.material.envMap = s.envMapOverride));
      }), a.hasComponent(Object3DComponent) ? s.append && a.getObject3D().add(o.scene) : a.addComponent(GLTFModel, { value: o }).addObject3DComponent(o.scene, s.parent), s.onLoaded && s.onLoaded(o.scene, o);
    }
    this.loaded.length = 0;
    const r = this.queries.toUnload.results;
    for (; r.length; ) {
      const n = r[0];
      n.removeComponent(GLTFLoaderState), n.removeObject3DComponent();
    }
  }
}
GLTFLoaderSystem.queries = {
  toLoad: {
    components: [GLTFLoader$1, Not(GLTFLoaderState)]
  },
  toUnload: {
    components: [GLTFLoaderState, Not(GLTFLoader$1)]
  }
};
class SkyBoxSystem extends System {
  execute() {
    let t = this.queries.entities.results;
    for (let r = 0; r < t.length; r++) {
      let n = t[r], a = n.getComponent(SkyBox), o = new Group(), s = new BoxBufferGeometry(100, 100, 100);
      if (s.scale(1, 1, -1), a.type === "cubemap-stereo") {
        let l = getTexturesFromAtlasFile(a.textureUrl, 12), c = [];
        for (let d = 0; d < 6; d++)
          c.push(new MeshBasicMaterial({ map: l[d] }));
        let u = new Mesh(s, c);
        u.layers.set(1), o.add(u);
        let h = [];
        for (let d = 6; d < 12; d++)
          h.push(new MeshBasicMaterial({ map: l[d] }));
        let f = new Mesh(s, h);
        f.layers.set(2), o.add(f), n.addObject3DComponent(o, !1);
      } else
        console.warn("Unknown skybox type: ", a.type);
    }
  }
}
function getTexturesFromAtlasFile(e, t) {
  let r = [];
  for (let a = 0; a < t; a++)
    r[a] = new Texture();
  return new ImageLoader().load(e, function(a) {
    let o, s, l = a.height;
    for (let c = 0; c < r.length; c++)
      o = document.createElement("canvas"), s = o.getContext("2d"), o.height = l, o.width = l, s.drawImage(
        a,
        l * c,
        0,
        l,
        l,
        0,
        0,
        l,
        l
      ), r[c].image = o, r[c].needsUpdate = !0;
  }), r;
}
SkyBoxSystem.queries = {
  entities: {
    components: [SkyBox, Not(Object3DComponent)]
  }
};
class VisibilitySystem extends System {
  processVisibility(t) {
    t.forEach((r) => {
      r.getObject3D().visible = r.getComponent(Visible).value;
    });
  }
  execute() {
    this.processVisibility(this.queries.entities.added), this.processVisibility(this.queries.entities.changed);
  }
}
VisibilitySystem.queries = {
  entities: {
    components: [Visible, Object3DComponent],
    listen: {
      added: !0,
      changed: [Visible]
    }
  }
};
function BespokeThenable() {
  let e = 0, t = [], r, n = 0, a = 0;
  function o(m, y) {
    const b = BespokeThenable();
    function M() {
      const x = e > 0 ? m : y;
      if (v(x))
        try {
          const w = x(r);
          w === b && g();
          const P = d(w);
          P ? P.call(w, b.resolve, b.reject) : b.resolve(w);
        } catch (w) {
          b.reject(w);
        }
      else
        b[e > 0 ? "resolve" : "reject"](r);
    }
    return t.push(M), e && u(), b;
  }
  const s = p((m) => {
    a || c(1, m);
  }), l = p((m) => {
    a || c(-1, m);
  });
  function c(m, y) {
    a++;
    let b = 0;
    try {
      y === _ && g();
      const M = m > 0 && d(y);
      M ? M.call(y, p((x) => {
        b++, c(1, x);
      }), p((x) => {
        b++, c(-1, x);
      })) : (e = m, r = y, u());
    } catch (M) {
      !e && !b && c(-1, M);
    }
  }
  function u() {
    n || (setTimeout(h, 0), n = 1);
  }
  function h() {
    const m = t;
    n = 0, t = [], m.forEach(f);
  }
  function f(m) {
    m();
  }
  function d(m) {
    const y = m && (v(m) || typeof m == "object") && m.then;
    return v(y) && y;
  }
  function p(m) {
    let y = 0;
    return function(...b) {
      y++ || m.apply(this, b);
    };
  }
  function g() {
    throw new TypeError("Chaining cycle detected");
  }
  const v = (m) => typeof m == "function", _ = {
    then: o,
    resolve: s,
    reject: l
  };
  return _;
}
function NativePromiseThenable() {
  let e, t;
  const r = new Promise((n, a) => {
    e = n, t = a;
  });
  return {
    then: r.then.bind(r),
    resolve: e,
    reject: t
  };
}
var Thenable = typeof Promise == "function" ? NativePromiseThenable : BespokeThenable;
let _workerModuleId = 0, _messageId = 0;
const workers = /* @__PURE__ */ Object.create(null), openRequests = /* @__PURE__ */ Object.create(null);
openRequests._count = 0;
function defineWorkerModule(e) {
  if (!e || typeof e.init != "function")
    throw new Error("requires `options.init` function");
  let { dependencies: t, init: r, getTransferables: n, workerId: a } = e;
  a == null && (a = "#default");
  const o = `workerModule${++_workerModuleId}`;
  let s = null;
  t = t && t.map((c) => (typeof c == "function" && !c.workerModuleData && (c = defineWorkerModule({
    workerId: a,
    init: new Function(`return function(){return (${stringifyFunction(c)})}`)()
  })), c && c.workerModuleData && (c = c.workerModuleData), c));
  function l(...c) {
    return s || (s = callWorker(a, "registerModule", l.workerModuleData)), s.then(({ isCallable: u }) => {
      if (u)
        return callWorker(a, "callModule", { id: o, args: c });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return l.workerModuleData = {
    isWorkerModule: !0,
    id: o,
    dependencies: t,
    init: stringifyFunction(r),
    getTransferables: n && stringifyFunction(n)
  }, l;
}
function stringifyFunction(e) {
  let t = e.toString();
  return !/^function/.test(t) && /^\w+\s*\(/.test(t) && (t = "function " + t), t;
}
function getWorker(e) {
  let t = workers[e];
  if (!t) {
    const r = (function() {
      const n = /* @__PURE__ */ Object.create(null);
      function a({ id: s, dependencies: l = [], init: c = function() {
      }, getTransferables: u = null }, h) {
        if (!n[s])
          try {
            l = l.map((d) => (d && d.isWorkerModule && (a(d, (p) => {
              if (p instanceof Error) throw p;
            }), d = n[d.id].value), d)), c = new Function(`return (${c})`)(), u && (u = new Function(`return (${u})`)());
            const f = c(...l);
            n[s] = {
              id: s,
              value: f,
              getTransferables: u
            }, h(f);
          } catch (f) {
            f && f.noLog || console.error(f), h(f);
          }
      }
      function o({ id: s, args: l }, c) {
        (!n[s] || typeof n[s].value != "function") && c(new Error(`Worker module ${s}: not found or its 'init' did not return a function`));
        try {
          const h = n[s].value(...l);
          h && typeof h.then == "function" ? h.then(u, (f) => c(f instanceof Error ? f : new Error("" + f))) : u(h);
        } catch (h) {
          c(h);
        }
        function u(h) {
          try {
            let f = n[s].getTransferables && n[s].getTransferables(h);
            (!f || !Array.isArray(f) || !f.length) && (f = void 0), c(h, f);
          } catch (f) {
            console.error(f), c(f);
          }
        }
      }
      self.addEventListener("message", (s) => {
        const { messageId: l, action: c, data: u } = s.data;
        try {
          c === "registerModule" && a(u, (h) => {
            h instanceof Error ? postMessage({
              messageId: l,
              success: !1,
              error: h.message
            }) : postMessage({
              messageId: l,
              success: !0,
              result: { isCallable: typeof h == "function" }
            });
          }), c === "callModule" && o(u, (h, f) => {
            h instanceof Error ? postMessage({
              messageId: l,
              success: !1,
              error: h.message
            }) : postMessage({
              messageId: l,
              success: !0,
              result: h
            }, f || void 0);
          });
        } catch (h) {
          postMessage({
            messageId: l,
            success: !1,
            error: h.stack
          });
        }
      });
    }).toString();
    t = workers[e] = new Worker(
      URL.createObjectURL(
        new Blob([`;(${r})()`], { type: "application/javascript" })
      )
    ), t.onmessage = (n) => {
      const a = n.data, o = a.messageId, s = openRequests[o];
      if (!s)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete openRequests[o], openRequests.count--, s(a);
    };
  }
  return t;
}
function callWorker(e, t, r) {
  const n = Thenable(), a = ++_messageId;
  return openRequests[a] = (o) => {
    o.success ? n.resolve(o.result) : n.reject(new Error(`Error in worker ${t} call: ${o.error}`));
  }, openRequests._count++, openRequests.count > 1e3 && console.warn("Large number of open WorkerModule requests, some may not be returning"), getWorker(e).postMessage({
    messageId: a,
    action: t,
    data: r
  }), n;
}
var ThenableWorkerModule = defineWorkerModule({
  dependencies: [Thenable],
  init: function(e) {
    return e;
  }
});
const voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function expandShaderIncludes(e) {
  const t = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function r(n, a) {
    let o = ShaderChunk[a];
    return o ? expandShaderIncludes(o) : n;
  }
  return e.replace(t, r);
}
const assign$1 = Object.assign || function() {
  let e = arguments[0];
  for (let t = 1, r = arguments.length; t < r; t++) {
    let n = arguments[t];
    if (n)
      for (let a in n)
        n.hasOwnProperty(a) && (e[a] = n[a]);
  }
  return e;
};
let idCtr = 0;
const epoch = Date.now(), CACHE = /* @__PURE__ */ new WeakMap();
function createDerivedMaterial(e, t) {
  const r = getOptionsHash(t);
  let n = CACHE.get(e);
  if (n || (n = /* @__PURE__ */ Object.create(null), CACHE.set(e, n)), n[r])
    return n[r].clone();
  const a = ++idCtr, o = `_derivedShaders${a}`, s = `_onBeforeCompile${a}`;
  let l, c;
  function u(d) {
    e.onBeforeCompile.call(this, d);
    const { vertex: p, fragment: g } = this[o] || (this[o] = { vertex: {}, fragment: {} });
    if (p.source !== d.vertexShader || g.source !== d.fragmentShader) {
      const v = upgradeShaders(d, t, a);
      p.source = d.vertexShader, p.result = v.vertexShader, g.source = d.fragmentShader, g.result = v.fragmentShader;
    }
    d.vertexShader = p.result, d.fragmentShader = g.result, assign$1(d.uniforms, this.uniforms), t.timeUniform && (d.uniforms[t.timeUniform] = {
      get value() {
        return Date.now() - epoch;
      }
    }), this[s] && this[s](d);
  }
  function h() {
    e.constructor.apply(this, arguments), this._listeners = void 0;
  }
  h.prototype = Object.create(e, {
    constructor: { value: h },
    isDerivedMaterial: { value: !0 },
    baseMaterial: { value: e },
    onBeforeCompile: {
      get() {
        return u;
      },
      set(d) {
        this[s] = d;
      }
    },
    copy: {
      value: function(d) {
        return e.copy.call(this, d), !e.isShaderMaterial && !e.isDerivedMaterial && (this.extensions = assign$1({}, d.extensions), this.defines = assign$1({}, d.defines), this.uniforms = UniformsUtils.clone(d.uniforms)), this;
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: { value: function() {
      let d = this._depthMaterial;
      return d || (c || (c = createDerivedMaterial(
        e.isDerivedMaterial ? e.getDepthMaterial() : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
        t
      ), c.defines.IS_DEPTH_MATERIAL = ""), d = this._depthMaterial = c.clone()), d;
    } },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: { value: function() {
      let d = this._distanceMaterial;
      return d || (l || (l = createDerivedMaterial(
        e.isDerivedMaterial ? e.getDistanceMaterial() : new MeshDistanceMaterial(),
        t
      ), l.defines.IS_DISTANCE_MATERIAL = ""), d = this._distanceMaterial = l.clone()), d;
    } },
    dispose: { value() {
      const { _depthMaterial: d, _distanceMaterial: p } = this;
      d && d.dispose(), p && p.dispose(), e.dispose.call(this);
    } }
  });
  const f = new h();
  return f.copy(e), f.uniforms = assign$1(UniformsUtils.clone(e.uniforms || {}), t.uniforms), f.defines = assign$1({}, e.defines, t.defines), f.defines.TROIKA_DERIVED_MATERIAL = a, f.extensions = assign$1({}, e.extensions, t.extensions), n[r] = f, f.clone();
}
function upgradeShaders({ vertexShader: e, fragmentShader: t }, r, n) {
  let {
    vertexDefs: a,
    vertexMainIntro: o,
    vertexTransform: s,
    fragmentDefs: l,
    fragmentMainIntro: c,
    fragmentColorTransform: u,
    timeUniform: h
  } = r;
  if (h) {
    const f = `
uniform float ${h};
`;
    a = (a || "") + f, l = (l || "") + f;
  }
  return (a || o || s) && (s && (e = expandShaderIncludes(e), a = `${a || ""}
void troikaVertexTransform${n}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${s}
}
`, e = e.replace(/\b(position|normal|uv)\b/g, (f, d, p, g) => /\battribute\s+vec[23]\s+$/.test(g.substr(0, p)) ? d : `troika_${d}_${n}`), o = `
vec3 troika_position_${n} = vec3(position);
vec3 troika_normal_${n} = vec3(normal);
vec2 troika_uv_${n} = vec2(uv);
troikaVertexTransform${n}(troika_position_${n}, troika_normal_${n}, troika_uv_${n});
${o || ""}
`), e = e.replace(
    voidMainRegExp,
    `${a || ""}

$&

${o || ""}`
  )), (l || c || u) && (t = expandShaderIncludes(t), t = t.replace(voidMainRegExp, `
${l || ""}
void troikaOrigMain${n}() {
${c || ""}
`), t += `
void main() {
  troikaOrigMain${n}();
  ${u || ""}
}`), {
    vertexShader: e,
    fragmentShader: t
  };
}
function getOptionsHash(e) {
  return JSON.stringify(e, optionsJsonReplacer);
}
function optionsJsonReplacer(e, t) {
  return e === "uniforms" ? void 0 : t;
}
new MeshStandardMaterial({ color: 16777215, side: DoubleSide });
function createSDFGenerator(e) {
  const {
    sdfTextureSize: t,
    sdfDistancePercent: r
  } = e, n = 16, a = 1 / 0;
  function o(f, d, p, g, v, _, m) {
    const y = 1 - m;
    return {
      x: y * y * f + 2 * y * m * p + m * m * v,
      y: y * y * d + 2 * y * m * g + m * m * _
    };
  }
  function s(f, d, p, g, v, _, m, y, b) {
    const M = 1 - b;
    return {
      x: M * M * M * f + 3 * M * M * b * p + 3 * M * b * b * v + b * b * b * m,
      y: M * M * M * d + 3 * M * M * b * g + 3 * M * b * b * _ + b * b * b * y
    };
  }
  function l(f) {
    return f * f;
  }
  function c(f, d, p, g, v, _) {
    const m = v - p, y = _ - g, b = l(m) + l(y), M = b ? Math.max(0, Math.min(1, ((f - p) * m + (d - g) * y) / b)) : 0;
    return Math.sqrt(l(f - (p + M * m)) + l(d - (g + M * y)));
  }
  class u {
    constructor(d) {
      const { xMin: p, yMin: g, xMax: v, yMax: _ } = d, m = v - p, y = _ - g, b = Math.round(p + m / 2), M = Math.round(g + y / 2), x = Math.pow(2, Math.floor(Math.log(Math.max(m, y)) * Math.LOG2E));
      this._root = {
        0: null,
        1: null,
        2: null,
        3: null,
        data: null,
        cx: b,
        cy: M,
        r: x,
        minX: a,
        minY: a,
        maxX: -a,
        maxY: -a
      };
    }
    addLineSegment(d, p, g, v) {
      const _ = (d + g) / 2, m = (p + v) / 2, y = {
        x0: d,
        y0: p,
        x1: g,
        y1: v,
        cx: _,
        cy: m,
        minX: Math.min(d, g),
        minY: Math.min(p, v),
        maxX: Math.max(d, g),
        maxY: Math.max(p, v),
        next: null
      };
      this._insertSegment(y, this._root);
    }
    _insertSegment(d, p) {
      const { minX: g, minY: v, maxX: _, maxY: m, cx: y, cy: b } = d;
      g < p.minX && (p.minX = g), v < p.minY && (p.minY = v), _ > p.maxX && (p.maxX = _), m > p.maxY && (p.maxY = m);
      let M = p.data;
      if (M)
        if (M.cx === y && M.cy === b) {
          for (; M.next; ) M = M.next;
          M.next = d;
        } else
          p.data = null, this._insertSegment(M, p), this._insertSegment(d, p);
      else {
        const x = (b < p.cy ? 0 : 2) + (y < p.cx ? 0 : 1);
        p[x] ? this._insertSegment(d, p[x]) : p[x] = {
          0: null,
          1: null,
          2: null,
          3: null,
          data: d,
          cx: p.cx + p.r / 2 * (x % 2 ? 1 : -1),
          cy: p.cy + p.r / 2 * (x < 2 ? -1 : 1),
          r: p.r / 2,
          minX: g,
          minY: v,
          maxX: _,
          maxY: m
        };
      }
    }
    walkTree(d) {
      this.walkBranch(this._root, d);
    }
    walkBranch(d, p) {
      if (p(d) !== !1 && !d.data)
        for (let g = 0; g < 4; g++)
          d[g] !== null && this.walkBranch(d[g], p);
    }
    findNearestSignedDistance(d, p, g) {
      let v = g;
      return this.walkTree(function(m) {
        if (d - v > m.maxX || d + v < m.minX || p - v > m.maxY || p + v < m.minY)
          return !1;
        if (m.data) {
          for (let y = m.data; y; y = y.next)
            if (
              //fast prefilter for segment to avoid dist calc
              d - v < y.maxX || d + v > y.minX || p - v < y.maxY || p + v > y.minY
            ) {
              const b = c(d, p, y.x0, y.y0, y.x1, y.y1);
              b < v && (v = b);
            }
        }
      }), this.isPointInPoly(d, p) || (v = -v), v;
    }
    isPointInPoly(d, p) {
      let g = !1;
      return this.walkTree((v) => {
        if (v.maxX < d || v.minY > p || v.maxY < p)
          return !1;
        if (v.data)
          for (let _ = v.data; _; _ = _.next) {
            const { x0: m, y0: y, x1: b, y1: M } = _;
            y > p != M > p && d < (b - m) * (p - y) / (M - y) + m && (g = !g);
          }
      }), g;
    }
  }
  function h(f) {
    const d = new Uint8Array(l(t)), p = f.xMax - f.xMin, g = f.yMax - f.yMin, v = Math.max(p, g) * r, _ = (p + v * 2) / t, m = (g + v * 2) / t, y = f.xMin - v - _, b = f.yMin - v - m, M = f.xMax + v + _, x = f.yMax + v + m;
    function w(V) {
      return y + (M - y) * V / t;
    }
    function P(V) {
      return b + (x - b) * V / t;
    }
    if (f.pathCommandCount) {
      const V = new u(f);
      let I, $, E, G;
      f.forEachPathCommand((O, W, B, q, te, ne, Q) => {
        switch (O) {
          case "M":
            E = I = W, G = $ = B;
            break;
          case "L":
            (W !== E || B !== G) && V.addLineSegment(E, G, E = W, G = B);
            break;
          case "Q": {
            let ae = { x: E, y: G };
            for (let oe = 1; oe < n; oe++) {
              let _e = o(
                E,
                G,
                W,
                B,
                q,
                te,
                oe / (n - 1)
              );
              V.addLineSegment(ae.x, ae.y, _e.x, _e.y), ae = _e;
            }
            E = q, G = te;
            break;
          }
          case "C": {
            let ae = { x: E, y: G };
            for (let oe = 1; oe < n; oe++) {
              let _e = s(
                E,
                G,
                W,
                B,
                q,
                te,
                ne,
                Q,
                oe / (n - 1)
              );
              V.addLineSegment(ae.x, ae.y, _e.x, _e.y), ae = _e;
            }
            E = ne, G = Q;
            break;
          }
          case "Z":
            (E !== I || G !== $) && V.addLineSegment(E, G, I, $);
            break;
        }
      });
      for (let O = 0; O < t; O++)
        for (let W = 0; W < t; W++) {
          const B = V.findNearestSignedDistance(
            w(O + 0.5),
            P(W + 0.5),
            v
          );
          let q = isFinite(B) ? Math.round(255 * (1 + B / v) * 0.5) : B;
          q = Math.max(0, Math.min(255, q)), d[W * t + O] = q;
        }
    }
    return {
      textureData: d,
      renderingBounds: [
        y,
        b,
        M,
        x
      ]
    };
  }
  return h;
}
function createFontProcessor(e, t, r) {
  const {
    defaultFontUrl: n
  } = r, a = /* @__PURE__ */ Object.create(null), o = 1 / 0;
  function s(f, d) {
    function p() {
      const g = (v) => {
        console.error(`Failure loading font ${f}${f === n ? "" : "; trying fallback"}`, v), f !== n && (f = n, p());
      };
      try {
        const v = new XMLHttpRequest();
        v.open("get", f, !0), v.responseType = "arraybuffer", v.onload = function() {
          if (v.status >= 400)
            g(new Error(v.statusText));
          else if (v.status > 0)
            try {
              const _ = e(v.response);
              d(_);
            } catch (_) {
              g(_);
            }
        }, v.onerror = g, v.send();
      } catch (v) {
        g(v);
      }
    }
    p();
  }
  function l(f, d) {
    f || (f = n);
    let p = a[f];
    if (p)
      p.onload ? p.onload.push(d) : d();
    else {
      const g = a[f] = { onload: [d] };
      s(f, (v) => {
        p = a[f] = {
          fontObj: v,
          glyphs: {},
          glyphCount: 0
        }, g.onload.forEach((_) => _());
      });
    }
  }
  function c(f, d) {
    f || (f = n), l(f, () => {
      d(a[f]);
    });
  }
  function u({
    text: f = "",
    font: d = n,
    fontSize: p = 1,
    letterSpacing: g = 0,
    lineHeight: v = "normal",
    maxWidth: _ = o,
    textAlign: m = "left",
    whiteSpace: y = "normal",
    overflowWrap: b = "normal",
    anchor: M,
    includeCaretPositions: x = !1
  }, w, P = !1) {
    f.indexOf("\r") > -1 && (console.warn("FontProcessor.process: got text with \\r chars; normalizing to \\n"), f = f.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), p = +p, g = +g, _ = +_, c(d, (V) => {
      const I = V.fontObj, $ = isFinite(_);
      let E = null, G = null, O = null, W = null, B = null, q = 0, te = y !== "nowrap";
      const { ascender: ne, descender: Q, unitsPerEm: ae } = I, oe = p / ae;
      v === "normal" && (v = (ne - Q) / ae), v = v * p;
      const _e = (v - (ne - Q) * oe) / 2, A = Math.min(v, (ne - Q) * oe), L = (ne + Q) / 2 * oe - A / 2;
      let D = 0, S = { glyphs: [], width: 0 };
      const H = [S];
      if (I.forEachGlyph(f, p, g, (z, N, F) => {
        const U = f.charAt(F), j = z.advanceWidth * oe, K = !!U && /\s/.test(U), Y = S.glyphs;
        let re;
        if (te && $ && !K && N + j + D > _ && Y.length) {
          if (Y[Y.length - 1].isWhitespace)
            re = [], D = -N;
          else
            for (let le = Y.length; le--; )
              if (le === 0 && b === "break-word") {
                re = [], D = -N;
                break;
              } else if (Y[le].isWhitespace) {
                re = Y.splice(le + 1);
                const T = re[0].x;
                D -= T;
                for (let C = 0; C < re.length; C++)
                  re[C].x -= T;
                break;
              }
          re && (S.isSoftWrapped = !0, S = { glyphs: re, width: 0 }, H.push(S), q = _);
        }
        S.glyphs.push({
          glyphObj: z,
          x: N + D,
          y: 0,
          //added later
          width: j,
          char: U,
          charIndex: F,
          isWhitespace: K,
          isEmpty: z.xMin === z.xMax || z.yMin === z.yMax,
          atlasInfo: null
          //added later
        }), U === `
` && (S = { glyphs: [], width: 0 }, H.push(S), D = -(N + j));
      }), H.forEach((z) => {
        const N = z.glyphs;
        for (let F = N.length; F--; ) {
          const U = N[F];
          if (!U.isWhitespace) {
            z.width = U.x + U.width, z.width > q && (q = z.width);
            return;
          }
        }
      }), !P) {
        const z = [];
        let N = -(p + _e);
        x && (W = new Float32Array(f.length * 3));
        let F = -1;
        H.forEach((K) => {
          const { glyphs: Y, width: re } = K;
          if (Y.length) {
            let le = 0, T = 0;
            if (m === "center")
              le = (q - re) / 2;
            else if (m === "right")
              le = q - re;
            else if (m === "justify") {
              for (let C = Y.length; C--; )
                if (!Y[C].isWhitespace) {
                  for (; C--; )
                    Y[C].isWhitespace && T++;
                  break;
                }
            }
            for (let C = 0, ie = Y.length; C < ie; C++) {
              const Z = Y[C];
              if (le && (Z.x += le), Z.y = N, Z.isWhitespace && m === "justify" && K.isSoftWrapped) {
                const ce = (q - re) / T;
                le += ce, Z.width += ce;
              }
              if (x) {
                const { charIndex: ce } = Z;
                for (W[ce * 3] = Z.x, W[ce * 3 + 1] = Z.x + Z.width, W[ce * 3 + 2] = Z.y + L; ce - F > 1; )
                  W[(F + 1) * 3] = W[F * 3 + 1], W[(F + 1) * 3 + 1] = W[F * 3 + 1], W[(F + 1) * 3 + 2] = W[F * 3 + 2], F++;
                F = ce;
              }
              if (!Z.isWhitespace && !Z.isEmpty) {
                const ce = Z.glyphObj;
                let se = V.glyphs[ce.index];
                if (!se) {
                  const ue = t(ce);
                  ue.atlasIndex = V.glyphCount++, E || (E = []), E.push(ue), se = V.glyphs[ce.index] = {
                    atlasIndex: ue.atlasIndex,
                    glyphObj: ce,
                    renderingBounds: ue.renderingBounds
                  };
                }
                Z.atlasInfo = se, z.push(Z);
              }
            }
          }
          N -= v;
        });
        let U = 0, j = 0;
        if (M && (M[0] && (U = -q * M[0]), M[1] && (j = H.length * v * M[1])), x && (U || j))
          for (let K = 0, Y = W.length; K < Y; K += 3)
            W[K] += U, W[K + 1] += U, W[K + 2] += j;
        G = new Float32Array(z.length * 4), O = new Float32Array(z.length), B = [o, o, -o, -o], z.forEach((K, Y) => {
          const { renderingBounds: re, atlasIndex: le } = K.atlasInfo, T = G[Y * 4] = K.x + re[0] * oe + U, C = G[Y * 4 + 1] = K.y + re[1] * oe + j, ie = G[Y * 4 + 2] = K.x + re[2] * oe + U, Z = G[Y * 4 + 3] = K.y + re[3] * oe + j;
          T < B[0] && (B[0] = T), C < B[1] && (B[1] = C), ie > B[2] && (B[2] = ie), Z > B[3] && (B[3] = Z), O[Y] = le;
        });
      }
      w({
        glyphBounds: G,
        //rendering quad bounds for each glyph [x1, y1, x2, y2]
        glyphAtlasIndices: O,
        //atlas indices for each glyph
        caretPositions: W,
        //x,y of bottom of cursor position before each char, plus one after last char
        caretHeight: A,
        //height of cursor from bottom to top
        totalBounds: B,
        //total rect including all glyphBounds; will be slightly larger than glyph edges due to SDF padding
        totalBlockSize: [q, H.length * v],
        //width and height of the text block; accurate for layout measurement
        newGlyphSDFs: E
        //if this request included any new SDFs for the atlas, they'll be included here
      });
    });
  }
  function h(f, d) {
    u(f, (p) => {
      d({
        width: p.totalBlockSize[0],
        height: p.totalBlockSize[1]
      });
    }, { metricsOnly: !0 });
  }
  return {
    process: u,
    measure: h,
    loadFont: l
  };
}
function typrFactory() {
  const e = self;
  var t = {};
  return t.parse = function(r) {
    var n = t._bin, a = new Uint8Array(r), o = n.readASCII(a, 0, 4);
    if (o == "ttcf") {
      var s = 4;
      n.readUshort(a, s), s += 2, n.readUshort(a, s), s += 2;
      var l = n.readUint(a, s);
      s += 4;
      for (var c = [], u = 0; u < l; u++) {
        var h = n.readUint(a, s);
        s += 4, c.push(t._readFont(a, h));
      }
      return c;
    } else return [t._readFont(a, 0)];
  }, t._readFont = function(r, n) {
    var a = t._bin, o = n;
    a.readFixed(r, n), n += 4;
    var s = a.readUshort(r, n);
    n += 2, a.readUshort(r, n), n += 2, a.readUshort(r, n), n += 2, a.readUshort(r, n), n += 2;
    for (var l = [
      "cmap",
      "head",
      "hhea",
      "maxp",
      "hmtx",
      "name",
      "OS/2",
      "post",
      //"cvt",
      //"fpgm",
      "loca",
      "glyf",
      "kern",
      //"prep"
      //"gasp"
      "CFF ",
      "GPOS",
      "GSUB",
      "SVG "
      //"VORG",
    ], c = { _data: r, _offset: o }, u = {}, h = 0; h < s; h++) {
      var f = a.readASCII(r, n, 4);
      n += 4, a.readUint(r, n), n += 4;
      var d = a.readUint(r, n);
      n += 4;
      var p = a.readUint(r, n);
      n += 4, u[f] = { offset: d, length: p };
    }
    for (var h = 0; h < l.length; h++) {
      var g = l[h];
      u[g] && (c[g.trim()] = t[g.trim()].parse(r, u[g].offset, u[g].length, c));
    }
    return c;
  }, t._tabOffset = function(r, n, a) {
    for (var o = t._bin, s = o.readUshort(r, a + 4), l = a + 12, c = 0; c < s; c++) {
      var u = o.readASCII(r, l, 4);
      l += 4, o.readUint(r, l), l += 4;
      var h = o.readUint(r, l);
      if (l += 4, o.readUint(r, l), l += 4, u == n) return h;
    }
    return 0;
  }, t._bin = {
    readFixed: function(r, n) {
      return (r[n] << 8 | r[n + 1]) + (r[n + 2] << 8 | r[n + 3]) / (256 * 256 + 4);
    },
    readF2dot14: function(r, n) {
      var a = t._bin.readShort(r, n);
      return a / 16384;
    },
    readInt: function(r, n) {
      var a = t._bin.t.uint8;
      return a[0] = r[n + 3], a[1] = r[n + 2], a[2] = r[n + 1], a[3] = r[n], t._bin.t.int32[0];
    },
    readInt8: function(r, n) {
      var a = t._bin.t.uint8;
      return a[0] = r[n], t._bin.t.int8[0];
    },
    readShort: function(r, n) {
      var a = t._bin.t.uint8;
      return a[1] = r[n], a[0] = r[n + 1], t._bin.t.int16[0];
    },
    readUshort: function(r, n) {
      return r[n] << 8 | r[n + 1];
    },
    readUshorts: function(r, n, a) {
      for (var o = [], s = 0; s < a; s++) o.push(t._bin.readUshort(r, n + s * 2));
      return o;
    },
    readUint: function(r, n) {
      var a = t._bin.t.uint8;
      return a[3] = r[n], a[2] = r[n + 1], a[1] = r[n + 2], a[0] = r[n + 3], t._bin.t.uint32[0];
    },
    readUint64: function(r, n) {
      return t._bin.readUint(r, n) * 4294967296 + t._bin.readUint(r, n + 4);
    },
    readASCII: function(r, n, a) {
      for (var o = "", s = 0; s < a; s++) o += String.fromCharCode(r[n + s]);
      return o;
    },
    readUnicode: function(r, n, a) {
      for (var o = "", s = 0; s < a; s++) {
        var l = r[n++] << 8 | r[n++];
        o += String.fromCharCode(l);
      }
      return o;
    },
    _tdec: e.TextDecoder ? new e.TextDecoder() : null,
    readUTF8: function(r, n, a) {
      var o = t._bin._tdec;
      return o && n == 0 && a == r.length ? o.decode(r) : t._bin.readASCII(r, n, a);
    },
    readBytes: function(r, n, a) {
      for (var o = [], s = 0; s < a; s++) o.push(r[n + s]);
      return o;
    },
    readASCIIArray: function(r, n, a) {
      for (var o = [], s = 0; s < a; s++)
        o.push(String.fromCharCode(r[n + s]));
      return o;
    }
  }, t._bin.t = {
    buff: new ArrayBuffer(8)
  }, t._bin.t.int8 = new Int8Array(t._bin.t.buff), t._bin.t.uint8 = new Uint8Array(t._bin.t.buff), t._bin.t.int16 = new Int16Array(t._bin.t.buff), t._bin.t.uint16 = new Uint16Array(t._bin.t.buff), t._bin.t.int32 = new Int32Array(t._bin.t.buff), t._bin.t.uint32 = new Uint32Array(t._bin.t.buff), t._lctf = {}, t._lctf.parse = function(r, n, a, o, s) {
    var l = t._bin, c = {}, u = n;
    l.readFixed(r, n), n += 4;
    var h = l.readUshort(r, n);
    n += 2;
    var f = l.readUshort(r, n);
    n += 2;
    var d = l.readUshort(r, n);
    return n += 2, c.scriptList = t._lctf.readScriptList(r, u + h), c.featureList = t._lctf.readFeatureList(r, u + f), c.lookupList = t._lctf.readLookupList(r, u + d, s), c;
  }, t._lctf.readLookupList = function(r, n, a) {
    var o = t._bin, s = n, l = [], c = o.readUshort(r, n);
    n += 2;
    for (var u = 0; u < c; u++) {
      var h = o.readUshort(r, n);
      n += 2;
      var f = t._lctf.readLookupTable(r, s + h, a);
      l.push(f);
    }
    return l;
  }, t._lctf.readLookupTable = function(r, n, a) {
    var o = t._bin, s = n, l = { tabs: [] };
    l.ltype = o.readUshort(r, n), n += 2, l.flag = o.readUshort(r, n), n += 2;
    var c = o.readUshort(r, n);
    n += 2;
    for (var u = 0; u < c; u++) {
      var h = o.readUshort(r, n);
      n += 2;
      var f = a(r, l.ltype, s + h);
      l.tabs.push(f);
    }
    return l;
  }, t._lctf.numOfOnes = function(r) {
    for (var n = 0, a = 0; a < 32; a++) r >>> a & 1 && n++;
    return n;
  }, t._lctf.readClassDef = function(r, n) {
    var a = t._bin, o = [], s = a.readUshort(r, n);
    if (n += 2, s == 1) {
      var l = a.readUshort(r, n);
      n += 2;
      var c = a.readUshort(r, n);
      n += 2;
      for (var u = 0; u < c; u++)
        o.push(l + u), o.push(l + u), o.push(a.readUshort(r, n)), n += 2;
    }
    if (s == 2) {
      var h = a.readUshort(r, n);
      n += 2;
      for (var u = 0; u < h; u++)
        o.push(a.readUshort(r, n)), n += 2, o.push(a.readUshort(r, n)), n += 2, o.push(a.readUshort(r, n)), n += 2;
    }
    return o;
  }, t._lctf.getInterval = function(r, n) {
    for (var a = 0; a < r.length; a += 3) {
      var o = r[a], s = r[a + 1];
      if (r[a + 2], o <= n && n <= s) return a;
    }
    return -1;
  }, t._lctf.readCoverage = function(r, n) {
    var a = t._bin, o = {};
    o.fmt = a.readUshort(r, n), n += 2;
    var s = a.readUshort(r, n);
    return n += 2, o.fmt == 1 && (o.tab = a.readUshorts(r, n, s)), o.fmt == 2 && (o.tab = a.readUshorts(r, n, s * 3)), o;
  }, t._lctf.coverageIndex = function(r, n) {
    var a = r.tab;
    if (r.fmt == 1) return a.indexOf(n);
    if (r.fmt == 2) {
      var o = t._lctf.getInterval(a, n);
      if (o != -1) return a[o + 2] + (n - a[o]);
    }
    return -1;
  }, t._lctf.readFeatureList = function(r, n) {
    var a = t._bin, o = n, s = [], l = a.readUshort(r, n);
    n += 2;
    for (var c = 0; c < l; c++) {
      var u = a.readASCII(r, n, 4);
      n += 4;
      var h = a.readUshort(r, n);
      n += 2, s.push({ tag: u.trim(), tab: t._lctf.readFeatureTable(r, o + h) });
    }
    return s;
  }, t._lctf.readFeatureTable = function(r, n) {
    var a = t._bin;
    a.readUshort(r, n), n += 2;
    var o = a.readUshort(r, n);
    n += 2;
    for (var s = [], l = 0; l < o; l++) s.push(a.readUshort(r, n + 2 * l));
    return s;
  }, t._lctf.readScriptList = function(r, n) {
    var a = t._bin, o = n, s = {}, l = a.readUshort(r, n);
    n += 2;
    for (var c = 0; c < l; c++) {
      var u = a.readASCII(r, n, 4);
      n += 4;
      var h = a.readUshort(r, n);
      n += 2, s[u.trim()] = t._lctf.readScriptTable(r, o + h);
    }
    return s;
  }, t._lctf.readScriptTable = function(r, n) {
    var a = t._bin, o = n, s = {}, l = a.readUshort(r, n);
    n += 2, s.default = t._lctf.readLangSysTable(r, o + l);
    var c = a.readUshort(r, n);
    n += 2;
    for (var u = 0; u < c; u++) {
      var h = a.readASCII(r, n, 4);
      n += 4;
      var f = a.readUshort(r, n);
      n += 2, s[h.trim()] = t._lctf.readLangSysTable(r, o + f);
    }
    return s;
  }, t._lctf.readLangSysTable = function(r, n) {
    var a = t._bin, o = {};
    a.readUshort(r, n), n += 2, o.reqFeature = a.readUshort(r, n), n += 2;
    var s = a.readUshort(r, n);
    return n += 2, o.features = a.readUshorts(r, n, s), o;
  }, t.CFF = {}, t.CFF.parse = function(r, n, a) {
    var o = t._bin;
    r = new Uint8Array(r.buffer, n, a), n = 0, r[n], n++, r[n], n++, r[n], n++, r[n], n++;
    var s = [];
    n = t.CFF.readIndex(r, n, s);
    for (var l = [], c = 0; c < s.length - 1; c++) l.push(o.readASCII(r, n + s[c], s[c + 1] - s[c]));
    n += s[s.length - 1];
    var u = [];
    n = t.CFF.readIndex(r, n, u);
    for (var h = [], c = 0; c < u.length - 1; c++) h.push(t.CFF.readDict(r, n + u[c], n + u[c + 1]));
    n += u[u.length - 1];
    var f = h[0], d = [];
    n = t.CFF.readIndex(r, n, d);
    for (var p = [], c = 0; c < d.length - 1; c++) p.push(o.readASCII(r, n + d[c], d[c + 1] - d[c]));
    if (n += d[d.length - 1], t.CFF.readSubrs(r, n, f), f.CharStrings) {
      n = f.CharStrings;
      var d = [];
      n = t.CFF.readIndex(r, n, d);
      for (var g = [], c = 0; c < d.length - 1; c++) g.push(o.readBytes(r, n + d[c], d[c + 1] - d[c]));
      f.CharStrings = g;
    }
    if (f.ROS) {
      n = f.FDArray;
      var v = [];
      n = t.CFF.readIndex(r, n, v), f.FDArray = [];
      for (var c = 0; c < v.length - 1; c++) {
        var _ = t.CFF.readDict(r, n + v[c], n + v[c + 1]);
        t.CFF._readFDict(r, _, p), f.FDArray.push(_);
      }
      n += v[v.length - 1], n = f.FDSelect, f.FDSelect = [];
      var m = r[n];
      if (n++, m == 3) {
        var y = o.readUshort(r, n);
        n += 2;
        for (var c = 0; c < y + 1; c++)
          f.FDSelect.push(o.readUshort(r, n), r[n + 2]), n += 3;
      } else throw m;
    }
    return f.Encoding && (f.Encoding = t.CFF.readEncoding(r, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = t.CFF.readCharset(r, f.charset, f.CharStrings.length)), t.CFF._readFDict(r, f, p), f;
  }, t.CFF._readFDict = function(r, n, a) {
    var o;
    n.Private && (o = n.Private[1], n.Private = t.CFF.readDict(r, o, o + n.Private[0]), n.Private.Subrs && t.CFF.readSubrs(r, o + n.Private.Subrs, n.Private));
    for (var s in n) ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(s) != -1 && (n[s] = a[n[s] - 426 + 35]);
  }, t.CFF.readSubrs = function(r, n, a) {
    var o = t._bin, s = [];
    n = t.CFF.readIndex(r, n, s);
    var l, c = s.length;
    c < 1240 ? l = 107 : c < 33900 ? l = 1131 : l = 32768, a.Bias = l, a.Subrs = [];
    for (var u = 0; u < s.length - 1; u++) a.Subrs.push(o.readBytes(r, n + s[u], s[u + 1] - s[u]));
  }, t.CFF.tableSE = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    0,
    111,
    112,
    113,
    114,
    0,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    0,
    123,
    0,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131,
    0,
    132,
    133,
    0,
    134,
    135,
    136,
    137,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    138,
    0,
    139,
    0,
    0,
    0,
    0,
    140,
    141,
    142,
    143,
    0,
    0,
    0,
    0,
    0,
    144,
    0,
    0,
    0,
    145,
    0,
    0,
    146,
    147,
    148,
    149,
    0,
    0,
    0,
    0
  ], t.CFF.glyphByUnicode = function(r, n) {
    for (var a = 0; a < r.charset.length; a++) if (r.charset[a] == n) return a;
    return -1;
  }, t.CFF.glyphBySE = function(r, n) {
    return n < 0 || n > 255 ? -1 : t.CFF.glyphByUnicode(r, t.CFF.tableSE[n]);
  }, t.CFF.readEncoding = function(r, n, a) {
    t._bin;
    var o = [".notdef"], s = r[n];
    if (n++, s == 0) {
      var l = r[n];
      n++;
      for (var c = 0; c < l; c++) o.push(r[n + c]);
    } else throw "error: unknown encoding format: " + s;
    return o;
  }, t.CFF.readCharset = function(r, n, a) {
    var o = t._bin, s = [".notdef"], l = r[n];
    if (n++, l == 0)
      for (var c = 0; c < a; c++) {
        var u = o.readUshort(r, n);
        n += 2, s.push(u);
      }
    else if (l == 1 || l == 2)
      for (; s.length < a; ) {
        var u = o.readUshort(r, n);
        n += 2;
        var h = 0;
        l == 1 ? (h = r[n], n++) : (h = o.readUshort(r, n), n += 2);
        for (var c = 0; c <= h; c++)
          s.push(u), u++;
      }
    else throw "error: format: " + l;
    return s;
  }, t.CFF.readIndex = function(r, n, a) {
    var o = t._bin, s = o.readUshort(r, n) + 1;
    n += 2;
    var l = r[n];
    if (n++, l == 1) for (var c = 0; c < s; c++) a.push(r[n + c]);
    else if (l == 2) for (var c = 0; c < s; c++) a.push(o.readUshort(r, n + c * 2));
    else if (l == 3) for (var c = 0; c < s; c++) a.push(o.readUint(r, n + c * 3 - 1) & 16777215);
    else if (s != 1) throw "unsupported offset size: " + l + ", count: " + s;
    return n += s * l, n - 1;
  }, t.CFF.getCharString = function(r, n, a) {
    var o = t._bin, s = r[n], l = r[n + 1];
    r[n + 2], r[n + 3], r[n + 4];
    var c = 1, u = null, h = null;
    s <= 20 && (u = s, c = 1), s == 12 && (u = s * 100 + l, c = 2), 21 <= s && s <= 27 && (u = s, c = 1), s == 28 && (h = o.readShort(r, n + 1), c = 3), 29 <= s && s <= 31 && (u = s, c = 1), 32 <= s && s <= 246 && (h = s - 139, c = 1), 247 <= s && s <= 250 && (h = (s - 247) * 256 + l + 108, c = 2), 251 <= s && s <= 254 && (h = -(s - 251) * 256 - l - 108, c = 2), s == 255 && (h = o.readInt(r, n + 1) / 65535, c = 5), a.val = h ?? "o" + u, a.size = c;
  }, t.CFF.readCharString = function(r, n, a) {
    for (var o = n + a, s = t._bin, l = []; n < o; ) {
      var c = r[n], u = r[n + 1];
      r[n + 2], r[n + 3], r[n + 4];
      var h = 1, f = null, d = null;
      c <= 20 && (f = c, h = 1), c == 12 && (f = c * 100 + u, h = 2), (c == 19 || c == 20) && (f = c, h = 2), 21 <= c && c <= 27 && (f = c, h = 1), c == 28 && (d = s.readShort(r, n + 1), h = 3), 29 <= c && c <= 31 && (f = c, h = 1), 32 <= c && c <= 246 && (d = c - 139, h = 1), 247 <= c && c <= 250 && (d = (c - 247) * 256 + u + 108, h = 2), 251 <= c && c <= 254 && (d = -(c - 251) * 256 - u - 108, h = 2), c == 255 && (d = s.readInt(r, n + 1) / 65535, h = 5), l.push(d ?? "o" + f), n += h;
    }
    return l;
  }, t.CFF.readDict = function(r, n, a) {
    for (var o = t._bin, s = {}, l = []; n < a; ) {
      var c = r[n], u = r[n + 1];
      r[n + 2], r[n + 3], r[n + 4];
      var h = 1, f = null, d = null;
      if (c == 28 && (d = o.readShort(r, n + 1), h = 3), c == 29 && (d = o.readInt(r, n + 1), h = 5), 32 <= c && c <= 246 && (d = c - 139, h = 1), 247 <= c && c <= 250 && (d = (c - 247) * 256 + u + 108, h = 2), 251 <= c && c <= 254 && (d = -(c - 251) * 256 - u - 108, h = 2), c == 255)
        throw d = o.readInt(r, n + 1) / 65535, h = 5, "unknown number";
      if (c == 30) {
        var p = [];
        for (h = 1; ; ) {
          var g = r[n + h];
          h++;
          var v = g >> 4, _ = g & 15;
          if (v != 15 && p.push(v), _ != 15 && p.push(_), _ == 15) break;
        }
        for (var m = "", y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], b = 0; b < p.length; b++) m += y[p[b]];
        d = parseFloat(m);
      }
      if (c <= 21) {
        var M = [
          "version",
          "Notice",
          "FullName",
          "FamilyName",
          "Weight",
          "FontBBox",
          "BlueValues",
          "OtherBlues",
          "FamilyBlues",
          "FamilyOtherBlues",
          "StdHW",
          "StdVW",
          "escape",
          "UniqueID",
          "XUID",
          "charset",
          "Encoding",
          "CharStrings",
          "Private",
          "Subrs",
          "defaultWidthX",
          "nominalWidthX"
        ];
        if (f = M[c], h = 1, c == 12) {
          var M = [
            "Copyright",
            "isFixedPitch",
            "ItalicAngle",
            "UnderlinePosition",
            "UnderlineThickness",
            "PaintType",
            "CharstringType",
            "FontMatrix",
            "StrokeWidth",
            "BlueScale",
            "BlueShift",
            "BlueFuzz",
            "StemSnapH",
            "StemSnapV",
            "ForceBold",
            0,
            0,
            "LanguageGroup",
            "ExpansionFactor",
            "initialRandomSeed",
            "SyntheticBase",
            "PostScript",
            "BaseFontName",
            "BaseFontBlend",
            0,
            0,
            0,
            0,
            0,
            0,
            "ROS",
            "CIDFontVersion",
            "CIDFontRevision",
            "CIDFontType",
            "CIDCount",
            "UIDBase",
            "FDArray",
            "FDSelect",
            "FontName"
          ];
          f = M[u], h = 2;
        }
      }
      f != null ? (s[f] = l.length == 1 ? l[0] : l, l = []) : l.push(d), n += h;
    }
    return s;
  }, t.cmap = {}, t.cmap.parse = function(r, n, a) {
    r = new Uint8Array(r.buffer, n, a), n = 0;
    var o = t._bin, s = {};
    o.readUshort(r, n), n += 2;
    var l = o.readUshort(r, n);
    n += 2;
    var c = [];
    s.tables = [];
    for (var u = 0; u < l; u++) {
      var h = o.readUshort(r, n);
      n += 2;
      var f = o.readUshort(r, n);
      n += 2;
      var d = o.readUint(r, n);
      n += 4;
      var p = "p" + h + "e" + f, g = c.indexOf(d);
      if (g == -1) {
        g = s.tables.length;
        var v;
        c.push(d);
        var _ = o.readUshort(r, d);
        _ == 0 ? v = t.cmap.parse0(r, d) : _ == 4 ? v = t.cmap.parse4(r, d) : _ == 6 ? v = t.cmap.parse6(r, d) : _ == 12 ? v = t.cmap.parse12(r, d) : console.log("unknown format: " + _, h, f, d), s.tables.push(v);
      }
      if (s[p] != null) throw "multiple tables for one platform+encoding";
      s[p] = g;
    }
    return s;
  }, t.cmap.parse0 = function(r, n) {
    var a = t._bin, o = {};
    o.format = a.readUshort(r, n), n += 2;
    var s = a.readUshort(r, n);
    n += 2, a.readUshort(r, n), n += 2, o.map = [];
    for (var l = 0; l < s - 6; l++) o.map.push(r[n + l]);
    return o;
  }, t.cmap.parse4 = function(r, n) {
    var a = t._bin, o = n, s = {};
    s.format = a.readUshort(r, n), n += 2;
    var l = a.readUshort(r, n);
    n += 2, a.readUshort(r, n), n += 2;
    var c = a.readUshort(r, n);
    n += 2;
    var u = c / 2;
    s.searchRange = a.readUshort(r, n), n += 2, s.entrySelector = a.readUshort(r, n), n += 2, s.rangeShift = a.readUshort(r, n), n += 2, s.endCount = a.readUshorts(r, n, u), n += u * 2, n += 2, s.startCount = a.readUshorts(r, n, u), n += u * 2, s.idDelta = [];
    for (var h = 0; h < u; h++)
      s.idDelta.push(a.readShort(r, n)), n += 2;
    for (s.idRangeOffset = a.readUshorts(r, n, u), n += u * 2, s.glyphIdArray = []; n < o + l; )
      s.glyphIdArray.push(a.readUshort(r, n)), n += 2;
    return s;
  }, t.cmap.parse6 = function(r, n) {
    var a = t._bin, o = {};
    o.format = a.readUshort(r, n), n += 2, a.readUshort(r, n), n += 2, a.readUshort(r, n), n += 2, o.firstCode = a.readUshort(r, n), n += 2;
    var s = a.readUshort(r, n);
    n += 2, o.glyphIdArray = [];
    for (var l = 0; l < s; l++)
      o.glyphIdArray.push(a.readUshort(r, n)), n += 2;
    return o;
  }, t.cmap.parse12 = function(r, n) {
    var a = t._bin, o = {};
    o.format = a.readUshort(r, n), n += 2, n += 2, a.readUint(r, n), n += 4, a.readUint(r, n), n += 4;
    var s = a.readUint(r, n);
    n += 4, o.groups = [];
    for (var l = 0; l < s; l++) {
      var c = n + l * 12, u = a.readUint(r, c + 0), h = a.readUint(r, c + 4), f = a.readUint(r, c + 8);
      o.groups.push([u, h, f]);
    }
    return o;
  }, t.glyf = {}, t.glyf.parse = function(r, n, a, o) {
    for (var s = [], l = 0; l < o.maxp.numGlyphs; l++) s.push(null);
    return s;
  }, t.glyf._parseGlyf = function(r, n) {
    var a = t._bin, o = r._data, s = t._tabOffset(o, "glyf", r._offset) + r.loca[n];
    if (r.loca[n] == r.loca[n + 1]) return null;
    var l = {};
    if (l.noc = a.readShort(o, s), s += 2, l.xMin = a.readShort(o, s), s += 2, l.yMin = a.readShort(o, s), s += 2, l.xMax = a.readShort(o, s), s += 2, l.yMax = a.readShort(o, s), s += 2, l.xMin >= l.xMax || l.yMin >= l.yMax) return null;
    if (l.noc > 0) {
      l.endPts = [];
      for (var c = 0; c < l.noc; c++)
        l.endPts.push(a.readUshort(o, s)), s += 2;
      var u = a.readUshort(o, s);
      if (s += 2, o.length - s < u) return null;
      l.instructions = a.readBytes(o, s, u), s += u;
      var h = l.endPts[l.noc - 1] + 1;
      l.flags = [];
      for (var c = 0; c < h; c++) {
        var f = o[s];
        if (s++, l.flags.push(f), f & 8) {
          var d = o[s];
          s++;
          for (var p = 0; p < d; p++)
            l.flags.push(f), c++;
        }
      }
      l.xs = [];
      for (var c = 0; c < h; c++) {
        var g = (l.flags[c] & 2) != 0, v = (l.flags[c] & 16) != 0;
        g ? (l.xs.push(v ? o[s] : -o[s]), s++) : v ? l.xs.push(0) : (l.xs.push(a.readShort(o, s)), s += 2);
      }
      l.ys = [];
      for (var c = 0; c < h; c++) {
        var g = (l.flags[c] & 4) != 0, v = (l.flags[c] & 32) != 0;
        g ? (l.ys.push(v ? o[s] : -o[s]), s++) : v ? l.ys.push(0) : (l.ys.push(a.readShort(o, s)), s += 2);
      }
      for (var _ = 0, m = 0, c = 0; c < h; c++)
        _ += l.xs[c], m += l.ys[c], l.xs[c] = _, l.ys[c] = m;
    } else {
      var y = 1, b = 2, M = 8, x = 32, w = 64, P = 128, V = 256;
      l.parts = [];
      var I;
      do {
        I = a.readUshort(o, s), s += 2;
        var $ = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
        if (l.parts.push($), $.glyphIndex = a.readUshort(o, s), s += 2, I & y) {
          var E = a.readShort(o, s);
          s += 2;
          var G = a.readShort(o, s);
          s += 2;
        } else {
          var E = a.readInt8(o, s);
          s++;
          var G = a.readInt8(o, s);
          s++;
        }
        I & b ? ($.m.tx = E, $.m.ty = G) : ($.p1 = E, $.p2 = G), I & M ? ($.m.a = $.m.d = a.readF2dot14(o, s), s += 2) : I & w ? ($.m.a = a.readF2dot14(o, s), s += 2, $.m.d = a.readF2dot14(o, s), s += 2) : I & P && ($.m.a = a.readF2dot14(o, s), s += 2, $.m.b = a.readF2dot14(o, s), s += 2, $.m.c = a.readF2dot14(o, s), s += 2, $.m.d = a.readF2dot14(o, s), s += 2);
      } while (I & x);
      if (I & V) {
        var O = a.readUshort(o, s);
        s += 2, l.instr = [];
        for (var c = 0; c < O; c++)
          l.instr.push(o[s]), s++;
      }
    }
    return l;
  }, t.GPOS = {}, t.GPOS.parse = function(r, n, a, o) {
    return t._lctf.parse(r, n, a, o, t.GPOS.subt);
  }, t.GPOS.subt = function(r, n, a) {
    var o = t._bin, s = a, l = {};
    if (l.fmt = o.readUshort(r, a), a += 2, n == 1 || n == 2 || n == 3 || n == 7 || n == 8 && l.fmt <= 2) {
      var c = o.readUshort(r, a);
      a += 2, l.coverage = t._lctf.readCoverage(r, c + s);
    }
    if (n == 1 && l.fmt == 1) {
      var u = o.readUshort(r, a);
      a += 2;
      var h = t._lctf.numOfOnes(u);
      u != 0 && (l.pos = t.GPOS.readValueRecord(r, a, u));
    } else if (n == 2) {
      var u = o.readUshort(r, a);
      a += 2;
      var f = o.readUshort(r, a);
      a += 2;
      var h = t._lctf.numOfOnes(u), d = t._lctf.numOfOnes(f);
      if (l.fmt == 1) {
        l.pairsets = [];
        var p = o.readUshort(r, a);
        a += 2;
        for (var g = 0; g < p; g++) {
          var v = s + o.readUshort(r, a);
          a += 2;
          var _ = o.readUshort(r, v);
          v += 2;
          for (var m = [], y = 0; y < _; y++) {
            var b = o.readUshort(r, v);
            v += 2;
            var M, x;
            u != 0 && (M = t.GPOS.readValueRecord(r, v, u), v += h * 2), f != 0 && (x = t.GPOS.readValueRecord(r, v, f), v += d * 2), m.push({ gid2: b, val1: M, val2: x });
          }
          l.pairsets.push(m);
        }
      }
      if (l.fmt == 2) {
        var w = o.readUshort(r, a);
        a += 2;
        var P = o.readUshort(r, a);
        a += 2;
        var V = o.readUshort(r, a);
        a += 2;
        var I = o.readUshort(r, a);
        a += 2, l.classDef1 = t._lctf.readClassDef(r, s + w), l.classDef2 = t._lctf.readClassDef(r, s + P), l.matrix = [];
        for (var g = 0; g < V; g++) {
          for (var $ = [], y = 0; y < I; y++) {
            var M = null, x = null;
            l.valFmt1 != 0 && (M = t.GPOS.readValueRecord(r, a, l.valFmt1), a += h * 2), l.valFmt2 != 0 && (x = t.GPOS.readValueRecord(r, a, l.valFmt2), a += d * 2), $.push({ val1: M, val2: x });
          }
          l.matrix.push($);
        }
      }
    }
    return l;
  }, t.GPOS.readValueRecord = function(r, n, a) {
    var o = t._bin, s = [];
    return s.push(a & 1 ? o.readShort(r, n) : 0), n += a & 1 ? 2 : 0, s.push(a & 2 ? o.readShort(r, n) : 0), n += a & 2 ? 2 : 0, s.push(a & 4 ? o.readShort(r, n) : 0), n += a & 4 ? 2 : 0, s.push(a & 8 ? o.readShort(r, n) : 0), n += a & 8 ? 2 : 0, s;
  }, t.GSUB = {}, t.GSUB.parse = function(r, n, a, o) {
    return t._lctf.parse(r, n, a, o, t.GSUB.subt);
  }, t.GSUB.subt = function(r, n, a) {
    var o = t._bin, s = a, l = {};
    if (l.fmt = o.readUshort(r, a), a += 2, n != 1 && n != 4 && n != 5 && n != 6) return null;
    if (n == 1 || n == 4 || n == 5 && l.fmt <= 2 || n == 6 && l.fmt <= 2) {
      var c = o.readUshort(r, a);
      a += 2, l.coverage = t._lctf.readCoverage(r, s + c);
    }
    if (n == 1) {
      if (l.fmt == 1)
        l.delta = o.readShort(r, a), a += 2;
      else if (l.fmt == 2) {
        var u = o.readUshort(r, a);
        a += 2, l.newg = o.readUshorts(r, a, u), a += l.newg.length * 2;
      }
    } else if (n == 4) {
      l.vals = [];
      var u = o.readUshort(r, a);
      a += 2;
      for (var h = 0; h < u; h++) {
        var f = o.readUshort(r, a);
        a += 2, l.vals.push(t.GSUB.readLigatureSet(r, s + f));
      }
    } else if (n == 5) {
      if (l.fmt == 2) {
        var d = o.readUshort(r, a);
        a += 2, l.cDef = t._lctf.readClassDef(r, s + d), l.scset = [];
        var p = o.readUshort(r, a);
        a += 2;
        for (var h = 0; h < p; h++) {
          var g = o.readUshort(r, a);
          a += 2, l.scset.push(g == 0 ? null : t.GSUB.readSubClassSet(r, s + g));
        }
      }
    } else if (n == 6 && l.fmt == 3) {
      for (var h = 0; h < 3; h++) {
        var u = o.readUshort(r, a);
        a += 2;
        for (var v = [], _ = 0; _ < u; _++) v.push(t._lctf.readCoverage(r, s + o.readUshort(r, a + _ * 2)));
        a += u * 2, h == 0 && (l.backCvg = v), h == 1 && (l.inptCvg = v), h == 2 && (l.ahedCvg = v);
      }
      var u = o.readUshort(r, a);
      a += 2, l.lookupRec = t.GSUB.readSubstLookupRecords(r, a, u);
    }
    return l;
  }, t.GSUB.readSubClassSet = function(r, n) {
    var a = t._bin.readUshort, o = n, s = [], l = a(r, n);
    n += 2;
    for (var c = 0; c < l; c++) {
      var u = a(r, n);
      n += 2, s.push(t.GSUB.readSubClassRule(r, o + u));
    }
    return s;
  }, t.GSUB.readSubClassRule = function(r, n) {
    var a = t._bin.readUshort, o = {}, s = a(r, n);
    n += 2;
    var l = a(r, n);
    n += 2, o.input = [];
    for (var c = 0; c < s - 1; c++)
      o.input.push(a(r, n)), n += 2;
    return o.substLookupRecords = t.GSUB.readSubstLookupRecords(r, n, l), o;
  }, t.GSUB.readSubstLookupRecords = function(r, n, a) {
    for (var o = t._bin.readUshort, s = [], l = 0; l < a; l++)
      s.push(o(r, n), o(r, n + 2)), n += 4;
    return s;
  }, t.GSUB.readChainSubClassSet = function(r, n) {
    var a = t._bin, o = n, s = [], l = a.readUshort(r, n);
    n += 2;
    for (var c = 0; c < l; c++) {
      var u = a.readUshort(r, n);
      n += 2, s.push(t.GSUB.readChainSubClassRule(r, o + u));
    }
    return s;
  }, t.GSUB.readChainSubClassRule = function(r, n) {
    for (var a = t._bin, o = {}, s = ["backtrack", "input", "lookahead"], l = 0; l < s.length; l++) {
      var c = a.readUshort(r, n);
      n += 2, l == 1 && c--, o[s[l]] = a.readUshorts(r, n, c), n += o[s[l]].length * 2;
    }
    var c = a.readUshort(r, n);
    return n += 2, o.subst = a.readUshorts(r, n, c * 2), n += o.subst.length * 2, o;
  }, t.GSUB.readLigatureSet = function(r, n) {
    var a = t._bin, o = n, s = [], l = a.readUshort(r, n);
    n += 2;
    for (var c = 0; c < l; c++) {
      var u = a.readUshort(r, n);
      n += 2, s.push(t.GSUB.readLigature(r, o + u));
    }
    return s;
  }, t.GSUB.readLigature = function(r, n) {
    var a = t._bin, o = { chain: [] };
    o.nglyph = a.readUshort(r, n), n += 2;
    var s = a.readUshort(r, n);
    n += 2;
    for (var l = 0; l < s - 1; l++)
      o.chain.push(a.readUshort(r, n)), n += 2;
    return o;
  }, t.head = {}, t.head.parse = function(r, n, a) {
    var o = t._bin, s = {};
    return o.readFixed(r, n), n += 4, s.fontRevision = o.readFixed(r, n), n += 4, o.readUint(r, n), n += 4, o.readUint(r, n), n += 4, s.flags = o.readUshort(r, n), n += 2, s.unitsPerEm = o.readUshort(r, n), n += 2, s.created = o.readUint64(r, n), n += 8, s.modified = o.readUint64(r, n), n += 8, s.xMin = o.readShort(r, n), n += 2, s.yMin = o.readShort(r, n), n += 2, s.xMax = o.readShort(r, n), n += 2, s.yMax = o.readShort(r, n), n += 2, s.macStyle = o.readUshort(r, n), n += 2, s.lowestRecPPEM = o.readUshort(r, n), n += 2, s.fontDirectionHint = o.readShort(r, n), n += 2, s.indexToLocFormat = o.readShort(r, n), n += 2, s.glyphDataFormat = o.readShort(r, n), n += 2, s;
  }, t.hhea = {}, t.hhea.parse = function(r, n, a) {
    var o = t._bin, s = {};
    return o.readFixed(r, n), n += 4, s.ascender = o.readShort(r, n), n += 2, s.descender = o.readShort(r, n), n += 2, s.lineGap = o.readShort(r, n), n += 2, s.advanceWidthMax = o.readUshort(r, n), n += 2, s.minLeftSideBearing = o.readShort(r, n), n += 2, s.minRightSideBearing = o.readShort(r, n), n += 2, s.xMaxExtent = o.readShort(r, n), n += 2, s.caretSlopeRise = o.readShort(r, n), n += 2, s.caretSlopeRun = o.readShort(r, n), n += 2, s.caretOffset = o.readShort(r, n), n += 2, n += 4 * 2, s.metricDataFormat = o.readShort(r, n), n += 2, s.numberOfHMetrics = o.readUshort(r, n), n += 2, s;
  }, t.hmtx = {}, t.hmtx.parse = function(r, n, a, o) {
    var s = t._bin, l = {};
    l.aWidth = [], l.lsBearing = [];
    for (var c = 0, u = 0, h = 0; h < o.maxp.numGlyphs; h++)
      h < o.hhea.numberOfHMetrics && (c = s.readUshort(r, n), n += 2, u = s.readShort(r, n), n += 2), l.aWidth.push(c), l.lsBearing.push(u);
    return l;
  }, t.kern = {}, t.kern.parse = function(r, n, a, o) {
    var s = t._bin, l = s.readUshort(r, n);
    if (n += 2, l == 1) return t.kern.parseV1(r, n - 2, a, o);
    var c = s.readUshort(r, n);
    n += 2;
    for (var u = { glyph1: [], rval: [] }, h = 0; h < c; h++) {
      n += 2;
      var a = s.readUshort(r, n);
      n += 2;
      var f = s.readUshort(r, n);
      n += 2;
      var d = f >>> 8;
      if (d &= 15, d == 0) n = t.kern.readFormat0(r, n, u);
      else throw "unknown kern table format: " + d;
    }
    return u;
  }, t.kern.parseV1 = function(r, n, a, o) {
    var s = t._bin;
    s.readFixed(r, n), n += 4;
    var l = s.readUint(r, n);
    n += 4;
    for (var c = { glyph1: [], rval: [] }, u = 0; u < l; u++) {
      s.readUint(r, n), n += 4;
      var h = s.readUshort(r, n);
      n += 2, s.readUshort(r, n), n += 2;
      var f = h >>> 8;
      if (f &= 15, f == 0) n = t.kern.readFormat0(r, n, c);
      else throw "unknown kern table format: " + f;
    }
    return c;
  }, t.kern.readFormat0 = function(r, n, a) {
    var o = t._bin, s = -1, l = o.readUshort(r, n);
    n += 2, o.readUshort(r, n), n += 2, o.readUshort(r, n), n += 2, o.readUshort(r, n), n += 2;
    for (var c = 0; c < l; c++) {
      var u = o.readUshort(r, n);
      n += 2;
      var h = o.readUshort(r, n);
      n += 2;
      var f = o.readShort(r, n);
      n += 2, u != s && (a.glyph1.push(u), a.rval.push({ glyph2: [], vals: [] }));
      var d = a.rval[a.rval.length - 1];
      d.glyph2.push(h), d.vals.push(f), s = u;
    }
    return n;
  }, t.loca = {}, t.loca.parse = function(r, n, a, o) {
    var s = t._bin, l = [], c = o.head.indexToLocFormat, u = o.maxp.numGlyphs + 1;
    if (c == 0) for (var h = 0; h < u; h++) l.push(s.readUshort(r, n + (h << 1)) << 1);
    if (c == 1) for (var h = 0; h < u; h++) l.push(s.readUint(r, n + (h << 2)));
    return l;
  }, t.maxp = {}, t.maxp.parse = function(r, n, a) {
    var o = t._bin, s = {}, l = o.readUint(r, n);
    return n += 4, s.numGlyphs = o.readUshort(r, n), n += 2, l == 65536 && (s.maxPoints = o.readUshort(r, n), n += 2, s.maxContours = o.readUshort(r, n), n += 2, s.maxCompositePoints = o.readUshort(r, n), n += 2, s.maxCompositeContours = o.readUshort(r, n), n += 2, s.maxZones = o.readUshort(r, n), n += 2, s.maxTwilightPoints = o.readUshort(r, n), n += 2, s.maxStorage = o.readUshort(r, n), n += 2, s.maxFunctionDefs = o.readUshort(r, n), n += 2, s.maxInstructionDefs = o.readUshort(r, n), n += 2, s.maxStackElements = o.readUshort(r, n), n += 2, s.maxSizeOfInstructions = o.readUshort(r, n), n += 2, s.maxComponentElements = o.readUshort(r, n), n += 2, s.maxComponentDepth = o.readUshort(r, n), n += 2), s;
  }, t.name = {}, t.name.parse = function(r, n, a) {
    var o = t._bin, s = {};
    o.readUshort(r, n), n += 2;
    var l = o.readUshort(r, n);
    n += 2, o.readUshort(r, n), n += 2;
    for (var c = [
      "copyright",
      "fontFamily",
      "fontSubfamily",
      "ID",
      "fullName",
      "version",
      "postScriptName",
      "trademark",
      "manufacturer",
      "designer",
      "description",
      "urlVendor",
      "urlDesigner",
      "licence",
      "licenceURL",
      "---",
      "typoFamilyName",
      "typoSubfamilyName",
      "compatibleFull",
      "sampleText",
      "postScriptCID",
      "wwsFamilyName",
      "wwsSubfamilyName",
      "lightPalette",
      "darkPalette"
    ], u = n, h = 0; h < l; h++) {
      var f = o.readUshort(r, n);
      n += 2;
      var d = o.readUshort(r, n);
      n += 2;
      var p = o.readUshort(r, n);
      n += 2;
      var g = o.readUshort(r, n);
      n += 2;
      var v = o.readUshort(r, n);
      n += 2;
      var _ = o.readUshort(r, n);
      n += 2;
      var m = c[g], y = u + l * 12 + _, b;
      if (f == 0) b = o.readUnicode(r, y, v / 2);
      else if (f == 3 && d == 0) b = o.readUnicode(r, y, v / 2);
      else if (d == 0) b = o.readASCII(r, y, v);
      else if (d == 1) b = o.readUnicode(r, y, v / 2);
      else if (d == 3) b = o.readUnicode(r, y, v / 2);
      else if (f == 1)
        b = o.readASCII(r, y, v), console.log("reading unknown MAC encoding " + d + " as ASCII");
      else throw "unknown encoding " + d + ", platformID: " + f;
      var M = "p" + f + "," + p.toString(16);
      s[M] == null && (s[M] = {}), s[M][m] = b, s[M]._lang = p;
    }
    for (var x in s) if (s[x].postScriptName != null && s[x]._lang == 1033) return s[x];
    for (var x in s) if (s[x].postScriptName != null && s[x]._lang == 0) return s[x];
    for (var x in s) if (s[x].postScriptName != null && s[x]._lang == 3084) return s[x];
    for (var x in s) if (s[x].postScriptName != null) return s[x];
    var w;
    for (var x in s) {
      w = x;
      break;
    }
    return console.log("returning name table with languageID " + s[w]._lang), s[w];
  }, t["OS/2"] = {}, t["OS/2"].parse = function(r, n, a) {
    var o = t._bin, s = o.readUshort(r, n);
    n += 2;
    var l = {};
    if (s == 0) t["OS/2"].version0(r, n, l);
    else if (s == 1) t["OS/2"].version1(r, n, l);
    else if (s == 2 || s == 3 || s == 4) t["OS/2"].version2(r, n, l);
    else if (s == 5) t["OS/2"].version5(r, n, l);
    else throw "unknown OS/2 table version: " + s;
    return l;
  }, t["OS/2"].version0 = function(r, n, a) {
    var o = t._bin;
    return a.xAvgCharWidth = o.readShort(r, n), n += 2, a.usWeightClass = o.readUshort(r, n), n += 2, a.usWidthClass = o.readUshort(r, n), n += 2, a.fsType = o.readUshort(r, n), n += 2, a.ySubscriptXSize = o.readShort(r, n), n += 2, a.ySubscriptYSize = o.readShort(r, n), n += 2, a.ySubscriptXOffset = o.readShort(r, n), n += 2, a.ySubscriptYOffset = o.readShort(r, n), n += 2, a.ySuperscriptXSize = o.readShort(r, n), n += 2, a.ySuperscriptYSize = o.readShort(r, n), n += 2, a.ySuperscriptXOffset = o.readShort(r, n), n += 2, a.ySuperscriptYOffset = o.readShort(r, n), n += 2, a.yStrikeoutSize = o.readShort(r, n), n += 2, a.yStrikeoutPosition = o.readShort(r, n), n += 2, a.sFamilyClass = o.readShort(r, n), n += 2, a.panose = o.readBytes(r, n, 10), n += 10, a.ulUnicodeRange1 = o.readUint(r, n), n += 4, a.ulUnicodeRange2 = o.readUint(r, n), n += 4, a.ulUnicodeRange3 = o.readUint(r, n), n += 4, a.ulUnicodeRange4 = o.readUint(r, n), n += 4, a.achVendID = [o.readInt8(r, n), o.readInt8(r, n + 1), o.readInt8(r, n + 2), o.readInt8(r, n + 3)], n += 4, a.fsSelection = o.readUshort(r, n), n += 2, a.usFirstCharIndex = o.readUshort(r, n), n += 2, a.usLastCharIndex = o.readUshort(r, n), n += 2, a.sTypoAscender = o.readShort(r, n), n += 2, a.sTypoDescender = o.readShort(r, n), n += 2, a.sTypoLineGap = o.readShort(r, n), n += 2, a.usWinAscent = o.readUshort(r, n), n += 2, a.usWinDescent = o.readUshort(r, n), n += 2, n;
  }, t["OS/2"].version1 = function(r, n, a) {
    var o = t._bin;
    return n = t["OS/2"].version0(r, n, a), a.ulCodePageRange1 = o.readUint(r, n), n += 4, a.ulCodePageRange2 = o.readUint(r, n), n += 4, n;
  }, t["OS/2"].version2 = function(r, n, a) {
    var o = t._bin;
    return n = t["OS/2"].version1(r, n, a), a.sxHeight = o.readShort(r, n), n += 2, a.sCapHeight = o.readShort(r, n), n += 2, a.usDefault = o.readUshort(r, n), n += 2, a.usBreak = o.readUshort(r, n), n += 2, a.usMaxContext = o.readUshort(r, n), n += 2, n;
  }, t["OS/2"].version5 = function(r, n, a) {
    var o = t._bin;
    return n = t["OS/2"].version2(r, n, a), a.usLowerOpticalPointSize = o.readUshort(r, n), n += 2, a.usUpperOpticalPointSize = o.readUshort(r, n), n += 2, n;
  }, t.post = {}, t.post.parse = function(r, n, a) {
    var o = t._bin, s = {};
    return s.version = o.readFixed(r, n), n += 4, s.italicAngle = o.readFixed(r, n), n += 4, s.underlinePosition = o.readShort(r, n), n += 2, s.underlineThickness = o.readShort(r, n), n += 2, s;
  }, t.SVG = {}, t.SVG.parse = function(r, n, a) {
    var o = t._bin, s = { entries: [] }, l = n;
    o.readUshort(r, n), n += 2;
    var c = o.readUint(r, n);
    n += 4, o.readUint(r, n), n += 4, n = c + l;
    var u = o.readUshort(r, n);
    n += 2;
    for (var h = 0; h < u; h++) {
      var f = o.readUshort(r, n);
      n += 2;
      var d = o.readUshort(r, n);
      n += 2;
      var p = o.readUint(r, n);
      n += 4;
      var g = o.readUint(r, n);
      n += 4;
      for (var v = new Uint8Array(r.buffer, l + p + c, g), _ = o.readUTF8(v, 0, v.length), m = f; m <= d; m++)
        s.entries[m] = _;
    }
    return s;
  }, t.SVG.toPath = function(r) {
    var n = { cmds: [], crds: [] };
    if (r == null) return n;
    for (var a = new DOMParser(), o = a.parseFromString(r, "image/svg+xml"), s = o.firstChild; s.tagName != "svg"; ) s = s.nextSibling;
    var l = s.getAttribute("viewBox");
    l ? l = l.trim().split(" ").map(parseFloat) : l = [0, 0, 1e3, 1e3], t.SVG._toPath(s.children, n);
    for (var c = 0; c < n.crds.length; c += 2) {
      var u = n.crds[c], h = n.crds[c + 1];
      u -= l[0], h -= l[1], h = -h, n.crds[c] = u, n.crds[c + 1] = h;
    }
    return n;
  }, t.SVG._toPath = function(r, n, a) {
    for (var o = 0; o < r.length; o++) {
      var s = r[o], l = s.tagName, c = s.getAttribute("fill");
      if (c == null && (c = a), l == "g") t.SVG._toPath(s.children, n, c);
      else if (l == "path") {
        n.cmds.push(c || "#000000");
        var u = s.getAttribute("d"), h = t.SVG._tokens(u);
        t.SVG._toksToPath(h, n), n.cmds.push("X");
      } else l == "defs" || console.log(l, s);
    }
  }, t.SVG._tokens = function(r) {
    for (var n = [], a = 0, o = !1, s = ""; a < r.length; ) {
      var l = r.charCodeAt(a), c = r.charAt(a);
      a++;
      var u = 48 <= l && l <= 57 || c == "." || c == "-";
      o ? c == "-" ? (n.push(parseFloat(s)), s = c) : u ? s += c : (n.push(parseFloat(s)), c != "," && c != " " && n.push(c), o = !1) : u ? (s = c, o = !0) : c != "," && c != " " && n.push(c);
    }
    return o && n.push(parseFloat(s)), n;
  }, t.SVG._toksToPath = function(r, n) {
    for (var a = 0, o = 0, s = 0, l = 0, c = 0, u = { M: 2, L: 2, H: 1, V: 1, S: 4, C: 6 }, h = n.cmds, f = n.crds; a < r.length; ) {
      var d = r[a];
      if (a++, d == "z")
        h.push("Z"), o = l, s = c;
      else
        for (var p = d.toUpperCase(), g = u[p], v = t.SVG._reps(r, a, g), _ = 0; _ < v; _++) {
          var m = 0, y = 0;
          if (d != p && (m = o, y = s), p == "M")
            o = m + r[a++], s = y + r[a++], h.push("M"), f.push(o, s), l = o, c = s;
          else if (p == "L")
            o = m + r[a++], s = y + r[a++], h.push("L"), f.push(o, s);
          else if (p == "H")
            o = m + r[a++], h.push("L"), f.push(o, s);
          else if (p == "V")
            s = y + r[a++], h.push("L"), f.push(o, s);
          else if (p == "C") {
            var b = m + r[a++], M = y + r[a++], x = m + r[a++], w = y + r[a++], P = m + r[a++], V = y + r[a++];
            h.push("C"), f.push(b, M, x, w, P, V), o = P, s = V;
          } else if (p == "S") {
            var I = Math.max(f.length - 4, 0), b = o + o - f[I], M = s + s - f[I + 1], x = m + r[a++], w = y + r[a++], P = m + r[a++], V = y + r[a++];
            h.push("C"), f.push(b, M, x, w, P, V), o = P, s = V;
          } else console.log("Unknown SVG command " + d);
        }
    }
  }, t.SVG._reps = function(r, n, a) {
    for (var o = n; o < r.length && typeof r[o] != "string"; )
      o += a;
    return (o - n) / a;
  }, t == null && (t = {}), t.U == null && (t.U = {}), t.U.codeToGlyph = function(r, n) {
    var a = r.cmap, o = -1;
    if (a.p0e4 != null ? o = a.p0e4 : a.p3e1 != null ? o = a.p3e1 : a.p1e0 != null ? o = a.p1e0 : a.p0e3 != null && (o = a.p0e3), o == -1) throw "no familiar platform and encoding!";
    var s = a.tables[o];
    if (s.format == 0)
      return n >= s.map.length ? 0 : s.map[n];
    if (s.format == 4) {
      for (var l = -1, c = 0; c < s.endCount.length; c++) if (n <= s.endCount[c]) {
        l = c;
        break;
      }
      if (l == -1 || s.startCount[l] > n) return 0;
      var u = 0;
      return s.idRangeOffset[l] != 0 ? u = s.glyphIdArray[n - s.startCount[l] + (s.idRangeOffset[l] >> 1) - (s.idRangeOffset.length - l)] : u = n + s.idDelta[l], u & 65535;
    } else if (s.format == 12) {
      if (n > s.groups[s.groups.length - 1][1]) return 0;
      for (var c = 0; c < s.groups.length; c++) {
        var h = s.groups[c];
        if (h[0] <= n && n <= h[1]) return h[2] + (n - h[0]);
      }
      return 0;
    } else throw "unknown cmap table format " + s.format;
  }, t.U.glyphToPath = function(r, n) {
    var a = { cmds: [], crds: [] };
    if (r.SVG && r.SVG.entries[n]) {
      var o = r.SVG.entries[n];
      return o == null ? a : (typeof o == "string" && (o = t.SVG.toPath(o), r.SVG.entries[n] = o), o);
    } else if (r.CFF) {
      var s = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: r.CFF.Private ? r.CFF.Private.defaultWidthX : 0, open: !1 }, l = r.CFF, c = r.CFF.Private;
      if (l.ROS) {
        for (var u = 0; l.FDSelect[u + 2] <= n; ) u += 2;
        c = l.FDArray[l.FDSelect[u + 1]].Private;
      }
      t.U._drawCFF(r.CFF.CharStrings[n], s, l, c, a);
    } else r.glyf && t.U._drawGlyf(n, r, a);
    return a;
  }, t.U._drawGlyf = function(r, n, a) {
    var o = n.glyf[r];
    o == null && (o = n.glyf[r] = t.glyf._parseGlyf(n, r)), o != null && (o.noc > -1 ? t.U._simpleGlyph(o, a) : t.U._compoGlyph(o, n, a));
  }, t.U._simpleGlyph = function(r, n) {
    for (var a = 0; a < r.noc; a++) {
      for (var o = a == 0 ? 0 : r.endPts[a - 1] + 1, s = r.endPts[a], l = o; l <= s; l++) {
        var c = l == o ? s : l - 1, u = l == s ? o : l + 1, h = r.flags[l] & 1, f = r.flags[c] & 1, d = r.flags[u] & 1, p = r.xs[l], g = r.ys[l];
        if (l == o)
          if (h)
            if (f) t.U.P.moveTo(n, r.xs[c], r.ys[c]);
            else {
              t.U.P.moveTo(n, p, g);
              continue;
            }
          else
            f ? t.U.P.moveTo(n, r.xs[c], r.ys[c]) : t.U.P.moveTo(n, (r.xs[c] + p) / 2, (r.ys[c] + g) / 2);
        h ? f && t.U.P.lineTo(n, p, g) : d ? t.U.P.qcurveTo(n, p, g, r.xs[u], r.ys[u]) : t.U.P.qcurveTo(n, p, g, (p + r.xs[u]) / 2, (g + r.ys[u]) / 2);
      }
      t.U.P.closePath(n);
    }
  }, t.U._compoGlyph = function(r, n, a) {
    for (var o = 0; o < r.parts.length; o++) {
      var s = { cmds: [], crds: [] }, l = r.parts[o];
      t.U._drawGlyf(l.glyphIndex, n, s);
      for (var c = l.m, u = 0; u < s.crds.length; u += 2) {
        var h = s.crds[u], f = s.crds[u + 1];
        a.crds.push(h * c.a + f * c.b + c.tx), a.crds.push(h * c.c + f * c.d + c.ty);
      }
      for (var u = 0; u < s.cmds.length; u++) a.cmds.push(s.cmds[u]);
    }
  }, t.U._getGlyphClass = function(r, n) {
    var a = t._lctf.getInterval(n, r);
    return a == -1 ? 0 : n[a + 2];
  }, t.U.getPairAdjustment = function(r, n, a) {
    if (r.GPOS)
      for (var o = r.GPOS, s = o.lookupList, l = o.featureList, c = [], u = 0; u < l.length; u++) {
        var h = l[u];
        if (h.tag == "kern") {
          for (var f = 0; f < h.tab.length; f++)
            if (!c[h.tab[f]]) {
              c[h.tab[f]] = !0;
              for (var d = s[h.tab[f]], p = 0; p < d.tabs.length; p++)
                if (d.tabs[u] != null) {
                  var g = d.tabs[p], v;
                  if (!(g.coverage && (v = t._lctf.coverageIndex(g.coverage, n), v == -1)) && d.ltype != 1) {
                    if (d.ltype == 2) {
                      var _;
                      if (g.fmt == 1)
                        for (var m = g.pairsets[v], u = 0; u < m.length; u++) m[u].gid2 == a && (_ = m[u]);
                      else if (g.fmt == 2) {
                        var y = t.U._getGlyphClass(n, g.classDef1), b = t.U._getGlyphClass(a, g.classDef2);
                        _ = g.matrix[y][b];
                      }
                      if (_ && _.val2) return _.val2[2];
                    }
                  }
                }
            }
        }
      }
    if (r.kern) {
      var M = r.kern.glyph1.indexOf(n);
      if (M != -1) {
        var x = r.kern.rval[M].glyph2.indexOf(a);
        if (x != -1) return r.kern.rval[M].vals[x];
      }
    }
    return 0;
  }, t.U.stringToGlyphs = function(r, n) {
    for (var a = [], o = 0; o < n.length; o++) {
      var s = n.codePointAt(o);
      s > 65535 && o++, a.push(t.U.codeToGlyph(r, s));
    }
    for (var o = 0; o < n.length; o++) {
      var s = n.codePointAt(o);
      if (s == 2367) {
        var l = a[o - 1];
        a[o - 1] = a[o], a[o] = l;
      }
      s > 65535 && o++;
    }
    var c = r.GSUB;
    if (c == null) return a;
    for (var u = c.lookupList, h = c.featureList, f = [
      "rlig",
      "liga",
      "mset",
      "isol",
      "init",
      "fina",
      "medi",
      "half",
      "pres",
      "blws"
      /* Tibetan fonts like Himalaya.ttf */
    ], d = [], p = 0; p < h.length; p++) {
      var g = h[p];
      if (f.indexOf(g.tag) != -1) {
        for (var v = 0; v < g.tab.length; v++)
          if (!d[g.tab[v]]) {
            d[g.tab[v]] = !0;
            for (var _ = u[g.tab[v]], m = 0; m < a.length; m++) {
              var y = t.U._getWPfeature(n, m);
              "isol,init,fina,medi".indexOf(g.tag) != -1 && g.tag != y || t.U._applySubs(a, m, _, u);
            }
          }
      }
    }
    return a;
  }, t.U._getWPfeature = function(r, n) {
    var a = `
	" ,.:;!?()  ،`, o = "آأؤإاةدذرزوٱٲٳٵٶٷڈډڊڋڌڍڎڏڐڑڒړڔڕږڗژڙۀۃۄۅۆۇۈۉۊۋۍۏےۓەۮۯܐܕܖܗܘܙܞܨܪܬܯݍݙݚݛݫݬݱݳݴݸݹࡀࡆࡇࡉࡔࡧࡩࡪࢪࢫࢬࢮࢱࢲࢹૅેૉ૊૎૏ૐ૑૒૝ૡ૤૯஁ஃ஄அஉ஌எஏ஑னப஫஬", s = "ꡲ્૗", l = n == 0 || a.indexOf(r[n - 1]) != -1, c = n == r.length - 1 || a.indexOf(r[n + 1]) != -1;
    !l && o.indexOf(r[n - 1]) != -1 && (l = !0), !c && o.indexOf(r[n]) != -1 && (c = !0), !c && s.indexOf(r[n + 1]) != -1 && (c = !0), !l && s.indexOf(r[n]) != -1 && (l = !0);
    var u = null;
    return l ? u = c ? "isol" : "init" : u = c ? "fina" : "medi", u;
  }, t.U._applySubs = function(r, n, a, o) {
    for (var s = r.length - n - 1, l = 0; l < a.tabs.length; l++)
      if (a.tabs[l] != null) {
        var c = a.tabs[l], u;
        if (!(c.coverage && (u = t._lctf.coverageIndex(c.coverage, r[n]), u == -1))) {
          if (a.ltype == 1)
            r[n], c.fmt == 1 ? r[n] = r[n] + c.delta : r[n] = c.newg[u];
          else if (a.ltype == 4)
            for (var h = c.vals[u], f = 0; f < h.length; f++) {
              var d = h[f], p = d.chain.length;
              if (!(p > s)) {
                for (var g = !0, v = 0, _ = 0; _ < p; _++) {
                  for (; r[n + v + (1 + _)] == -1; ) v++;
                  d.chain[_] != r[n + v + (1 + _)] && (g = !1);
                }
                if (g) {
                  r[n] = d.nglyph;
                  for (var _ = 0; _ < p + v; _++) r[n + _ + 1] = -1;
                  break;
                }
              }
            }
          else if (a.ltype == 5 && c.fmt == 2)
            for (var m = t._lctf.getInterval(c.cDef, r[n]), y = c.cDef[m + 2], b = c.scset[y], M = 0; M < b.length; M++) {
              var x = b[M], w = x.input;
              if (!(w.length > s)) {
                for (var g = !0, _ = 0; _ < w.length; _++) {
                  var P = t._lctf.getInterval(c.cDef, r[n + 1 + _]);
                  if (m == -1 && c.cDef[P + 2] != w[_]) {
                    g = !1;
                    break;
                  }
                }
                if (g)
                  for (var V = x.substLookupRecords, f = 0; f < V.length; f += 2)
                    V[f], V[f + 1];
              }
            }
          else if (a.ltype == 6 && c.fmt == 3) {
            if (!t.U._glsCovered(r, c.backCvg, n - c.backCvg.length) || !t.U._glsCovered(r, c.inptCvg, n) || !t.U._glsCovered(r, c.ahedCvg, n + c.inptCvg.length)) continue;
            for (var I = c.lookupRec, M = 0; M < I.length; M += 2) {
              var m = I[M], $ = o[I[M + 1]];
              t.U._applySubs(r, n + m, $, o);
            }
          }
        }
      }
  }, t.U._glsCovered = function(r, n, a) {
    for (var o = 0; o < n.length; o++) {
      var s = t._lctf.coverageIndex(n[o], r[a + o]);
      if (s == -1) return !1;
    }
    return !0;
  }, t.U.glyphsToPath = function(r, n, a) {
    for (var o = { cmds: [], crds: [] }, s = 0, l = 0; l < n.length; l++) {
      var c = n[l];
      if (c != -1) {
        for (var u = l < n.length - 1 && n[l + 1] != -1 ? n[l + 1] : 0, h = t.U.glyphToPath(r, c), f = 0; f < h.crds.length; f += 2)
          o.crds.push(h.crds[f] + s), o.crds.push(h.crds[f + 1]);
        a && o.cmds.push(a);
        for (var f = 0; f < h.cmds.length; f++) o.cmds.push(h.cmds[f]);
        a && o.cmds.push("X"), s += r.hmtx.aWidth[c], l < n.length - 1 && (s += t.U.getPairAdjustment(r, c, u));
      }
    }
    return o;
  }, t.U.pathToSVG = function(r, n) {
    n == null && (n = 5);
    for (var a = [], o = 0, s = { M: 2, L: 2, Q: 4, C: 6 }, l = 0; l < r.cmds.length; l++) {
      var c = r.cmds[l], u = o + (s[c] ? s[c] : 0);
      for (a.push(c); o < u; ) {
        var h = r.crds[o++];
        a.push(parseFloat(h.toFixed(n)) + (o == u ? "" : " "));
      }
    }
    return a.join("");
  }, t.U.pathToContext = function(r, n) {
    for (var a = 0, o = r.crds, s = 0; s < r.cmds.length; s++) {
      var l = r.cmds[s];
      l == "M" ? (n.moveTo(o[a], o[a + 1]), a += 2) : l == "L" ? (n.lineTo(o[a], o[a + 1]), a += 2) : l == "C" ? (n.bezierCurveTo(o[a], o[a + 1], o[a + 2], o[a + 3], o[a + 4], o[a + 5]), a += 6) : l == "Q" ? (n.quadraticCurveTo(o[a], o[a + 1], o[a + 2], o[a + 3]), a += 4) : l.charAt(0) == "#" ? (n.beginPath(), n.fillStyle = l) : l == "Z" ? n.closePath() : l == "X" && n.fill();
    }
  }, t.U.P = {}, t.U.P.moveTo = function(r, n, a) {
    r.cmds.push("M"), r.crds.push(n, a);
  }, t.U.P.lineTo = function(r, n, a) {
    r.cmds.push("L"), r.crds.push(n, a);
  }, t.U.P.curveTo = function(r, n, a, o, s, l, c) {
    r.cmds.push("C"), r.crds.push(n, a, o, s, l, c);
  }, t.U.P.qcurveTo = function(r, n, a, o, s) {
    r.cmds.push("Q"), r.crds.push(n, a, o, s);
  }, t.U.P.closePath = function(r) {
    r.cmds.push("Z");
  }, t.U._drawCFF = function(r, n, a, o, s) {
    for (var l = n.stack, c = n.nStems, u = n.haveWidth, h = n.width, f = n.open, d = 0, p = n.x, g = n.y, v = 0, _ = 0, m = 0, y = 0, b = 0, M = 0, x = 0, w = 0, P = 0, V = 0, I = { val: 0, size: 0 }; d < r.length; ) {
      t.CFF.getCharString(r, d, I);
      var $ = I.val;
      if (d += I.size, $ == "o1" || $ == "o18") {
        var E;
        E = l.length % 2 !== 0, E && !u && (h = l.shift() + o.nominalWidthX), c += l.length >> 1, l.length = 0, u = !0;
      } else if ($ == "o3" || $ == "o23") {
        var E;
        E = l.length % 2 !== 0, E && !u && (h = l.shift() + o.nominalWidthX), c += l.length >> 1, l.length = 0, u = !0;
      } else if ($ == "o4")
        l.length > 1 && !u && (h = l.shift() + o.nominalWidthX, u = !0), f && t.U.P.closePath(s), g += l.pop(), t.U.P.moveTo(s, p, g), f = !0;
      else if ($ == "o5")
        for (; l.length > 0; )
          p += l.shift(), g += l.shift(), t.U.P.lineTo(s, p, g);
      else if ($ == "o6" || $ == "o7")
        for (var G = l.length, O = $ == "o6", W = 0; W < G; W++) {
          var B = l.shift();
          O ? p += B : g += B, O = !O, t.U.P.lineTo(s, p, g);
        }
      else if ($ == "o8" || $ == "o24") {
        for (var G = l.length, q = 0; q + 6 <= G; )
          v = p + l.shift(), _ = g + l.shift(), m = v + l.shift(), y = _ + l.shift(), p = m + l.shift(), g = y + l.shift(), t.U.P.curveTo(s, v, _, m, y, p, g), q += 6;
        $ == "o24" && (p += l.shift(), g += l.shift(), t.U.P.lineTo(s, p, g));
      } else {
        if ($ == "o11") break;
        if ($ == "o1234" || $ == "o1235" || $ == "o1236" || $ == "o1237")
          $ == "o1234" && (v = p + l.shift(), _ = g, m = v + l.shift(), y = _ + l.shift(), P = m + l.shift(), V = y, b = P + l.shift(), M = y, x = b + l.shift(), w = g, p = x + l.shift(), t.U.P.curveTo(s, v, _, m, y, P, V), t.U.P.curveTo(s, b, M, x, w, p, g)), $ == "o1235" && (v = p + l.shift(), _ = g + l.shift(), m = v + l.shift(), y = _ + l.shift(), P = m + l.shift(), V = y + l.shift(), b = P + l.shift(), M = V + l.shift(), x = b + l.shift(), w = M + l.shift(), p = x + l.shift(), g = w + l.shift(), l.shift(), t.U.P.curveTo(s, v, _, m, y, P, V), t.U.P.curveTo(s, b, M, x, w, p, g)), $ == "o1236" && (v = p + l.shift(), _ = g + l.shift(), m = v + l.shift(), y = _ + l.shift(), P = m + l.shift(), V = y, b = P + l.shift(), M = y, x = b + l.shift(), w = M + l.shift(), p = x + l.shift(), t.U.P.curveTo(s, v, _, m, y, P, V), t.U.P.curveTo(s, b, M, x, w, p, g)), $ == "o1237" && (v = p + l.shift(), _ = g + l.shift(), m = v + l.shift(), y = _ + l.shift(), P = m + l.shift(), V = y + l.shift(), b = P + l.shift(), M = V + l.shift(), x = b + l.shift(), w = M + l.shift(), Math.abs(x - p) > Math.abs(w - g) ? p = x + l.shift() : g = w + l.shift(), t.U.P.curveTo(s, v, _, m, y, P, V), t.U.P.curveTo(s, b, M, x, w, p, g));
        else if ($ == "o14") {
          if (l.length > 0 && !u && (h = l.shift() + a.nominalWidthX, u = !0), l.length == 4) {
            var te = l.shift(), ne = l.shift(), Q = l.shift(), ae = l.shift(), oe = t.CFF.glyphBySE(a, Q), _e = t.CFF.glyphBySE(a, ae);
            t.U._drawCFF(a.CharStrings[oe], n, a, o, s), n.x = te, n.y = ne, t.U._drawCFF(a.CharStrings[_e], n, a, o, s);
          }
          f && (t.U.P.closePath(s), f = !1);
        } else if ($ == "o19" || $ == "o20") {
          var E;
          E = l.length % 2 !== 0, E && !u && (h = l.shift() + o.nominalWidthX), c += l.length >> 1, l.length = 0, u = !0, d += c + 7 >> 3;
        } else if ($ == "o21")
          l.length > 2 && !u && (h = l.shift() + o.nominalWidthX, u = !0), g += l.pop(), p += l.pop(), f && t.U.P.closePath(s), t.U.P.moveTo(s, p, g), f = !0;
        else if ($ == "o22")
          l.length > 1 && !u && (h = l.shift() + o.nominalWidthX, u = !0), p += l.pop(), f && t.U.P.closePath(s), t.U.P.moveTo(s, p, g), f = !0;
        else if ($ == "o25") {
          for (; l.length > 6; )
            p += l.shift(), g += l.shift(), t.U.P.lineTo(s, p, g);
          v = p + l.shift(), _ = g + l.shift(), m = v + l.shift(), y = _ + l.shift(), p = m + l.shift(), g = y + l.shift(), t.U.P.curveTo(s, v, _, m, y, p, g);
        } else if ($ == "o26")
          for (l.length % 2 && (p += l.shift()); l.length > 0; )
            v = p, _ = g + l.shift(), m = v + l.shift(), y = _ + l.shift(), p = m, g = y + l.shift(), t.U.P.curveTo(s, v, _, m, y, p, g);
        else if ($ == "o27")
          for (l.length % 2 && (g += l.shift()); l.length > 0; )
            v = p + l.shift(), _ = g, m = v + l.shift(), y = _ + l.shift(), p = m + l.shift(), g = y, t.U.P.curveTo(s, v, _, m, y, p, g);
        else if ($ == "o10" || $ == "o29") {
          var A = $ == "o10" ? o : a;
          if (l.length == 0)
            console.log("error: empty stack");
          else {
            var L = l.pop(), D = A.Subrs[L + A.Bias];
            n.x = p, n.y = g, n.nStems = c, n.haveWidth = u, n.width = h, n.open = f, t.U._drawCFF(D, n, a, o, s), p = n.x, g = n.y, c = n.nStems, u = n.haveWidth, h = n.width, f = n.open;
          }
        } else if ($ == "o30" || $ == "o31") {
          var G, S = l.length, q = 0, H = $ == "o31";
          for (G = S & -3, q += S - G; q < G; )
            H ? (v = p + l.shift(), _ = g, m = v + l.shift(), y = _ + l.shift(), g = y + l.shift(), G - q == 5 ? (p = m + l.shift(), q++) : p = m, H = !1) : (v = p, _ = g + l.shift(), m = v + l.shift(), y = _ + l.shift(), p = m + l.shift(), G - q == 5 ? (g = y + l.shift(), q++) : g = y, H = !0), t.U.P.curveTo(s, v, _, m, y, p, g), q += 4;
        } else {
          if (($ + "").charAt(0) == "o")
            throw console.log("Unknown operation: " + $, r), $;
          l.push($);
        }
      }
    }
    n.x = p, n.y = g, n.nStems = c, n.haveWidth = u, n.width = h, n.open = f;
  }, t;
}
function woff2otfFactory() {
  const e = function() {
    const r = {};
    var n = 0, a = -3;
    function o() {
      this.table = new Uint16Array(16), this.trans = new Uint16Array(288);
    }
    function s(E, G) {
      this.source = E, this.sourceIndex = 0, this.tag = 0, this.bitcount = 0, this.dest = G, this.destLen = 0, this.ltree = new o(), this.dtree = new o();
    }
    var l = new o(), c = new o(), u = new Uint8Array(30), h = new Uint16Array(30), f = new Uint8Array(30), d = new Uint16Array(30), p = new Uint8Array([
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ]), g = new o(), v = new Uint8Array(320);
    function _(E, G, O, W) {
      var B, q;
      for (B = 0; B < O; ++B) E[B] = 0;
      for (B = 0; B < 30 - O; ++B) E[B + O] = B / O | 0;
      for (q = W, B = 0; B < 30; ++B)
        G[B] = q, q += 1 << E[B];
    }
    function m(E, G) {
      var O;
      for (O = 0; O < 7; ++O) E.table[O] = 0;
      for (E.table[7] = 24, E.table[8] = 152, E.table[9] = 112, O = 0; O < 24; ++O) E.trans[O] = 256 + O;
      for (O = 0; O < 144; ++O) E.trans[24 + O] = O;
      for (O = 0; O < 8; ++O) E.trans[168 + O] = 280 + O;
      for (O = 0; O < 112; ++O) E.trans[176 + O] = 144 + O;
      for (O = 0; O < 5; ++O) G.table[O] = 0;
      for (G.table[5] = 32, O = 0; O < 32; ++O) G.trans[O] = O;
    }
    var y = new Uint16Array(16);
    function b(E, G, O, W) {
      var B, q;
      for (B = 0; B < 16; ++B) E.table[B] = 0;
      for (B = 0; B < W; ++B) E.table[G[O + B]]++;
      for (E.table[0] = 0, q = 0, B = 0; B < 16; ++B)
        y[B] = q, q += E.table[B];
      for (B = 0; B < W; ++B)
        G[O + B] && (E.trans[y[G[O + B]]++] = B);
    }
    function M(E) {
      E.bitcount-- || (E.tag = E.source[E.sourceIndex++], E.bitcount = 7);
      var G = E.tag & 1;
      return E.tag >>>= 1, G;
    }
    function x(E, G, O) {
      if (!G)
        return O;
      for (; E.bitcount < 24; )
        E.tag |= E.source[E.sourceIndex++] << E.bitcount, E.bitcount += 8;
      var W = E.tag & 65535 >>> 16 - G;
      return E.tag >>>= G, E.bitcount -= G, W + O;
    }
    function w(E, G) {
      for (; E.bitcount < 24; )
        E.tag |= E.source[E.sourceIndex++] << E.bitcount, E.bitcount += 8;
      var O = 0, W = 0, B = 0, q = E.tag;
      do
        W = 2 * W + (q & 1), q >>>= 1, ++B, O += G.table[B], W -= G.table[B];
      while (W >= 0);
      return E.tag = q, E.bitcount -= B, G.trans[O + W];
    }
    function P(E, G, O) {
      var W, B, q, te, ne, Q;
      for (W = x(E, 5, 257), B = x(E, 5, 1), q = x(E, 4, 4), te = 0; te < 19; ++te) v[te] = 0;
      for (te = 0; te < q; ++te) {
        var ae = x(E, 3, 0);
        v[p[te]] = ae;
      }
      for (b(g, v, 0, 19), ne = 0; ne < W + B; ) {
        var oe = w(E, g);
        switch (oe) {
          case 16:
            var _e = v[ne - 1];
            for (Q = x(E, 2, 3); Q; --Q)
              v[ne++] = _e;
            break;
          case 17:
            for (Q = x(E, 3, 3); Q; --Q)
              v[ne++] = 0;
            break;
          case 18:
            for (Q = x(E, 7, 11); Q; --Q)
              v[ne++] = 0;
            break;
          default:
            v[ne++] = oe;
            break;
        }
      }
      b(G, v, 0, W), b(O, v, W, B);
    }
    function V(E, G, O) {
      for (; ; ) {
        var W = w(E, G);
        if (W === 256)
          return n;
        if (W < 256)
          E.dest[E.destLen++] = W;
        else {
          var B, q, te, ne;
          for (W -= 257, B = x(E, u[W], h[W]), q = w(E, O), te = E.destLen - x(E, f[q], d[q]), ne = te; ne < te + B; ++ne)
            E.dest[E.destLen++] = E.dest[ne];
        }
      }
    }
    function I(E) {
      for (var G, O, W; E.bitcount > 8; )
        E.sourceIndex--, E.bitcount -= 8;
      if (G = E.source[E.sourceIndex + 1], G = 256 * G + E.source[E.sourceIndex], O = E.source[E.sourceIndex + 3], O = 256 * O + E.source[E.sourceIndex + 2], G !== (~O & 65535))
        return a;
      for (E.sourceIndex += 4, W = G; W; --W)
        E.dest[E.destLen++] = E.source[E.sourceIndex++];
      return E.bitcount = 0, n;
    }
    function $(E, G) {
      var O = new s(E, G), W, B, q;
      do {
        switch (W = M(O), B = x(O, 2, 0), B) {
          case 0:
            q = I(O);
            break;
          case 1:
            q = V(O, l, c);
            break;
          case 2:
            P(O, O.ltree, O.dtree), q = V(O, O.ltree, O.dtree);
            break;
          default:
            q = a;
        }
        if (q !== n)
          throw new Error("Data error");
      } while (!W);
      return O.destLen < O.dest.length ? typeof O.dest.slice == "function" ? O.dest.slice(0, O.destLen) : O.dest.subarray(0, O.destLen) : O.dest;
    }
    return m(l, c), _(u, h, 4, 3), _(f, d, 2, 1), u[28] = 0, h[28] = 258, r.exports = $, r.exports;
  }();
  function t(r, n) {
    var a = new DataView(r), o = 0;
    function s() {
      var w = a.getUint16(o);
      return o += 2, w;
    }
    function l() {
      var w = a.getUint32(o);
      return o += 4, w;
    }
    function c(w) {
      b.setUint16(M, w), M += 2;
    }
    function u(w) {
      b.setUint32(M, w), M += 4;
    }
    for (var h = {
      signature: l(),
      flavor: l(),
      length: l(),
      numTables: s(),
      reserved: s(),
      totalSfntSize: l(),
      majorVersion: s(),
      minorVersion: s(),
      metaOffset: l(),
      metaLength: l(),
      metaOrigLength: l(),
      privOffset: l(),
      privLength: l()
    }, f = 0; Math.pow(2, f) <= h.numTables; )
      f++;
    f--;
    for (var d = Math.pow(2, f) * 16, p = h.numTables * 16 - d, g = 12, v = [], _ = 0; _ < h.numTables; _++)
      v.push({
        tag: l(),
        offset: l(),
        compLength: l(),
        origLength: l(),
        origChecksum: l()
      }), g += 4 * 4;
    var m = new Uint8Array(
      12 + v.length * 16 + v.reduce(function(w, P) {
        return w + P.origLength + 4;
      }, 0)
    ), y = m.buffer, b = new DataView(y), M = 0;
    u(h.flavor), c(h.numTables), c(d), c(f), c(p), v.forEach(function(w) {
      u(w.tag), u(w.origChecksum), u(g), u(w.origLength), w.outOffset = g, g += w.origLength, g % 4 != 0 && (g += 4 - g % 4);
    });
    var x;
    return v.forEach(function(w) {
      var P = r.slice(
        w.offset,
        w.offset + w.compLength
      );
      if (w.compLength != w.origLength) {
        var V = new Uint8Array(w.origLength);
        n(
          new Uint8Array(P, 2),
          //skip deflate header
          V
        );
      } else
        V = new Uint8Array(P);
      m.set(V, w.outOffset), g = w.outOffset + w.origLength;
      var I = 0;
      g % 4 != 0 && (I = 4 - g % 4), m.set(
        new Uint8Array(I).buffer,
        w.outOffset + w.origLength
      ), x = g + I;
    }), y.slice(0, x);
  }
  return function(r) {
    return t(r, e);
  };
}
function parserFactory(e, t) {
  const r = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  };
  function n([a]) {
    const o = /* @__PURE__ */ Object.create(null), s = {
      unitsPerEm: a.head.unitsPerEm,
      ascender: a.hhea.ascender,
      descender: a.hhea.descender,
      forEachGlyph(l, c, u, h) {
        let f = 0;
        const d = 1 / s.unitsPerEm * c, p = e.U.stringToGlyphs(a, l);
        let g = 0;
        return p.forEach((v) => {
          if (v !== -1) {
            let _ = o[v];
            if (!_) {
              const m = e.glyf._parseGlyf(a, v) || { xMin: 0, xMax: 0, yMin: 0, yMax: 0 }, { cmds: y, crds: b } = e.U.glyphToPath(a, v);
              _ = o[v] = {
                index: v,
                advanceWidth: a.hmtx.aWidth[v],
                xMin: m.xMin,
                yMin: m.yMin,
                xMax: m.xMax,
                yMax: m.yMax,
                pathCommandCount: y.length,
                forEachPathCommand(M) {
                  let x = 0;
                  const w = [];
                  for (let P = 0, V = y.length; P < V; P++) {
                    const I = r[y[P]];
                    w.length = 1 + I, w[0] = y[P];
                    for (let $ = 1; $ <= I; $++)
                      w[$] = b[x++];
                    M.apply(null, w);
                  }
                }
              };
            }
            h.call(null, _, f, g), _.advanceWidth && (f += _.advanceWidth * d), u && (f += u * c);
          }
          g += l.codePointAt(g) > 65535 ? 2 : 1;
        }), f;
      }
    };
    return s;
  }
  return function(o) {
    const s = new Uint8Array(o, 0, 4), l = e._bin.readASCII(s, 0, 4);
    if (l === "wOFF")
      o = t(o);
    else if (l === "wOF2")
      throw new Error("woff2 fonts not supported");
    return n(e.parse(o));
  };
}
const workerModule = defineWorkerModule({
  dependencies: [typrFactory, woff2otfFactory, parserFactory],
  init(e, t, r) {
    const n = e(), a = t();
    return r(n, a);
  }
}), CONFIG = {
  defaultFontURL: "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",
  //Roboto Regular
  sdfGlyphSize: 64,
  textureWidth: 2048
}, linkEl = document.createElement("a"), SDF_DISTANCE_PERCENT = 1 / 8, atlases = /* @__PURE__ */ Object.create(null);
function getTextRenderInfo(e, t) {
  e = assign({}, e), linkEl.href = e.font || CONFIG.defaultFontURL, e.font = linkEl.href, e.text = "" + e.text;
  const { sdfGlyphSize: r, textureWidth: n } = CONFIG;
  let a = atlases[e.font];
  a || (a = atlases[e.font] = {
    sdfTexture: new DataTexture(
      new Uint8Array(r * n),
      n,
      r,
      LuminanceFormat,
      void 0,
      void 0,
      void 0,
      void 0,
      LinearFilter,
      LinearFilter
    )
  }, a.sdfTexture.font = e.font), processInWorker(e).then((o) => {
    o.newGlyphSDFs && (o.newGlyphSDFs.forEach(({ textureData: s, atlasIndex: l }) => {
      const c = a.sdfTexture.image;
      for (; c.data.length < (l + 1) * r * r; ) {
        const h = new Uint8Array(c.data.length * 2);
        h.set(c.data), c.data = h, c.height *= 2;
      }
      const u = c.width / r;
      for (let h = 0; h < r; h++) {
        const f = h * r, d = c.width * r * Math.floor(l / u) + l % u * r + h * c.width;
        for (let p = 0; p < r; p++)
          c.data[d + p] = s[f + p];
      }
    }), a.sdfTexture.needsUpdate = !0), t(Object.freeze({
      sdfTexture: a.sdfTexture,
      sdfGlyphSize: r,
      sdfMinDistancePercent: SDF_DISTANCE_PERCENT,
      glyphBounds: o.glyphBounds,
      glyphAtlasIndices: o.glyphAtlasIndices,
      caretPositions: o.caretPositions,
      caretHeight: o.caretHeight,
      totalBounds: o.totalBounds,
      totalBlockSize: o.totalBlockSize
    }));
  });
}
function assign(e, t) {
  for (let r in t)
    t.hasOwnProperty(r) && (e[r] = t[r]);
  return e;
}
const fontProcessorWorkerModule = defineWorkerModule({
  dependencies: [
    CONFIG,
    SDF_DISTANCE_PERCENT,
    workerModule,
    createSDFGenerator,
    createFontProcessor
  ],
  init(e, t, r, n, a) {
    const o = n({
      sdfTextureSize: e.sdfGlyphSize,
      sdfDistancePercent: t
    });
    return a(r, o, {
      defaultFontUrl: e.defaultFontURL
    });
  }
}), processInWorker = defineWorkerModule({
  dependencies: [fontProcessorWorkerModule, ThenableWorkerModule],
  init(e, t) {
    return function(r) {
      const n = new t();
      return e.process(r, n.resolve), n;
    };
  },
  getTransferables(e) {
    const t = [
      e.glyphBounds.buffer,
      e.glyphAtlasIndices.buffer
    ];
    return e.caretPositions && t.push(e.caretPositions.buffer), e.newGlyphSDFs && e.newGlyphSDFs.forEach((r) => {
      t.push(r.textureData.buffer);
    }), t;
  }
}), templateGeometry = new PlaneBufferGeometry(1, 1).translate(0.5, 0.5, 0), tempVec3 = new Vector3(), glyphBoundsAttrName = "aTroikaGlyphBounds", glyphIndexAttrName = "aTroikaGlyphIndex";
class GlyphsGeometry extends InstancedBufferGeometry {
  constructor() {
    super(), this.copy(templateGeometry), this.boundingSphere = new Sphere();
  }
  computeBoundingSphere() {
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} totalBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   */
  updateGlyphs(t, r, n) {
    updateBufferAttr(this, glyphBoundsAttrName, t, 4), updateBufferAttr(this, glyphIndexAttrName, r, 1), this.maxInstancedCount = r.length;
    const a = this.boundingSphere;
    a.center.set(
      (n[0] + n[2]) / 2,
      (n[1] + n[3]) / 2,
      0
    ), a.radius = a.center.distanceTo(tempVec3.set(n[0], n[1], 0));
  }
}
GlyphsGeometry.prototype.setAttribute || (GlyphsGeometry.prototype.setAttribute = function(e, t) {
  return this.attributes[e] = t, this;
});
function updateBufferAttr(e, t, r, n) {
  const a = e.getAttribute(t);
  a && a.array.length === r.length ? (a.array.set(r), a.needsUpdate = !0) : e.setAttribute(t, new InstancedBufferAttribute(r, n));
}
const VERTEX_DEFS = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
varying vec2 vTroikaSDFTextureUV;
varying vec2 vTroikaGlyphUV;
varying vec3 vTroikaLocalPos;
`, VERTEX_TRANSFORM = `
vTroikaGlyphUV = vec2(position);

vec2 colsAndRows = uTroikaSDFTextureSize / uTroikaSDFGlyphSize;
vTroikaSDFTextureUV = vec2(
  mod(aTroikaGlyphIndex, colsAndRows.x) + position.x,
  floor(aTroikaGlyphIndex / colsAndRows.x) + position.y
) * uTroikaSDFGlyphSize / uTroikaSDFTextureSize;

position = vec3(
  mix(aTroikaGlyphBounds.x, aTroikaGlyphBounds.z, position.x),
  mix(aTroikaGlyphBounds.y, aTroikaGlyphBounds.w, position.y),
  position.z
);
vTroikaLocalPos = vec3(position);

uv = vec2(
  (position.x - uTroikaTotalBounds.x) / (uTroikaTotalBounds.z - uTroikaTotalBounds.x),
  (position.y - uTroikaTotalBounds.y) / (uTroikaTotalBounds.w - uTroikaTotalBounds.y)
);
`, FRAGMENT_DEFS = `
uniform sampler2D uTroikaSDFTexture;
uniform float uTroikaSDFMinDistancePct;
uniform bool uTroikaSDFDebug;
uniform vec4 uTroikaClipRect;
varying vec2 vTroikaSDFTextureUV;
varying vec2 vTroikaGlyphUV;
varying vec3 vTroikaLocalPos;

float troikaGetClipAlpha() {
  vec4 clip = uTroikaClipRect;
  vec3 pos = vTroikaLocalPos;
  float dClip = min(
    min(pos.x - min(clip.x, clip.z), max(clip.x, clip.z) - pos.x),
    min(pos.y - min(clip.y, clip.w), max(clip.y, clip.w) - pos.y)
  );
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  float aa = length(fwidth(pos)) * 0.5;
  return smoothstep(-aa, aa, dClip);
  #else
  return step(0.0, dClip);
  #endif
}

float troikaGetTextAlpha() {
  float troikaSDFValue = texture2D(uTroikaSDFTexture, vTroikaSDFTextureUV).r;
  
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(0.5, troikaSDFValue);
  #else
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  float aaDist = min(
    0.5,
    0.5 * min(
      fwidth(vTroikaGlyphUV.x),
      fwidth(vTroikaGlyphUV.y)
    )
  ) / uTroikaSDFMinDistancePct;
  #else
  float aaDist = 0.01;
  #endif
  
  float alpha = uTroikaSDFDebug ? troikaSDFValue : smoothstep(
    0.5 - aaDist,
    0.5 + aaDist,
    troikaSDFValue
  );
  #endif
  
  return min(alpha, troikaGetClipAlpha());
}
`, FRAGMENT_TRANSFORM = `
float troikaAlphaMult = troikaGetTextAlpha();
if (troikaAlphaMult == 0.0) {
  discard;
} else {
  gl_FragColor.a *= troikaAlphaMult;
}
`;
function createTextDerivedMaterial(e) {
  const t = createDerivedMaterial(e, {
    extensions: { derivatives: !0 },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Vector2() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFMinDistancePct: { value: 0 },
      uTroikaTotalBounds: { value: new Vector4() },
      uTroikaClipRect: { value: new Vector4() },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: VERTEX_DEFS,
    vertexTransform: VERTEX_TRANSFORM,
    fragmentDefs: FRAGMENT_DEFS,
    fragmentColorTransform: FRAGMENT_TRANSFORM
  });
  return t.transparent = !0, Object.defineProperty(t, "shadowSide", {
    get() {
      return this.side;
    }
  }), t;
}
const defaultMaterial = new MeshBasicMaterial({
  color: 16777215,
  side: DoubleSide,
  transparent: !0
}), tempMat4 = new Matrix4(), raycastMesh = new Mesh(
  new PlaneBufferGeometry(1, 1).translate(0.5, 0.5, 0),
  defaultMaterial
);
class TextMesh extends Mesh {
  constructor(t) {
    const r = new GlyphsGeometry();
    super(r, null), this.text = "", this.anchor = null, this.font = null, this.fontSize = 0.1, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.whiteSpace = "normal", this.material = null, this.color = null, this.depthOffset = 0, this.clipRect = null, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(t) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(t) : (this._isSyncing = !0, getTextRenderInfo({
      text: this.text,
      font: this.font,
      fontSize: this.fontSize,
      letterSpacing: this.letterSpacing,
      lineHeight: this.lineHeight,
      maxWidth: this.maxWidth,
      textAlign: this.textAlign,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchor: this.anchor,
      includeCaretPositions: !0
      //TODO parameterize
    }, (r) => {
      this._isSyncing = !1, this._textRenderInfo = r, this.geometry.updateGlyphs(r.glyphBounds, r.glyphAtlasIndices, r.totalBounds);
      const n = this._queuedSyncs;
      n && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        n.forEach((a) => a && a());
      })), t && t();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender() {
    this.sync(), this._prepareMaterial();
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let t = this._derivedMaterial;
    const r = this._baseMaterial || defaultMaterial;
    return (!t || t.baseMaterial !== r) && (t && t.dispose(), t = this._derivedMaterial = createTextDerivedMaterial(r), r.addEventListener("dispose", function n() {
      r.removeEventListener("dispose", n), t.dispose();
    })), t;
  }
  set material(t) {
    this._baseMaterial = t;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return this._updateLayoutUniforms(this.material.getDepthMaterial());
  }
  get customDistanceMaterial() {
    return this._updateLayoutUniforms(this.material.getDistanceMaterial());
  }
  _prepareMaterial() {
    const t = this._derivedMaterial;
    this._updateLayoutUniforms(t);
    const r = t.uniforms;
    r.uTroikaSDFDebug.value = !!this.debugSDF, t.polygonOffset = !!this.depthOffset, t.polygonOffsetFactor = t.polygonOffsetUnits = this.depthOffset || 0;
    const n = this.color;
    n != null && t.color && t.color.isColor && n !== t._troikaColor && t.color.set(t._troikaColor = n);
  }
  _updateLayoutUniforms(t) {
    const r = this.textRenderInfo, n = t.uniforms;
    if (r) {
      const { sdfTexture: a, totalBounds: o } = r;
      n.uTroikaSDFTexture.value = a, n.uTroikaSDFTextureSize.value.set(a.image.width, a.image.height), n.uTroikaSDFGlyphSize.value = r.sdfGlyphSize, n.uTroikaSDFMinDistancePct.value = r.sdfMinDistancePercent, n.uTroikaTotalBounds.value.fromArray(o);
      let s = this.clipRect;
      s && Array.isArray(s) && s.length === 4 ? n.uTroikaClipRect.value.set(
        Math.max(o[0], s[0]),
        Math.max(o[1], s[1]),
        Math.min(o[2], s[2]),
        Math.min(o[3], s[3])
      ) : n.uTroikaClipRect.value.fromArray(o);
    }
    return t;
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(t, r) {
    const n = this.textRenderInfo;
    if (n) {
      const a = n.totalBounds;
      raycastMesh.matrixWorld.multiplyMatrices(
        this.matrixWorld,
        tempMat4.set(
          a[2] - a[0],
          0,
          0,
          a[0],
          0,
          a[3] - a[1],
          0,
          a[1],
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        )
      ), raycastMesh.raycast(t, r);
    }
  }
}
const SYNCABLE_PROPS = [
  "font",
  "fontSize",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "textAlign",
  "whiteSpace",
  "anchor"
];
SYNCABLE_PROPS.forEach((e) => {
  const t = "_private_" + e;
  Object.defineProperty(TextMesh.prototype, e, {
    get: function() {
      return this[t];
    },
    set: e === "anchor" ? function(r) {
      JSON.stringify(r) !== JSON.stringify(this[t]) && (this[t] = r, this._needsSync = !0);
    } : function(r) {
      r !== this[t] && (this[t] = r, this._needsSync = !0);
    }
  });
});
const anchorMapping = {
  left: 0,
  center: 0.5,
  right: 1
}, baselineMapping = {
  top: 0,
  center: 0.5,
  bottom: 1
};
class SDFTextSystem extends System {
  updateText(t, r) {
    t.text = r.text, t.textAlign = r.textAlign, t.anchor[0] = anchorMapping[r.anchor], t.anchor[1] = baselineMapping[r.baseline], t.color = r.color, t.font = r.font, t.fontSize = r.fontSize, t.letterSpacing = r.letterSpacing || 0, t.lineHeight = r.lineHeight || null, t.overflowWrap = r.overflowWrap, t.whiteSpace = r.whiteSpace, t.maxWidth = r.maxWidth, t.material.opacity = r.opacity, t.sync();
  }
  execute() {
    var t = this.queries.entities;
    t.added.forEach((r) => {
      var n = r.getComponent(Text);
      const a = new TextMesh();
      a.name = "textMesh", a.anchor = [0, 0], a.renderOrder = 10, this.updateText(a, n), r.addComponent(Object3DComponent, { value: a });
    }), t.removed.forEach((r) => {
      var n = r.getObject3D(), a = n.getObjectByName("textMesh");
      a.dispose(), n.remove(a);
    }), t.changed.forEach((r) => {
      var n = r.getObject3D();
      if (n instanceof TextMesh) {
        var a = r.getComponent(Text);
        this.updateText(n, a);
      }
    });
  }
}
SDFTextSystem.queries = {
  entities: {
    components: [Text],
    listen: {
      added: !0,
      removed: !0,
      changed: [Text]
    }
  }
};
const Constants = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
async function fetchJsonFile(e) {
  const t = await fetch(e);
  if (t.ok)
    return t.json();
  throw new Error(t.statusText);
}
async function fetchProfilesList(e) {
  if (!e)
    throw new Error("No basePath supplied");
  return await fetchJsonFile(`${e}/profilesList.json`);
}
async function fetchProfile(e, t, r = null, n = !0) {
  if (!e)
    throw new Error("No xrInputSource supplied");
  if (!t)
    throw new Error("No basePath supplied");
  const a = await fetchProfilesList(t);
  let o;
  if (e.profiles.some((c) => {
    const u = a[c];
    return u && (o = {
      profileId: c,
      profilePath: `${t}/${u.path}`,
      deprecated: !!u.deprecated
    }), !!o;
  }), !o) {
    if (!r)
      throw new Error("No matching profile name found");
    const c = a[r];
    if (!c)
      throw new Error(`No matching profile name found and default profile "${r}" missing.`);
    o = {
      profileId: r,
      profilePath: `${t}/${c.path}`,
      deprecated: !!c.deprecated
    };
  }
  const s = await fetchJsonFile(o.profilePath);
  let l;
  if (n) {
    let c;
    if (e.handedness === "any" ? c = s.layouts[Object.keys(s.layouts)[0]] : c = s.layouts[e.handedness], !c)
      throw new Error(
        `No matching handedness, ${e.handedness}, in profile ${o.profileId}`
      );
    c.assetPath && (l = o.profilePath.replace("profile.json", c.assetPath));
  }
  return { profile: s, assetPath: l };
}
const defaultComponentValues = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: Constants.ComponentState.DEFAULT
};
function normalizeAxes(e = 0, t = 0) {
  let r = e, n = t;
  if (Math.sqrt(e * e + t * t) > 1) {
    const s = Math.atan2(t, e);
    r = Math.cos(s), n = Math.sin(s);
  }
  return {
    normalizedXAxis: r * 0.5 + 0.5,
    normalizedYAxis: n * 0.5 + 0.5
  };
}
class VisualResponse {
  constructor(t) {
    this.componentProperty = t.componentProperty, this.states = t.states, this.valueNodeName = t.valueNodeName, this.valueNodeProperty = t.valueNodeProperty, this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM && (this.minNodeName = t.minNodeName, this.maxNodeName = t.maxNodeName), this.value = 0, this.updateFromComponent(defaultComponentValues);
  }
  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent({
    xAxis: t,
    yAxis: r,
    button: n,
    state: a
  }) {
    const { normalizedXAxis: o, normalizedYAxis: s } = normalizeAxes(t, r);
    switch (this.componentProperty) {
      case Constants.ComponentProperty.X_AXIS:
        this.value = this.states.includes(a) ? o : 0.5;
        break;
      case Constants.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(a) ? s : 0.5;
        break;
      case Constants.ComponentProperty.BUTTON:
        this.value = this.states.includes(a) ? n : 0;
        break;
      case Constants.ComponentProperty.STATE:
        this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY ? this.value = this.states.includes(a) : this.value = this.states.includes(a) ? 1 : 0;
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
}
class Component {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(t, r) {
    if (!t || !r || !r.visualResponses || !r.gamepadIndices || Object.keys(r.gamepadIndices).length === 0)
      throw new Error("Invalid arguments supplied");
    this.id = t, this.type = r.type, this.rootNodeName = r.rootNodeName, this.touchPointNodeName = r.touchPointNodeName, this.visualResponses = {}, Object.keys(r.visualResponses).forEach((n) => {
      const a = new VisualResponse(r.visualResponses[n]);
      this.visualResponses[n] = a;
    }), this.gamepadIndices = Object.assign({}, r.gamepadIndices), this.values = {
      state: Constants.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
    };
  }
  get data() {
    return { id: this.id, ...this.values };
  }
  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(t) {
    if (this.values.state = Constants.ComponentState.DEFAULT, this.gamepadIndices.button !== void 0 && t.buttons.length > this.gamepadIndices.button) {
      const r = t.buttons[this.gamepadIndices.button];
      this.values.button = r.value, this.values.button = this.values.button < 0 ? 0 : this.values.button, this.values.button = this.values.button > 1 ? 1 : this.values.button, r.pressed || this.values.button === 1 ? this.values.state = Constants.ComponentState.PRESSED : (r.touched || this.values.button > Constants.ButtonTouchThreshold) && (this.values.state = Constants.ComponentState.TOUCHED);
    }
    this.gamepadIndices.xAxis !== void 0 && t.axes.length > this.gamepadIndices.xAxis && (this.values.xAxis = t.axes[this.gamepadIndices.xAxis], this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis, this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis, this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold && (this.values.state = Constants.ComponentState.TOUCHED)), this.gamepadIndices.yAxis !== void 0 && t.axes.length > this.gamepadIndices.yAxis && (this.values.yAxis = t.axes[this.gamepadIndices.yAxis], this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis, this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis, this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold && (this.values.state = Constants.ComponentState.TOUCHED)), Object.values(this.visualResponses).forEach((r) => {
      r.updateFromComponent(this.values);
    });
  }
}
class MotionController {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(t, r, n) {
    if (!t)
      throw new Error("No xrInputSource supplied");
    if (!r)
      throw new Error("No profile supplied");
    this.xrInputSource = t, this.assetUrl = n, this.id = r.profileId, this.layoutDescription = r.layouts[t.handedness], this.components = {}, Object.keys(this.layoutDescription.components).forEach((a) => {
      const o = this.layoutDescription.components[a];
      this.components[a] = new Component(a, o);
    }), this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const t = [];
    return Object.values(this.components).forEach((r) => {
      t.push(r.data);
    }), t;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach((t) => {
      t.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
}
const DEFAULT_PROFILES_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles", DEFAULT_PROFILE = "generic-trigger";
function XRControllerModel() {
  Object3D.call(this), this.motionController = null, this.envMap = null;
}
XRControllerModel.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: XRControllerModel,
  setEnvironmentMap: function(e) {
    return this.envMap == e ? this : (this.envMap = e, this.traverse((t) => {
      t.isMesh && (t.material.envMap = this.envMap, t.material.needsUpdate = !0);
    }), this);
  },
  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */
  updateMatrixWorld: function(e) {
    Object3D.prototype.updateMatrixWorld.call(this, e), this.motionController && (this.motionController.updateFromGamepad(), Object.values(this.motionController.components).forEach((t) => {
      Object.values(t.visualResponses).forEach((r) => {
        const { valueNode: n, minNode: a, maxNode: o, value: s, valueNodeProperty: l } = r;
        n && (l === Constants.VisualResponseProperty.VISIBILITY ? n.visible = s : l === Constants.VisualResponseProperty.TRANSFORM && (Quaternion.slerp(
          a.quaternion,
          o.quaternion,
          n.quaternion,
          s
        ), n.position.lerpVectors(
          a.position,
          o.position,
          s
        )));
      });
    }));
  }
});
function findNodes(e, t) {
  Object.values(e.components).forEach((r) => {
    const { type: n, touchPointNodeName: a, visualResponses: o } = r;
    if (n === Constants.ComponentType.TOUCHPAD)
      if (r.touchPointNode = t.getObjectByName(a), r.touchPointNode) {
        const s = new SphereGeometry(1e-3), l = new MeshBasicMaterial({ color: 255 }), c = new Mesh(s, l);
        r.touchPointNode.add(c);
      } else
        console.warn(`Could not find touch dot, ${r.touchPointNodeName}, in touchpad component ${r.id}`);
    Object.values(o).forEach((s) => {
      const { valueNodeName: l, minNodeName: c, maxNodeName: u, valueNodeProperty: h } = s;
      if (h === Constants.VisualResponseProperty.TRANSFORM) {
        if (s.minNode = t.getObjectByName(c), s.maxNode = t.getObjectByName(u), !s.minNode) {
          console.warn(`Could not find ${c} in the model`);
          return;
        }
        if (!s.maxNode) {
          console.warn(`Could not find ${u} in the model`);
          return;
        }
      }
      s.valueNode = t.getObjectByName(l), s.valueNode || console.warn(`Could not find ${l} in the model`);
    });
  });
}
function addAssetSceneToControllerModel(e, t) {
  findNodes(e.motionController, t), e.envMap && t.traverse((r) => {
    r.isMesh && (r.material.envMap = e.envMap, r.material.needsUpdate = !0);
  }), e.add(t);
}
var XRControllerModelFactory = function() {
  function e(t = null) {
    this.gltfLoader = t, this.path = DEFAULT_PROFILES_PATH, this._assetCache = {}, this.gltfLoader || (this.gltfLoader = new GLTFLoader());
  }
  return e.prototype = {
    constructor: e,
    createControllerModel: function(t) {
      const r = new XRControllerModel();
      let n = null;
      return t.addEventListener("connected", (a) => {
        const o = a.data;
        o.targetRayMode !== "tracked-pointer" || !o.gamepad || fetchProfile(o, this.path, DEFAULT_PROFILE).then(({ profile: s, assetPath: l }) => {
          r.motionController = new MotionController(
            o,
            s,
            l
          );
          let c = this._assetCache[r.motionController.assetUrl];
          if (c)
            n = c.scene.clone(), addAssetSceneToControllerModel(r, n);
          else {
            if (!this.gltfLoader)
              throw new Error("GLTFLoader not set.");
            this.gltfLoader.setPath(""), this.gltfLoader.load(
              r.motionController.assetUrl,
              (u) => {
                this._assetCache[r.motionController.assetUrl] = u, n = u.scene.clone(), addAssetSceneToControllerModel(r, n);
              },
              null,
              () => {
                throw new Error(`Asset ${r.motionController.assetUrl} missing or malformed.`);
              }
            );
          }
        }).catch((s) => {
          console.warn(s);
        });
      }), t.addEventListener("disconnected", () => {
        r.motionController = null, r.remove(n), n = null;
      }), r;
    }
  }, e;
}(), controllerModelFactory = new XRControllerModelFactory();
class VRControllerSystem extends System {
  init() {
    this.world.registerComponent(VRController).registerComponent(VRControllerBasicBehaviour).registerComponent(ControllerConnected);
  }
  execute() {
    let t = this.queries.rendererContext.results[0].getComponent(
      WebGLRendererContext
    ).value;
    this.queries.controllers.added.forEach((r) => {
      let n = r.getComponent(VRController).id;
      var a = t.xr.getController(n);
      a.name = "controller";
      var o = new Group();
      if (o.add(a), r.addComponent(Object3DComponent, { value: o }), a.addEventListener("connected", () => {
        r.addComponent(ControllerConnected);
      }), a.addEventListener("disconnected", () => {
        r.removeComponent(ControllerConnected);
      }), r.hasComponent(VRControllerBasicBehaviour)) {
        var s = r.getComponent(VRControllerBasicBehaviour);
        Object.keys(s).forEach((c) => {
          s[c] && a.addEventListener(c, s[c]);
        });
      }
      let l = t.xr.getControllerGrip(n);
      l.add(
        controllerModelFactory.createControllerModel(l)
      ), l.name = "model", o.add(l);
    });
  }
}
VRControllerSystem.queries = {
  controllers: {
    components: [VRController],
    listen: {
      added: !0
      //changed: [Visible]
    }
  },
  rendererContext: {
    components: [WebGLRendererContext],
    mandatory: !0
  }
};
class AnimationMixerComponent extends Component$1 {
}
AnimationMixerComponent.schema = {
  value: { default: 0, type: Types.Number }
};
class AnimationActionsComponent extends Component$1 {
}
AnimationActionsComponent.schema = {
  animations: { default: [], type: Types.Array },
  duration: { default: 0, type: Types.Number }
};
class AnimationSystem extends System {
  init() {
    this.world.registerComponent(AnimationMixerComponent).registerComponent(AnimationActionsComponent);
  }
  execute(t) {
    this.queries.entities.added.forEach((r) => {
      let n = r.getComponent(GLTFModel).value, a = new AnimationMixer(n.scene);
      r.addComponent(AnimationMixerComponent, {
        value: a
      });
      let o = [];
      n.animations.forEach((s) => {
        const l = a.clipAction(s, n.scene);
        l.loop = LoopOnce, o.push(l);
      }), r.addComponent(AnimationActionsComponent, {
        animations: o,
        duration: r.getComponent(Animation).duration
      });
    }), this.queries.mixers.results.forEach((r) => {
      r.getComponent(AnimationMixerComponent).value.update(t);
    }), this.queries.playClips.results.forEach((r) => {
      let n = r.getComponent(AnimationActionsComponent);
      n.animations.forEach((a) => {
        n.duration !== -1 && a.setDuration(n.duration), a.clampWhenFinished = !0, a.reset(), a.play();
      }), r.removeComponent(Play);
    }), this.queries.stopClips.results.forEach((r) => {
      r.getComponent(AnimationActionsComponent).animations.forEach((a) => {
        a.reset(), a.stop();
      }), r.removeComponent(Stop);
    });
  }
}
AnimationSystem.queries = {
  entities: {
    components: [Animation, GLTFModel],
    listen: {
      added: !0
    }
  },
  mixers: {
    components: [AnimationMixerComponent]
  },
  playClips: {
    components: [AnimationActionsComponent, Play]
  },
  stopClips: {
    components: [AnimationActionsComponent, Stop]
  }
};
class InputSystem extends System {
  init() {
    //!!!!!!!!!!!!!
    this.world.registerComponent(InputState);
    let t = this.world.createEntity().addComponent(InputState);
    this.inputStateComponent = t.getMutableComponent(InputState);
  }
  execute() {
    this.processVRControllers();
  }
  processVRControllers() {
    this.queries.vrcontrollers.added.forEach((t) => {
      t.addComponent(VRControllerBasicBehaviour, {
        selectstart: (r) => {
          let n = this.inputStateComponent.vrcontrollers.get(r.target);
          n.selected = !0, n.prevSelected = !1;
        },
        selectend: (r) => {
          let n = this.inputStateComponent.vrcontrollers.get(r.target);
          n.selected = !1, n.prevSelected = !0;
        },
        connected: (r) => {
          this.inputStateComponent.vrcontrollers.set(r.target, {});
        },
        disconnected: (r) => {
          this.inputStateComponent.vrcontrollers.delete(r.target);
        }
      });
    }), this.inputStateComponent.vrcontrollers.forEach((t) => {
      t.selectStart = t.selected && !t.prevSelected, t.selectEnd = !t.selected && t.prevSelected, t.prevSelected = t.selected;
    });
  }
}
InputSystem.queries = {
  vrcontrollers: {
    components: [VRController],
    listen: {
      added: !0
    }
  }
};
class PositionalAudioPolyphonic extends Object3D {
  constructor(t, r) {
    super(), this.listener = t, this.context = t.context, this.poolSize = r || 5;
    for (var n = 0; n < this.poolSize; n++)
      this.children.push(new PositionalAudio(t));
  }
  setBuffer(t) {
    this.children.forEach((r) => {
      r.setBuffer(t);
    });
  }
  play() {
    var t = !1;
    for (let r = 0; r < this.children.length; r++) {
      let n = this.children[r];
      if (!n.isPlaying && n.buffer && !t) {
        n.play(), n.isPaused = !1, t = !0;
        continue;
      }
    }
    if (!t) {
      console.warn(
        "All the sounds are playing. If you need to play more sounds simultaneously consider increasing the pool size"
      );
      return;
    }
  }
}
class SoundSystem extends System {
  init() {
    this.listener = new AudioListener();
  }
  execute() {
    this.queries.sounds.added.forEach((t) => {
      const r = t.getMutableComponent(Sound), n = new PositionalAudioPolyphonic(this.listener, 10);
      new AudioLoader().load(r.url, (o) => {
        n.setBuffer(o);
      }), r.sound = n;
    });
  }
}
SoundSystem.queries = {
  sounds: {
    components: [Sound],
    listen: {
      added: !0,
      removed: !0,
      changed: !0
      // [Sound]
    }
  }
};
class LevelItem extends Component$1 {
}
class Level extends Component$1 {
}
Level.schema = {
  value: { default: 0, type: Types.Number }
};
class FloorCollided extends TagComponent {
}
class Cleared extends TagComponent {
}
class Element extends Component$1 {
}
Element.schema = {
  value: { default: 0, type: Types.Number },
  type: { default: 0, type: Types.Number }
};
class Rotating extends Component$1 {
}
Rotating.schema = {
  speed: {
    default: new Vector3(0, 0, 0),
    type: ThreeTypes.Vector3Type
  }
};
class Dissolve extends Component$1 {
}
Dissolve.schema = {
  speed: { default: 1, type: Types.Number },
  value: { default: 1, type: Types.Number }
};
class GameState extends Component$1 {
}
GameState.schema = {
  playing: { default: !1, type: Types.Boolean },
  prevPlaying: { default: !1, type: Types.Boolean },
  levelFinished: { default: !1, type: Types.Boolean },
  numBallsFailed: { default: 0, type: Types.Number },
  numBallsTotal: { default: 0, type: Types.Number },
  levelStartTime: { default: 0, type: Types.Number },
  gameStartTime: { default: 0, type: Types.Number }
};
class BallGenerator extends Component$1 {
}
BallGenerator.schema = {
  position: { default: new Vector3(), type: ThreeTypes.Vector3Type },
  linearVelocity: { default: new Vector3(), type: ThreeTypes.Vector3Type }
};
class Ball extends Component$1 {
}
Ball.schema = {
  radius: { default: 0.4, type: Types.Number },
  position: { default: new Vector3(), type: ThreeTypes.Vector3Type },
  linearVelocity: { default: new Vector3(), type: ThreeTypes.Vector3Type }
};
class Target extends Component$1 {
}
Target.schema = {
  position: { default: new Vector3(), type: ThreeTypes.Vector3Type }
};
class UI extends TagComponent {
}
class Button extends Component$1 {
}
Button.schema = {
  text: { default: "", type: Types.String },
  onClick: { default: null, type: Types.Ref }
};
class RaycastReceiver extends Component$1 {
}
RaycastReceiver.schema = {
  hovering: { default: !1, type: Types.Boolean },
  selecting: { default: !1, type: Types.Boolean },
  onHover: { default: null, type: Types.Ref },
  onEnter: { default: null, type: Types.Ref },
  onLeave: { default: null, type: Types.Ref },
  onSelectStart: { default: null, type: Types.Ref },
  onSelect: { default: null, type: Types.Ref },
  onSelectEnd: { default: null, type: Types.Ref },
  layerMask: { default: 0, type: Types.Number }
};
class Raycaster extends Component$1 {
}
Raycaster.schema = {
  enabled: { default: !0, type: Types.Boolean },
  currentEntity: { default: null, type: Types.Ref },
  layerMask: { default: 0, type: Types.Number },
  value: { default: null, type: Types.Ref }
};
class Floor extends TagComponent {
}
const Components = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Active,
  Animation,
  AnimationSystem,
  Ball,
  BallGenerator,
  Button,
  Camera,
  CameraRig,
  CameraTagComponent,
  Cleared,
  Colliding,
  CollisionStart,
  CollisionStop,
  ControllerConnected,
  Dissolve,
  Draggable,
  Dragging,
  ECSYThreeSystem: System,
  ECSYThreeWorld,
  Element,
  Floor,
  FloorCollided,
  GLTFLoader: GLTFLoader$1,
  GLTFLoaderSystem,
  GLTFModel,
  GameState,
  Geometry,
  GeometrySystem,
  InputState,
  InputSystem,
  Level,
  LevelItem,
  MeshTagComponent,
  Object3DComponent,
  OnObject3DAdded,
  OnObject3DAddedSystem,
  Parent,
  ParentObject3D,
  Play,
  Position,
  RaycastReceiver,
  Raycaster,
  RenderPass,
  RigidBody,
  Rotating,
  Rotation,
  SDFTextSystem,
  Scale,
  Scene,
  SceneTagComponent,
  Shape,
  SkyBox,
  SkyBoxSystem,
  Sound,
  SoundSystem,
  Stop,
  Target,
  Text,
  ThreeTypes,
  Transform,
  TransformSystem,
  Types,
  UI,
  UpdateAspectOnResizeSystem,
  UpdateAspectOnResizeTag,
  VRController,
  VRControllerBasicBehaviour,
  VRControllerSystem,
  Vector3Type,
  VisibilitySystem,
  Visible,
  WebGLRenderer,
  WebGLRendererContext,
  WebGLRendererSystem,
  defaultObject3DInflator,
  initialize
}, Symbol.toStringTag, { value: "Module" })), environmentMap = new TextureLoader().load(
  "assets/textures/env.jpg"
);
environmentMap.mapping = EquirectangularReflectionMapping;
environmentMap.encoding = sRGBEncoding;
environmentMap.flipY = !1;
const UIMaterial = new MeshBasicMaterial({
  map: new TextureLoader().load("assets/textures/ui.png"),
  transparent: !0
});
UIMaterial.map.encoding = sRGBEncoding;
UIMaterial.map.flipY = !1;
var textures = {};
const textureURLs = [
  "metal.jpg",
  "rubber.png",
  "wood.png",
  "floor.png",
  "target.png",
  "cannon.jpg",
  "ball.png",
  "wood_spec.jpg",
  "cannon_spec.jpg",
  "metal_spec.jpg"
];
for (let e = 0; e < textureURLs.length; e++) {
  let t = new TextureLoader().load(`assets/textures/${textureURLs[e]}`);
  t.encoding = sRGBEncoding, t.flipY = !1, textures[textureURLs[e]] = t;
}
var worldPos = new Vector3();
class TargetSystem extends System {
  init() {
    this.world.registerComponent(Rotating).registerComponent(Cleared);
  }
  execute() {
    var t = this.queries.balls.results, r = this.queries.targets.results;
    for (let l = 0; l < r.length; l++) {
      var n = r[l], a = n.getObject3D();
      let c = a.children[0];
      c.getWorldPosition(worldPos), c.geometry.boundingSphere || c.geometry.computeBoundingSphere();
      let u = c.geometry.boundingSphere.radius;
      for (let h = 0; h < t.length; h++) {
        var o = t[h], s = o.getObject3D();
        s.geometry.boundingSphere || s.geometry.computeBoundingSphere();
        let d = s.geometry.boundingSphere.radius + u;
        s.position.distanceToSquared(worldPos) <= d * d && (o.removeComponent(Active), n.addComponent(Rotating, { speed: new Vector3(0, 30, 0) }), n.addComponent(Cleared));
      }
    }
  }
}
TargetSystem.queries = {
  targets: { components: [Target, Object3DComponent] },
  balls: { components: [Ball, Active, Object3DComponent] }
};
const METAL = 0, RUBBER = 1, WOOD = 2, STATIC = 3, levels = [
  // 1
  {
    targets: [{
      position: { x: 0.7, y: 1, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: -0.7, y: 1, z: 0 },
      linearVelocity: { x: 2, y: 2, z: 0 }
    }],
    elements: [
      {
        type: RUBBER,
        position: { x: 0, y: 1.1, z: 0 },
        rotation: { x: 0, y: 0, z: Math.PI / 2 }
      }
    ]
  },
  // 2
  {
    targets: [{
      position: { x: 0.7, y: 0.7, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: -0.6, y: 1.2, z: 0 },
      linearVelocity: { x: 0.6, y: 2.8, z: 0 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: -0.3, y: 0.5, z: 0 },
        rotation: { x: -0.1, y: 0, z: -0.2 }
      },
      {
        type: WOOD,
        position: { x: 0.1, y: 0.75, z: -0.2 },
        rotation: { x: -0.3, y: 0.1, z: 1.1 }
      }
    ]
  },
  // 3
  {
    targets: [{
      position: { x: 0.5, y: 1.4, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: -0.5, y: 1, z: 0 },
      linearVelocity: { x: 1, y: -2, z: 0 }
    }],
    elements: [
      {
        type: METAL,
        position: { x: -0.1, y: 1, z: 0 },
        rotation: { x: 0.2, y: 0.3, z: 0 }
      },
      {
        type: RUBBER,
        position: { x: 0.4, y: 0.95, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.2, y: 1.5, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.4, y: 0.8, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 4
  {
    targets: [{
      position: { x: 0.6, y: 1.2, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: -0.7, y: 1, z: 0 },
      linearVelocity: { x: 2, y: -1, z: 0 }
    }],
    elements: [
      {
        type: METAL,
        position: { x: -0.5, y: 0.8, z: 0 },
        rotation: { x: 1.4, y: 1.4, z: -1.5 }
      },
      {
        type: RUBBER,
        position: { x: 0.5, y: 0.5, z: 0 },
        rotation: { x: -1.4, y: 1.4, z: 1.1 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.3, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.5, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.2, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 5
  {
    targets: [{
      position: { x: 0.5, y: 0.65, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: 0.1, y: 1.4, z: 0 },
      linearVelocity: { x: -3, y: 0.5, z: 0 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: 0.1, y: 0.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: RUBBER,
        position: { x: 1, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.22, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.22, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.44, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 6
  {
    targets: [{
      position: { x: 0.6, y: 1.6, z: 0 },
      rotation: { x: Math.PI / 2, y: 0.3, z: 0 }
    }],
    generators: [{
      position: { x: -1.4, y: 1, z: 0 },
      linearVelocity: { x: 2, y: 3, z: 0 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: 0.4, y: 0.5, z: 0 },
        rotation: { x: 0.08, y: 0, z: 0.2 }
      },
      {
        type: RUBBER,
        position: { x: 0.6, y: 0.7, z: 0 },
        rotation: { x: 0.3, y: 0, z: -0.1 }
      },
      {
        type: RUBBER,
        position: { x: -0.5, y: 0.96, z: 0 },
        rotation: { x: 0.5, y: 0, z: 0.7 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.8, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.2, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 7
  {
    targets: [{
      position: { x: 0, y: 1, z: 0 },
      rotation: { x: 0, y: Math.PI / 2, z: 0 }
    }],
    generators: [{
      position: { x: 0.8, y: 1.7, z: 0 },
      linearVelocity: { x: -0.4, y: 3, z: 0 }
    }],
    elements: [
      {
        type: METAL,
        position: { x: -0.7, y: 1.5, z: 0 },
        rotation: { x: 0.2, y: 0, z: -0.3 }
      },
      {
        type: WOOD,
        position: { x: 0.6, y: 0.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0.6 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: 0 },
        rotation: { x: 0.1, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.4, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.4, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.2, y: 1.2, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.2, y: 0.8, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.2, y: 1.2, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.2, y: 0.8, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 8
  {
    targets: [{
      position: { x: -0.7, y: 0.8, z: 0 },
      rotation: { x: -0.1, y: -1.5, z: 2.2 }
    }],
    generators: [{
      position: { x: -0.1, y: 1.58, z: 0 },
      linearVelocity: { x: 3, y: 1, z: 0 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: 0.7, y: 1.3, z: 0 },
        rotation: { x: 0.1, y: 0, z: -0.2 }
      },
      {
        type: RUBBER,
        position: { x: 0.5, y: 0.7, z: 0 },
        rotation: { x: 0.1, y: -0.4, z: 0.7 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.8, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.2, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.4, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.8, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.6, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.2, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.8, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.4, z: 0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.8, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.6, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.2, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.8, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.6, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 0.4, z: -0.2 },
        rotation: { x: 0, y: 0, z: 0 }
      }
    ]
  },
  // 9
  {
    targets: [{
      position: { x: 0.8, y: 0.7, z: -0.7 },
      rotation: { x: 2.6, y: 0.9, z: 3 }
    }],
    generators: [{
      position: { x: -1, y: 1.4, z: -0.2 },
      linearVelocity: { x: 2, y: 2, z: 1.5 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: -0.3, y: 0.8, z: 0.1 },
        rotation: { x: -0.1, y: 0.3, z: -0.2 }
      },
      {
        type: METAL,
        position: { x: 0.4, y: 1.3, z: 0 },
        rotation: { x: 0, y: 0.6, z: 0.1 }
      },
      {
        type: WOOD,
        position: { x: 0, y: 0.9, z: 0 },
        rotation: { x: -0.1, y: -0.1, z: -0.2 }
      },
      {
        type: STATIC,
        position: { x: 0.3, y: 0.5, z: -0.4 },
        rotation: { x: -0.1, y: -0.4, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.6, y: 1, z: 0.1 },
        rotation: { x: 0, y: 0.5, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.3, y: 1, z: -0.4 },
        rotation: { x: -0.1, y: 0.1, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.1, y: 0.9, z: -0.6 },
        rotation: { x: -0.1, y: -0.3, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.3, y: 1.3, z: -0.3 },
        rotation: { x: 0.1, y: -0.5, z: 0.1 }
      },
      {
        type: STATIC,
        position: { x: 0.5, y: 0.9, z: 0 },
        rotation: { x: 0, y: -0.7, z: -0.1 }
      },
      {
        type: STATIC,
        position: { x: 0.5, y: 0.8, z: -0.5 },
        rotation: { x: 0, y: 0.3, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.3, y: 1.5, z: -0.2 },
        rotation: { x: 0.1, y: 0.1, z: -0.1 }
      }
    ]
  },
  // 10
  {
    targets: [{
      position: { x: 1.2, y: 0.8, z: 0 },
      rotation: { x: 0, y: 1.5, z: 0 }
    }],
    generators: [{
      position: { x: -1.2, y: 1.7, z: 0 },
      linearVelocity: { x: 0.4, y: 1, z: -1.5 }
    }],
    elements: [
      {
        type: WOOD,
        position: { x: -0.4, y: 1.5, z: -0.4 },
        rotation: { x: 0.3, y: 0.1, z: -0.5 }
      },
      {
        type: WOOD,
        position: { x: 0.1, y: 0.7, z: -0.4 },
        rotation: { x: -0.2, y: -0.2, z: 0.2 }
      },
      {
        type: RUBBER,
        position: { x: -0.3, y: 0.8, z: 0 },
        rotation: { x: -0.1, y: 0.4, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.3, y: 1.2, z: -0.4 },
        rotation: { x: 0.1, y: -0.1, z: -0.1 }
      },
      {
        type: STATIC,
        position: { x: 0.8, y: 1, z: -0.4 },
        rotation: { x: 0, y: -0.8, z: 0.1 }
      },
      {
        type: STATIC,
        position: { x: -0.5, y: 0.9, z: -0.2 },
        rotation: { x: -0.1, y: 0.4, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.6, y: 0.8, z: -0.1 },
        rotation: { x: 0, y: -0.8, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.1, y: 1, z: -0.8 },
        rotation: { x: 0, y: -0.4, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0.3, y: 1, z: -0.4 },
        rotation: { x: 0, y: -0.5, z: 0 }
      },
      {
        type: STATIC,
        position: { x: 0, y: 1.4, z: -0.6 },
        rotation: { x: 0.2, y: -0.3, z: 0.1 }
      },
      {
        type: STATIC,
        position: { x: -0.6, y: 1.2, z: -0.2 },
        rotation: { x: 0.1, y: 0.4, z: -0.2 }
      },
      {
        type: STATIC,
        position: { x: 0.4, y: 1.2, z: 0.1 },
        rotation: { x: 0, y: -0.3, z: 0 }
      },
      {
        type: STATIC,
        position: { x: -0.9, y: 1.5, z: -0.7 },
        rotation: { x: 0, y: 0.2, z: -0.1 }
      },
      {
        type: STATIC,
        position: { x: -0.5, y: 1.1, z: 0.2 },
        rotation: { x: 0.1, y: 0.8, z: -0.2 }
      },
      {
        type: STATIC,
        position: { x: -0.5, y: 1.2, z: -0.8 },
        rotation: { x: 0.1, y: -0.1, z: -0.1 }
      },
      {
        type: STATIC,
        position: { x: 0.7, y: 0.7, z: 0.3 },
        rotation: { x: 0.1, y: -1.1, z: 0.2 }
      }
    ]
  }
];
class GameStateSystem extends System {
  setVisibilityByName(t, r) {
    let n = this.world.entityManager.getEntityByName(t);
    n && (n.getMutableComponent(Visible).value = r);
  }
  finish() {
    this.stopGame(), this.setVisibilityByName("startbutton", !0), this.setVisibilityByName("finished", !0), this.setVisibilityByName("playingGroup", !1), this.world.getSystem(LevelManager).clearCurrentLevel(), this.world.entityManager.getEntityByName("singleton").getMutableComponent(Level).value = 1, this.queries.raycasters.results.forEach((n) => {
      n.getMutableComponent(Raycaster).layerMask = 4;
    });
    let t = this.world.entityManager.getEntityByName("panelInfo");
    t.addComponent(Play);
    let r = t.getObject3D().children[0];
    r.userData.oldPosition || (r.userData.oldPosition = new Vector3()), r.userData.oldPosition.copy(r.position), r.position.set(0, 1.6, -2), r.scale.set(3, 3, 3);
  }
  playGame() {
    let t = this.queries.gameState.results[0].getMutableComponent(
      GameState
    );
    if (t.playing)
      return;
    this.setVisibilityByName("help", !1), this.setVisibilityByName("startbutton", !1), this.setVisibilityByName("finished", !1), this.setVisibilityByName("playingGroup", !0), this.setVisibilityByName("panelInfo", !0), this.queries.raycasters.results.forEach((a) => {
      a.getMutableComponent(Raycaster).layerMask = 2;
    }), t.playing = !0, t.numBallsFailed = 0, t.numBallsTotal = 0, t.levelStartTime = performance.now(), t.gameStartTime = performance.now(), this.updateTexts(t), this.queries.ballGenerators.results.forEach((a) => {
      a.addComponent(Active);
    });
    let r = this.world.entityManager.getEntityByName("panelInfo");
    r.addComponent(Stop);
    let n = r.getComponent(Object3DComponent);
    n && (n = n.value.children[0], n.userData.oldPosition && n.position.copy(n.userData.oldPosition), n.scale.set(1, 1, 1)), this.world.getSystem(PhysicsSystem).play();
  }
  updateTexts(t) {
    let r = this.world.entityManager.getEntityByName("numberBalls");
    r && (r.getMutableComponent(
      Text
    ).text = `${t.numBallsFailed}/${t.numBallsTotal}`);
  }
  stopGame() {
    this.queries.gameState.results[0].getMutableComponent(
      GameState
    ).playing = !1;
  }
  execute() {
    var t = this.queries.gameState.results[0].getComponent(GameState);
    if (!t.playing)
      return;
    let r = performance.now() - t.levelStartTime, n = performance.now() - t.gameStartTime, a = this.world.entityManager.getEntityByName("singleton"), o = this.world.entityManager.getEntityByName("timer");
    o && (o.getMutableComponent(Text).text = new Date(r).toISOString().substr(14, 5));
    let s = this.world.entityManager.getEntityByName("timerTotal");
    s && (s.getMutableComponent(Text).text = new Date(n).toISOString().substr(14, 5)), this.queries.ballFloorCollided.added.forEach((l) => {
      t.numBallsFailed++, this.world.entityManager.getEntityByName("numberBalls").getMutableComponent(
        Text
      ).text = `${t.numBallsFailed}`;
      let c = a.getComponent(Level).value;
      this.queries.ballGenerators.results.forEach((u) => {
        u.addComponent(Play);
      }), setTimeout(() => {
        a.getComponent(Level).value === c && this.queries.ballGenerators.results.forEach((u) => {
          u.addComponent(Active);
        });
      }, 1900), setTimeout(() => {
        !l || !l.alive || a.getComponent(Level).value;
      }, 2e3), l.addComponent(Dissolve);
    }), this.queries.targetCleared.added.forEach((l) => {
      l.getComponent(Sound).sound.play(), setTimeout(() => {
        var c = a.getMutableComponent(Level);
        c.value === levels.length - 1 ? (c.value = 1, this.finish()) : (c.value++, t.levelStartTime = performance.now(), t.levelFinished = !1);
      }, 2e3), t.levelFinished = !0;
    });
  }
}
GameStateSystem.queries = {
  ballGenerators: { components: [BallGenerator] },
  gameState: {
    components: [GameState],
    listen: {
      changed: !0
    }
  },
  ballFloorCollided: {
    components: [Ball, FloorCollided],
    listen: {
      added: !0
    }
  },
  targetCleared: {
    components: [Target, Cleared],
    listen: {
      added: !0
    }
  },
  raycasters: {
    components: [Raycaster]
  }
};
const RADIUS = 0.03;
class BallGeneratorSystem extends System {
  execute() {
    this.queries.entities.added.forEach((t) => {
      let r = t.getComponent(Sound);
      r.sound && r.sound.play();
      var n = t.getComponent(BallGenerator), a = this.world.createEntity();
      a.addComponent(GLTFLoader$1, {
        url: "assets/models/ball.glb",
        onLoaded: (o) => {
          a.getMutableComponent(Object3DComponent).value = o.children[0], o.children[0].material = new THREE.MeshPhongMaterial({
            map: textures["ball.png"],
            envMap: environmentMap,
            reflectivity: 0.2
          });
        }
      }).addComponent(Transform, {
        position: n.position,
        rotation: { x: 0, y: 0, z: 0 }
      }).addComponent(Shape, {
        primitive: "sphere",
        radius: RADIUS
      }).addComponent(RigidBody, {
        weight: 10,
        restitution: 0.5,
        friction: 0.5,
        linearDamping: 0,
        angularDamping: 0,
        linearVelocity: n.linearVelocity
      }).addComponent(LevelItem).addComponent(Ball, {
        position: n.position,
        radius: RADIUS,
        linearVelocity: n.linearVelocity
      }).addComponent(Active).addComponent(Parent, {
        value: this.world.entityManager.getEntityByName("playingGroup")
      }), t.removeComponent(Active);
    });
  }
}
BallGeneratorSystem.queries = {
  entities: {
    components: [BallGenerator, Active],
    listen: {
      added: !0
    }
  }
};
class DissolveSystem extends System {
  execute(t) {
    var r = this.queries.entities.results;
    for (let s = 0; s < r.length; s++) {
      var n = r[s], a = n.getMutableComponent(Dissolve), o = n.getObject3D();
      o.material && (o.material.opacity = a.value, o.material.transparent = !0, a.value -= t * a.speed, a.value <= 0 && n.remove());
    }
  }
}
DissolveSystem.queries = {
  entities: {
    components: [Ball, Dissolve, Object3DComponent],
    listen: {
      added: !0
    }
  }
};
class RotatingSystem extends System {
  execute(t) {
    this.queries.entities.results.forEach((r) => {
      var n = r.getComponent(Rotating), a = r.getObject3D();
      a.rotation.x += n.speed.x * t, a.rotation.y += n.speed.y * t, a.rotation.z += n.speed.z * t;
    });
  }
}
RotatingSystem.queries = {
  entities: {
    components: [Object3DComponent, Rotating]
  }
};
const urlParams$2 = new URLSearchParams(window.location.search);
var editMode$1 = urlParams$2.has("edit");
const elementTypes = [
  {
    model: "metal",
    restitution: 1.7,
    draggable: !0,
    scale: 1,
    sound: "metal.ogg",
    material: new MeshPhongMaterial({
      map: textures["metal.jpg"],
      envMap: environmentMap,
      specularMap: textures["metal_spec.jpg"],
      shininess: 70,
      specular: new Color(8947848),
      reflectivity: 0.7
    })
  },
  {
    model: "rubber",
    restitution: 2.5,
    draggable: !0,
    scale: 1,
    sound: "rubber.ogg",
    material: new MeshPhongMaterial({
      map: textures["rubber.png"],
      envMap: environmentMap,
      shininess: 10,
      specular: new Color(400159),
      reflectivity: 0.1
    })
  },
  {
    model: "wood",
    restitution: 1,
    draggable: !0,
    scale: 1,
    sound: "wood.ogg",
    material: new MeshPhongMaterial({
      map: textures["wood.png"],
      envMap: environmentMap,
      specularMap: textures["wood_spec.jpg"],
      shininess: 20,
      specular: new Color(6710886),
      reflectivity: 0.5
    })
  },
  {
    model: "static",
    restitution: 0.05,
    draggable: editMode$1,
    scale: 0.2,
    sound: "",
    material: new MeshLambertMaterial({
      map: textures["floor.png"]
    })
  }
];
class ElementSystem extends System {
  execute() {
    var t = this.queries.entities.added;
    for (let n = 0; n < t.length; n++) {
      let a = t[n];
      var r = a.getComponent(Element);
      const o = elementTypes[r.type];
      a.addComponent(GLTFLoader$1, {
        url: "assets/models/" + o.model + ".glb",
        onLoaded: (s) => {
          let l = s.children[0], c = l.geometry;
          o.scale && (c.scale(o.scale, o.scale, o.scale), c.computeBoundingBox());
          let u = c.boundingBox.min, h = c.boundingBox.max, f = Math.abs(h.x - u.x), d = Math.abs(h.y - u.y), p = Math.abs(h.z - u.z);
          l.material = o.material.clone(), a.addComponent(Shape, {
            primitive: "box",
            width: f,
            height: d,
            depth: p
          }), a.addComponent(Sound, {
            url: "assets/sounds/" + o.sound
          });
        }
      }).addComponent(RigidBody, {
        weight: 0,
        restitution: o.restitution,
        friction: 0.5,
        linearDamping: 0,
        angularDamping: 0
      }), o.draggable && a.addComponent(Draggable);
    }
    this.queries.colliding.results.forEach((n) => {
      let a = n.getComponent(Colliding), o = n.hasComponent(Ball), s = o ? n : a.collidingWith[0], l = o ? a.collidingWith[0] : n;
      l.hasComponent(Floor) ? s.hasComponent(Active) && (l.getComponent(Sound).sound.play(), s.removeComponent(Active), s.addComponent(FloorCollided)) : l.hasComponent(Sound) && l.getComponent(Sound).sound.play();
    });
  }
}
ElementSystem.queries = {
  entities: {
    components: [Element],
    listen: {
      added: !0
    }
  },
  colliding: {
    components: [CollisionStart]
  }
};
class OutputSystem extends System {
  trimDecimals(t) {
    t.x = Math.floor(t.x * 10) / 10, t.y = Math.floor(t.y * 10) / 10, t.z = Math.floor(t.z * 10) / 10;
  }
  outputJSON() {
    var t = {
      targets: [],
      generators: [],
      elements: []
    };
    this.queries.elements.results.forEach((r) => {
      var n = {}, a = r.getComponent(Element);
      n.type = a.type;
      var o = r.getObject3D();
      n.position = JSON.parse(JSON.stringify(o.position)), n.rotation = {
        x: o.rotation._x,
        y: o.rotation._y,
        z: o.rotation._z
      }, this.trimDecimals(n.position), this.trimDecimals(n.rotation), t.elements.push(n);
    }), this.queries.targets.results.forEach((r) => {
      var n = {}, a = r.getObject3D();
      n.position = JSON.parse(JSON.stringify(a.position)), n.rotation = {
        x: a.rotation._x,
        y: a.rotation._y,
        z: a.rotation._z
      }, this.trimDecimals(n.position), this.trimDecimals(n.rotation), t.targets.push(n);
    }), this.queries.generators.results.forEach((r) => {
      var n = {}, a = r.getComponent(BallGenerator), o = r.getObject3D();
      n.position = JSON.parse(JSON.stringify(o.position)), n.linearVelocity = a.linearVelocity, this.trimDecimals(n.position), this.trimDecimals(n.linearVelocity), t.generators.push(n);
    }), console.log(JSON.stringify(t, null, 2));
  }
  execute() {
  }
}
OutputSystem.queries = {
  elements: { components: [Element] },
  targets: { components: [Target] },
  generators: { components: [BallGenerator] }
};
const urlParams$1 = new URLSearchParams(window.location.search);
var editMode = urlParams$1.has("edit");
class LevelManager extends System {
  execute() {
    this.queries.levels.added.forEach((t) => {
      this.initializeLevel(t.getComponent(Level).value);
    }), this.queries.levels.changed.forEach((t) => {
      this.initializeLevel(t.getComponent(Level).value);
    });
  }
  clearCurrentLevel() {
    for (var t = this.queries.levelItems.results, r = t.length - 1; r >= 0; r--)
      t[r].remove();
  }
  initializeLevel(t) {
    t > levels.length && (t = 0);
    let r = this.world.entityManager.getEntityByName("level");
    r && (r.getMutableComponent(Text).text = t);
    let n = this.world.entityManager.getEntityByName("levelGroup");
    this.clearCurrentLevel();
    var a = levels[t];
    let o = this.world.entityManager.getEntityByName("singleton");
    a.generators.forEach((s) => {
      let l = new Vector3().copy(s.linearVelocity).normalize(), c = this.world.createEntity().addComponent(BallGenerator, {
        position: s.position,
        linearVelocity: s.linearVelocity
      }).addComponent(GLTFLoader$1, {
        url: "assets/models/cannon.glb",
        onLoaded: (u, h) => {
          u.lookAt(l), u.getObjectByName(
            "cannon"
          ).material = new MeshPhongMaterial({
            map: textures["cannon.jpg"],
            envMap: environmentMap,
            reflectivity: 0.2,
            specularMap: textures["cannon_spec.jpg"],
            shininess: 50,
            specular: new Color(3355443)
          });
          var f = new MeshBasicMaterial({ color: 15188515 });
          u.getObjectByName("explosion").material = f, u.getObjectByName("sparks").material = f;
          let d = u.userData.mixer = new AnimationMixer(
            u
          );
          const p = AnimationClip.findByName(
            h.animations,
            "cannonAction"
          ), g = d.clipAction(p, u);
          u.userData.animationClip = g;
        }
      }).addComponent(Animation, { duration: 2.35 }).addComponent(Sound, { url: "assets/sounds/cannon.ogg" }).addComponent(Position, {
        value: new Vector3().copy(s.position)
      }).addComponent(LevelItem).addComponent(Parent, { value: n });
      editMode && c.addComponent(Draggable), o.getComponent(GameState).playing && setTimeout(() => {
        c.addComponent(Play), setTimeout(() => {
          c.addComponent(Active);
        }, 1900);
      }, 2e3);
    }), a.targets.forEach((s) => {
      let l = this.world.createEntity().addComponent(Target).addComponent(GLTFLoader$1, {
        url: "assets/models/target.glb",
        onLoaded: (c) => {
          c.children[0].material = new MeshPhongMaterial({
            map: textures["target.png"],
            envMap: environmentMap,
            reflectivity: 0.2
          });
        }
      }).addComponent(Transform, {
        position: s.position,
        rotation: s.rotation
      }).addComponent(LevelItem).addComponent(Parent, { value: n }).addComponent(Sound, { url: "assets/sounds/target.ogg" });
      editMode && l.addComponent(Draggable);
    }), a.elements.forEach((s) => {
      this.world.createEntity().addComponent(Element, { type: s.type }).addComponent(Transform, {
        position: s.position,
        rotation: s.rotation
      }).addComponent(LevelItem).addComponent(Parent, { value: n });
    });
  }
}
LevelManager.queries = {
  /* @todo singleton */
  levels: {
    components: [Level],
    listen: {
      added: !0,
      changed: !0
    }
  },
  levelItems: {
    components: [LevelItem]
  }
};
class CameraRigSystem extends System {
  init() {
    window.addEventListener("resize", this.onWindowResize.bind(this), !1);
  }
  execute() {
    this.queries.entities.added.forEach((t) => {
      var r = new Group();
      t.addComponent(Object3DComponent, { value: r }).addComponent(Position, { value: new Vector3(0, 0, 0.5) }), this.world.entityManager.queryComponents([
        Camera,
        Active
      ]).entities.forEach((a) => {
        a.removeComponent(Active);
      }), this.world.createEntity().addComponent(Position, {
        value: new Vector3(0, 1.6, -0.6)
      }).addObject3DComponent(
        new PerspectiveCamera(
          90,
          window.innerWidth / window.innerHeight,
          0.1,
          500
        ),
        t
      ).addComponent(UpdateAspectOnResizeTag).addComponent(Active), this.world.createEntity().addComponent(VRController, { id: 0 }).addComponent(Parent, { value: t }), this.world.createEntity().addComponent(VRController, { id: 1 }).addComponent(Parent, { value: t });
    });
  }
  onWindowResize() {
    this.queries.entities.results.forEach((t) => {
    });
  }
}
CameraRigSystem.queries = {
  entities: {
    components: [CameraRig],
    listen: {
      added: !0
    }
  }
};
var raycaster = new Raycaster$1(), tempMatrix = new Matrix4(), intersected = [];
function setEmisive(e, t, r) {
  e.traverse((n) => {
    n.material && n.material.emissive && (r ? n.material.emissive[r] = t : n.material.emissive.set(t));
  });
}
class VRControllerInteraction extends System {
  execute() {
    this.queries.dragging.results.forEach((t) => {
      this.reposition(t.getObject3D(), !0);
    }), this.queries.objects.added.forEach((t) => {
      let r = t.getObject3D().children[0];
      t.addComponent(RaycastReceiver, {
        layerMask: 2,
        onHover: (n, a) => {
          let s = a.getObject3D().getObjectByName("line");
          s.scale.z = n.distance;
        },
        onEnter: () => {
          setEmisive(r, 2245717);
        },
        onLeave: (n) => {
          let o = n.getObject3D().getObjectByName("line");
          o.scale.z = 10, setEmisive(r, 0);
        },
        onSelectStart: this.onSelectStart.bind(this)
      });
    }), this.world.getSystem(InputSystem).inputStateComponent.vrcontrollers.forEach((t, r) => {
      t.selectEnd && this.onSelectEnd(r);
    }), this.queries.controllers.added.forEach((t) => {
      t.addComponent(Raycaster, {
        value: raycaster,
        layerMask: 4
      });
      var r = new BufferGeometry().setFromPoints([
        new Vector3(0, 0, 0),
        new Vector3(0, 0, -1)
      ]), n = new Line(r);
      n.name = "line", n.scale.z = 5;
      let a = t.getObject3D().getObjectByName("controller");
      this.world.createEntity().addComponent(Object3DComponent, { value: n }).addComponent(ParentObject3D, { value: a });
    }), this.cleanIntersected();
  }
  onSelectStart(t, r) {
    var n = r;
    tempMatrix.getInverse(n.matrixWorld);
    var a = t.object.parent;
    a.matrix.premultiply(tempMatrix), a.matrix.decompose(a.position, a.quaternion, a.scale), setEmisive(a, 1, "b"), a.userData.previousParent = a.parent, n.add(a), a.children[0].material.transparent = !0, a.children[0].renderOrder = 20, a.children[0].material.opacity = 0.5, n.userData.selected = a, this.disablePhysics(a);
  }
  onSelectEnd(t) {
    if (t.userData.selected !== void 0) {
      var r = t.userData.selected;
      r.children[0].material.transparent = !1, r.userData.entity.removeComponent(Dragging), r.matrix.premultiply(t.matrixWorld), r.matrix.decompose(r.position, r.quaternion, r.scale), setEmisive(r, 0, "b"), r.userData.previousParent.add(r), t.userData.selected = void 0, this.reposition(r);
    }
  }
  disablePhysics(t) {
    const r = new Ammo.btTransform();
    r.setIdentity(), r.setOrigin(new Ammo.btVector3(0, -10, 0)), t.userData.body.setWorldTransform(r);
  }
  reposition(t, r) {
    if (t.userData.body)
      if (r) {
        var n = new Vector3(), a = new Vector3(), o = new Quaternion();
        t.updateWorldMatrix(!0), t.matrixWorld.decompose(n, o, a);
        var s = t.userData.body.getWorldTransform();
        s.setIdentity();
        const l = new Ammo.btTransform();
        l.setIdentity(), l.setOrigin(
          new Ammo.btVector3(n.x, n.y, n.z)
        ), l.setRotation(
          new Ammo.btQuaternion(
            o.x,
            o.y,
            o.z,
            o.w
          )
        ), t.userData.body.setWorldTransform(l);
      } else {
        const l = new Ammo.btTransform();
        l.setIdentity(), l.setOrigin(
          new Ammo.btVector3(
            t.position.x,
            t.position.y,
            t.position.z
          )
        ), l.setRotation(
          new Ammo.btQuaternion(
            t.quaternion.x,
            t.quaternion.y,
            t.quaternion.z,
            t.quaternion.w
          )
        ), t.userData.body.setWorldTransform(l);
      }
  }
  cleanIntersected() {
    for (; intersected.length; ) {
      var t = intersected.pop();
      t.material.emissive.r = 0;
    }
  }
}
VRControllerInteraction.queries = {
  controllers: {
    components: [VRController],
    listen: {
      added: !0
    }
  },
  objects: {
    components: [Draggable, Object3DComponent],
    listen: {
      added: !0
    }
  },
  dragging: { components: [Dragging] },
  rendererContext: {
    components: [WebGLRendererContext],
    mandatory: !0
  }
};
var quaternion = new Quaternion(), euler = new Euler();
class PhysicsSystem extends System {
  init() {
    this.epsilon = 1e-5, this.collisions = /* @__PURE__ */ new Map(), this.collisionKeys = [], this.frame = 0, this._physicsWorld = this._createWorld(), this._transform = new Ammo.btTransform(), this._quaternion = new Ammo.btQuaternion(0, 0, 0, 1), this.bodyToEntity = /* @__PURE__ */ new Map();
  }
  execute(t) {
    this.frame++, this.queries.entities.added.forEach((a) => {
      var o = a.getObject3D();
      const s = this._setupRigidBody(this._createRigidBody(a), a);
      s.setCcdMotionThreshold(0.01), s.setCcdSweptSphereRadius(0.01), s.Object3DComponent = o, o.userData.body = s, this._physicsWorld.addRigidBody(s);
    }), this._physicsWorld.stepSimulation(t, 4, 1 / 60), this.queries.collisionsStart.results.forEach((a) => {
      a.removeComponent(CollisionStart);
    });
    const r = this.dispatcher.getNumManifolds();
    for (let a = 0; a < r; a++) {
      const o = this.dispatcher.getManifoldByIndexInternal(a), s = o.getNumContacts(), l = Ammo.getPointer(o.getBody0()), c = Ammo.getPointer(o.getBody1());
      for (let u = 0; u < s; u++)
        if (o.getContactPoint(u).getDistance() <= this.epsilon) {
          let d = this.bodyToEntity.get(l), p = this.bodyToEntity.get(c);
          d.hasComponent(Colliding) || (d.addComponent(Colliding, { collidingFrame: this.frame }), d.addComponent(CollisionStart));
          let g = d.getMutableComponent(Colliding);
          g.collidingWith.indexOf(p) === -1 && g.collidingWith.push(p);
          break;
        }
    }
    const n = this.queries.entities.results;
    for (let a = 0, o = n.length; a < o; a++) {
      const s = n[a];
      if (s.getComponent(RigidBody).weight === 0) continue;
      const c = s.getObject3D(), u = c.userData.body;
      if (u.isActive() && u.getMotionState()) {
        const h = this._transform, f = this._quaternion;
        u.getMotionState().getWorldTransform(h);
        const d = h.getOrigin();
        h.getBasis().getRotation(f), c.position.set(d.x(), d.y(), d.z()), c.quaternion.set(f.x(), f.y(), f.z(), f.w());
        let p = s.getMutableComponent(Transform);
        p.position.copy(c.position), p.rotation.copy(c.rotation);
      }
    }
    this.queries.entities.removed.forEach((a) => {
      this._removeRigidBody(a);
    }), this.queries.collisionsStop.results.forEach((a) => {
      a.removeComponent(CollisionStop);
    }), this.queries.collisions.results.forEach((a) => {
      a.getComponent(Colliding).collidingFrame !== this.frame && (a.removeComponent(Colliding), a.addComponent(CollisionStop));
    });
  }
  _removeRigidBody(t) {
    var r = t.getRemovedComponent(Object3DComponent);
    if (r) {
      let a = r.value;
      var n = a.userData.body;
      this._physicsWorld.removeRigidBody(n), this.bodyToEntity.delete(Ammo.getPointer(n)), Ammo.destroy(n), delete a.userData.body;
    } else
      console.warn(">>>>>>>>>>>>>>> Not found");
  }
  _createWorld() {
    const t = new Ammo.btDefaultCollisionConfiguration();
    this.dispatcher = new Ammo.btCollisionDispatcher(t);
    const r = new Ammo.btDbvtBroadphase(), n = new Ammo.btSequentialImpulseConstraintSolver(), a = new Ammo.btDiscreteDynamicsWorld(
      this.dispatcher,
      r,
      n,
      t
    );
    return a.setGravity(new Ammo.btVector3(0, -9.8, 0)), a;
  }
  _createShape(t) {
    var r = t.getComponent(Shape);
    return r.primitive === "box" ? new Ammo.btBoxShape(
      new Ammo.btVector3(r.width / 2, r.height / 2, r.depth / 2)
    ) : r.primitive === "sphere" ? new Ammo.btSphereShape(r.radius) : new Ammo.btBoxShape(new Ammo.btVector3(1, 1, 1));
  }
  _createRigidBody(t) {
    const r = t.getComponent(RigidBody), n = t.getComponent(Transform), a = this._createShape(t), o = new Ammo.btVector3(0, 0, 0);
    a.calculateLocalInertia(r.weight, o);
    const s = new Ammo.btTransform();
    s.setIdentity(), s.setOrigin(
      new Ammo.btVector3(
        n.position.x,
        n.position.y,
        n.position.z
      )
    ), euler.set(n.rotation.x, n.rotation.y, n.rotation.z), quaternion.setFromEuler(euler), s.setRotation(
      new Ammo.btQuaternion(
        quaternion.x,
        quaternion.y,
        quaternion.z,
        quaternion.w
      )
    );
    const l = new Ammo.btDefaultMotionState(s), c = new Ammo.btRigidBodyConstructionInfo(
      r.weight,
      l,
      a,
      o
    );
    var u = new Ammo.btRigidBody(c);
    return this.bodyToEntity.set(Ammo.getPointer(u), t), u;
  }
  _setupRigidBody(t, r) {
    const n = r.getComponent(RigidBody), a = n.linearVelocity;
    return t.setRestitution(n.restitution), t.setFriction(n.friction), t.setDamping(n.linearDamping, n.angularDamping), t.setSleepingThresholds(0, 0), t.setLinearVelocity(
      new Ammo.btVector3(a.x, a.y, a.z)
    ), t;
  }
}
PhysicsSystem.queries = {
  entities: {
    components: [RigidBody, Shape, Object3DComponent],
    listen: {
      added: !0,
      removed: !0
    }
  },
  collisions: {
    components: [Colliding],
    listen: {
      added: !0
    }
  },
  collisionsStart: {
    components: [CollisionStart],
    listen: {
      added: !0
    }
  },
  collisionsStop: {
    components: [CollisionStop],
    listen: {
      added: !0
    }
  }
};
var version = "18.4.2", _Group = function() {
  this._tweens = {}, this._tweensAddedDuringUpdate = {};
};
_Group.prototype = {
  getAll: function() {
    return Object.keys(this._tweens).map((function(e) {
      return this._tweens[e];
    }).bind(this));
  },
  removeAll: function() {
    this._tweens = {};
  },
  add: function(e) {
    this._tweens[e.getId()] = e, this._tweensAddedDuringUpdate[e.getId()] = e;
  },
  remove: function(e) {
    delete this._tweens[e.getId()], delete this._tweensAddedDuringUpdate[e.getId()];
  },
  update: function(e, t) {
    var r = Object.keys(this._tweens);
    if (r.length === 0)
      return !1;
    for (e = e !== void 0 ? e : TWEEN.now(); r.length > 0; ) {
      this._tweensAddedDuringUpdate = {};
      for (var n = 0; n < r.length; n++) {
        var a = this._tweens[r[n]];
        a && a.update(e) === !1 && (a._isPlaying = !1, t || delete this._tweens[r[n]]);
      }
      r = Object.keys(this._tweensAddedDuringUpdate);
    }
    return !0;
  }
};
var TWEEN = new _Group();
TWEEN.Group = _Group;
TWEEN._nextId = 0;
TWEEN.nextId = function() {
  return TWEEN._nextId++;
};
typeof self > "u" && typeof process < "u" && process.hrtime ? TWEEN.now = function() {
  var e = process.hrtime();
  return e[0] * 1e3 + e[1] / 1e6;
} : typeof self < "u" && self.performance !== void 0 && self.performance.now !== void 0 ? TWEEN.now = self.performance.now.bind(self.performance) : Date.now !== void 0 ? TWEEN.now = Date.now : TWEEN.now = function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
TWEEN.Tween = function(e, t) {
  this._isPaused = !1, this._pauseStart = null, this._object = e, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._repeat = 0, this._repeatDelayTime = void 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = null, this._easingFunction = TWEEN.Easing.Linear.None, this._interpolationFunction = TWEEN.Interpolation.Linear, this._chainedTweens = [], this._onStartCallback = null, this._onStartCallbackFired = !1, this._onUpdateCallback = null, this._onRepeatCallback = null, this._onCompleteCallback = null, this._onStopCallback = null, this._group = t || TWEEN, this._id = TWEEN.nextId();
};
TWEEN.Tween.prototype = {
  getId: function() {
    return this._id;
  },
  isPlaying: function() {
    return this._isPlaying;
  },
  isPaused: function() {
    return this._isPaused;
  },
  to: function(e, t) {
    return this._valuesEnd = Object.create(e), t !== void 0 && (this._duration = t), this;
  },
  duration: function e(t) {
    return this._duration = t, this;
  },
  start: function(e) {
    this._group.add(this), this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._startTime = e !== void 0 ? typeof e == "string" ? TWEEN.now() + parseFloat(e) : e : TWEEN.now(), this._startTime += this._delayTime;
    for (var t in this._valuesEnd) {
      if (this._valuesEnd[t] instanceof Array) {
        if (this._valuesEnd[t].length === 0)
          continue;
        this._valuesEnd[t] = [this._object[t]].concat(this._valuesEnd[t]);
      }
      this._object[t] !== void 0 && (typeof this._valuesStart[t] > "u" && (this._valuesStart[t] = this._object[t]), this._valuesStart[t] instanceof Array || (this._valuesStart[t] *= 1), this._valuesStartRepeat[t] = this._valuesStart[t] || 0);
    }
    return this;
  },
  stop: function() {
    return this._isPlaying ? (this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback !== null && this._onStopCallback(this._object), this.stopChainedTweens(), this) : this;
  },
  end: function() {
    return this.update(1 / 0), this;
  },
  pause: function(e) {
    return this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = e === void 0 ? TWEEN.now() : e, this._group.remove(this), this);
  },
  resume: function(e) {
    return !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += (e === void 0 ? TWEEN.now() : e) - this._pauseStart, this._pauseStart = 0, this._group.add(this), this);
  },
  stopChainedTweens: function() {
    for (var e = 0, t = this._chainedTweens.length; e < t; e++)
      this._chainedTweens[e].stop();
  },
  group: function(e) {
    return this._group = e, this;
  },
  delay: function(e) {
    return this._delayTime = e, this;
  },
  repeat: function(e) {
    return this._repeat = e, this;
  },
  repeatDelay: function(e) {
    return this._repeatDelayTime = e, this;
  },
  yoyo: function(e) {
    return this._yoyo = e, this;
  },
  easing: function(e) {
    return this._easingFunction = e, this;
  },
  interpolation: function(e) {
    return this._interpolationFunction = e, this;
  },
  chain: function() {
    return this._chainedTweens = arguments, this;
  },
  onStart: function(e) {
    return this._onStartCallback = e, this;
  },
  onUpdate: function(e) {
    return this._onUpdateCallback = e, this;
  },
  onRepeat: function e(t) {
    return this._onRepeatCallback = t, this;
  },
  onComplete: function(e) {
    return this._onCompleteCallback = e, this;
  },
  onStop: function(e) {
    return this._onStopCallback = e, this;
  },
  update: function(e) {
    var t, r, n;
    if (e < this._startTime)
      return !0;
    this._onStartCallbackFired === !1 && (this._onStartCallback !== null && this._onStartCallback(this._object), this._onStartCallbackFired = !0), r = (e - this._startTime) / this._duration, r = this._duration === 0 || r > 1 ? 1 : r, n = this._easingFunction(r);
    for (t in this._valuesEnd)
      if (this._valuesStart[t] !== void 0) {
        var a = this._valuesStart[t] || 0, o = this._valuesEnd[t];
        o instanceof Array ? this._object[t] = this._interpolationFunction(o, n) : (typeof o == "string" && (o.charAt(0) === "+" || o.charAt(0) === "-" ? o = a + parseFloat(o) : o = parseFloat(o)), typeof o == "number" && (this._object[t] = a + (o - a) * n));
      }
    if (this._onUpdateCallback !== null && this._onUpdateCallback(this._object, r), r === 1)
      if (this._repeat > 0) {
        isFinite(this._repeat) && this._repeat--;
        for (t in this._valuesStartRepeat) {
          if (typeof this._valuesEnd[t] == "string" && (this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(this._valuesEnd[t])), this._yoyo) {
            var s = this._valuesStartRepeat[t];
            this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = s;
          }
          this._valuesStart[t] = this._valuesStartRepeat[t];
        }
        return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = e + this._repeatDelayTime : this._startTime = e + this._delayTime, this._onRepeatCallback !== null && this._onRepeatCallback(this._object), !0;
      } else {
        this._onCompleteCallback !== null && this._onCompleteCallback(this._object);
        for (var l = 0, c = this._chainedTweens.length; l < c; l++)
          this._chainedTweens[l].start(this._startTime + this._duration);
        return !1;
      }
    return !0;
  }
};
TWEEN.Easing = {
  Linear: {
    None: function(e) {
      return e;
    }
  },
  Quadratic: {
    In: function(e) {
      return e * e;
    },
    Out: function(e) {
      return e * (2 - e);
    },
    InOut: function(e) {
      return (e *= 2) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1);
    }
  },
  Cubic: {
    In: function(e) {
      return e * e * e;
    },
    Out: function(e) {
      return --e * e * e + 1;
    },
    InOut: function(e) {
      return (e *= 2) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2);
    }
  },
  Quartic: {
    In: function(e) {
      return e * e * e * e;
    },
    Out: function(e) {
      return 1 - --e * e * e * e;
    },
    InOut: function(e) {
      return (e *= 2) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2);
    }
  },
  Quintic: {
    In: function(e) {
      return e * e * e * e * e;
    },
    Out: function(e) {
      return --e * e * e * e * e + 1;
    },
    InOut: function(e) {
      return (e *= 2) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2);
    }
  },
  Sinusoidal: {
    In: function(e) {
      return 1 - Math.cos(e * Math.PI / 2);
    },
    Out: function(e) {
      return Math.sin(e * Math.PI / 2);
    },
    InOut: function(e) {
      return 0.5 * (1 - Math.cos(Math.PI * e));
    }
  },
  Exponential: {
    In: function(e) {
      return e === 0 ? 0 : Math.pow(1024, e - 1);
    },
    Out: function(e) {
      return e === 1 ? 1 : 1 - Math.pow(2, -10 * e);
    },
    InOut: function(e) {
      return e === 0 ? 0 : e === 1 ? 1 : (e *= 2) < 1 ? 0.5 * Math.pow(1024, e - 1) : 0.5 * (-Math.pow(2, -10 * (e - 1)) + 2);
    }
  },
  Circular: {
    In: function(e) {
      return 1 - Math.sqrt(1 - e * e);
    },
    Out: function(e) {
      return Math.sqrt(1 - --e * e);
    },
    InOut: function(e) {
      return (e *= 2) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1);
    }
  },
  Elastic: {
    In: function(e) {
      return e === 0 ? 0 : e === 1 ? 1 : -Math.pow(2, 10 * (e - 1)) * Math.sin((e - 1.1) * 5 * Math.PI);
    },
    Out: function(e) {
      return e === 0 ? 0 : e === 1 ? 1 : Math.pow(2, -10 * e) * Math.sin((e - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(e) {
      return e === 0 ? 0 : e === 1 ? 1 : (e *= 2, e < 1 ? -0.5 * Math.pow(2, 10 * (e - 1)) * Math.sin((e - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (e - 1)) * Math.sin((e - 1.1) * 5 * Math.PI) + 1);
    }
  },
  Back: {
    In: function(e) {
      var t = 1.70158;
      return e * e * ((t + 1) * e - t);
    },
    Out: function(e) {
      var t = 1.70158;
      return --e * e * ((t + 1) * e + t) + 1;
    },
    InOut: function(e) {
      var t = 2.5949095;
      return (e *= 2) < 1 ? 0.5 * (e * e * ((t + 1) * e - t)) : 0.5 * ((e -= 2) * e * ((t + 1) * e + t) + 2);
    }
  },
  Bounce: {
    In: function(e) {
      return 1 - TWEEN.Easing.Bounce.Out(1 - e);
    },
    Out: function(e) {
      return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
    },
    InOut: function(e) {
      return e < 0.5 ? TWEEN.Easing.Bounce.In(e * 2) * 0.5 : TWEEN.Easing.Bounce.Out(e * 2 - 1) * 0.5 + 0.5;
    }
  }
};
TWEEN.Interpolation = {
  Linear: function(e, t) {
    var r = e.length - 1, n = r * t, a = Math.floor(n), o = TWEEN.Interpolation.Utils.Linear;
    return t < 0 ? o(e[0], e[1], n) : t > 1 ? o(e[r], e[r - 1], r - n) : o(e[a], e[a + 1 > r ? r : a + 1], n - a);
  },
  Bezier: function(e, t) {
    for (var r = 0, n = e.length - 1, a = Math.pow, o = TWEEN.Interpolation.Utils.Bernstein, s = 0; s <= n; s++)
      r += a(1 - t, n - s) * a(t, s) * e[s] * o(n, s);
    return r;
  },
  CatmullRom: function(e, t) {
    var r = e.length - 1, n = r * t, a = Math.floor(n), o = TWEEN.Interpolation.Utils.CatmullRom;
    return e[0] === e[r] ? (t < 0 && (a = Math.floor(n = r * (1 + t))), o(e[(a - 1 + r) % r], e[a], e[(a + 1) % r], e[(a + 2) % r], n - a)) : t < 0 ? e[0] - (o(e[0], e[0], e[1], e[1], -n) - e[0]) : t > 1 ? e[r] - (o(e[r], e[r], e[r - 1], e[r - 1], n - r) - e[r]) : o(e[a ? a - 1 : 0], e[a], e[r < a + 1 ? r : a + 1], e[r < a + 2 ? r : a + 2], n - a);
  },
  Utils: {
    Linear: function(e, t, r) {
      return (t - e) * r + e;
    },
    Bernstein: function(e, t) {
      var r = TWEEN.Interpolation.Utils.Factorial;
      return r(e) / r(t) / r(e - t);
    },
    Factorial: /* @__PURE__ */ function() {
      var e = [1];
      return function(t) {
        var r = 1;
        if (e[t])
          return e[t];
        for (var n = t; n > 1; n--)
          r *= n;
        return e[t] = r, r;
      };
    }(),
    CatmullRom: function(e, t, r, n, a) {
      var o = (r - e) * 0.5, s = (n - t) * 0.5, l = a * a, c = a * l;
      return (2 * t - 2 * r + o + s) * c + (-3 * t + 3 * r - 2 * o - s) * l + o * a + t;
    }
  }
};
TWEEN.version = version;
function setColor(e, t) {
  e.traverse((r) => {
    r.material && r.material.color.setRGB(t, t, t);
  });
}
class UISystem extends System {
  execute(t, r) {
    TWEEN.update();
    const n = this.queries.entities;
    for (let a = 0; a < n.results.length; a++)
      n.results[a].getComponent(UI);
    for (let a = 0; a < n.added.length; a++) {
      const o = n.added[a];
      o.getComponent(UI);
      const s = o.getComponent(Button);
      let l = this.world.createEntity(), c = new Group();
      o.addComponent(Object3DComponent, { value: c }), o.addComponent(RaycastReceiver, {
        layerMask: 4,
        onHover: () => {
        },
        onEnter: () => {
          let u = o.getObject3D();
          setColor(u, 1), new TWEEN.Tween(u.scale).to(
            {
              x: 1.1,
              y: 1.1,
              z: 1.1
            },
            500
          ).onUpdate(() => {
          }).easing(TWEEN.Easing.Quadratic.Out).start();
        },
        onLeave: () => {
          let u = o.getObject3D();
          setColor(u, 0.7), new TWEEN.Tween(u.scale).to(
            {
              x: 1,
              y: 1,
              z: 1
            },
            300
          ).onUpdate(() => {
          }).easing(TWEEN.Easing.Quadratic.Out).start();
        },
        onSelectStart: () => {
          let u = o.getObject3D();
          setColor(u, 1), setTimeout(() => {
            setColor(u, 0.7);
          }, 300), new TWEEN.Tween(u.scale).to(
            {
              x: 1.2,
              y: 1.2,
              z: 1.2
            },
            100
          ).repeat(1).yoyo(!0).easing(TWEEN.Easing.Quadratic.Out).start().onComplete(() => {
            s.onClick && s.onClick();
          }), o.hasComponent(Sound) && o.getComponent(Sound).sound.play();
        }
      }), l.addComponent(Text, {
        color: "#999",
        font: "assets/fonts/WetinCaroWant.ttf",
        fontSize: 0.09,
        anchor: "center",
        textAlign: "center",
        baseline: "center",
        maxWidth: 10,
        lineHeight: 0,
        text: s.text
      }).addComponent(Position, { value: new Vector3(0, 0.03, 0.01) }).addComponent(Parent, { value: o });
    }
  }
}
UISystem.queries = {
  entities: {
    components: [UI, Button],
    listen: {
      added: !0,
      removed: !0,
      changed: !0
      // [UI]
    }
  }
};
class RaycasterSystem extends System {
  init() {
    this.world.registerComponent(Raycaster);
  }
  execute() {
    let t = this.queries.inputState.results[0].getComponent(
      InputState
    );
    this.queries.raycasters.added.forEach((r) => {
      new Raycaster$1();
    }), this.queries.raycasters.results.forEach((r) => {
      let n = r.getComponent(Raycaster);
      if (!n.enabled)
        return;
      var a = this.queries.receivers.results.filter((d) => {
        var p = d.getComponent(RaycastReceiver).layerMask;
        return (p & n.layerMask) !== 0;
      }).map((d) => {
        var p = d.getObject3D();
        return p.traverse((g) => {
          g.userData.entity = d;
        }), p;
      });
      if (a.length === 0)
        return;
      let o = n.value;
      var s = new Matrix4(), l = r.getObject3D().getObjectByName("controller");
      s.identity().extractRotation(l.matrixWorld), o.ray.origin.setFromMatrixPosition(l.matrixWorld), o.ray.direction.set(0, 0, -1).applyMatrix4(s);
      let c = o.intersectObjects(a, !0), u = r.getObject3D(), h = u ? u.children[0] : null, f = t.vrcontrollers.get(
        h
      );
      if (c.length > 0) {
        let d = c[0].object.parent ? c[0] : c[1], p = d.object, g = p.userData.entity;
        for (; !g && p.parent; )
          p = p.parent, g = p.userData.entity;
        if (g) {
          const v = g.getComponent(RaycastReceiver);
          v && !v.hovering && (v.hovering = !0, v.onEnter(d, r)), v.onHover && v.onHover(d, r), f && f.selectStart && v.onSelectStart && v.onSelectStart(d, h), n.currentEntity = g;
        }
      } else if (n.currentEntity) {
        const d = n.currentEntity.getComponent(
          RaycastReceiver
        );
        d && d.hovering && (d.hovering = !1, d.onLeave && d.onLeave(r)), n.currentEntity = null;
      }
    });
  }
}
RaycasterSystem.queries = {
  raycasters: {
    components: [Raycaster],
    listen: {
      added: !0,
      removed: !0,
      changed: !0
      // [RaycasterReceiver]
    }
  },
  receivers: {
    components: [RaycastReceiver],
    listen: {
      added: !0,
      removed: !0,
      changed: !0
      // [RaycasterReceiver]
    }
  },
  inputState: {
    components: [InputState]
  }
};
const Systems = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BallGeneratorSystem,
  CameraRigSystem,
  DissolveSystem,
  ElementSystem,
  GameStateSystem,
  LevelManager,
  OutputSystem,
  PhysicsSystem,
  RaycasterSystem,
  RotatingSystem,
  TargetSystem,
  UISystem,
  VRControllerInteraction
}, Symbol.toStringTag, { value: "Module" }));
window.Components = Components;
window.Systems = Systems;
window.THREE = THREE$1;
var world;
const urlParams = new URLSearchParams(window.location.search);
function detectWebXR() {
  "xr" in navigator ? navigator.xr.isSessionSupported("immersive-vr").then((e) => {
    e || document.getElementById("no-webxr").classList.remove("hidden");
  }) : document.getElementById("no-webxr").classList.remove("hidden");
}
function initGame() {
  detectWebXR(), world = new ECSYThreeWorld(), world.registerComponent(BallGenerator).registerComponent(GameState).registerComponent(Geometry).registerComponent(FloorCollided).registerComponent(Dissolve).registerComponent(Sound).registerComponent(Level).registerComponent(LevelItem).registerComponent(Colliding).registerComponent(CollisionStart).registerComponent(CollisionStop).registerComponent(Ball).registerComponent(Stop).registerComponent(Play).registerComponent(Text).registerComponent(RaycastReceiver).registerComponent(Target).registerComponent(Element).registerComponent(ParentObject3D).registerComponent(RigidBody).registerComponent(Animation).registerComponent(Floor).registerComponent(Position).registerComponent(Shape).registerComponent(Draggable).registerComponent(GLTFLoader$1).registerComponent(Transform).registerComponent(Visible).registerComponent(UI).registerComponent(Button), world.registerSystem(InputSystem).registerSystem(GameStateSystem).registerSystem(LevelManager).registerSystem(AnimationSystem).registerSystem(RaycasterSystem).registerSystem(UISystem).registerSystem(DissolveSystem).registerSystem(BallGeneratorSystem).registerSystem(VRControllerSystem).registerSystem(VRControllerInteraction).registerSystem(CameraRigSystem).registerSystem(ElementSystem).registerSystem(PhysicsSystem).registerSystem(SoundSystem).registerSystem(VisibilitySystem).registerSystem(TargetSystem).registerSystem(SDFTextSystem).registerSystem(RotatingSystem).registerSystem(OutputSystem).registerSystem(GLTFLoaderSystem).registerSystem(GeometrySystem);
  let e = initialize(world, { vr: !0 });
  var t = e.entities.scene.getObject3D();
  window.entityScene = e.entities.scene;
  let r = urlParams.has("level") ? parseInt(urlParams.get("level")) : 0;
  world.createEntity("singleton").addComponent(Scene, { value: e.entities.scene }).addComponent(GameState, {
    levelStartTime: performance.now(),
    gameStartTime: performance.now()
  }).addComponent(Level, { value: r }), world.getSystem(PhysicsSystem).stop(), n(e);
  function n(l) {
    t.fog = new FogExp2(new Color(5948892), 0.05), t.add(new HemisphereLight(13421772, 7368816));
    var c = new DirectionalLight(11184810);
    c.position.set(0.2, 1.7, -0.7), c.castShadow = !0, c.shadow.camera.top = 1, c.shadow.camera.bottom = -1, c.shadow.camera.right = 10, c.shadow.camera.left = -10, c.shadow.mapSize.set(4096, 4096), t.add(c), window.world = world, a(l);
    var u = new AudioListener(), h = new Audio$1(u), f = new Audio("assets/sounds/JosSs - Wehehey (Looped).ogg");
    f.loop = !0, h.setVolume(0.6), h.setMediaElementSource(f);
    let d = world.createEntity("startbutton").addComponent(UI).addComponent(GLTFLoader$1, {
      url: "assets/models/startbutton.glb",
      append: !0,
      onLoaded: (p) => {
        p.children[0].material = UIMaterial, p.children[0].material.color.setRGB(0.7, 0.7, 0.7);
      }
    }).addComponent(Button, {
      text: "START",
      onClick: () => {
        f.play(), world.getSystem(GameStateSystem).playGame(), setTimeout(() => {
          d.addComponent(Visible, { value: !1 });
        }, 300);
      }
    }).addComponent(Parent, { value: l.entities.scene }).addComponent(Position, { value: new Vector3(0, 0.6, -1.5) }).addComponent(Sound, { url: "assets/sounds/click.ogg" }).addComponent(Visible, { value: !urlParams.has("autostart") });
    urlParams.has("autostart") && world.getSystem(GameStateSystem).playGame(), world.execute(0.016, 0), l.entities.renderer.getComponent(
      WebGLRendererContext
    ).value.outputEncoding = sRGBEncoding;
  }
  function a(l) {
    o(l);
    let c = world.createEntity("playingGroup").addComponent(Object3DComponent, { value: new Group() }).addComponent(Parent, { value: l.entities.scene }).addComponent(Visible, { value: urlParams.has("autostart") });
    world.createEntity("levelGroup").addComponent(Object3DComponent, { value: new Group() }).addComponent(Parent, { value: c }).addComponent(Visible, { value: !0 }), world.createEntity().addComponent(GLTFLoader$1, {
      url: "assets/models/set.glb",
      onLoaded: (u) => {
        const h = u.getObjectByName("clouds").material;
        h.transparent = !0, h.fog = !1;
        const f = u.getObjectByName("sky").material;
        f.fog = !1;
      }
    }).addComponent(Parent, { value: l.entities.scene }), world.createEntity("help").addComponent(GLTFLoader$1, {
      url: "assets/models/help.glb",
      onLoaded: (u) => {
        u.children[0].material.transparent = !0, u.children[0].material.map.magFilter = LinearFilter, u.children[0].material.map.minFilter = LinearMipmapLinearFilter;
      }
    }).addComponent(Position, { value: new Vector3(0, 1.6, -2) }).addComponent(Parent, { value: l.entities.scene }).addComponent(Visible, { value: !0 }), world.createEntity("panelLevel").addComponent(GLTFLoader$1, {
      url: "assets/models/panellevel.glb",
      onLoaded: (u) => {
        u.children[0].material = UIMaterial, u.children[0].renderOrder = 1, world.createEntity("levelLabel").addComponent(
          Text,
          s("Level", "#20b4d6", 0.12, "center")
        ).addComponent(ParentObject3D, { value: u.children[0] }).addComponent(Position, { value: new Vector3(0, 0.2, 0.01) }), world.createEntity("level").addComponent(
          Text,
          s("1", "#90cdeb", 0.3, "center")
        ).addComponent(OnObject3DAdded, {
          callback: (h) => {
            u.children[0].add(h);
          }
        }).addComponent(ParentObject3D, { value: u.children[0] }).addComponent(Position, { value: new Vector3(0, 0, 0.01) });
      }
    }).addComponent(Parent, { value: c }).addComponent(Position, { value: new Vector3(0, 3.2, -6) }), world.createEntity("panelInfo").addComponent(GLTFLoader$1, {
      url: "assets/models/panelinfo.glb",
      onLoaded: (u) => {
        u.children[0].material = UIMaterial, u.children[0].children[0].material = UIMaterial, u.children[0].children[0].renderOrder = 1, u.children[0].renderOrder = 2;
        let h = u.children[0].children[0];
        world.createEntity("finished").addComponent(
          Text,
          s("Finished!", "#ffffff", 0.2, "center")
        ).addComponent(ParentObject3D, { value: h }).addComponent(Position, { value: new Vector3(0, 0.1, -0.1) }).addComponent(Visible, { value: !0 }), world.createEntity("numberBallsLabel").addComponent(
          Text,
          s("Balls", "#c0095d", 0.2, "center")
        ).addComponent(ParentObject3D, { value: u.children[0] }).addComponent(Position, { value: new Vector3(-0.4, 0.26, 0.01) }), world.createEntity("numberBalls").addComponent(
          Text,
          s("0", "#f9258b", 0.2, "center")
        ).addComponent(ParentObject3D, { value: u.children[0] }).addComponent(Position, { value: new Vector3(-0.4, 0, 0.01) }), world.createEntity("timeLabel").addComponent(
          Text,
          s("Time", "#836000", 0.2, "center")
        ).addComponent(ParentObject3D, { value: u.children[0] }).addComponent(Position, { value: new Vector3(0.4, 0.28, 0.01) }), world.createEntity("totalTimeLabel").addComponent(
          Text,
          s("Total", "#836000", 0.095, "center")
        ).addComponent(ParentObject3D, { value: u.children[0] }).addComponent(Position, { value: new Vector3(0.16, -0.21, 0.01) }), world.createEntity("timer").addComponent(
          Text,
          s("00:00", "#ebb808", 0.22, "center")
        ).addComponent(ParentObject3D, { value: u.children[0] }).addComponent(Position, { value: new Vector3(0.4, 0.04, 0.01) }), world.createEntity("timerTotal").addComponent(
          Text,
          s("00:00", "#ebb808", 0.12, "left")
        ).addComponent(ParentObject3D, { value: u.children[0] }).addComponent(Position, { value: new Vector3(0.36, -0.13, 0.01) });
      }
    }).addComponent(Parent, {
      value: l.entities.scene
      /*playingGroup*/
    }).addComponent(Animation, { duration: 2.35 }).addComponent(Position, { value: new Vector3(0, 2, -6) }).addComponent(Visible, { value: !1 });
  }
  function o(l) {
    world.createEntity().addComponent(Geometry, {
      primitive: "box",
      width: 100,
      height: 0.1,
      depth: 100
    }).addComponent(Shape, {
      primitive: "box",
      width: 100,
      height: 0.1,
      depth: 100
    }).addComponent(Visible, { value: !1 }).addComponent(Transform, {
      position: { x: 0, y: -0.05, z: 0 },
      rotation: { x: 0, y: 0, z: 0 }
    }).addComponent(Floor).addComponent(Sound, { url: "assets/sounds/miss.ogg" }).addComponent(RigidBody, {
      weight: 0,
      restitution: 0.5,
      friction: 3,
      linearDamping: 0,
      angularDamping: 0
    }).addComponent(Parent, { value: l.entities.scene });
  }
  function s(l, c, u, h) {
    return {
      color: c || "0xFFFFFF",
      fontSize: u || 0.5,
      anchor: h || "center",
      textAlign: h || "center",
      baseline: h || "center",
      font: "assets/fonts/WetinCaroWant.ttf",
      maxWidth: 10,
      lineHeight: 1.3,
      text: l || "LOREM IPSUM"
    };
  }
}
Ammo().then(initGame);
